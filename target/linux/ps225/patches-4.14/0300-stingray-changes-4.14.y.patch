--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-bus-pci-devices-aer_stats
@@ -0,0 +1,122 @@
+==========================
+PCIe Device AER statistics
+==========================
+These attributes show up under all the devices that are AER capable. These
+statistical counters indicate the errors "as seen/reported by the device".
+Note that this may mean that if an endpoint is causing problems, the AER
+counters may increment at its link partner (e.g. root port) because the
+errors may be "seen" / reported by the link partner and not the
+problematic endpoint itself (which may report all counters as 0 as it never
+saw any problems).
+
+Where:		/sys/bus/pci/devices/<dev>/aer_dev_correctable
+Date:		July 2018
+Kernel Version: 4.19.0
+Contact:	linux-pci@vger.kernel.org, rajatja@google.com
+Description:	List of correctable errors seen and reported by this
+		PCI device using ERR_COR. Note that since multiple errors may
+		be reported using a single ERR_COR message, thus
+		TOTAL_ERR_COR at the end of the file may not match the actual
+		total of all the errors in the file. Sample output:
+-------------------------------------------------------------------------
+localhost /sys/devices/pci0000:00/0000:00:1c.0 # cat aer_dev_correctable
+Receiver Error 2
+Bad TLP 0
+Bad DLLP 0
+RELAY_NUM Rollover 0
+Replay Timer Timeout 0
+Advisory Non-Fatal 0
+Corrected Internal Error 0
+Header Log Overflow 0
+TOTAL_ERR_COR 2
+-------------------------------------------------------------------------
+
+Where:		/sys/bus/pci/devices/<dev>/aer_dev_fatal
+Date:		July 2018
+Kernel Version: 4.19.0
+Contact:	linux-pci@vger.kernel.org, rajatja@google.com
+Description:	List of uncorrectable fatal errors seen and reported by this
+		PCI device using ERR_FATAL. Note that since multiple errors may
+		be reported using a single ERR_FATAL message, thus
+		TOTAL_ERR_FATAL at the end of the file may not match the actual
+		total of all the errors in the file. Sample output:
+-------------------------------------------------------------------------
+localhost /sys/devices/pci0000:00/0000:00:1c.0 # cat aer_dev_fatal
+Undefined 0
+Data Link Protocol 0
+Surprise Down Error 0
+Poisoned TLP 0
+Flow Control Protocol 0
+Completion Timeout 0
+Completer Abort 0
+Unexpected Completion 0
+Receiver Overflow 0
+Malformed TLP 0
+ECRC 0
+Unsupported Request 0
+ACS Violation 0
+Uncorrectable Internal Error 0
+MC Blocked TLP 0
+AtomicOp Egress Blocked 0
+TLP Prefix Blocked Error 0
+TOTAL_ERR_FATAL 0
+-------------------------------------------------------------------------
+
+Where:		/sys/bus/pci/devices/<dev>/aer_dev_nonfatal
+Date:		July 2018
+Kernel Version: 4.19.0
+Contact:	linux-pci@vger.kernel.org, rajatja@google.com
+Description:	List of uncorrectable nonfatal errors seen and reported by this
+		PCI device using ERR_NONFATAL. Note that since multiple errors
+		may be reported using a single ERR_FATAL message, thus
+		TOTAL_ERR_NONFATAL at the end of the file may not match the
+		actual total of all the errors in the file. Sample output:
+-------------------------------------------------------------------------
+localhost /sys/devices/pci0000:00/0000:00:1c.0 # cat aer_dev_nonfatal
+Undefined 0
+Data Link Protocol 0
+Surprise Down Error 0
+Poisoned TLP 0
+Flow Control Protocol 0
+Completion Timeout 0
+Completer Abort 0
+Unexpected Completion 0
+Receiver Overflow 0
+Malformed TLP 0
+ECRC 0
+Unsupported Request 0
+ACS Violation 0
+Uncorrectable Internal Error 0
+MC Blocked TLP 0
+AtomicOp Egress Blocked 0
+TLP Prefix Blocked Error 0
+TOTAL_ERR_NONFATAL 0
+-------------------------------------------------------------------------
+
+============================
+PCIe Rootport AER statistics
+============================
+These attributes show up under only the rootports (or root complex event
+collectors) that are AER capable. These indicate the number of error messages as
+"reported to" the rootport. Please note that the rootports also transmit
+(internally) the ERR_* messages for errors seen by the internal rootport PCI
+device, so these counters include them and are thus cumulative of all the error
+messages on the PCI hierarchy originating at that root port.
+
+Where:		/sys/bus/pci/devices/<dev>/aer_stats/aer_rootport_total_err_cor
+Date:		July 2018
+Kernel Version: 4.19.0
+Contact:	linux-pci@vger.kernel.org, rajatja@google.com
+Description:	Total number of ERR_COR messages reported to rootport.
+
+Where:	    /sys/bus/pci/devices/<dev>/aer_stats/aer_rootport_total_err_fatal
+Date:		July 2018
+Kernel Version: 4.19.0
+Contact:	linux-pci@vger.kernel.org, rajatja@google.com
+Description:	Total number of ERR_FATAL messages reported to rootport.
+
+Where:	    /sys/bus/pci/devices/<dev>/aer_stats/aer_rootport_total_err_nonfatal
+Date:		July 2018
+Kernel Version: 4.19.0
+Contact:	linux-pci@vger.kernel.org, rajatja@google.com
+Description:	Total number of ERR_NONFATAL messages reported to rootport.
--- a/Documentation/PCI/pcieaer-howto.txt
+++ b/Documentation/PCI/pcieaer-howto.txt
@@ -73,6 +73,11 @@ In the example, 'Requester ID' means the ID of the device who sends
 the error message to root port. Pls. refer to pci express specs for
 other fields.
 
+2.4 AER Statistics / Counters
+
+When PCIe AER errors are captured, the counters / statistics are also exposed
+in the form of sysfs attributes which are documented at
+Documentation/ABI/testing/sysfs-bus-pci-devices-aer_stats
 
 3. Developer Guide
 
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -936,6 +936,12 @@
 			in the same format described for "console=ttyS<n>"; if
 			unspecified, the h/w is not initialized.
 
+		uart[8250]_log,...
+			When '_log' is added, the 8250/16550 based UART
+			earlycon will also enable logging support, i.e., these
+			earlycon UART traces will also be saved in memory
+			location specified in the 'earlylog' parameter
+
 		pl011,<addr>
 		pl011,mmio32,<addr>
 			Start an early, polled-mode console on a pl011 serial
--- a/Documentation/devicetree/bindings/clock/brcm,iproc-clocks.txt
+++ b/Documentation/devicetree/bindings/clock/brcm,iproc-clocks.txt
@@ -263,6 +263,7 @@ These clock IDs are defined in:
     clk_125_nitro	genpll2		3	BCM_SR_GENPLL2_125_NITRO_CLK
     clk_chimp		genpll2		4	BCM_SR_GENPLL2_CHIMP_CLK
     clk_nic_flash	genpll2		5	BCM_SR_GENPLL2_NIC_FLASH
+    clk_fs		genpll2		6	BCM_SR_GENPLL2_FS_CLK
 
     genpll3		crystal		0	BCM_SR_GENPLL3
     clk_hsls		genpll3		1	BCM_SR_GENPLL3_HSLS_CLK
--- /dev/null
+++ b/Documentation/devicetree/bindings/crypto/brcm,iproc-pka.txt
@@ -0,0 +1,15 @@
+Broadcom iProc Public Key accelarator
+-------------------------------------
+PKA (Public Key accelarator) supports several public key
+algorithms like RSA crypto system, Digital Signature
+Algorithm, etc.
+
+Required properties:
+- compatible 	: "brcm,iproc-pka"
+- reg 		: Base address of PKA_CONTROL_STATUS register.
+
+Example:
+	pka: iproc_pka@18031000 {
+		compatible = "brcm,iproc-pka";
+		reg = <0x18031000 0x10>;
+	};
--- a/Documentation/devicetree/bindings/crypto/brcm,spu-crypto.txt
+++ b/Documentation/devicetree/bindings/crypto/brcm,spu-crypto.txt
@@ -12,7 +12,9 @@ Required properties:
 
 - reg: Should contain SPU registers location and length.
 - mboxes: The mailbox channel to be used to communicate with the SPU.
-  Mailbox channels correspond to DMA rings on the device.
+  Mailbox channels correspond to DMA rings on the device. spu2-v2 based devices
+  may have more DMA rings than the number of SPU hardware blocks and internally
+  hardware schedules the assignment of DMA rings to SPU hardware blocks.
 
 Example:
 	crypto@612d0000 {
@@ -20,3 +22,49 @@ Example:
 		reg = <0 0x612d0000 0 0x900>;
 		mboxes = <&pdc0 0>;
 	};
+
+	spu2: spu2 {
+		compatible = "brcm,spu2-v2-crypto";
+		reg = <0x672c0000 0x1000>,
+		      <0x672c1000 0x1000>,
+		      <0x672c2000 0x1000>,
+		      <0x672c3000 0x1000>,
+		      <0x672c4000 0x1000>,
+		      <0x672c5000 0x1000>,
+		      <0x672c6000 0x1000>,
+		      <0x672c7000 0x1000>,
+		      <0x672c8000 0x1000>,
+		      <0x672c9000 0x1000>;
+		mboxes = <&crypto_mbox 0 0x1 0xff00>,
+			 <&crypto_mbox 1 0x1 0xff00>,
+			 <&crypto_mbox 2 0x1 0xff00>,
+			 <&crypto_mbox 3 0x1 0xff00>,
+			 <&crypto_mbox 4 0x1 0xff00>,
+			 <&crypto_mbox 5 0x1 0xff00>,
+			 <&crypto_mbox 6 0x1 0xff00>,
+			 <&crypto_mbox 7 0x1 0xff00>,
+			 <&crypto_mbox 8 0x1 0xff00>,
+			 <&crypto_mbox 9 0x1 0xff00>,
+			 <&crypto_mbox 10 0x1 0xff00>,
+			 <&crypto_mbox 11 0x1 0xff00>,
+			 <&crypto_mbox 12 0x1 0xff00>,
+			 <&crypto_mbox 13 0x1 0xff00>,
+			 <&crypto_mbox 14 0x1 0xff00>,
+			 <&crypto_mbox 15 0x1 0xff00>,
+			 <&crypto_mbox 16 0x1 0xff00>,
+			 <&crypto_mbox 17 0x1 0xff00>,
+			 <&crypto_mbox 18 0x1 0xff00>,
+			 <&crypto_mbox 19 0x1 0xff00>,
+			 <&crypto_mbox 20 0x1 0xff00>,
+			 <&crypto_mbox 21 0x1 0xff00>,
+			 <&crypto_mbox 22 0x1 0xff00>,
+			 <&crypto_mbox 23 0x1 0xff00>,
+			 <&crypto_mbox 24 0x1 0xff00>,
+			 <&crypto_mbox 25 0x1 0xff00>,
+			 <&crypto_mbox 26 0x1 0xff00>,
+			 <&crypto_mbox 27 0x1 0xff00>,
+			 <&crypto_mbox 28 0x1 0xff00>,
+			 <&crypto_mbox 29 0x1 0xff00>,
+			 <&crypto_mbox 30 0x1 0xff00>,
+			 <&crypto_mbox 31 0x1 0xff00>;
+	};
--- a/Documentation/devicetree/bindings/extcon/extcon-usb-gpio.txt
+++ b/Documentation/devicetree/bindings/extcon/extcon-usb-gpio.txt
@@ -10,6 +10,10 @@ Either one of id-gpio or vbus-gpio must be present. Both can be present as well.
 - id-gpio: gpio for USB ID pin. See gpio binding.
 - vbus-gpio: gpio for USB VBUS pin.
 
+Optional properties:
+- debounce-timeout-ms: debounce timeout value for id and vbus gpio in
+  milliseconds.
+
 Example: Examples of extcon-usb-gpio node in dra7-evm.dts as listed below:
 	extcon_usb1 {
 		compatible = "linux,extcon-usb-gpio";
--- a/Documentation/devicetree/bindings/gpio/gpio-pca953x.txt
+++ b/Documentation/devicetree/bindings/gpio/gpio-pca953x.txt
@@ -34,6 +34,11 @@ Optional properties:
  - reset-gpios: GPIO specification for the RESET input. This is an
 		active low signal to the PCA953x.
 
+ - interrupt-controller: Identifies the node as an interrupt controller.
+ - #interrupt-cells: Number of cells to encode an interrupt source.
+ - interrupt-parent: phandle of the parent interrupt controller.
+ - interrupts: Interrupt specifier for the controllers interrupt.
+
 Example:
 
 
--- a/Documentation/devicetree/bindings/i2c/brcm,iproc-i2c.txt
+++ b/Documentation/devicetree/bindings/i2c/brcm,iproc-i2c.txt
@@ -3,15 +3,12 @@ Broadcom iProc I2C controller
 Required properties:
 
 - compatible:
-    Must be "brcm,iproc-i2c"
+    Must be "brcm,iproc-i2c" or "brcm,iproc-nic-i2c"
 
 - reg:
     Define the base and range of the I/O address space that contain the iProc
     I2C controller registers
 
-- interrupts:
-    Should contain the I2C interrupt
-
 - clock-frequency:
     This is the I2C bus clock. Need to be either 100000 or 400000
 
@@ -21,6 +18,15 @@ Required properties:
 - #size-cells:
     Always 0
 
+Optional properties:
+
+- interrupts:
+    Should contain the I2C interrupt. If unspecified, driver will fall back to
+    polling mode
+
+- brcm,ape-hsls-addr-mask:
+    Required for "brcm,iproc-nic-i2c". Host view of address mask into APE
+
 Example:
 	i2c0: i2c@18008000 {
 		compatible = "brcm,iproc-i2c";
--- /dev/null
+++ b/Documentation/devicetree/bindings/i2c/i2c-slave-bmc.txt
@@ -0,0 +1,19 @@
+BMC Client Device Tree Bindings
+-------------------------------------------------------------
+
+Required properties:
+	- compatible: Should be "i2c-slave-bmc".
+	- reg       : I2C address of the device, and I2C_OWN_SLAVE_ADDRESS
+		      (1 << 30) is used to mark addresses on which we listen
+		      to be devices ourselves.
+	- bmc-thermal-zone: name of thermal zone.
+
+Examples:
+
+&i2c1 {
+	bmc@40000035 {
+		compatible = "i2c-slave-bmc";
+		reg = <0x40000035>;
+		bmc-thermal-zone = "ihost0-thermal";
+	};
+};
--- /dev/null
+++ b/Documentation/devicetree/bindings/interrupt-controller/brcm,iproc-crmu-intc.txt
@@ -0,0 +1,50 @@
+* Broadcom's iProc CRMU Interrupt Controller
+
+The iProc CRMU Interrupt Controller driver handles interrupts generated by the
+Cortex-M0 MCU processor. The driver determines the type of event and forwards
+the interrupt to the appropriate IRQ domain.
+
+Required properties:
+- compatible: Must be "brcm,iproc-crmu-intc"
+- reg: Defines the base address of 1) The MCU to CRMU mailbox and 2) The CRMU to
+  iProc interrupt registers.
+- interrupts: The IRQ of the mailbox controller.
+- #interrupt-cells: Must be 1.
+- interrupt-controller: Sets the device as an interrupt controller.
+- mboxes: The mailbox channel used to communicate with the mailbox controller.
+
+Example:
+
+Shows how the CRMU GPIO controller configures an IRQ domain and sets the iProc
+CRMU Interrupt controller as the interrupt parent. When AON GPIO interrupts are
+generated they will be forwared to the CRMU GPIO controller for processing.
+
+	mailbox: mailbox@03024024 {
+		compatible = "brcm,iproc-mailbox";
+		reg = <0x03024024 0x8>;
+		#mbox-cells = <1>;
+	};
+
+	iproc_crmu_intc: interrupt-controller@0302402c {
+		compatible = "brcm,iproc-crmu-intc";
+		reg = <0x0302402c 0x8>,
+		      <0x03024058 0xc>;
+		interrupts = <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+		/* Mailbox channel used by controller. */
+		mboxes = <&mailbox 3>;
+	};
+
+	gpio_crmu: gpio@03024800 {
+		compatible = "brcm,cygnus-crmu-gpio";
+		reg = <0x03024800 0x50>,
+		      <0x03024008 0x18>;
+		ngpios = <6>;
+		#gpio-cells = <2>;
+		gpio-controller;
+		interrupt-controller;
+		interrupt-parent = <&iproc_crmu_intc>;
+		interrupts = <0>;
+		mboxes = <&mailbox 1>;
+	};
--- a/Documentation/devicetree/bindings/iommu/arm,smmu.txt
+++ b/Documentation/devicetree/bindings/iommu/arm,smmu.txt
@@ -71,6 +71,24 @@ conditions.
                   or using stream matching with #iommu-cells = <2>, and
                   may be ignored if present in such cases.
 
+- reserved-context-banks: Number of S1 context banks (from end) to be
+                  reserved for non-secure bootloader (or firmware). The
+                  bootloader (or firmware) can use these reserved context
+                  banks for devices requiring System MMU configuration
+                  at boot time.
+
+- reserved-s2-context-banks: Number of S2 context banks (from end) to
+                  be reserved for non-secure bootloader (or firmware).
+                  The bootloader (or firmware) can use these reserved
+                  S2 context banks for devices requiring System MMU
+                  configuration at boot time.
+
+- reserved-mapping-groups: Number of SMRs and S2CRs (from end) to be
+                  reserved for non-secure bootloader (or firmware).
+                  The bootloader (or firmware) can use these reserved
+                  SMRs and S2CRs for devices requiring System MMU
+                  configuration at boot time.
+
 ** Deprecated properties:
 
 - mmu-masters (deprecated in favour of the generic "iommus" binding) :
--- /dev/null
+++ b/Documentation/devicetree/bindings/mailbox/brcm,fs4-test.txt
@@ -0,0 +1,116 @@
+Broadcom FlexSparx4 Test Client
+===============================
+The FlexSparx4 (FS4) offload engines are available on various iProc SoC
+such as Pegasus and Stingray. These FS4 offload engines are accessible
+via SoC specific ring manager hardware. The driver for SoC specific
+ring manager hardware will be mailbox controller driver hence Broadcom
+FlexSparx4 Test Client is a mailbox client which helps us exersice
+or stress offload engine features via sysfs interface.
+
+Required properties:
+--------------------
+- compatible:	Should be one of the following:
+		"brcm,fs4-test-spu2"
+		"brcm,fs4-test-sba-memcpy"
+		"brcm,fs4-test-sba-xor"
+		"brcm,fs4-test-sba-pq"
+- mboxes:	List of phandle and mailbox channel specifiers
+
+Optional properties:
+--------------------
+- reg:		Specifies base physical address and size of the offload
+		engine registers. This is an optional attribute because
+		offload engines are mostly programmed via ring manager
+		hardware so we don't require to touch offload engine
+		registers.
+
+Example:
+---------
+crypto_mbox: mbox@67000000 {
+	compatible = "brcm,flexdma-mbox";
+	reg = <0x67000000 0x200000>;
+	msi-parent = <&gic_its 0x7ffd>;
+	#mbox-cells = <3>;
+	dma-coherent;
+};
+
+spu2 {
+	compatible = "brcm,fs4-test-spu2";
+	reg = <0x672c0000 0x1000>,
+	      <0x672c1000 0x1000>,
+	      <0x672c2000 0x1000>,
+	      <0x672c3000 0x1000>,
+	      <0x672c4000 0x1000>,
+	      <0x672c5000 0x1000>,
+	      <0x672c6000 0x1000>,
+	      <0x672c7000 0x1000>,
+	      <0x672c8000 0x1000>,
+	      <0x672c9000 0x1000>;
+	mboxes = <&crypto_mbox 0 0x1 0xff00>,
+		 <&crypto_mbox 1 0x1 0xff00>,
+		 <&crypto_mbox 2 0x1 0xff00>,
+		 <&crypto_mbox 3 0x1 0xff00>,
+		 <&crypto_mbox 4 0x1 0xff00>,
+		 <&crypto_mbox 5 0x1 0xff00>,
+		 <&crypto_mbox 6 0x1 0xff00>,
+		 <&crypto_mbox 7 0x1 0xff00>,
+		 <&crypto_mbox 8 0x1 0xff00>,
+		 <&crypto_mbox 9 0x1 0xff00>,
+		 <&crypto_mbox 10 0x1 0xff00>,
+		 <&crypto_mbox 11 0x1 0xff00>,
+		 <&crypto_mbox 12 0x1 0xff00>,
+		 <&crypto_mbox 13 0x1 0xff00>,
+		 <&crypto_mbox 14 0x1 0xff00>,
+		 <&crypto_mbox 15 0x1 0xff00>,
+		 <&crypto_mbox 16 0x1 0xff00>,
+		 <&crypto_mbox 17 0x1 0xff00>,
+		 <&crypto_mbox 18 0x1 0xff00>,
+		 <&crypto_mbox 19 0x1 0xff00>,
+		 <&crypto_mbox 20 0x1 0xff00>,
+		 <&crypto_mbox 21 0x1 0xff00>,
+		 <&crypto_mbox 22 0x1 0xff00>,
+		 <&crypto_mbox 23 0x1 0xff00>,
+		 <&crypto_mbox 24 0x1 0xff00>,
+		 <&crypto_mbox 25 0x1 0xff00>,
+		 <&crypto_mbox 26 0x1 0xff00>,
+		 <&crypto_mbox 27 0x1 0xff00>,
+		 <&crypto_mbox 28 0x1 0xff00>,
+		 <&crypto_mbox 29 0x1 0xff00>,
+		 <&crypto_mbox 30 0x1 0xff00>,
+		 <&crypto_mbox 31 0x1 0xff00>;
+};
+
+raid_mbox: mbox@67400000 {
+	compatible = "brcm,flexdma-mbox";
+	reg = <0x67400000 0x200000>;
+	msi-parent = <&gic_its 0x7ffe>;
+	#mbox-cells = <3>;
+	dma-coherent;
+};
+
+raid_memcpy {
+	compatible = "brcm,fs4-test-sba-memcpy";
+	brcm,max-pq-disks = <30>;
+	brcm,max-requests = <256>;
+	brcm,request-size = <131072>;
+	mboxes = <&raid_mbox 16 0x4 0xff00>,
+		 <&raid_mbox 17 0x4 0xff00>,
+		 <&raid_mbox 18 0x4 0xff00>,
+		 <&raid_mbox 19 0x4 0xff00>,
+		 <&raid_mbox 20 0x4 0xff00>,
+		 <&raid_mbox 21 0x4 0xff00>,
+		 <&raid_mbox 22 0x4 0xff00>,
+		 <&raid_mbox 23 0x4 0xff00>;
+};
+
+raid_xor {
+	compatible = "brcm,fs4-test-sba-xor";
+	mboxes = <&raid_mbox 24 0x4 0xff00>,
+		 <&raid_mbox 25 0x4 0xff00>,
+		 <&raid_mbox 26 0x4 0xff00>,
+		 <&raid_mbox 27 0x4 0xff00>,
+		 <&raid_mbox 28 0x4 0xff00>,
+		 <&raid_mbox 29 0x4 0xff00>,
+		 <&raid_mbox 30 0x4 0xff00>,
+		 <&raid_mbox 31 0x4 0xff00>;
+};
--- a/Documentation/devicetree/bindings/mailbox/brcm,iproc-flexrm-mbox.txt
+++ b/Documentation/devicetree/bindings/mailbox/brcm,iproc-flexrm-mbox.txt
@@ -31,6 +31,13 @@ Required properties:
 		specified by this cell then it will inject one MSI interrupt
 		to CPU provided atleast one completion message is available.
 
+-clocks:	pll handle + channel specifier
+		three clocks needed for this defined as-
+		1. dme/rm clock
+		2. accelerated engine clock
+		3. fs4 block AXI clock
+-clock-names:	list should be defined as - "dme_rm_clk", "ae_clk", "fs4_clk".
+
 Optional properties:
 --------------------
 - dma-coherent:	Present if DMA operations made by the FlexRM engine (such
@@ -43,6 +50,10 @@ Example:
 crypto_mbox: mbox@67000000 {
 	compatible = "brcm,iproc-flexrm-mbox";
 	reg = <0x67000000 0x200000>;
+	clocks = <&genpll5 BCM_SR_GENPLL5_FS4_HF_CLK>,
+		 <&genpll5 BCM_SR_GENPLL5_CRYPTO_AE_CLK>,
+		 <&genpll2 BCM_SR_GENPLL2_FS4_CLK>;
+	clock-names = "dme_rm_clk", "ae_clk", "fs4_clk";
 	msi-parent = <&gic_its 0x7f00>;
 	#mbox-cells = <3>;
 };
--- /dev/null
+++ b/Documentation/devicetree/bindings/mailbox/brcm,iproc-mailbox.txt
@@ -0,0 +1,14 @@
+* Broadcom's iProc Mailbox Controller
+
+Required properties:
+- compatible: Must be "brcm,iproc-mailbox"
+- reg: Defines the base address of the mailbox controller.
+- #mbox-cells: Must be 1.
+
+Example:
+
+	mailbox: mailbox@03024024 {
+		compatible = "brcm,iproc-mailbox";
+		reg = <0x03024024 0x8>;
+		#mbox-cells = <1>;
+	};
--- /dev/null
+++ b/Documentation/devicetree/bindings/mfd/brcm,iproc-cdru.txt
@@ -0,0 +1,16 @@
+Broadcom iProc Chip Device Resource Unit (CDRU)
+
+Various Broadcom iProc SoCs have a set of registers that provide various
+chip specific device and resource configurations. This node allows access to
+these CDRU registers via syscon.
+
+Required properties:
+- compatible: should contain:
+		"brcm,sr-cdru", "syscon" for Stingray
+- reg: base address and range of the CDRU registers
+
+Example:
+	cdru: syscon@6641d000 {
+		compatible = "brcm,sr-cdru", "syscon";
+		reg = <0 0x6641d000 0 0x400>;
+	};
--- /dev/null
+++ b/Documentation/devicetree/bindings/mfd/brcm,iproc-mhb.txt
@@ -0,0 +1,18 @@
+Broadcom iProc Multi Host Bridge (MHB)
+
+Certain Broadcom iProc SoCs have a multi host bridge (MHB) block that controls
+the connection and configuration of 1) internal PCIe serdes; 2) PCIe endpoint
+interface; 3) access to the Nitro (network processing) engine
+
+This node allows access to these MHB registers via syscon.
+
+Required properties:
+- compatible: should contain:
+		"brcm,sr-mhb", "syscon" for Stingray
+- reg: base address and range of the MHB registers
+
+Example:
+	mhb: syscon@60401000 {
+		compatible = "brcm,sr-mhb", "syscon";
+		reg = <0 0x60401000 0 0x38c>;
+	};
--- /dev/null
+++ b/Documentation/devicetree/bindings/misc/brcm,iproc-ftm.txt
@@ -0,0 +1,45 @@
+Flextimer support for reading  magnetic stripe of smart cards.
+
+Magnetic stripe reader head reads the smart card's magnetic stripe flux
+and generates the analog signal. This signal is digitalized and fed to
+flex time which time stamp the data. Time stamp is decoded to get the stripe
+tracks data.
+
+
+Required properties:
+
+- compatible:
+    Must be "brcm,iproc-ftm"
+
+-reg:
+	base address of flex channels registers.
+
+-flextimer_syscon:
+	handler of syscon node defining physical base address of the
+	TS/ADC controller and length of memory mapped region.
+
+-interrupts:
+	interrupt line used by flex timer.
+
+-clocks and clock-names:
+	clock used in flex timer.clock-names must be "ftm_clk".
+
+-pinctrl-0:
+	configure the mux to activate pin for flex timer functionalites.
+
+For example:
+
+	ts_adc_syscon: ts_adc_syscon@180a6000 {
+		compatible = "brcm,iproc-ts-adc-syscon", "syscon";
+		reg = <0x180a6000 0xc30>;
+	};
+
+	flextimer: flextimer@180a6000 {
+		compatible = "brcm,iproc-ftm";
+		flextimer_syscon = <&ts_adc_syscon>;
+		interrupts = <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&asiu_clks BCM_CYGNUS_ASIU_ADC_CLK>;
+		clock-names = "ftm_clk";
+		pinctrl-0 = <&flextimer_default_mux>;
+		status = "disabled";
+	};
--- /dev/null
+++ b/Documentation/devicetree/bindings/misc/brcm,nvme-lpm-ssr.txt
@@ -0,0 +1,33 @@
+Broadcom NVME/SSR data backup device tree binding
+
+Required_properties:
+	-compatible: must be "brcm,nvme-lpm-data-backup".
+	- reg: memory address used for sharing SSR commands/data.
+	- intrpt-gpio: GPIO that is asserted when PMIC detect 12V supply loss
+		       and de-asserted when suply gets re-stored.
+	- mboxes: list of phandle and mailbox channel specifier,
+		  used for communication with a power management co-processor.
+	- memory-region : phandle to a node describing reserved memory region
+			  for sharing data of NVMe device used for data-backup
+			  with power management co-processor.
+
+Example:
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		pci_lpm_region: pci_lpm_region@801f0000 {
+			reg = <0x0 0x8f101000 0x0 0x1000>;
+			no-map;
+		};
+	};
+
+	nvme_lpm_data_backup: nvme-lpm-data-backup@14 {
+		compatible = "brcm,nvme-lpm-data-backup";
+		reg = <0x0 0x100>;
+		intrpt-gpio = <&gpio_hsls 2 GPIO_ACTIVE_HIGH>;
+		mboxes = <&mailbox 0>;
+		memory-region = <&pci_lpm_region>;
+		status = "disabled";
+	};
--- a/Documentation/devicetree/bindings/net/brcm,mdio-mux-iproc.txt
+++ b/Documentation/devicetree/bindings/net/brcm,mdio-mux-iproc.txt
@@ -18,9 +18,9 @@ at- Documentation/devicetree/bindings/net/mdio-mux.txt
 
 
 for example:
-		mdio_mux_iproc: mdio-mux@6602023c {
+		mdio_mux_iproc: mdio-mux@66020000 {
 			compatible = "brcm,mdio-mux-iproc";
-			reg = <0x6602023c 0x14>;
+			reg = <0x66020000 0x250>;
 			#address-cells = <1>;
 			#size-cells = <0>;
 
--- a/Documentation/devicetree/bindings/pci/brcm,iproc-pcie.txt
+++ b/Documentation/devicetree/bindings/pci/brcm,iproc-pcie.txt
@@ -14,8 +14,10 @@ controller, used in Stingray
 root complex is connected to emulated endpoint devices internal to the ASIC
 - reg: base address and length of the PCIe controller I/O register space
 - #interrupt-cells: set to <1>
+- interrupt-controller: claims itself as an interrupt controller for INTx
 - interrupt-map-mask and interrupt-map, standard PCI properties to define the
   mapping of the PCIe interface to interrupt numbers
+- interrupts: interrupt line wired to the generic GIC for INTx support
 - linux,pci-domain: PCI domain ID. Should be unique for each host controller
 - bus-range: PCI bus numbers covered
 - #address-cells: set to <3>
@@ -77,9 +79,14 @@ Example:
 		compatible = "brcm,iproc-pcie";
 		reg = <0x18012000 0x1000>;
 
+		interrupt-controller;
 		#interrupt-cells = <1>;
-		interrupt-map-mask = <0 0 0 0>;
-		interrupt-map = <0 0 0 0 &gic GIC_SPI 100 IRQ_TYPE_NONE>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 0 1 &pcie0 1>,
+				<0 0 0 0 2 &pcie0 2>,
+				<0 0 0 0 3 &pcie0 3>,
+				<0 0 0 0 4 &pcie0 4>;
+		interrupts = <GIC_SPI 100 IRQ_TYPE_NONE>;
 
 		linux,pci-domain = <0>;
 
@@ -91,7 +98,7 @@ Example:
 		ranges = <0x81000000 0 0	  0x28000000 0 0x00010000
 			  0x82000000 0 0x20000000 0x20000000 0 0x04000000>;
 
-		phys = <&phy 0 5>;
+		phys = <&pcie0_phy>;
 		phy-names = "pcie-phy";
 
 		brcm,pcie-ob;
@@ -115,9 +122,14 @@ Example:
 		compatible = "brcm,iproc-pcie";
 		reg = <0x18013000 0x1000>;
 
+		interrupt-controller;
 		#interrupt-cells = <1>;
-		interrupt-map-mask = <0 0 0 0>;
-		interrupt-map = <0 0 0 0 &gic GIC_SPI 106 IRQ_TYPE_NONE>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 0 1 &pcie1 1>,
+				<0 0 0 0 2 &pcie1 2>,
+				<0 0 0 0 3 &pcie1 3>,
+				<0 0 0 0 4 &pcie1 4>;
+		interrupts = <GIC_SPI 106 IRQ_TYPE_NONE>;
 
 		linux,pci-domain = <1>;
 
@@ -129,6 +141,6 @@ Example:
 		ranges = <0x81000000 0 0	  0x48000000 0 0x00010000
 			  0x82000000 0 0x40000000 0x40000000 0 0x04000000>;
 
-		phys = <&phy 1 6>;
+		phys = <&pcie1_phy>;
 		phy-names = "pcie-phy";
 	};
--- a/Documentation/devicetree/bindings/pci/pci-iommu.txt
+++ b/Documentation/devicetree/bindings/pci/pci-iommu.txt
@@ -44,6 +44,9 @@ Optional properties
 - iommu-map-mask: A mask to be applied to each Requester ID prior to being
   mapped to an IOMMU specifier per the iommu-map property.
 
+- iommu-map-drop-mask: A drop mask represents the bits which will be
+  removed/dropped by system from Requester ID before mapping it to
+  stream ID.
 
 Example (1)
 ===========
@@ -169,3 +172,32 @@ Example (4)
 			    <0x8000 &iommu_b 0x0000 0x8000>;
 	};
 };
+
+Example (5)
+===========
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	iommu: iommu@a {
+		reg = <0xa 0x1>;
+		compatible = "vendor,some-iommu";
+		#iommu-cells = <1>;
+	};
+
+	pci: pci@f {
+		reg = <0xf 0x1>;
+		compatible = "vendor,pcie-root-complex";
+		device_type = "pci";
+
+		/*
+		 * The sideband data provided to the IOMMU is a 10bit
+		 * data derived from the RID by dropping 4 MSBs
+		 * of device number and 2 MSBs of function number.
+		 */
+		iommu-map = <0x0 &iommu 0x0 0x1024>;
+		iommu-map-drop-mask = <0xff09>;
+	};
+};
+
--- a/Documentation/devicetree/bindings/pci/pci-msi.txt
+++ b/Documentation/devicetree/bindings/pci/pci-msi.txt
@@ -49,6 +49,10 @@ Optional properties
 - msi-map-mask: A mask to be applied to each Requester ID prior to being mapped
   to an msi-specifier per the msi-map property.
 
+- msi-map-drop-mask: A drop mask represents the bits which will be
+  removed/dropped by system from Requester ID before mapping it to
+  msi ID.
+
 - msi-parent: Describes the MSI parent of the root complex itself. Where
   the root complex and MSI controller do not pass sideband data with MSI
   writes, this property may be used to describe the MSI controller(s)
@@ -218,3 +222,33 @@ Example (5)
 			  <0x0000 &msi_b 0x0000 0x10000>;
 	};
 };
+
+Example (6)
+===========
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	msi: msi-controller@a {
+		reg = <0xa 0x1>;
+		compatible = "vendor,some-controller";
+		msi-controller;
+		#msi-cells = <1>;
+	};
+
+	pci: pci@f {
+		reg = <0xf 0x1>;
+		compatible = "vendor,pcie-root-complex";
+		device_type = "pci";
+
+		/*
+		 * The sideband data provided to the  MSI controller is
+		 * a 10bit data derived from the RID by dropping
+		 * 4 MSBs of device number and 2 MSBs of function number.
+		 */
+		msi-map = <0x0 &msi_a 0x0 0x100>,
+		msi-map-drop-mask = <0xff09>
+	};
+};
+
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/brcm,sr-pcie-phy.txt
@@ -0,0 +1,40 @@
+Broadcom Stingray PCIe PHY
+
+* TBD whether to upstream or not based on Stingray A1 and Stingray+ design
+
+Required properties:
+- compatible: must be "brcm,sr-pcie-phy"
+- reg: base address and length of the PCIe SS register space
+- brcm,sr-cdru: phandle to the CDRU syscon node
+- brcm,sr-mhb: phandle to the MHB syscon node
+- #phy-cells: Must be 1, denotes the PHY index
+
+For PAXB based interfaces, PHY index goes from 0 to 7. PAXC uses index 8
+
+Example:
+	mhb: syscon@60401000 {
+		compatible = "brcm,sr-mhb", "syscon";
+		reg = <0 0x60401000 0 0x38c>;
+	};
+
+	cdru: syscon@6641d000 {
+		compatible = "brcm,sr-cdru", "syscon";
+		reg = <0 0x6641d000 0 0x400>;
+	};
+
+	pcie_phy: phy {
+		compatible = "brcm,sr-pcie-phy";
+		reg = <0 0x40000000 0 0x800>;
+		brcm,sr-cdru = <&cdru>;
+		brcm,sr-mhb = <&mhb>;
+		#phy-cells = <1>;
+	};
+
+	/* users of the PCIe PHY */
+
+	pcie0: pcie@48000000 {
+		...
+		...
+		phys = <&pcie_phy 0>;
+		phy-names = "pcie-phy";
+	};
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/brcm,stingray-pcie-phy-prbs.txt
@@ -0,0 +1,67 @@
+Broadcom PCIe PHY PRBS for Stingray
+
+Required PHY properties:
+- compatible: should be "brcm,stingray-pcie-phy-prbs"
+- reg: base address and length of the PCIe subsystem register space
+- address-cells: should be 2
+- size-cells: should be 2
+- ranges : the child address space are mapped 1:1 onto the parent address space
+- brcm,pcie-pipemux-strap-syscon: A phandle to the CDRU syscon node containing
+				  the PIPEMUX strap register value.
+
+Sub-nodes:
+ Each PHY should be represented as a sub-node. It is required to list all
+ the PCIe PHYs present in SoC as sub-nodes of pcie.
+
+Sub-nodes required properties:
+- reg: base address and length of the PCIe controller I/O register space
+
+Example:
+	pcie {
+		compatible = "brcm,stingray-pcie-phy-prbs";
+		reg = <0x0 0x40000000 0x0 0x1000>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		brcm,pcie-pipemux-strap-syscon = <&cdru>;
+
+		pcie_phy0: phy@48000000 {
+			reg = <0x0 0x48000000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy1: phy@48004000 {
+			reg = <0x0 0x48004000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy2: phy@48008000 {
+			reg = <0x0 0x48008000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy3: phy@4800c000{
+			reg = <0x0 0x4800c000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy4: phy@48010000 {
+			reg = <0x0 0x48010000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy5: phy@48014000 {
+			reg = <0x0 0x48014000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy6: phy@48018000 {
+			reg = <0x0 0x48018000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy7: phy@4801c000 {
+			reg = <0x0 0x4801c000 0x0 0x4000>;
+			status = "okay";
+		};
+	};
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/brcm,stingray-sata-phy-prbs.txt
@@ -0,0 +1,27 @@
+Broadcom SATA PHY PRBS for Stingray
+
+Required properties:
+- compatible : should be "brcm,stingray-sata-phy-prbs"
+- address-cells: should be 1
+- size-cells: should be 0
+- reg: register ranges for the PHY PCB interface
+- reg-names: should be "phy"
+
+Sub-nodes:
+  Each port's PHY should be represented as a sub-node.
+
+Sub-nodes required properties:
+- reg: the PHY number
+
+Example:
+	sata_phy0: sata_phy@67d02100 {
+		compatible = "brcm,stingray-sata-phy-prbs";
+		reg = <0x67d02100 0x1000>;
+		reg-names = "phy";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sata0_phy0: sata-phy@0 {
+			reg = <0>;
+		};
+	};
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/brcm,stingray-usb-phy.txt
@@ -0,0 +1,62 @@
+BROADCOM STINGRAY USB PHY
+
+Required properties:
+ - compatible : should be one of the listed compatibles
+	- "brcm,sr-usb-phy"
+	- "brcm,sr-usb-phy-v2"
+ - reg: offset and length of the PHY blocks registers
+ - address-cells: should be 1
+ - size-cells: should be 0
+
+Sub-nodes:
+  Each port's PHY should be represented as a sub-node.
+
+Sub-nodes required properties:
+ - reg: required for brcm,sr-usb-phy model phy.
+	reg value 0 is HS phy and 1 is SS phy.
+ - phy-cells: generic PHY binding; must be 0
+
+Refer to phy/phy-bindings.txt for the generic PHY binding properties
+
+Example:
+	usbphy0: usb-phy@68500000 {
+		compatible = "brcm,sr-usb-phy";
+		reg = <0x68500000 0x100>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		usb0_phy0: phy@0 {
+			reg = <0>;
+			#phy-cells = <0>;
+		};
+
+		usb0_phy1: phy@1 {
+			reg = <1>;
+			#phy-cells = <0>;
+		};
+	};
+
+	usbphy1: usb-phy@68510000 {
+		compatible = "brcm,sr-usb-phy";
+		reg = <0x68510000 0x100>,
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		usb1_phy0: phy@0 {
+			reg = <0>;
+			#phy-cells = <0>;
+		};
+
+		usb1_phy1: phy@1 {
+			reg = <1>;
+			#phy-cells = <0>;
+		};
+	};
+
+	usbphy2: usb-phy@68520000 {
+		compatible = "brcm,sr-usb-phy-v2";
+		reg = <0x68520000 0x100>,
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#phy-cells = <0>;
+	};
--- a/Documentation/devicetree/bindings/phy/brcm-sata-phy.txt
+++ b/Documentation/devicetree/bindings/phy/brcm-sata-phy.txt
@@ -27,7 +27,16 @@ Sub-nodes optional properties:
      This property is not applicable for "brcm,iproc-ns2-sata-phy",
      "brcm,iproc-nsp-sata-phy" and "brcm,iproc-sr-sata-phy".
 
-Example:
+- brcm,rxaeq-mode: string that indicates the desired RX equalizer
+  mode, possible values are:
+	"off" (equivalent to not specifying the property)
+	"auto"
+	"manual" (brcm,rxaeq-value is used in that case)
+
+- brcm,rxaeq-value: when 'rxaeq-mode' is set to "manual", provides the RX
+  equalizer value that should be used. Allowed range is 0..63.
+
+Example
 	sata-phy@f0458100 {
 		compatible = "brcm,bcm7445-sata-phy", "brcm,phy-sata3";
 		reg = <0xf0458100 0x1e00>, <0xf045804c 0x10>;
--- a/Documentation/devicetree/bindings/pinctrl/brcm,iproc-gpio.txt
+++ b/Documentation/devicetree/bindings/pinctrl/brcm,iproc-gpio.txt
@@ -21,8 +21,10 @@ Required properties:
     different IP block is used to handle pinctrl related functions
 
 - reg:
-    Define the base and range of the I/O address space that contains SoC
-GPIO/PINCONF controller registers
+  - Register set that define the base and range of the I/O address space that
+contains SoC GPIO/PINCONF controller registers. Always present
+  - Additional PINCONF registers. Present only for "brcm,cygnus-ccm-gpio",
+"brcm,cygnus-crmu-gpio"
 
 - ngpios:
     Total number of in-use slots in GPIO controller
@@ -43,6 +45,17 @@ Optional properties:
 - interrupt-controller:
     Specifies that the node is an interrupt controller
 
+- interrupt-parent:
+    Specifies an interrupt parent. The parent can be the mailbox controller if
+    interrupt forwarding is being used. If this is the case then 'interrupts'
+    must be 0 to specify the AON GPIO irq domain.
+
+- #interrupt-cells:
+    Must be two. The first cell is the GPIO pin number (within the controller's
+    pin space) and the second cell is used to specify flags. See also
+    Documentation/devicetree/bindings/interrupt-controller/interrupts.txt
+    for more details.
+
 - gpio-ranges:
     Specifies the mapping between gpio controller and pin-controllers pins.
     This requires 4 fields in cells defined as -
@@ -51,6 +64,16 @@ Optional properties:
     3  Pin-control base pin offset.
     4. number of gpio pins which are linearly mapped from pin base.
 
+- brcm,pinconf-func-off:
+    Certain iProc SoCs might have some of the PINCONF functions disabled in
+the chip when the iProc GPIO controller is integrated. This optional property
+allows unsupported PINCONF functions to be disabled
+
+- mboxes:
+    A phandle specifying the mailbox controller and channel used to communicate
+    with the co-processor. This is required to configure a gpio pin as a wake
+    source from sleep and deep sleep states.
+
 Supported generic PINCONF properties in child nodes:
 
 - pins:
@@ -69,7 +92,43 @@ in the node apply to. Pin names are "gpio-<pin>"
 - drive-strength:
     Valid drive strength values include 2, 4, 6, 8, 10, 12, 14, 16 (mA)
 
+- input-schmitt-enable:
+    Enable schmitt-trigger mode
+
+- input-schmitt-disable:
+    Disable schmitt-trigger mode
+
 Example:
+	/*
+	 * Mailbox controller used by gpio_crmu. For more information see:
+	 * Documentation/devicetree/bindings/mailbox/brcm,iproc-mailbox.txt
+	 */
+	mailbox: mailbox@03024024 {
+		compatible = "brcm,iproc-mailbox";
+		reg = <0x03024024 0x40>;
+		interrupts = <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+		#mbox-cells = <1>;
+	};
+
+	/*
+	 * CRMU gpio handler configured with mailbox channel 1 to
+	 * support wake source configuration.
+	 */
+	gpio_crmu: gpio@03024800 {
+		compatible = "brcm,cygnus-crmu-gpio";
+		reg = <0x03024800 0x50>,
+		      <0x03024008 0x18>;
+		ngpios = <6>;
+		#gpio-cells = <2>;
+		gpio-controller;
+		interrupt-controller;
+		interrupt-parent = <&mailbox>;
+		interrupts = <0>;
+		mboxes = <&mailbox 1>;
+	};
+
 	gpio_ccm: gpio@1800a000 {
 		compatible = "brcm,cygnus-ccm-gpio";
 		reg = <0x1800a000 0x50>,
--- /dev/null
+++ b/Documentation/devicetree/bindings/power/reset/brcm,iproc-reset.txt
@@ -0,0 +1,18 @@
+Device tree binding for broadcom iproc reset functionality.
+
+The system reset is implemented in the M0 processor.
+A message is sent to M0 via the mailbox driver which would
+contain a command to reset. This command when received at M0
+triggers the reset sequence.
+
+Required properties:
+- compatible: should be "brcm,iproc-reset".
+- mboxes: list of phandle and mailbox channel specifier,
+used for communication with a power management co-processor.
+
+Examples:
+
+		iproc-reset {
+			compatible = "brcm,iproc-reset";
+			mboxes = <&mailbox 0>;
+		};
\ No newline at end of file
--- /dev/null
+++ b/Documentation/devicetree/bindings/rtc/brcm,iproc-rtc.txt
@@ -0,0 +1,16 @@
+Broadcom RTC driver used for accessing RTC via smc calls
+
+Required properties:
+- compatible: "brcm,iproc-rtc"
+- interrupts: interrupt number for periodic interrupt
+
+Optional properties:
+- interrupts: interrupt number for alarm interrupt
+
+Example:
+rtc: rtc {
+	compatible = "brcm,iproc-rtc";
+	interrupts = <GIC_SPI 20 IRQ_TYPE_EDGE_RISING>,
+		     <GIC_SPI 21 IRQ_TYPE_EDGE_RISING>;
+};
+
--- a/Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt
+++ b/Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt
@@ -28,6 +28,7 @@ Required properties:
 						   BRCMSTB  SoCs
     "brcm,spi-bcm-qspi", "brcm,spi-nsp-qspi"     : MSPI+BSPI on Cygnus, NSP
     "brcm,spi-bcm-qspi", "brcm,spi-ns2-qspi"     : NS2 SoCs
+    "brcm,spi-iproc-qspi-v1", "brcm,spi-bcm-qspi": All iproc SoC's
 
 - reg:
     Define the bases and ranges of the associated I/O address spaces.
--- /dev/null
+++ b/Documentation/devicetree/bindings/thermal/brcm,sr-thermal.txt
@@ -0,0 +1,105 @@
+* Broadcom Stingray Thermal
+
+This binding describes thermal sensors that is part of Stingray SoCs.
+
+Required properties:
+- compatible : Must be "brcm,sr-thermal"
+- reg : Memory where tmon data will be available.
+- brcm,tmon-mask: A one cell bit mask of valid TMON sources.
+                  Each bit represents single TMON source.
+- #thermal-sensor-cells : Thermal sensor phandler
+- polling-delay: Max number of milliseconds to wait between polls.
+- thermal-sensors: A list of thermal sensor phandles and specifier.
+                   specifier value is tmon ID and it should be
+                   in correspond with brcm,tmon-mask.
+- temperature: trip temperature threshold in millicelsius.
+
+Example:
+	tmons {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x8f100000 0x100>;
+
+		tmon: tmon@0 {
+			compatible = "brcm,sr-thermal";
+			reg = <0x0 0x40>;
+			brcm,tmon-mask = <0x3f>;
+			#thermal-sensor-cells = <1>;
+		};
+	};
+
+	thermal-zones {
+		ihost0_thermal: ihost0-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 0>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+		ihost1_thermal: ihost1-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 1>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+		ihost2_thermal: ihost2-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 2>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+		ihost3_thermal: ihost3-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 3>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+		crmu_thermal: crmu-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 4>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+		nitro_thermal: nitro-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 5>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+	};
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/brcm,bdc-usb3.txt
@@ -0,0 +1,20 @@
+Broadcom USB device controller
+
+Required properties:
+  - compatible: "brcm,bdc-usb3"
+  - reg: Base address and length of the BDC register
+  - interrupts: Interrupt line of BDC
+
+Optional properties:
+  - phys: list of phandles to PHY nodes.
+  - phy-names: list of phy phandle names.
+	phy-names has to be "bdc-phy".
+
+Example:
+	bdc0: usb@68521000{
+			compatible = "brcm,bdc-usb3";
+			reg = <0x68521000 0x1000>;
+			interrupts = <GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>;
+			phys = <&usb1_phy1 1>;
+			phy-names = "bdc-phy";
+		};
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/snps,dw-ahb-udc.txt
@@ -0,0 +1,29 @@
+Synopsys USB Device controller.
+
+The device node is used for Synopsys Designware Cores AHB
+Subsystem Device Controller (UDC).
+
+Required properties:
+ - compatible: should be "snps,dw-ahbudc"
+ - reg: Offset and length of UDC register set
+ - interrupts: description of interrupt line
+ - phys: phandle to phy node.
+ - phy-names: name of phy node. Must be usb2drd.
+ - extcon: phandle to the extcon device
+
+Example:
+
+	usbdrd_phy: phy@6501c000 {
+		#phy-cells = <0>;
+		compatible = "brcm,ns2-drd-phy";
+		reg = <0x66000000 0x1000>,
+	}
+
+	udc_dwc: usb@664e0000 {
+		compatible = "snps,dw-ahb-udc";
+		reg = <0x664e0000 0x2000>;
+		interrupts = <GIC_SPI 424 IRQ_TYPE_LEVEL_HIGH>;
+		phys = <&usbdrd_phy>;
+		phy-names = "usb2drd";
+		extcon = <&usbdrd_phy>";
+	};
--- a/Documentation/devicetree/bindings/usb/usb-xhci.txt
+++ b/Documentation/devicetree/bindings/usb/usb-xhci.txt
@@ -29,6 +29,7 @@ Optional properties:
   - clocks: reference to a clock
   - usb3-lpm-capable: determines if platform is USB3 LPM capable
   - quirk-broken-port-ped: set if the controller has broken port disable mechanism
+  - needs-reset-on-resume : boolean, set this to force XHCI reset after resume
 
 Example:
 	usb@f0931000 {
--- a/Documentation/devicetree/bindings/watchdog/sp805-wdt.txt
+++ b/Documentation/devicetree/bindings/watchdog/sp805-wdt.txt
@@ -19,6 +19,8 @@ Required properties:
 
 Optional properties:
 - interrupts : Should specify WDT interrupt number.
+- timeout-sec : Should specify default WDT timeout in seconds. If unset, the
+                default timeout is 30 seconds
 
 Examples:
 
--- a/Documentation/kbuild/makefiles.txt
+++ b/Documentation/kbuild/makefiles.txt
@@ -1158,7 +1158,6 @@ When kbuild executes, the following steps are followed (roughly):
 
 	Example:
 		targets += $(dtb-y)
-		clean-files += *.dtb
 		DTC_FLAGS ?= -p 1024
 
 --- 6.8 Custom kbuild commands
--- a/Makefile
+++ b/Makefile
@@ -1582,7 +1582,7 @@ clean: $(clean-dirs)
 	$(call cmd,rmfiles)
 	@find $(if $(KBUILD_EXTMOD), $(KBUILD_EXTMOD), .) $(RCS_FIND_IGNORE) \
 		\( -name '*.[oas]' -o -name '*.ko' -o -name '.*.cmd' \
-		-o -name '*.ko.*' \
+		-o -name '*.ko.*' -o -name '*.dtb' -o -name '*.dtb.S' \
 		-o -name '*.dwo'  \
 		-o -name '*.su'  \
 		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
--- /dev/null
+++ b/arch/arm/include/asm/mach/bcm_optee_smc.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2017 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef BCM_OPTEE_SMC_H
+#define BCM_OPTEE_SMC_H
+
+#include <linux/arm-smccc.h>
+#include <linux/types.h>
+
+#define FAST_SMC_CALL		(ARM_SMCCC_FAST_CALL << ARM_SMCCC_TYPE_SHIFT)
+#define FAST_SMC(call)		(FAST_SMC_CALL | call)
+#define SMC_CALL_OK		0x0
+
+#define SSAPI_ENABLE_L2_CACHE	0x01000002
+#define SSAPI_DISABLE_L2_CACHE	0x01000003
+#define SSAPI_SLEEP_DORMANT	0x01004000
+#define SSAPI_SLEEP_DEEP	0x01004001
+
+#endif /* BCM_OPTEE_SMC_H */
--- a/arch/arm64/Kconfig.platforms
+++ b/arch/arm64/Kconfig.platforms
@@ -37,6 +37,7 @@ config ARCH_BCM2835
 
 config ARCH_BCM_IPROC
 	bool "Broadcom iProc SoC Family"
+	select ARM64_MODULE_PLTS
 	select COMMON_CLK_IPROC
 	select GPIOLIB
 	select PINCTRL
--- a/arch/arm64/boot/dts/Makefile
+++ b/arch/arm64/boot/dts/Makefile
@@ -1,34 +1,26 @@
 # SPDX-License-Identifier: GPL-2.0
-dts-dirs += actions
-dts-dirs += al
-dts-dirs += allwinner
-dts-dirs += altera
-dts-dirs += amd
-dts-dirs += amlogic
-dts-dirs += apm
-dts-dirs += arm
-dts-dirs += broadcom
-dts-dirs += cavium
-dts-dirs += exynos
-dts-dirs += freescale
-dts-dirs += hisilicon
-dts-dirs += marvell
-dts-dirs += mediatek
-dts-dirs += nvidia
-dts-dirs += qcom
-dts-dirs += realtek
-dts-dirs += renesas
-dts-dirs += rockchip
-dts-dirs += socionext
-dts-dirs += sprd
-dts-dirs += xilinx
-dts-dirs += lg
-dts-dirs += zte
-
-subdir-y	:= $(dts-dirs)
-
-dtstree		:= $(srctree)/$(src)
-
-dtb-$(CONFIG_OF_ALL_DTBS) := $(patsubst $(dtstree)/%.dts,%.dtb, $(foreach d,$(dts-dirs), $(wildcard $(dtstree)/$(d)/*.dts)))
-
-always		:= $(dtb-y)
+subdir-y += actions
+subdir-y += al
+subdir-y += allwinner
+subdir-y += altera
+subdir-y += amd
+subdir-y += amlogic
+subdir-y += apm
+subdir-y += arm
+subdir-y += broadcom
+subdir-y += cavium
+subdir-y += exynos
+subdir-y += freescale
+subdir-y += hisilicon
+subdir-y += lg
+subdir-y += marvell
+subdir-y += mediatek
+subdir-y += nvidia
+subdir-y += qcom
+subdir-y += realtek
+subdir-y += renesas
+subdir-y += rockchip
+subdir-y += socionext
+subdir-y += sprd
+subdir-y += xilinx
+subdir-y += zte
--- a/arch/arm64/boot/dts/broadcom/Makefile
+++ b/arch/arm64/boot/dts/broadcom/Makefile
@@ -1,8 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
 dtb-$(CONFIG_ARCH_BCM2835) += bcm2837-rpi-3-b.dtb
 
-dts-dirs	+= northstar2
-dts-dirs	+= stingray
-always		:= $(dtb-y)
-subdir-y	:= $(dts-dirs)
-clean-files	:= *.dtb
+subdir-y	+= northstar2
+subdir-y	+= stingray
--- a/arch/arm64/boot/dts/broadcom/northstar2/ns2.dtsi
+++ b/arch/arm64/boot/dts/broadcom/northstar2/ns2.dtsi
@@ -639,7 +639,7 @@
 			status = "disabled";
 		};
 
-		ssp0: ssp@66180000 {
+		ssp0: spi@66180000 {
 			compatible = "arm,pl022", "arm,primecell";
 			reg = <0x66180000 0x1000>;
 			interrupts = <GIC_SPI 404 IRQ_TYPE_LEVEL_HIGH>;
@@ -650,7 +650,7 @@
 			status = "disabled";
 		};
 
-		ssp1: ssp@66190000 {
+		ssp1: spi@66190000 {
 			compatible = "arm,pl022", "arm,primecell";
 			reg = <0x66190000 0x1000>;
 			interrupts = <GIC_SPI 405 IRQ_TYPE_LEVEL_HIGH>;
--- a/arch/arm64/boot/dts/broadcom/stingray/Makefile
+++ b/arch/arm64/boot/dts/broadcom/stingray/Makefile
@@ -1,7 +1,36 @@
 # SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm957604k.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm957604k-diag.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm957604k-optee.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm957604k-paxb-iommu.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm957604k-pcie-iommu.dtb
+
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958732t.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958732t-optee.dtb
+
 dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958742k.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958742k-diag.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958742k-optee.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958742k-paxb-iommu.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958742k-pcie-iommu.dtb
+
 dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958742t.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958742t-diag.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958742t-ns3.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958742t-optee.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958742t-paxb-iommu.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958742t-pcie-iommu.dtb
+
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958802a8023.dtb
+
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958802a804x.dtb
+
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958804a8040.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958804a8040-diag.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958804a8040-paxb-iommu.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958804a8040-pcie-iommu.dtb
+
+dtb-$(CONFIG_ARCH_BCM_IPROC) += ps250.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += ps410t.dtb
 
-always		:= $(dtb-y)
-subdir-y	:= $(dts-dirs)
-clean-files	:= *.dtb
+subdir-y	:= custom emulator
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/README
@@ -0,0 +1,23 @@
+bcm957604k.dtb                         - SmartIO SVK
+bcm957604k-diag.dtb                    - SmartIO SVK for userspace diag
+bcm957604k-optee.dtb                   - SmartIO SVK with optee enable
+bcm957604k-fs4.dtb                     - SmartIO SVK w/FS4
+
+bcm958732t.dtb                         - COMX
+
+bcm958742k.dtb                         - Combo SVK
+bcm958742k-diag.dtb                    - Combo SVK for userspace diag
+bcm958742k-fs4.dtb                     - Combo SVK w/FS4
+
+bcm958742t.dtb                         - SST100
+bcm958742t-diag.dtb                    - SST100 for userspace diag
+bcm958742t-fs4.dtb                     - SST100 w/FS4
+bcm958742t-fs4-uio.dtb                 - SST100 w/FS4 PMD
+
+bcm958802a.dtb                         - PS150xx 50G smartIO NIC board
+bcm958802a8023.dtb                     - PS410T 4x10G smartIO NIC board
+bcm958802a804x.dtb                     - PS225xx 2x25G smartIO NIC board, 4GB, 8GB, 16GB
+bcm958804a8040.dtb                     - PS1100R 1x100G smartIO NIC board
+bcm958804a8040-diag.dtb                - PS1100R for userspace diag
+ps250.dtb                              - PS250 2x50G smartIO NIC board: BCM958804A8042(16G)
+ps410t.dtb                             - PS410T 4x10G smartIO NIC board: BCM958802A8023(4G)
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm957604k-diag.dts
@@ -0,0 +1,52 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define NUM_PAXB 0
+
+#include "bcm957604k.dts"
+
+/*
+ * We do not want to perform PRBS on the two SATA ports of
+ * SmartIO board. Instead, read-write test will be done
+ */
+#undef NUM_SATA
+#define NUM_SATA 0
+
+#include "stingray-diag.dtsi"
+
+/ {
+	chosen {
+		bootargs = "root=/dev/ram rw console=ttyS0,115200n8 \
+			    earlycon=uart8250,mmio32,0x68a10000 cma=64M \
+			    mtdparts=brcmnand.0:10m(nboot),16m(kernel),1m(dt-blob),940m(nroot),32m(nand-test)";
+	};
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm957604k-optee.dts
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2019 Broadcom
+ */
+
+#define ENABLE_OPTEE 1
+
+#include "bcm957604k.dts"
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm957604k-paxb-iommu.dts
@@ -0,0 +1,40 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define ENABLE_PAXB_IOMMU 1
+#define ENABLE_PAXC_IOMMU 0
+
+#include "bcm957604k.dts"
+
+/ {
+	model = "Stingray SmartIO SVK w/PAXB IOMMU (BCM957604K)";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm957604k-pcie-iommu.dts
@@ -0,0 +1,40 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define ENABLE_PAXB_IOMMU 1
+#define ENABLE_PAXC_IOMMU 1
+
+#include "bcm957604k.dts"
+
+/ {
+	model = "Stingray SmartIO SVK w/PCIe IOMMU (BCM957604K)";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm957604k.dts
@@ -0,0 +1,57 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/dts-v1/;
+
+#define NUM_CRYPTO	32
+#define NUM_RAID	8
+#define ENABLE_I2C0	1
+#define ENABLE_I2C1	1
+#define ENABLE_PWM	0
+#define ENABLE_RTC	1
+#define ENABLE_SSP0	1
+#define ENABLE_SSP1	1
+#define ENABLE_UART2	0
+#define ENABLE_UART3	0
+#define ENABLE_USB1	0
+#ifndef NUM_SATA
+#define NUM_SATA	2
+#endif
+
+/ {
+	model = "Stingray SmartIO SVK (BCM957604K)";
+};
+
+#include "bcm958742-base.dtsi"
+&sdio0 {
+	mmc-ddr-1_8v;
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958732-base.dtsi
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2016-2018 Broadcom
+ */
+
+#ifndef ENABLE_EMMC
+#define ENABLE_EMMC	1
+#endif
+
+#ifndef ENABLE_PAXC
+#define ENABLE_PAXC	1
+#endif
+
+#ifndef ENABLE_PWM
+#define ENABLE_PWM	1
+#endif
+
+#ifndef ENABLE_SDCARD
+#define ENABLE_SDCARD	1
+#endif
+
+#ifndef NUM_PAXB
+#define NUM_PAXB	8
+#endif
+
+#include "stingray-board-base.dtsi"
+
+&ssp0 {
+	spi-flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <20000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		pl022,com-mode = <0>;
+	};
+};
+
+&ssp1 {
+	spi-flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <20000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		pl022,com-mode = <0>;
+	};
+};
+
+#if (ENABLE_I2C0 == 1)
+&i2c0 {
+	pca9505: pca9505@20 {
+		compatible = "nxp,pca9505";
+		gpio-controller;
+		#gpio-cells = <2>;
+		reg = <0x20>;
+		interrupt-parent = <&gpio_hsls>;
+		interrupts = <118 1>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+	};
+};
+#endif
+
+#if (ENABLE_I2C1 == 1)
+&i2c1 {
+	pcf8574: pcf8574@20 {
+		compatible = "nxp,pcf8574a";
+		gpio-controller;
+		#gpio-cells = <2>;
+		reg = <0x27>;
+	};
+};
+#endif
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958732t-optee.dts
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2016-2018 Broadcom
+ */
+
+#define ENABLE_OPTEE 1
+
+#include "bcm958732t.dts"
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958732t.dts
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2016-2018 Broadcom
+ */
+
+/dts-v1/;
+
+#define NUM_CRYPTO	32
+#define NUM_RAID	8
+#define ENABLE_I2C0	1
+#define ENABLE_I2C1	1
+#define ENABLE_PWM	0
+#define ENABLE_RTC	1
+#define ENABLE_SSP0	1
+#define ENABLE_SSP1	1
+#define ENABLE_UART2	0
+#define ENABLE_UART3	0
+#define ENABLE_USB1	0
+#define NUM_SATA	2
+#define ENABLE_EMMC	1
+
+/ {
+	model = "Stingray COMX (BCM958732T)";
+};
+
+#include "bcm958732-base.dtsi"
+
+&sdio0 {
+	mmc-ddr-1_8v;
+};
--- a/arch/arm64/boot/dts/broadcom/stingray/bcm958742-base.dtsi
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742-base.dtsi
@@ -30,20 +30,30 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "stingray.dtsi"
+#ifndef ENABLE_EMMC
+#define ENABLE_EMMC	1
+#endif
 
-/ {
-	chosen {
-		stdout-path = "serial0:115200n8";
-	};
+#ifndef ENABLE_NAND
+#define ENABLE_NAND	1
+#endif
 
-	aliases {
-		serial0 = &uart1;
-		serial1 = &uart0;
-		serial2 = &uart2;
-		serial3 = &uart3;
-	};
+#ifndef ENABLE_PAXC
+#define ENABLE_PAXC	1
+#endif
+
+#ifndef ENABLE_PWM
+#define ENABLE_PWM	1
+#endif
 
+#ifndef ENABLE_SDCARD
+#define ENABLE_SDCARD	1
+#endif
+
+#include "stingray-board-base.dtsi"
+
+/ {
+#if (ENABLE_I2C0 == 1)
 	sdio0_vddo_ctrl_reg: sdio0_vddo_ctrl {
 		compatible = "regulator-gpio";
 		regulator-name = "sdio0_vddo_ctrl_reg";
@@ -54,7 +64,9 @@
 		states = <3300000 0x0
 			  1800000 0x1>;
 	};
+#endif
 
+#if (ENABLE_I2C0 == 1)
 	sdio1_vddo_ctrl_reg: sdio1_vddo_ctrl {
 		compatible = "regulator-gpio";
 		regulator-name = "sdio1_vddo_ctrl_reg";
@@ -65,123 +77,70 @@
 		states = <3300000 0x0
 			  1800000 0x1>;
 	};
+#endif
 };
 
-&memory { /* Default DRAM banks */
-	reg = <0x00000000 0x80000000 0x0 0x80000000>, /* 2G @ 2G */
-	      <0x00000008 0x80000000 0x1 0x80000000>; /* 6G @ 34G */
-};
-
-&sata0 {
-	status = "okay";
-};
-
-&sata_phy0{
-	status = "okay";
-};
-
-&sata1 {
-	status = "okay";
-};
-
-&sata_phy1{
-	status = "okay";
-};
-
-&sata2 {
-	status = "okay";
-};
-
-&sata_phy2{
-	status = "okay";
-};
-
-&sata3 {
-	status = "okay";
-};
-
-&sata_phy3{
-	status = "okay";
-};
-
-&sata4 {
-	status = "okay";
-};
-
-&sata_phy4{
-	status = "okay";
-};
-
-&sata5 {
-	status = "okay";
-};
-
-&sata_phy5{
-	status = "okay";
-};
-
-&sata6 {
-	status = "okay";
-};
-
-&sata_phy6{
-	status = "okay";
-};
-
-&sata7 {
-	status = "okay";
+&sdio0 {
+#if (ENABLE_I2C0 == 1)
+	vqmmc-supply = <&sdio0_vddo_ctrl_reg>;
+#endif
 };
 
-&sata_phy7{
-	status = "okay";
+&sdio1 {
+#if (ENABLE_I2C0 == 1)
+	vqmmc-supply = <&sdio1_vddo_ctrl_reg>;
+#endif
 };
 
-&mdio_mux_iproc {
-	mdio@10 {
-		gphy0: eth-phy@10 {
-			reg = <0x10>;
-		};
+&ssp0 {
+	spi-flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <20000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		pl022,com-mode = <0>;
 	};
 };
 
-&uart1 {
-	status = "okay";
-};
-
-&pwm {
-	status = "okay";
+&ssp1 {
+	spi-flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <20000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		pl022,com-mode = <0>;
+	};
 };
 
+#if (ENABLE_I2C0 == 1)
 &i2c0 {
-	status = "okay";
-
 	pca9505: pca9505@20 {
 		compatible = "nxp,pca9505";
 		gpio-controller;
 		#gpio-cells = <2>;
 		reg = <0x20>;
+		interrupt-parent = <&gpio_hsls>;
+		interrupts = <118 1>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
 	};
 };
+#endif
 
+#if (ENABLE_I2C1 == 1)
 &i2c1 {
-	status = "okay";
-
-	pcf8574: pcf8574@20 {
+	pcf8574: pcf8574@27 {
 		compatible = "nxp,pcf8574a";
 		gpio-controller;
 		#gpio-cells = <2>;
 		reg = <0x27>;
 	};
 };
-
-&enet {
-	phy-mode = "rgmii-id";
-	phy-handle = <&gphy0>;
-	status = "okay";
-};
+#endif
 
 &nand {
-	status = "ok";
 	nandcs@0 {
 		compatible = "brcm,nandcs";
 		reg = <0>;
@@ -194,16 +153,3 @@
 		#size-cells = <1>;
 	};
 };
-
-&sdio0 {
-	vqmmc-supply = <&sdio0_vddo_ctrl_reg>;
-	non-removable;
-	full-pwr-cycle;
-	status = "okay";
-};
-
-&sdio1 {
-	vqmmc-supply = <&sdio1_vddo_ctrl_reg>;
-	full-pwr-cycle;
-	status = "okay";
-};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742k-diag.dts
@@ -0,0 +1,46 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define NUM_PAXB 0
+
+#include "bcm958742k.dts"
+
+#include "stingray-diag.dtsi"
+
+/ {
+	chosen {
+		bootargs = "root=/dev/ram rw console=ttyS0,115200n8 \
+			    earlycon=uart8250,mmio32,0x68a10000 cma=64M \
+			    mtdparts=brcmnand.0:10m(nboot),16m(kernel),1m(dt-blob),940m(nroot),32m(nand-test)";
+	};
+};
+
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742k-optee.dts
@@ -0,0 +1,35 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define ENABLE_OPTEE 1
+
+#include "bcm958742k.dts"
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742k-paxb-iommu.dts
@@ -0,0 +1,40 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define ENABLE_PAXB_IOMMU 1
+#define ENABLE_PAXC_IOMMU 0
+
+#include "bcm958742k.dts"
+
+/ {
+	model = "Stingray Combo SVK w/PAXB IOMMU (BCM958742K)";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742k-pcie-iommu.dts
@@ -0,0 +1,40 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define ENABLE_PAXB_IOMMU 1
+#define ENABLE_PAXC_IOMMU 1
+
+#include "bcm958742k.dts"
+
+/ {
+	model = "Stingray Combo SVK w/PCIe IOMMU (BCM958742K)";
+};
--- a/arch/arm64/boot/dts/broadcom/stingray/bcm958742k.dts
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742k.dts
@@ -32,10 +32,20 @@
 
 /dts-v1/;
 
+#define NUM_CRYPTO	32
+#define NUM_RAID	8
+#define ENABLE_I2C0	1
+#define ENABLE_I2C1	1
+#define ENABLE_RTC	1
+#define ENABLE_SSP0	1
+#define ENABLE_SSP1	1
+#define ENABLE_UART2	1
+#define ENABLE_UART3	1
+#define NUM_SATA	8
+
 #include "bcm958742-base.dtsi"
 
 / {
-	compatible = "brcm,bcm958742k", "brcm,stingray";
 	model = "Stingray Combo SVK (BCM958742K)";
 };
 
@@ -46,41 +56,3 @@
 &sdio0 {
 	mmc-ddr-1_8v;
 };
-
-&uart2 {
-	status = "okay";
-};
-
-&uart3 {
-	status = "okay";
-};
-
-&ssp0 {
-	pinctrl-0 = <&spi0_pins>;
-	pinctrl-names = "default";
-	cs-gpios = <&gpio_hsls 34 0>;
-	status = "okay";
-
-	spi-flash@0 {
-		compatible = "jedec,spi-nor";
-		reg = <0>;
-		spi-max-frequency = <20000000>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-	};
-};
-
-&ssp1 {
-	pinctrl-0 = <&spi1_pins>;
-	pinctrl-names = "default";
-	cs-gpios = <&gpio_hsls 96 0>;
-	status = "okay";
-
-	spi-flash@0 {
-		compatible = "jedec,spi-nor";
-		reg = <0>;
-		spi-max-frequency = <20000000>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-	};
-};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742t-diag.dts
@@ -0,0 +1,47 @@
+
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define NUM_PAXB 0
+
+#include "bcm958742t.dts"
+
+#include "stingray-diag.dtsi"
+
+/ {
+	chosen {
+		bootargs = "root=/dev/ram rw console=ttyS0,115200n8 \
+			    earlycon=uart8250,mmio32,0x68a10000 cma=64M \
+			    mtdparts=brcmnand.0:10m(nboot),16m(kernel),1m(dt-blob),940m(nroot),32m(nand-test)";
+	};
+};
+
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742t-ns3.dts
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2019 Broadcom
+ */
+
+/dts-v1/;
+
+#define NUM_CRYPTO	0
+#define NUM_RAID	0
+#define NUM_SATA	0
+#define ENABLE_NAND	0
+#define ENABLE_SSP0	0
+#define ENABLE_SSP1	0
+#define ENABLE_SDCARD	0
+#define ENABLE_PWM	0
+#define ENABLE_USB1	0
+#define ENABLE_UART2	0
+#define ENABLE_UART3	0
+
+#define ENABLE_I2C0	1
+#define ENABLE_I2C1	1
+#define ENABLE_EMMC	1
+#define ENABLE_OPTEE	1
+#define ENABLE_MDIO	1
+#define ENABLE_ENET	1
+
+#define NUM_PAXB	1
+
+#ifndef ENABLE_PAXC
+#define ENABLE_PAXC	1
+#endif
+
+#define ENABLE_PAXB_IOMMU	1
+#define ENABLE_PAXC_IOMMU	1
+
+#include "bcm958742-base.dtsi"
+
+/ {
+	model = "NS3 (BCM958742T)";
+};
+
+&i2c0 {
+	pca9505: pca9505@20 {
+		interrupts = <111 1 1>;
+	};
+};
+
+&gphy0 {
+	enet-phy-lane-swap;
+};
+
+&sdio0 {
+	mmc-ddr-1_8v;
+};
+
+&qspi {
+	status = "okay";
+};
+
+&pci_lpm_region {
+	status = "disabled";
+};
+
+&pcie0 {
+	msi-map = <0x0000 &gic_its 0x0000 0x3ff>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x0000 0x3ff>;
+#endif
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742t-optee.dts
@@ -0,0 +1,35 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define ENABLE_OPTEE 1
+
+#include "bcm958742t.dts"
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742t-paxb-iommu.dts
@@ -0,0 +1,40 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define ENABLE_PAXB_IOMMU 1
+#define ENABLE_PAXC_IOMMU 0
+
+#include "bcm958742t.dts"
+
+/ {
+	model = "Stingray SST100 w/PAXB IOMMU (BCM958742T)";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742t-pcie-iommu.dts
@@ -0,0 +1,40 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define ENABLE_PAXB_IOMMU 1
+#define ENABLE_PAXC_IOMMU 1
+
+#include "bcm958742t.dts"
+
+/ {
+	model = "Stingray SST100 w/PCIe IOMMU (BCM958742T)";
+};
--- a/arch/arm64/boot/dts/broadcom/stingray/bcm958742t.dts
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958742t.dts
@@ -32,13 +32,23 @@
 
 /dts-v1/;
 
+#define NUM_CRYPTO	32
+#define NUM_RAID	8
+#define ENABLE_I2C0	1
+#define NUM_SATA	8
+
 #include "bcm958742-base.dtsi"
 
 / {
-	compatible = "brcm,bcm958742t", "brcm,stingray";
 	model = "Stingray SST100 (BCM958742T)";
 };
 
+&i2c0 {
+	pca9505: pca9505@20 {
+		interrupts = <111 1 1>;
+	};
+};
+
 &gphy0 {
 	enet-phy-lane-swap;
 };
@@ -46,3 +56,62 @@
 &sdio0 {
 	mmc-ddr-1_8v;
 };
+
+&pcie0 {
+	msi-map = <0x0000 &gic_its 0x0000 0x3ff>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x0000 0x3ff>;
+#endif
+};
+
+&pcie1 {
+        msi-map = <0x0000 &gic_its 0x0400 0x3ff>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x0400 0x3ff>;
+#endif
+};
+
+&pcie2 {
+        msi-map = <0x0000 &gic_its 0x0800 0x3ff>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x0800 0x3ff>;
+#endif
+};
+
+&pcie3 {
+        msi-map = <0x0000 &gic_its 0x0c00 0x3ff>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x0c00 0x3ff>;
+#endif
+};
+
+&pcie4 {
+
+        msi-map = <0x0000 &gic_its 0x1000 0x3ff>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x1000 0x3ff>;
+#endif
+};
+&pcie5 {
+
+        msi-map = <0x0000 &gic_its 0x1400 0x3ff>;
+
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x1400 0x3ff>;
+#endif
+};
+&pcie6 {
+
+        msi-map = <0x0000 &gic_its 0x1800 0x3ff>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x1800 0x3ff>;
+#endif
+};
+
+&pcie7 {
+
+        msi-map = <0x0000 &gic_its 0x1c00 0x3ff>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x1c00 0x3ff>;
+#endif
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958802a804x.dts
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2018 Broadcom
+ */
+
+/dts-v1/;
+
+#define NUM_CRYPTO	32
+#define NUM_RAID	0
+#define ENABLE_ENET	0
+#define ENABLE_MDIO	0
+#define ENABLE_USB1	0
+#define NUM_PAXB	0
+
+#include "stingray-board-base.dtsi"
+
+/ {
+	model = "Stingray PS225xx (BCM958802A804x)";
+
+	chosen {
+		stdout-path = "serial1:115200n8";
+	};
+};
+
+&sdio0 {
+	no-1-8-v;
+};
+
+&uart0 {
+	status = "okay";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958804a8040-diag.dts
@@ -0,0 +1,46 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define NUM_PAXB	0
+#define ENABLE_I2C1	1
+
+#include "bcm958804a8040.dts"
+
+#include "stingray-diag.dtsi"
+
+/ {
+	chosen {
+		bootargs = "root=/dev/ram rw console=ttyS0,115200n8 \
+			    earlycon=uart8250,mmio32,0x68a10000 cma=64M \
+			    mtdparts=brcmnand.0:10m(nboot),16m(kernel),1m(dt-blob),940m(nroot),32m(nand-test)";
+	};
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958804a8040-paxb-iommu.dts
@@ -0,0 +1,40 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2018 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define ENABLE_PAXB_IOMMU 1
+#define ENABLE_PAXC_IOMMU 0
+
+#include "bcm958804a8040.dts"
+
+/ {
+	model = "Stingray PS1100R w/PAXB IOMMU (BCM958804A8040)";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958804a8040-pcie-iommu.dts
@@ -0,0 +1,40 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2018 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define ENABLE_PAXB_IOMMU 1
+#define ENABLE_PAXC_IOMMU 1
+
+#include "bcm958804a8040.dts"
+
+/ {
+	model = "Stingray PS1100R w/PCIe IOMMU (BCM958804A8040)";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/bcm958804a8040.dts
@@ -0,0 +1,60 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/dts-v1/;
+
+#define NUM_CRYPTO	32
+#define NUM_RAID	8
+#define ENABLE_I2C0	1
+#define ENABLE_USB1	0
+
+/ {
+	model = "Stingray PS1100R (BCM958804A8040)";
+};
+
+#include "stingray-board-base.dtsi"
+
+&sdio0 {
+	no-1-8-v;
+};
+
+&gphy0 {
+	reg = <0x0>;
+};
+
+&i2c0 {
+	thermal: thermal@4c {
+		compatible = "national,lm90";
+		reg = <0x4c>;
+		#thermal-sensor-cells = <1>;
+	};
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/Makefile
@@ -0,0 +1,5 @@
+subdir-y	:= bcm958808ce
+subdir-y	+= bcm958802ht
+subdir-y	+= bcm958804a8046i
+subdir-y	+= bcm958804wt
+subdir-y	+= overlake
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/README
@@ -0,0 +1,3 @@
+bcm958804a8046i.dtb                    - BCM58804 PS225N smartnic platform
+bcm958804wt.dtb                        - BCM58804 WT storage platform
+bcm958808ce.dtb                        - BCM58808 CE storage platform
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/bcm958802ht/Makefile
@@ -0,0 +1 @@
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958802ht.dtb
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/bcm958802ht/bcm958802ht.dts
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2018 Broadcom
+ */
+
+/dts-v1/;
+
+#define NUM_CRYPTO	32
+#define NUM_RAID	0
+#define ENABLE_ENET	0
+#define ENABLE_MDIO	0
+#define ENABLE_USB1	0
+
+#define ENABLE_I2C0	1
+
+#define ENABLE_32BIT_OUTBOUND 1
+#define ENABLE_IHOST12_CPUS 0
+
+#include "../../stingray-board-base.dtsi"
+
+/ {
+	model = "Stingray HT (BCM958802HT)";
+
+	chosen {
+		stdout-path = "serial1:115200n8";
+	};
+
+	nvme_lpm {
+		status = "okay";
+	};
+};
+
+&sdio0 {
+	no-1-8-v;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&nvme_lpm {
+	status = "okay";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/bcm958804a8046i/Makefile
@@ -0,0 +1,4 @@
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958804a8046i.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958804a8046i-diag.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958804a8046i-paxb-iommu.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958804a8046i-pcie-iommu.dtb
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/bcm958804a8046i/bcm958804a8046i-diag.dts
@@ -0,0 +1,11 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2019 Broadcom
+ */
+
+#define NUM_PAXB 0
+
+#include "bcm958804a8046i.dts"
+
+#include "../../stingray-diag.dtsi"
+
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/bcm958804a8046i/bcm958804a8046i-paxb-iommu.dts
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2019 Broadcom
+ */
+
+#define ENABLE_PAXB_IOMMU 1
+#define ENABLE_PAXC_IOMMU 0
+
+#include "bcm958804a8046i.dts"
+
+/ {
+	model = "Stingray PS225N w/PAXB IOMMU (BCM958804A8046I)";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/bcm958804a8046i/bcm958804a8046i-pcie-iommu.dts
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2019 Broadcom
+ */
+
+#define ENABLE_PAXB_IOMMU 1
+#define ENABLE_PAXC_IOMMU 1
+
+#include "bcm958804a8046i.dts"
+
+/ {
+	model = "Stingray PS225N w/PCIE IOMMU (BCM958804A8046I)";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/bcm958804a8046i/bcm958804a8046i.dts
@@ -0,0 +1,84 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2018 Broadcom
+ */
+
+/dts-v1/;
+
+#define NUM_CRYPTO	32
+#define NUM_RAID	0
+#define ENABLE_ENET	0
+#define ENABLE_MDIO	0
+#define ENABLE_USB1	0
+#define ENABLE_I2C0	1
+#define ENABLE_I2C1	1
+#define ENABLE_SSP0	1
+#define ENABLE_SSP1	1
+
+#include "../../stingray-board-base.dtsi"
+
+/ {
+	model = "Stingray PS225N (BCM958804A8046I)";
+
+	chosen {
+		stdout-path = "serial1:115200n8";
+	};
+};
+
+&sdio0 {
+	no-1-8-v;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&pcie7 {
+	msi-map = <0x0000 &gic_its 0x1c00 0x400>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x1c00 0x400>;
+#endif
+};
+
+&ssp0 {
+	status = "okay";
+	num-cs = <1>;
+
+	spiflash: m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "n25q512a";
+		spi-max-frequency = <25000000>;
+		reg = <0>;
+		spi-cpol;
+		spi-cpha;
+		pl022,com-mode = <0>;
+
+		partition@0 {
+			label = "boot";
+			reg = <0x00000000 0x4000000>;
+		};
+	};
+};
+
+&ssp1 {
+	status = "okay";
+	num-cs = <1>;
+
+	spidev@0 {
+		compatible = "spidev";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+		pl022,com-mode = <0>;
+	};
+};
+
+&i2c1 {
+	bmc@40000035 {
+		compatible = "i2c-slave-bmc";
+		reg = <0x40000035>;
+		/* name of thermal zone */
+		bmc-thermal-zone = "ihost0-thermal";
+	};
+};
+
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/bcm958804wt/Makefile
@@ -0,0 +1 @@
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958804wt.dtb
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/bcm958804wt/bcm958804wt.dts
@@ -0,0 +1,45 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2018 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/dts-v1/;
+
+#define ENABLE_I2C1	1
+
+/ {
+	model = "BCM958804WT";
+};
+
+#include "../../stingray-board-base.dtsi"
+
+&sdio0 {
+	no-1-8-v;
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/bcm958808ce/Makefile
@@ -0,0 +1 @@
+dtb-$(CONFIG_ARCH_BCM_IPROC) += bcm958808ce.dtb
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/bcm958808ce/bcm958808ce.dts
@@ -0,0 +1,52 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/dts-v1/;
+
+#define ENABLE_I2C0	1
+#define ENABLE_I2C1	1
+#define ENABLE_SDCARD	1
+#define NUM_SATA	1
+
+/ {
+	model = "BCM958808CE";
+};
+
+#include "../../stingray-board-base.dtsi"
+
+&sdio0 {
+	no-1-8-v;
+};
+
+&sdio1 {
+	no-1-8-v;
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/overlake/Makefile
@@ -0,0 +1,2 @@
+dtb-$(CONFIG_ARCH_BCM_IPROC) += overlake.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += overlake-diag.dtb
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/overlake/overlake-diag.dts
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2018 Broadcom
+ */
+
+#define NUM_PAXB 0
+
+#include "overlake.dts"
+
+#include "../../stingray-diag.dtsi"
+
+/ {
+	chosen {
+		bootargs = "root=/dev/ram rw console=ttyS0,115200n8 \
+			    earlycon=uart8250,mmio32,0x68a10000 cma=64M";
+	};
+};
+
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/custom/overlake/overlake.dts
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2018 Broadcom
+ */
+
+/dts-v1/;
+
+
+#define NUM_CRYPTO	0
+#define NUM_RAID	0
+#define NUM_SATA	0
+#define ENABLE_NAND	0
+#define ENABLE_SSP0	0
+#define ENABLE_SSP1	0
+#define ENABLE_SDCARD	0
+#define ENABLE_PWM	0
+#define ENABLE_ENET	0
+#define ENABLE_MDIO	0
+#define ENABLE_USB1	0
+#define ENABLE_UART2	0
+#define ENABLE_UART3	0
+
+#define ENABLE_I2C0	1
+#define ENABLE_I2C1	1
+#define ENABLE_EMMC	1
+#define ENABLE_OPTEE	1
+
+#define ENABLE_PCIE0	1
+
+#ifndef ENABLE_PAXC
+#define ENABLE_PAXC	1
+#endif
+
+#define ENABLE_PAXB_IOMMU	1
+#define ENABLE_PAXC_IOMMU	1
+
+#include "../../stingray-board-base.dtsi"
+
+/ {
+	model = "Overlake";
+};
+
+&sdio0 {
+	mmc-hs200-1_8v;
+};
+
+&i2c0 {
+	tca9535@20 {
+		compatible = "nxp,pca9535";
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+};
+
+&qspi {
+	status = "okay";
+};
+
+&pci_lpm_region {
+	status = "disabled";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/emulator/Makefile
@@ -0,0 +1,5 @@
+dtb-$(CONFIG_ARCH_BCM_IPROC) += stingray-palladium.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += stingray-pd-paxc-chimp.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += stingray-pd-paxb.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += stingray-pd-usb.dtb
+dtb-$(CONFIG_ARCH_BCM_IPROC) += stingray-pd-sata.dtb
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/emulator/stingray-palladium.dts
@@ -0,0 +1,151 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/dts-v1/;
+
+#define NUM_CRYPTO	32
+#define NUM_RAID	8
+
+/* HACK: Reserve initrd location
+ * The memreserve entry for initrd is supposed
+ * to be updated in DTB by bootloader before
+ * handing over DTB to Linux kernel.
+ */
+/memreserve/ 0x81000000 0x00800000;
+
+/* HACK: Reserve bl31 location
+ * The memreserve entry for bl31 is supposed to
+ * be updated in DTB by bootloader before handing
+ * over DTB to Linux kernel. This is so because
+ * only firmware (or bootloader) know the correct
+ * location of bl31 and bl31 location in DDR can
+ * also change in-future.
+ */
+/memreserve/ 0x8f000000 0x00100000;
+
+#include "./stingray-pd-base.dtsi"
+
+/ {
+	model = "Broadcom Stingray Palladium";
+
+	chosen { /* HACK: hard-code kernel args and initrd location */
+		bootargs = "root=/dev/ram rw console=ttyS0,4800n8 \
+			    earlycon=uart8250,mmio32,0x68a10000 cma=64M \
+			    maxcpus=2";
+		linux,initrd-start = <0x0 0x81000000>;
+		linux,initrd-end = <0x0 0x81800000>;
+	};
+};
+
+&uart1 {
+	/* Hack: For palladium we force DLL=1 and DLM=0.
+	 * To achieve this, we set:
+	 * clock-frequency = <desired_baudrate> x 16
+	 */
+	clock-frequency = <76800>;
+	status = "okay";
+};
+
+&ssp0 {
+	status = "okay";
+
+	spidev@0 {
+		compatible = "spidev-test";
+		spi-max-frequency = <8000000>;
+		reg = <0>;
+	};
+};
+
+&ssp1 {
+	status = "okay";
+
+	spidev@0 {
+		compatible = "spidev-test";
+		spi-max-frequency = <8000000>;
+		reg = <0>;
+	};
+};
+
+&sdio0 {
+	/* For palladium eMMC is always present. */
+	non-removable;
+	status = "okay";
+};
+
+&qspi {
+	bspi-sel = <0>;
+	flash: m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "m25p80";
+		reg = <0x0>;
+		spi-max-frequency = <12500000>;
+		m25p,fast-read;
+		spi-cpol;
+		spi-cpha;
+
+		partition@0 {
+			label = "boot";
+			reg = <0x00000000 0x100000>;
+		};
+
+		partition@1 {
+			label = "env";
+			reg = <0x000a0000 0x00060000>;
+		};
+
+		partition@2 {
+			label = "system";
+			reg = <0x00100000 0x00600000>;
+		};
+
+		partition@3 {
+			label = "rootfs";
+			reg = <0x00700000 0x01900000>;
+		};
+	};
+};
+
+&mdio_mux_iproc {
+	mdio@10 {
+		gphy0: eth-phy@10 {
+			reg = <0x10>;
+		};
+	};
+};
+
+&enet {
+	phy-mode = "mii";
+	phy-handle = <&gphy0>;
+	/* switch mode used in emulator to bypass phy */
+	brcm,enet-switch-mode;
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/emulator/stingray-pd-base.dtsi
@@ -0,0 +1,46 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "../stingray.dtsi"
+
+/ {
+	aliases {
+		serial0 = &uart1;
+		serial1 = &uart0;
+		serial2 = &uart2;
+		serial3 = &uart3;
+	};
+};
+
+&memory {
+	reg = <0x00000000 0x80000000 0x0 0x40000000>;
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/emulator/stingray-pd-paxb.dts
@@ -0,0 +1,92 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/dts-v1/;
+
+/* HACK: Reserve initrd location
+ * The memreserve entry for initrd is supposed
+ * to be updated in DTB by bootloader before
+ * handing over DTB to Linux kernel.
+ */
+/memreserve/ 0x81000000 0x00800000;
+
+/* HACK: Reserve bl31 location
+ * The memreserve entry for bl31 is supposed to
+ * be updated in DTB by bootloader before handing
+ * over DTB to Linux kernel. This is so because
+ * only firmware (or bootloader) know the correct
+ * location of bl31 and bl31 location in DDR can
+ * also change in-future.
+ */
+/memreserve/ 0x8f000000 0x00100000;
+
+#include "./stingray-pd-base.dtsi"
+
+/ {
+	model = "Broadcom Stingray PAXB Palladium";
+
+	chosen { /* HACK: hard-code kernel args and initrd location */
+		bootargs = "root=/dev/ram rw console=ttyS3,4800n8 \
+		earlycon=uart8250,mmio32,0x68a30000 cma=64M \
+		maxcpus=2";
+
+		linux,stdout-path = "/soc/uart@68a30000:4800n8";
+		linux,initrd-start = <0x0 0x81000000>;
+		linux,initrd-end = <0x0 0x81800000>;
+	};
+
+};
+
+&uart3 {
+	/* Hack: For palladium we force DLL=1 and DLM=0.
+	 * To achieve this, we set:
+	 * clock-frequency = <desired_baudrate> x 16
+	 */
+	clock-frequency = <76800>;
+	status = "okay";
+};
+
+&pcie1 {
+	dma-coherent;
+	dma-ranges = <0x43000000 0 0x80000000 0 0x80000000 0x0 0x80000000
+		      0x43000000 0x8 0x80000000 0x8 0x80000000 0x0 0x80000000>;
+
+	status = "okay";
+};
+
+/*
+ * HACK to disable fs4 bus to speed up paxb palladium kernel boot up
+ * speed, since this palladium is dedicated for PAXB bring up
+ */
+&fs4 {
+	status = "disabled";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/emulator/stingray-pd-paxc-chimp.dts
@@ -0,0 +1,91 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/dts-v1/;
+
+#define ENABLE_PAXC	1
+
+/* HACK: Reserve initrd location
+ * The memreserve entry for initrd is supposed
+ * to be updated in DTB by bootloader before
+ * handing over DTB to Linux kernel.
+ */
+/memreserve/ 0x81000000 0x00800000;
+
+/* HACK: Reserve bl31 location
+ * The memreserve entry for bl31 is supposed to
+ * be updated in DTB by bootloader before handing
+ * over DTB to Linux kernel. This is so because
+ * only firmware (or bootloader) know the correct
+ * location of bl31 and bl31 location in DDR can
+ * also change in-future.
+ */
+/memreserve/ 0x8f000000 0x00100000;
+
+#include "./stingray-pd-base.dtsi"
+
+/ {
+	model = "Broadcom Stingray PAXC Chimp Palladium";
+
+	chosen { /* HACK: hard-code kernel args and initrd location */
+		bootargs = "root=/dev/ram rw console=ttyS0,4800n8 \
+			    earlycon=uart8250,mmio32,0x68a10000 cma=64M \
+			    maxcpus=2";
+		linux,initrd-start = <0x0 0x81000000>;
+		linux,initrd-end = <0x0 0x81800000>;
+	};
+};
+
+&uart1 {
+	/* Hack: For palladium we force DLL=1 and DLM=0.
+	 * To achieve this, we set:
+	 * clock-frequency = <desired_baudrate> x 16
+	 */
+	clock-frequency = <76800>;
+	status = "okay";
+};
+
+/*
+ * HACK to disable fs4 bus to speed up paxc-chimp palladium kernel boot up
+ * speed, since this palladium is dedicated for PAXC/Chimp/Nitro bring up
+ */
+&fs4 {
+	status = "disabled";
+};
+
+/*
+ * Remove reference to PHY (PIPEMUX) that's missing on palladium
+ */
+&pcie8 {
+	/delete-property/ phys;
+	/delete-property/ phy-names;
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/emulator/stingray-pd-sata.dts
@@ -0,0 +1,75 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/dts-v1/;
+
+#define NUM_SATA	1
+
+/* HACK: Reserve initrd location
+ * The memreserve entry for initrd is supposed
+ * to be updated in DTB by bootloader before
+ * handing over DTB to Linux kernel.
+ */
+/memreserve/ 0x81000000 0x00800000;
+/* HACK: Reserve bl31 location
+ * The memreserve entry for bl31 is supposed to
+ * be updated in DTB by bootloader before handing
+ * over DTB to Linux kernel. This is so because
+ * only firmware (or bootloader) know the correct
+ * location of bl31 and bl31 location in DDR can
+ * also change in-future.
+ */
+/memreserve/ 0x8f000000 0x00100000;
+
+#include "./stingray-pd-base.dtsi"
+
+/ {
+	model = "Broadcom Stingray SATA Palladium";
+
+	chosen { /* HACK: hard-code kernel args and initrd location */
+		bootargs = "root=/dev/ram rw console=ttyS1,4800n8 \
+			    earlycon=uart8250,mmio32,0x68a10000 cma=64M \
+			    maxcpus=2";
+		linux,stdout-path = "/soc/uart@68a30000:4800n8";
+		linux,initrd-start = <0x0 0x81000000>;
+		linux,initrd-end = <0x0 0x81800000>;
+	};
+};
+
+&uart1 {
+	/* Hack: For palladium we force DLL=1 and DLM=0.
+	 * To achieve this, we set:
+	 * clock-frequency = <desired_baudrate> x 16
+	 */
+	clock-frequency = <76800>;
+	status = "okay";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/emulator/stingray-pd-usb.dts
@@ -0,0 +1,76 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/dts-v1/;
+
+#define ENABLE_USB0	1
+#define ENABLE_USB1	1
+
+/* HACK: Reserve initrd location
+ * The memreserve entry for initrd is supposed
+ * to be updated in DTB by bootloader before
+ * handing over DTB to Linux kernel.
+ */
+/memreserve/ 0x81000000 0x00800000;
+/* HACK: Reserve bl31 location
+ * The memreserve entry for bl31 is supposed to
+ * be updated in DTB by bootloader before handing
+ * over DTB to Linux kernel. This is so because
+ * only firmware (or bootloader) know the correct
+ * location of bl31 and bl31 location in DDR can
+ * also change in-future.
+ */
+/memreserve/ 0x8f000000 0x00100000;
+
+#include "./stingray-pd-base.dtsi"
+
+/ {
+	model = "Broadcom Stingray Palladium";
+
+	chosen { /* HACK: hard-code kernel args and initrd location */
+		bootargs = "root=/dev/ram rw console=ttyS1,4800n8 \
+			    earlycon=uart8250,mmio32,0x68a10000 cma=64M \
+			    maxcpus=2";
+		linux,stdout-path = "/soc/uart@68a30000:4800n8";
+		linux,initrd-start = <0x0 0x81000000>;
+		linux,initrd-end = <0x0 0x81800000>;
+	};
+};
+
+&uart1 {
+	/* Hack: For palladium we force DLL=1 and DLM=0.
+	 * To achieve this, we set:
+	 * clock-frequency = <desired_baudrate> x 16
+	 */
+	clock-frequency = <76800>;
+	status = "okay";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/ps250.dts
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2019 Broadcom
+ */
+
+/dts-v1/;
+
+#define NUM_CRYPTO	32
+#define NUM_RAID	0
+#define ENABLE_ENET	0
+#define ENABLE_MDIO	0
+#define ENABLE_USB1	0
+
+#include "stingray-board-base.dtsi"
+
+/ {
+	model = "Stingray PS250 (BCM958804A8042)";
+
+	chosen {
+		stdout-path = "serial1:115200n8";
+	};
+};
+
+&sdio0 {
+	no-1-8-v;
+};
+
+&uart0 {
+	status = "okay";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/ps410t.dts
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2019 Broadcom
+ */
+
+/dts-v1/;
+
+#define NUM_CRYPTO	32
+#define NUM_RAID	0
+#define ENABLE_ENET	0
+#define ENABLE_MDIO	0
+#define ENABLE_USB1	0
+#define NUM_PAXB	0
+
+#include "stingray-board-base.dtsi"
+
+/ {
+	model = "Stingray PS410T (BCM958802A8023)";
+
+	chosen {
+		stdout-path = "serial1:115200n8";
+	};
+};
+
+&sdio0 {
+	no-1-8-v;
+};
+
+&uart0 {
+	status = "okay";
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/stingray-board-base.dtsi
@@ -0,0 +1,260 @@
+// SPDX-License-Identifier: (GPL-2.0 or BSD-3-Clause)
+/*
+ *  Copyright(c) 2016-2018 Broadcom
+ */
+
+#ifndef ENABLE_EMMC
+#define ENABLE_EMMC	1
+#endif
+
+#ifndef ENABLE_ENET
+#define ENABLE_ENET	1
+#endif
+
+#ifndef ENABLE_MDIO
+#define ENABLE_MDIO	1
+#endif
+
+#ifndef ENABLE_NAND
+#define ENABLE_NAND	0
+#endif
+
+#ifndef ENABLE_PAXC
+#define ENABLE_PAXC	1
+#endif
+
+#ifndef ENABLE_PWM
+#define ENABLE_PWM	0
+#endif
+
+#ifndef ENABLE_SDCARD
+#define ENABLE_SDCARD	0
+#endif
+
+#ifndef ENABLE_USB0
+#define ENABLE_USB0	1
+#endif
+
+#ifndef ENABLE_USB1
+#define ENABLE_USB1	1
+#endif
+
+#ifndef NUM_PAXB
+#define NUM_PAXB	8
+#endif
+
+#include "stingray.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+#define PCIE_DMA_RANGES dma-ranges = < \
+	0x43000000 0x00 0x80000000 0x00 0x80000000 0x00 0x80000000 \
+	0x43000000 0x08 0x00000000 0x08 0x00000000 0x08 0x00000000 \
+	0x43000000 0x80 0x00000000 0x80 0x00000000 0x80 0x00000000>
+
+/ {
+	aliases {
+		serial0 = &uart1;
+		serial1 = &uart0;
+		serial2 = &uart2;
+		serial3 = &uart3;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+#if (ENABLE_PAXC_IOMMU == 0)
+/*
+ * When standard IOMMU is disabled for PAXC, one needs to enable IOMMU
+ * identity mapping for PAXC on SR A2. In this case, below DDR region
+ * needs to be reserved for SMMU map table created for identity mapping.
+ */
+		smmu_pg_region {
+			reg = <0x8 0x80200000 0x0 0x200000>;
+			no-map;
+		};
+#endif
+		pci_lpm_region: pci_lpm_region@801f0000 {
+			reg = <0x0 0x8f101000 0x0 0x1000>;
+			no-map;
+		};
+	};
+
+	nvme_lpm: nvme_lpm {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x8f100100 0x100>;
+		status = "disabled";
+		nvme_lpm_data_backup: nvme-lpm-data-backup@14 {
+			compatible = "brcm,nvme-lpm-data-backup";
+			reg = <0x0 0x100>;
+			intrpt-gpio = <&gpio_hsls 2 GPIO_ACTIVE_HIGH>;
+			mboxes = <&mailbox 0>;
+			memory-region = <&pci_lpm_region>;
+		};
+	};
+};
+
+&memory { /* Default DRAM banks */
+	reg = <0x00000000 0x80000000 0x0 0x80000000>, /* 2G @ 2G */
+	      <0x00000008 0x80000000 0x1 0x80000000>; /* 6G @ 34G */
+};
+
+&pcie0 {
+	PCIE_DMA_RANGES;
+};
+
+&pcie1 {
+	PCIE_DMA_RANGES;
+};
+
+&pcie2 {
+	PCIE_DMA_RANGES;
+};
+
+&pcie3 {
+	PCIE_DMA_RANGES;
+};
+
+&pcie4 {
+	PCIE_DMA_RANGES;
+};
+
+&pcie5 {
+	PCIE_DMA_RANGES;
+};
+
+&pcie6 {
+	PCIE_DMA_RANGES;
+};
+
+&pcie7 {
+	PCIE_DMA_RANGES;
+};
+
+&enet {
+	phy-mode = "rgmii-id";
+	phy-handle = <&gphy0>;
+#if (ENABLE_ENET == 1)
+	status = "okay";
+#endif
+};
+
+&uart1 {
+	status = "okay";
+};
+
+&uart2 {
+#if (ENABLE_UART2 == 1)
+	status = "okay";
+#endif
+};
+
+&uart3 {
+#if (ENABLE_UART3 == 1)
+	status = "okay";
+#endif
+};
+
+&sdio0 {
+#if (ENABLE_EMMC == 1)
+	non-removable;
+	full-pwr-cycle;
+	status = "okay";
+#endif
+};
+
+&sdio1 {
+#if (ENABLE_SDCARD == 1)
+	full-pwr-cycle;
+	status = "okay";
+#endif
+};
+
+&pwm {
+#if (ENABLE_PWM == 1)
+	status = "okay";
+#endif
+};
+
+&ssp0 {
+	cs-gpios = <&gpio_hsls 34 0>;
+#if (ENABLE_SSP0 == 1)
+	status = "okay";
+#endif
+};
+
+&ssp1 {
+	cs-gpios = <&gpio_hsls 96 0>;
+#if (ENABLE_SSP1 == 1)
+	status = "okay";
+#endif
+};
+
+&i2c0 {
+#if (ENABLE_I2C0 == 1)
+	status = "okay";
+#endif
+};
+
+&i2c1 {
+#if (ENABLE_I2C1 == 1)
+	status = "okay";
+#endif
+};
+
+&mdio_mux_iproc {
+#if (ENABLE_MDIO == 1)
+	status = "okay";
+#endif
+	mdio@2 { /* SATA */
+#if (NUM_SATA > 0)
+		status = "okay";
+#endif
+	};
+
+	mdio@10 {
+#if (ENABLE_ENET == 1)
+		status = "okay";
+#endif
+		gphy0: eth-phy@10 {
+			reg = <0x10>;
+		};
+	};
+};
+
+&nand {
+#if (ENABLE_NAND == 1)
+	status = "ok";
+#endif
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&qspi_pins>;
+	bspi-sel = <0>;
+/* reserve QSPI for Chimp NVRAM when PAXC is enabled */
+#if (ENABLE_PAXC != 1)
+	status = "okay";
+#endif
+
+	flash: w25q64@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0x0>;
+		spi-max-frequency = <12500000>;
+	};
+};
+
+&rtc {
+#if (ENABLE_RTC == 1)
+	status = "okay";
+#endif
+};
--- a/arch/arm64/boot/dts/broadcom/stingray/stingray-clock.dtsi
+++ b/arch/arm64/boot/dts/broadcom/stingray/stingray-clock.dtsi
@@ -46,7 +46,7 @@
 			clock-mult = <1>;
 		};
 
-		genpll0: genpll0@0001d104 {
+		genpll0: genpll0@1d104 {
 			#clock-cells = <1>;
 			compatible = "brcm,sr-genpll0";
 			reg = <0x0001d104 0x32>,
@@ -58,7 +58,19 @@
 					     "clk_paxc_axi";
 		};
 
-		genpll3: genpll3@0001d1e0 {
+		genpll2: genpll2@1d1ac {
+			#clock-cells = <1>;
+			compatible = "brcm,sr-genpll2";
+			reg = <0x0001d1ac 0x32>,
+			      <0x0001c854 0x4>;
+			clocks = <&osc>;
+			clock-output-names = "genpll2", "clk_nic",
+					     "clk_ts_500_ref", "clk_125_nitro",
+					     "clk_chimp", "clk_nic_flash",
+					     "clk_fs";
+		};
+
+		genpll3: genpll3@1d1e0 {
 			#clock-cells = <1>;
 			compatible = "brcm,sr-genpll3";
 			reg = <0x0001d1e0 0x32>,
@@ -68,7 +80,7 @@
 					     "clk_sdio";
 		};
 
-		genpll4: genpll4@0001d214 {
+		genpll4: genpll4@1d214 {
 			#clock-cells = <1>;
 			compatible = "brcm,sr-genpll4";
 			reg = <0x0001d214 0x32>,
@@ -80,7 +92,7 @@
 					     "clk_bridge_fscpu";
 		};
 
-		genpll5: genpll5@0001d248 {
+		genpll5: genpll5@1d248 {
 			#clock-cells = <1>;
 			compatible = "brcm,sr-genpll5";
 			reg = <0x0001d248 0x32>,
@@ -90,7 +102,7 @@
 					     "crypto_ae_clk", "raid_ae_clk";
 		};
 
-		lcpll0: lcpll0@0001d0c4 {
+		lcpll0: lcpll0@1d0c4 {
 			#clock-cells = <1>;
 			compatible = "brcm,sr-lcpll0";
 			reg = <0x0001d0c4 0x3c>,
@@ -101,7 +113,7 @@
 					     "clk_sata_500";
 		};
 
-		lcpll1: lcpll1@0001d138 {
+		lcpll1: lcpll1@1d138 {
 			#clock-cells = <1>;
 			compatible = "brcm,sr-lcpll1";
 			reg = <0x0001d138 0x3c>,
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/stingray-diag.dtsi
@@ -0,0 +1,236 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/ {
+#if (NUM_PAXB == 0)
+	pcie {
+		compatible = "brcm,stingray-pcie-phy-prbs";
+		reg = <0x0 0x40000000 0x0 0x1000>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		brcm,pcie-pipemux-strap-syscon = <&cdru>;
+
+		pcie_phy0: phy@48000000 {
+			reg = <0x0 0x48000000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy1: phy@48004000 {
+			reg = <0x0 0x48004000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy2: phy@48008000 {
+			reg = <0x0 0x48008000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy3: phy@4800c000{
+			reg = <0x0 0x4800c000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy4: phy@48010000 {
+			reg = <0x0 0x48010000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy5: phy@48014000 {
+			reg = <0x0 0x48014000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy6: phy@48018000 {
+			reg = <0x0 0x48018000 0x0 0x4000>;
+			status = "okay";
+		};
+
+		pcie_phy7: phy@4801c000 {
+			reg = <0x0 0x4801c000 0x0 0x4000>;
+			status = "okay";
+		};
+	};
+#endif
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "okay";
+};
+
+#if (ENABLE_SSP0 == 1)
+&ssp0 {
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {				/* 2 MiB */
+			label = "spi0-user";
+			reg = <0x00000000 0x00200000>;
+		};
+
+		partition@200000 {			/* 2 MiB */
+			label = "spi0-test";
+			reg = <0x00200000 0x00200000>;
+		};
+	};
+};
+#endif
+
+#if (ENABLE_SSP1 == 1)
+&ssp1 {
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {				/* 2 MiB */
+			label = "spi1-user";
+			reg = <0x00000000 0x00200000>;
+		};
+
+		partition@200000 {			/* 2 MiB */
+			label = "spi1-test";
+			reg = <0x00200000 0x00200000>;
+		};
+	};
+};
+#endif
+
+&qspi {
+	flash: w25q64@0 {
+		partition@0 {
+			label = "sf-boot";		/* 4 MiB */
+			reg = <0x00000000 0x00400000>;
+		};
+
+		partition@400000 {			/* 2 MiB */
+			label = "sf-user";
+			reg = <0x00400000 0x00200000>;
+		};
+
+		partition@600000 {			/* 2 MiB */
+			label = "sf-test";
+			reg = <0x00600000 0x00200000>;
+		};
+
+	};
+};
+
+#if (NUM_SATA > 0)
+&sata0 {
+	status = "disabled";
+};
+
+&sata_phy0 {
+	compatible = "brcm,stingray-sata-phy-prbs";
+	status = "okay";
+};
+#endif
+
+#if (NUM_SATA > 1)
+&sata1 {
+	status = "disabled";
+};
+
+&sata_phy1 {
+	compatible = "brcm,stingray-sata-phy-prbs";
+	status = "okay";
+};
+#endif
+
+#if (NUM_SATA > 2)
+&sata2 {
+	status = "disabled";
+};
+
+&sata_phy2 {
+	compatible = "brcm,stingray-sata-phy-prbs";
+	status = "okay";
+};
+#endif
+
+#if (NUM_SATA > 3)
+&sata3 {
+	status = "disabled";
+};
+
+&sata_phy3 {
+	compatible = "brcm,stingray-sata-phy-prbs";
+	status = "okay";
+};
+#endif
+
+#if (NUM_SATA > 4)
+&sata4 {
+	status = "disabled";
+};
+
+&sata_phy4 {
+	compatible = "brcm,stingray-sata-phy-prbs";
+	status = "okay";
+};
+#endif
+
+#if (NUM_SATA > 5)
+&sata5 {
+	status = "disabled";
+};
+
+&sata_phy5 {
+	compatible = "brcm,stingray-sata-phy-prbs";
+	status = "okay";
+};
+#endif
+
+#if (NUM_SATA > 6)
+&sata6 {
+	status = "disabled";
+};
+
+&sata_phy6 {
+	compatible = "brcm,stingray-sata-phy-prbs";
+	status = "okay";
+};
+#endif
+
+#if (NUM_SATA > 7)
+&sata7 {
+	status = "disabled";
+};
+
+&sata_phy7 {
+	compatible = "brcm,stingray-sata-phy-prbs";
+	status = "okay";
+};
+#endif
--- a/arch/arm64/boot/dts/broadcom/stingray/stingray-fs4.dtsi
+++ b/arch/arm64/boot/dts/broadcom/stingray/stingray-fs4.dtsi
@@ -32,87 +32,237 @@
 
 	fs4: fs4 {
 		compatible = "simple-bus";
+		dma-ranges;
 		#address-cells = <1>;
 		#size-cells = <1>;
 		ranges = <0x0 0x0 0x67000000 0x00800000>;
 
-		crypto_mbox: crypto_mbox@00000000 {
+		crypto_mbox: crypto_mbox@0 {
 			compatible = "brcm,iproc-flexrm-mbox";
 			reg = <0x00000000 0x200000>;
+			clocks = <&genpll5 BCM_SR_GENPLL5_FS4_HF_CLK>,
+				 <&genpll5 BCM_SR_GENPLL5_CRYPTO_AE_CLK>,
+				 <&genpll2 BCM_SR_GENPLL2_FS4_CLK>;
+			clock-names = "dme_rm_clk", "ae_clk", "fs4_clk";
 			msi-parent = <&gic_its 0x4100>;
 			#mbox-cells = <3>;
 			dma-coherent;
+#if (ENABLE_FS4_IOMMU == 1)
+			iommus = <&smmu 0x4000 0x00ff>,
+				 <&smmu 0x4100 0x0000>;
+#endif
 		};
 
-		raid_mbox: raid_mbox@00400000 {
+		raid_mbox: raid_mbox@400000 {
 			compatible = "brcm,iproc-flexrm-mbox";
 			reg = <0x00400000 0x200000>;
+			clocks = <&genpll5 BCM_SR_GENPLL5_FS4_HF_CLK>,
+				 <&genpll5 BCM_SR_GENPLL5_RAID_AE_CLK>,
+				 <&genpll2 BCM_SR_GENPLL2_FS4_CLK>;
+			clock-names = "dme_rm_clk", "ae_clk", "fs4_clk";
 			dma-coherent;
 			msi-parent = <&gic_its 0x4300>;
 			#mbox-cells = <3>;
+#if (ENABLE_FS4_IOMMU == 1)
+			iommus = <&smmu 0x4200 0x00ff>,
+				 <&smmu 0x4300 0x0000>;
+#endif
 		};
 
 		raid0: raid@0 {
 			compatible = "brcm,iproc-sba-v2";
-			mboxes = <&raid_mbox 0 0x1 0xff00>,
-				 <&raid_mbox 1 0x1 0xff00>,
-				 <&raid_mbox 2 0x1 0xff00>,
-				 <&raid_mbox 3 0x1 0xff00>;
+			mboxes = <&raid_mbox 0 0x1 0xff00>;
+
+#if (NUM_RAID > 0)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
 		};
 
 		raid1: raid@1 {
 			compatible = "brcm,iproc-sba-v2";
-			mboxes = <&raid_mbox 4 0x1 0xff00>,
-				 <&raid_mbox 5 0x1 0xff00>,
-				 <&raid_mbox 6 0x1 0xff00>,
-				 <&raid_mbox 7 0x1 0xff00>;
+			mboxes = <&raid_mbox 4 0x1 0xff00>;
+
+#if (NUM_RAID > 1)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
 		};
 
 		raid2: raid@2 {
 			compatible = "brcm,iproc-sba-v2";
-			mboxes = <&raid_mbox 8 0x1 0xff00>,
-				 <&raid_mbox 9 0x1 0xff00>,
-				 <&raid_mbox 10 0x1 0xff00>,
-				 <&raid_mbox 11 0x1 0xff00>;
+			mboxes = <&raid_mbox 8 0x1 0xff00>;
+
+#if (NUM_RAID > 2)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
 		};
 
 		raid3: raid@3 {
 			compatible = "brcm,iproc-sba-v2";
-			mboxes = <&raid_mbox 12 0x1 0xff00>,
-				 <&raid_mbox 13 0x1 0xff00>,
-				 <&raid_mbox 14 0x1 0xff00>,
-				 <&raid_mbox 15 0x1 0xff00>;
+			mboxes = <&raid_mbox 12 0x1 0xff00>;
+#if (NUM_RAID > 3)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
 		};
 
 		raid4: raid@4 {
 			compatible = "brcm,iproc-sba-v2";
-			mboxes = <&raid_mbox 16 0x1 0xff00>,
-				 <&raid_mbox 17 0x1 0xff00>,
-				 <&raid_mbox 18 0x1 0xff00>,
-				 <&raid_mbox 19 0x1 0xff00>;
+			mboxes = <&raid_mbox 16 0x1 0xff00>;
+#if (NUM_RAID > 4)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
 		};
 
 		raid5: raid@5 {
 			compatible = "brcm,iproc-sba-v2";
-			mboxes = <&raid_mbox 20 0x1 0xff00>,
-				 <&raid_mbox 21 0x1 0xff00>,
-				 <&raid_mbox 22 0x1 0xff00>,
-				 <&raid_mbox 23 0x1 0xff00>;
+			mboxes = <&raid_mbox 20 0x1 0xff00>;
+#if (NUM_RAID > 5)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
 		};
 
 		raid6: raid@6 {
 			compatible = "brcm,iproc-sba-v2";
-			mboxes = <&raid_mbox 24 0x1 0xff00>,
-				 <&raid_mbox 25 0x1 0xff00>,
-				 <&raid_mbox 26 0x1 0xff00>,
-				 <&raid_mbox 27 0x1 0xff00>;
+			mboxes = <&raid_mbox 24 0x1 0xff00>;
+#if (NUM_RAID > 6)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
 		};
 
 		raid7: raid@7 {
 			compatible = "brcm,iproc-sba-v2";
-			mboxes = <&raid_mbox 28 0x1 0xff00>,
-				 <&raid_mbox 29 0x1 0xff00>,
-				 <&raid_mbox 30 0x1 0xff00>,
-				 <&raid_mbox 31 0x1 0xff00>;
+			mboxes = <&raid_mbox 28 0x1 0xff00>;
+#if (NUM_RAID > 7)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
+		};
+
+		spu2: spu2 {
+			compatible = "brcm,spu2-v2-crypto";
+			reg = <0x672c0000 0x1000>,
+			      <0x672c1000 0x1000>,
+			      <0x672c2000 0x1000>,
+			      <0x672c3000 0x1000>,
+			      <0x672c4000 0x1000>,
+			      <0x672c5000 0x1000>,
+			      <0x672c6000 0x1000>,
+			      <0x672c7000 0x1000>,
+			      <0x672c8000 0x1000>,
+			      <0x672c9000 0x1000>;
+#if (NUM_CRYPTO > 0)
+			mboxes = <&crypto_mbox 0 0x1 0xff00>
+#if (NUM_CRYPTO > 1)
+				 ,<&crypto_mbox 1 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 2)
+				 ,<&crypto_mbox 2 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 3)
+				 ,<&crypto_mbox 3 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 4)
+				 ,<&crypto_mbox 4 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 5)
+				 ,<&crypto_mbox 5 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 6)
+				 ,<&crypto_mbox 6 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 7)
+				 ,<&crypto_mbox 7 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 8)
+				 ,<&crypto_mbox 8 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 9)
+				 ,<&crypto_mbox 9 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 10)
+				 ,<&crypto_mbox 10 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 11)
+				 ,<&crypto_mbox 11 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 12)
+				 ,<&crypto_mbox 12 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 13)
+				 ,<&crypto_mbox 13 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 14)
+				 ,<&crypto_mbox 14 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 15)
+				 ,<&crypto_mbox 15 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 16)
+				 ,<&crypto_mbox 16 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 17)
+				 ,<&crypto_mbox 17 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 18)
+				 ,<&crypto_mbox 18 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 19)
+				 ,<&crypto_mbox 19 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 20)
+				 ,<&crypto_mbox 20 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 21)
+				 ,<&crypto_mbox 21 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 22)
+				 ,<&crypto_mbox 22 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 23)
+				 ,<&crypto_mbox 23 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 24)
+				 ,<&crypto_mbox 24 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 25)
+				 ,<&crypto_mbox 25 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 26)
+				 ,<&crypto_mbox 26 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 27)
+				 ,<&crypto_mbox 27 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 28)
+				 ,<&crypto_mbox 28 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 29)
+				 ,<&crypto_mbox 29 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 30)
+				 ,<&crypto_mbox 30 0x1 0xff00>
+#endif
+#if (NUM_CRYPTO > 31)
+				 ,<&crypto_mbox 31 0x1 0xff00>
+#endif
+				 ;
+			status = "okay";
+#else
+			status = "disabled";
+#endif
 		};
 	};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/stingray-optee.dtsi
@@ -0,0 +1,43 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef ENABLE_OPTEE
+#define ENABLE_OPTEE	0
+#endif
+
+#if (ENABLE_OPTEE == 1)
+	firmware {
+		optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+		};
+	};
+#endif
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/stingray-pcie-msi-map.dtsi
@@ -0,0 +1,8263 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2018-2019 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+&pcie0 {
+	msi-map = <0x0000 &gic_its 0x0000 0x2>,
+		  <0x0008 &gic_its 0x0002 0x2>,
+		  <0x0100 &gic_its 0x0004 0x2>,
+		  <0x0108 &gic_its 0x0006 0x2>,
+		  <0x0200 &gic_its 0x0008 0x2>,
+		  <0x0208 &gic_its 0x000a 0x2>,
+		  <0x0300 &gic_its 0x000c 0x2>,
+		  <0x0308 &gic_its 0x000e 0x2>,
+		  <0x0400 &gic_its 0x0010 0x2>,
+		  <0x0408 &gic_its 0x0012 0x2>,
+		  <0x0500 &gic_its 0x0014 0x2>,
+		  <0x0508 &gic_its 0x0016 0x2>,
+		  <0x0600 &gic_its 0x0018 0x2>,
+		  <0x0608 &gic_its 0x001a 0x2>,
+		  <0x0700 &gic_its 0x001c 0x2>,
+		  <0x0708 &gic_its 0x001e 0x2>,
+		  <0x0800 &gic_its 0x0020 0x2>,
+		  <0x0808 &gic_its 0x0022 0x2>,
+		  <0x0900 &gic_its 0x0024 0x2>,
+		  <0x0908 &gic_its 0x0026 0x2>,
+		  <0x0a00 &gic_its 0x0028 0x2>,
+		  <0x0a08 &gic_its 0x002a 0x2>,
+		  <0x0b00 &gic_its 0x002c 0x2>,
+		  <0x0b08 &gic_its 0x002e 0x2>,
+		  <0x0c00 &gic_its 0x0030 0x2>,
+		  <0x0c08 &gic_its 0x0032 0x2>,
+		  <0x0d00 &gic_its 0x0034 0x2>,
+		  <0x0d08 &gic_its 0x0036 0x2>,
+		  <0x0e00 &gic_its 0x0038 0x2>,
+		  <0x0e08 &gic_its 0x003a 0x2>,
+		  <0x0f00 &gic_its 0x003c 0x2>,
+		  <0x0f08 &gic_its 0x003e 0x2>,
+		  <0x1000 &gic_its 0x0040 0x2>,
+		  <0x1008 &gic_its 0x0042 0x2>,
+		  <0x1100 &gic_its 0x0044 0x2>,
+		  <0x1108 &gic_its 0x0046 0x2>,
+		  <0x1200 &gic_its 0x0048 0x2>,
+		  <0x1208 &gic_its 0x004a 0x2>,
+		  <0x1300 &gic_its 0x004c 0x2>,
+		  <0x1308 &gic_its 0x004e 0x2>,
+		  <0x1400 &gic_its 0x0050 0x2>,
+		  <0x1408 &gic_its 0x0052 0x2>,
+		  <0x1500 &gic_its 0x0054 0x2>,
+		  <0x1508 &gic_its 0x0056 0x2>,
+		  <0x1600 &gic_its 0x0058 0x2>,
+		  <0x1608 &gic_its 0x005a 0x2>,
+		  <0x1700 &gic_its 0x005c 0x2>,
+		  <0x1708 &gic_its 0x005e 0x2>,
+		  <0x1800 &gic_its 0x0060 0x2>,
+		  <0x1808 &gic_its 0x0062 0x2>,
+		  <0x1900 &gic_its 0x0064 0x2>,
+		  <0x1908 &gic_its 0x0066 0x2>,
+		  <0x1a00 &gic_its 0x0068 0x2>,
+		  <0x1a08 &gic_its 0x006a 0x2>,
+		  <0x1b00 &gic_its 0x006c 0x2>,
+		  <0x1b08 &gic_its 0x006e 0x2>,
+		  <0x1c00 &gic_its 0x0070 0x2>,
+		  <0x1c08 &gic_its 0x0072 0x2>,
+		  <0x1d00 &gic_its 0x0074 0x2>,
+		  <0x1d08 &gic_its 0x0076 0x2>,
+		  <0x1e00 &gic_its 0x0078 0x2>,
+		  <0x1e08 &gic_its 0x007a 0x2>,
+		  <0x1f00 &gic_its 0x007c 0x2>,
+		  <0x1f08 &gic_its 0x007e 0x2>,
+		  <0x2000 &gic_its 0x0080 0x2>,
+		  <0x2008 &gic_its 0x0082 0x2>,
+		  <0x2100 &gic_its 0x0084 0x2>,
+		  <0x2108 &gic_its 0x0086 0x2>,
+		  <0x2200 &gic_its 0x0088 0x2>,
+		  <0x2208 &gic_its 0x008a 0x2>,
+		  <0x2300 &gic_its 0x008c 0x2>,
+		  <0x2308 &gic_its 0x008e 0x2>,
+		  <0x2400 &gic_its 0x0090 0x2>,
+		  <0x2408 &gic_its 0x0092 0x2>,
+		  <0x2500 &gic_its 0x0094 0x2>,
+		  <0x2508 &gic_its 0x0096 0x2>,
+		  <0x2600 &gic_its 0x0098 0x2>,
+		  <0x2608 &gic_its 0x009a 0x2>,
+		  <0x2700 &gic_its 0x009c 0x2>,
+		  <0x2708 &gic_its 0x009e 0x2>,
+		  <0x2800 &gic_its 0x00a0 0x2>,
+		  <0x2808 &gic_its 0x00a2 0x2>,
+		  <0x2900 &gic_its 0x00a4 0x2>,
+		  <0x2908 &gic_its 0x00a6 0x2>,
+		  <0x2a00 &gic_its 0x00a8 0x2>,
+		  <0x2a08 &gic_its 0x00aa 0x2>,
+		  <0x2b00 &gic_its 0x00ac 0x2>,
+		  <0x2b08 &gic_its 0x00ae 0x2>,
+		  <0x2c00 &gic_its 0x00b0 0x2>,
+		  <0x2c08 &gic_its 0x00b2 0x2>,
+		  <0x2d00 &gic_its 0x00b4 0x2>,
+		  <0x2d08 &gic_its 0x00b6 0x2>,
+		  <0x2e00 &gic_its 0x00b8 0x2>,
+		  <0x2e08 &gic_its 0x00ba 0x2>,
+		  <0x2f00 &gic_its 0x00bc 0x2>,
+		  <0x2f08 &gic_its 0x00be 0x2>,
+		  <0x3000 &gic_its 0x00c0 0x2>,
+		  <0x3008 &gic_its 0x00c2 0x2>,
+		  <0x3100 &gic_its 0x00c4 0x2>,
+		  <0x3108 &gic_its 0x00c6 0x2>,
+		  <0x3200 &gic_its 0x00c8 0x2>,
+		  <0x3208 &gic_its 0x00ca 0x2>,
+		  <0x3300 &gic_its 0x00cc 0x2>,
+		  <0x3308 &gic_its 0x00ce 0x2>,
+		  <0x3400 &gic_its 0x00d0 0x2>,
+		  <0x3408 &gic_its 0x00d2 0x2>,
+		  <0x3500 &gic_its 0x00d4 0x2>,
+		  <0x3508 &gic_its 0x00d6 0x2>,
+		  <0x3600 &gic_its 0x00d8 0x2>,
+		  <0x3608 &gic_its 0x00da 0x2>,
+		  <0x3700 &gic_its 0x00dc 0x2>,
+		  <0x3708 &gic_its 0x00de 0x2>,
+		  <0x3800 &gic_its 0x00e0 0x2>,
+		  <0x3808 &gic_its 0x00e2 0x2>,
+		  <0x3900 &gic_its 0x00e4 0x2>,
+		  <0x3908 &gic_its 0x00e6 0x2>,
+		  <0x3a00 &gic_its 0x00e8 0x2>,
+		  <0x3a08 &gic_its 0x00ea 0x2>,
+		  <0x3b00 &gic_its 0x00ec 0x2>,
+		  <0x3b08 &gic_its 0x00ee 0x2>,
+		  <0x3c00 &gic_its 0x00f0 0x2>,
+		  <0x3c08 &gic_its 0x00f2 0x2>,
+		  <0x3d00 &gic_its 0x00f4 0x2>,
+		  <0x3d08 &gic_its 0x00f6 0x2>,
+		  <0x3e00 &gic_its 0x00f8 0x2>,
+		  <0x3e08 &gic_its 0x00fa 0x2>,
+		  <0x3f00 &gic_its 0x00fc 0x2>,
+		  <0x3f08 &gic_its 0x00fe 0x2>,
+		  <0x4000 &gic_its 0x0100 0x2>,
+		  <0x4008 &gic_its 0x0102 0x2>,
+		  <0x4100 &gic_its 0x0104 0x2>,
+		  <0x4108 &gic_its 0x0106 0x2>,
+		  <0x4200 &gic_its 0x0108 0x2>,
+		  <0x4208 &gic_its 0x010a 0x2>,
+		  <0x4300 &gic_its 0x010c 0x2>,
+		  <0x4308 &gic_its 0x010e 0x2>,
+		  <0x4400 &gic_its 0x0110 0x2>,
+		  <0x4408 &gic_its 0x0112 0x2>,
+		  <0x4500 &gic_its 0x0114 0x2>,
+		  <0x4508 &gic_its 0x0116 0x2>,
+		  <0x4600 &gic_its 0x0118 0x2>,
+		  <0x4608 &gic_its 0x011a 0x2>,
+		  <0x4700 &gic_its 0x011c 0x2>,
+		  <0x4708 &gic_its 0x011e 0x2>,
+		  <0x4800 &gic_its 0x0120 0x2>,
+		  <0x4808 &gic_its 0x0122 0x2>,
+		  <0x4900 &gic_its 0x0124 0x2>,
+		  <0x4908 &gic_its 0x0126 0x2>,
+		  <0x4a00 &gic_its 0x0128 0x2>,
+		  <0x4a08 &gic_its 0x012a 0x2>,
+		  <0x4b00 &gic_its 0x012c 0x2>,
+		  <0x4b08 &gic_its 0x012e 0x2>,
+		  <0x4c00 &gic_its 0x0130 0x2>,
+		  <0x4c08 &gic_its 0x0132 0x2>,
+		  <0x4d00 &gic_its 0x0134 0x2>,
+		  <0x4d08 &gic_its 0x0136 0x2>,
+		  <0x4e00 &gic_its 0x0138 0x2>,
+		  <0x4e08 &gic_its 0x013a 0x2>,
+		  <0x4f00 &gic_its 0x013c 0x2>,
+		  <0x4f08 &gic_its 0x013e 0x2>,
+		  <0x5000 &gic_its 0x0140 0x2>,
+		  <0x5008 &gic_its 0x0142 0x2>,
+		  <0x5100 &gic_its 0x0144 0x2>,
+		  <0x5108 &gic_its 0x0146 0x2>,
+		  <0x5200 &gic_its 0x0148 0x2>,
+		  <0x5208 &gic_its 0x014a 0x2>,
+		  <0x5300 &gic_its 0x014c 0x2>,
+		  <0x5308 &gic_its 0x014e 0x2>,
+		  <0x5400 &gic_its 0x0150 0x2>,
+		  <0x5408 &gic_its 0x0152 0x2>,
+		  <0x5500 &gic_its 0x0154 0x2>,
+		  <0x5508 &gic_its 0x0156 0x2>,
+		  <0x5600 &gic_its 0x0158 0x2>,
+		  <0x5608 &gic_its 0x015a 0x2>,
+		  <0x5700 &gic_its 0x015c 0x2>,
+		  <0x5708 &gic_its 0x015e 0x2>,
+		  <0x5800 &gic_its 0x0160 0x2>,
+		  <0x5808 &gic_its 0x0162 0x2>,
+		  <0x5900 &gic_its 0x0164 0x2>,
+		  <0x5908 &gic_its 0x0166 0x2>,
+		  <0x5a00 &gic_its 0x0168 0x2>,
+		  <0x5a08 &gic_its 0x016a 0x2>,
+		  <0x5b00 &gic_its 0x016c 0x2>,
+		  <0x5b08 &gic_its 0x016e 0x2>,
+		  <0x5c00 &gic_its 0x0170 0x2>,
+		  <0x5c08 &gic_its 0x0172 0x2>,
+		  <0x5d00 &gic_its 0x0174 0x2>,
+		  <0x5d08 &gic_its 0x0176 0x2>,
+		  <0x5e00 &gic_its 0x0178 0x2>,
+		  <0x5e08 &gic_its 0x017a 0x2>,
+		  <0x5f00 &gic_its 0x017c 0x2>,
+		  <0x5f08 &gic_its 0x017e 0x2>,
+		  <0x6000 &gic_its 0x0180 0x2>,
+		  <0x6008 &gic_its 0x0182 0x2>,
+		  <0x6100 &gic_its 0x0184 0x2>,
+		  <0x6108 &gic_its 0x0186 0x2>,
+		  <0x6200 &gic_its 0x0188 0x2>,
+		  <0x6208 &gic_its 0x018a 0x2>,
+		  <0x6300 &gic_its 0x018c 0x2>,
+		  <0x6308 &gic_its 0x018e 0x2>,
+		  <0x6400 &gic_its 0x0190 0x2>,
+		  <0x6408 &gic_its 0x0192 0x2>,
+		  <0x6500 &gic_its 0x0194 0x2>,
+		  <0x6508 &gic_its 0x0196 0x2>,
+		  <0x6600 &gic_its 0x0198 0x2>,
+		  <0x6608 &gic_its 0x019a 0x2>,
+		  <0x6700 &gic_its 0x019c 0x2>,
+		  <0x6708 &gic_its 0x019e 0x2>,
+		  <0x6800 &gic_its 0x01a0 0x2>,
+		  <0x6808 &gic_its 0x01a2 0x2>,
+		  <0x6900 &gic_its 0x01a4 0x2>,
+		  <0x6908 &gic_its 0x01a6 0x2>,
+		  <0x6a00 &gic_its 0x01a8 0x2>,
+		  <0x6a08 &gic_its 0x01aa 0x2>,
+		  <0x6b00 &gic_its 0x01ac 0x2>,
+		  <0x6b08 &gic_its 0x01ae 0x2>,
+		  <0x6c00 &gic_its 0x01b0 0x2>,
+		  <0x6c08 &gic_its 0x01b2 0x2>,
+		  <0x6d00 &gic_its 0x01b4 0x2>,
+		  <0x6d08 &gic_its 0x01b6 0x2>,
+		  <0x6e00 &gic_its 0x01b8 0x2>,
+		  <0x6e08 &gic_its 0x01ba 0x2>,
+		  <0x6f00 &gic_its 0x01bc 0x2>,
+		  <0x6f08 &gic_its 0x01be 0x2>,
+		  <0x7000 &gic_its 0x01c0 0x2>,
+		  <0x7008 &gic_its 0x01c2 0x2>,
+		  <0x7100 &gic_its 0x01c4 0x2>,
+		  <0x7108 &gic_its 0x01c6 0x2>,
+		  <0x7200 &gic_its 0x01c8 0x2>,
+		  <0x7208 &gic_its 0x01ca 0x2>,
+		  <0x7300 &gic_its 0x01cc 0x2>,
+		  <0x7308 &gic_its 0x01ce 0x2>,
+		  <0x7400 &gic_its 0x01d0 0x2>,
+		  <0x7408 &gic_its 0x01d2 0x2>,
+		  <0x7500 &gic_its 0x01d4 0x2>,
+		  <0x7508 &gic_its 0x01d6 0x2>,
+		  <0x7600 &gic_its 0x01d8 0x2>,
+		  <0x7608 &gic_its 0x01da 0x2>,
+		  <0x7700 &gic_its 0x01dc 0x2>,
+		  <0x7708 &gic_its 0x01de 0x2>,
+		  <0x7800 &gic_its 0x01e0 0x2>,
+		  <0x7808 &gic_its 0x01e2 0x2>,
+		  <0x7900 &gic_its 0x01e4 0x2>,
+		  <0x7908 &gic_its 0x01e6 0x2>,
+		  <0x7a00 &gic_its 0x01e8 0x2>,
+		  <0x7a08 &gic_its 0x01ea 0x2>,
+		  <0x7b00 &gic_its 0x01ec 0x2>,
+		  <0x7b08 &gic_its 0x01ee 0x2>,
+		  <0x7c00 &gic_its 0x01f0 0x2>,
+		  <0x7c08 &gic_its 0x01f2 0x2>,
+		  <0x7d00 &gic_its 0x01f4 0x2>,
+		  <0x7d08 &gic_its 0x01f6 0x2>,
+		  <0x7e00 &gic_its 0x01f8 0x2>,
+		  <0x7e08 &gic_its 0x01fa 0x2>,
+		  <0x7f00 &gic_its 0x01fc 0x2>,
+		  <0x7f08 &gic_its 0x01fe 0x2>,
+		  <0x8000 &gic_its 0x0200 0x2>,
+		  <0x8008 &gic_its 0x0202 0x2>,
+		  <0x8100 &gic_its 0x0204 0x2>,
+		  <0x8108 &gic_its 0x0206 0x2>,
+		  <0x8200 &gic_its 0x0208 0x2>,
+		  <0x8208 &gic_its 0x020a 0x2>,
+		  <0x8300 &gic_its 0x020c 0x2>,
+		  <0x8308 &gic_its 0x020e 0x2>,
+		  <0x8400 &gic_its 0x0210 0x2>,
+		  <0x8408 &gic_its 0x0212 0x2>,
+		  <0x8500 &gic_its 0x0214 0x2>,
+		  <0x8508 &gic_its 0x0216 0x2>,
+		  <0x8600 &gic_its 0x0218 0x2>,
+		  <0x8608 &gic_its 0x021a 0x2>,
+		  <0x8700 &gic_its 0x021c 0x2>,
+		  <0x8708 &gic_its 0x021e 0x2>,
+		  <0x8800 &gic_its 0x0220 0x2>,
+		  <0x8808 &gic_its 0x0222 0x2>,
+		  <0x8900 &gic_its 0x0224 0x2>,
+		  <0x8908 &gic_its 0x0226 0x2>,
+		  <0x8a00 &gic_its 0x0228 0x2>,
+		  <0x8a08 &gic_its 0x022a 0x2>,
+		  <0x8b00 &gic_its 0x022c 0x2>,
+		  <0x8b08 &gic_its 0x022e 0x2>,
+		  <0x8c00 &gic_its 0x0230 0x2>,
+		  <0x8c08 &gic_its 0x0232 0x2>,
+		  <0x8d00 &gic_its 0x0234 0x2>,
+		  <0x8d08 &gic_its 0x0236 0x2>,
+		  <0x8e00 &gic_its 0x0238 0x2>,
+		  <0x8e08 &gic_its 0x023a 0x2>,
+		  <0x8f00 &gic_its 0x023c 0x2>,
+		  <0x8f08 &gic_its 0x023e 0x2>,
+		  <0x9000 &gic_its 0x0240 0x2>,
+		  <0x9008 &gic_its 0x0242 0x2>,
+		  <0x9100 &gic_its 0x0244 0x2>,
+		  <0x9108 &gic_its 0x0246 0x2>,
+		  <0x9200 &gic_its 0x0248 0x2>,
+		  <0x9208 &gic_its 0x024a 0x2>,
+		  <0x9300 &gic_its 0x024c 0x2>,
+		  <0x9308 &gic_its 0x024e 0x2>,
+		  <0x9400 &gic_its 0x0250 0x2>,
+		  <0x9408 &gic_its 0x0252 0x2>,
+		  <0x9500 &gic_its 0x0254 0x2>,
+		  <0x9508 &gic_its 0x0256 0x2>,
+		  <0x9600 &gic_its 0x0258 0x2>,
+		  <0x9608 &gic_its 0x025a 0x2>,
+		  <0x9700 &gic_its 0x025c 0x2>,
+		  <0x9708 &gic_its 0x025e 0x2>,
+		  <0x9800 &gic_its 0x0260 0x2>,
+		  <0x9808 &gic_its 0x0262 0x2>,
+		  <0x9900 &gic_its 0x0264 0x2>,
+		  <0x9908 &gic_its 0x0266 0x2>,
+		  <0x9a00 &gic_its 0x0268 0x2>,
+		  <0x9a08 &gic_its 0x026a 0x2>,
+		  <0x9b00 &gic_its 0x026c 0x2>,
+		  <0x9b08 &gic_its 0x026e 0x2>,
+		  <0x9c00 &gic_its 0x0270 0x2>,
+		  <0x9c08 &gic_its 0x0272 0x2>,
+		  <0x9d00 &gic_its 0x0274 0x2>,
+		  <0x9d08 &gic_its 0x0276 0x2>,
+		  <0x9e00 &gic_its 0x0278 0x2>,
+		  <0x9e08 &gic_its 0x027a 0x2>,
+		  <0x9f00 &gic_its 0x027c 0x2>,
+		  <0x9f08 &gic_its 0x027e 0x2>,
+		  <0xa000 &gic_its 0x0280 0x2>,
+		  <0xa008 &gic_its 0x0282 0x2>,
+		  <0xa100 &gic_its 0x0284 0x2>,
+		  <0xa108 &gic_its 0x0286 0x2>,
+		  <0xa200 &gic_its 0x0288 0x2>,
+		  <0xa208 &gic_its 0x028a 0x2>,
+		  <0xa300 &gic_its 0x028c 0x2>,
+		  <0xa308 &gic_its 0x028e 0x2>,
+		  <0xa400 &gic_its 0x0290 0x2>,
+		  <0xa408 &gic_its 0x0292 0x2>,
+		  <0xa500 &gic_its 0x0294 0x2>,
+		  <0xa508 &gic_its 0x0296 0x2>,
+		  <0xa600 &gic_its 0x0298 0x2>,
+		  <0xa608 &gic_its 0x029a 0x2>,
+		  <0xa700 &gic_its 0x029c 0x2>,
+		  <0xa708 &gic_its 0x029e 0x2>,
+		  <0xa800 &gic_its 0x02a0 0x2>,
+		  <0xa808 &gic_its 0x02a2 0x2>,
+		  <0xa900 &gic_its 0x02a4 0x2>,
+		  <0xa908 &gic_its 0x02a6 0x2>,
+		  <0xaa00 &gic_its 0x02a8 0x2>,
+		  <0xaa08 &gic_its 0x02aa 0x2>,
+		  <0xab00 &gic_its 0x02ac 0x2>,
+		  <0xab08 &gic_its 0x02ae 0x2>,
+		  <0xac00 &gic_its 0x02b0 0x2>,
+		  <0xac08 &gic_its 0x02b2 0x2>,
+		  <0xad00 &gic_its 0x02b4 0x2>,
+		  <0xad08 &gic_its 0x02b6 0x2>,
+		  <0xae00 &gic_its 0x02b8 0x2>,
+		  <0xae08 &gic_its 0x02ba 0x2>,
+		  <0xaf00 &gic_its 0x02bc 0x2>,
+		  <0xaf08 &gic_its 0x02be 0x2>,
+		  <0xb000 &gic_its 0x02c0 0x2>,
+		  <0xb008 &gic_its 0x02c2 0x2>,
+		  <0xb100 &gic_its 0x02c4 0x2>,
+		  <0xb108 &gic_its 0x02c6 0x2>,
+		  <0xb200 &gic_its 0x02c8 0x2>,
+		  <0xb208 &gic_its 0x02ca 0x2>,
+		  <0xb300 &gic_its 0x02cc 0x2>,
+		  <0xb308 &gic_its 0x02ce 0x2>,
+		  <0xb400 &gic_its 0x02d0 0x2>,
+		  <0xb408 &gic_its 0x02d2 0x2>,
+		  <0xb500 &gic_its 0x02d4 0x2>,
+		  <0xb508 &gic_its 0x02d6 0x2>,
+		  <0xb600 &gic_its 0x02d8 0x2>,
+		  <0xb608 &gic_its 0x02da 0x2>,
+		  <0xb700 &gic_its 0x02dc 0x2>,
+		  <0xb708 &gic_its 0x02de 0x2>,
+		  <0xb800 &gic_its 0x02e0 0x2>,
+		  <0xb808 &gic_its 0x02e2 0x2>,
+		  <0xb900 &gic_its 0x02e4 0x2>,
+		  <0xb908 &gic_its 0x02e6 0x2>,
+		  <0xba00 &gic_its 0x02e8 0x2>,
+		  <0xba08 &gic_its 0x02ea 0x2>,
+		  <0xbb00 &gic_its 0x02ec 0x2>,
+		  <0xbb08 &gic_its 0x02ee 0x2>,
+		  <0xbc00 &gic_its 0x02f0 0x2>,
+		  <0xbc08 &gic_its 0x02f2 0x2>,
+		  <0xbd00 &gic_its 0x02f4 0x2>,
+		  <0xbd08 &gic_its 0x02f6 0x2>,
+		  <0xbe00 &gic_its 0x02f8 0x2>,
+		  <0xbe08 &gic_its 0x02fa 0x2>,
+		  <0xbf00 &gic_its 0x02fc 0x2>,
+		  <0xbf08 &gic_its 0x02fe 0x2>,
+		  <0xc000 &gic_its 0x0300 0x2>,
+		  <0xc008 &gic_its 0x0302 0x2>,
+		  <0xc100 &gic_its 0x0304 0x2>,
+		  <0xc108 &gic_its 0x0306 0x2>,
+		  <0xc200 &gic_its 0x0308 0x2>,
+		  <0xc208 &gic_its 0x030a 0x2>,
+		  <0xc300 &gic_its 0x030c 0x2>,
+		  <0xc308 &gic_its 0x030e 0x2>,
+		  <0xc400 &gic_its 0x0310 0x2>,
+		  <0xc408 &gic_its 0x0312 0x2>,
+		  <0xc500 &gic_its 0x0314 0x2>,
+		  <0xc508 &gic_its 0x0316 0x2>,
+		  <0xc600 &gic_its 0x0318 0x2>,
+		  <0xc608 &gic_its 0x031a 0x2>,
+		  <0xc700 &gic_its 0x031c 0x2>,
+		  <0xc708 &gic_its 0x031e 0x2>,
+		  <0xc800 &gic_its 0x0320 0x2>,
+		  <0xc808 &gic_its 0x0322 0x2>,
+		  <0xc900 &gic_its 0x0324 0x2>,
+		  <0xc908 &gic_its 0x0326 0x2>,
+		  <0xca00 &gic_its 0x0328 0x2>,
+		  <0xca08 &gic_its 0x032a 0x2>,
+		  <0xcb00 &gic_its 0x032c 0x2>,
+		  <0xcb08 &gic_its 0x032e 0x2>,
+		  <0xcc00 &gic_its 0x0330 0x2>,
+		  <0xcc08 &gic_its 0x0332 0x2>,
+		  <0xcd00 &gic_its 0x0334 0x2>,
+		  <0xcd08 &gic_its 0x0336 0x2>,
+		  <0xce00 &gic_its 0x0338 0x2>,
+		  <0xce08 &gic_its 0x033a 0x2>,
+		  <0xcf00 &gic_its 0x033c 0x2>,
+		  <0xcf08 &gic_its 0x033e 0x2>,
+		  <0xd000 &gic_its 0x0340 0x2>,
+		  <0xd008 &gic_its 0x0342 0x2>,
+		  <0xd100 &gic_its 0x0344 0x2>,
+		  <0xd108 &gic_its 0x0346 0x2>,
+		  <0xd200 &gic_its 0x0348 0x2>,
+		  <0xd208 &gic_its 0x034a 0x2>,
+		  <0xd300 &gic_its 0x034c 0x2>,
+		  <0xd308 &gic_its 0x034e 0x2>,
+		  <0xd400 &gic_its 0x0350 0x2>,
+		  <0xd408 &gic_its 0x0352 0x2>,
+		  <0xd500 &gic_its 0x0354 0x2>,
+		  <0xd508 &gic_its 0x0356 0x2>,
+		  <0xd600 &gic_its 0x0358 0x2>,
+		  <0xd608 &gic_its 0x035a 0x2>,
+		  <0xd700 &gic_its 0x035c 0x2>,
+		  <0xd708 &gic_its 0x035e 0x2>,
+		  <0xd800 &gic_its 0x0360 0x2>,
+		  <0xd808 &gic_its 0x0362 0x2>,
+		  <0xd900 &gic_its 0x0364 0x2>,
+		  <0xd908 &gic_its 0x0366 0x2>,
+		  <0xda00 &gic_its 0x0368 0x2>,
+		  <0xda08 &gic_its 0x036a 0x2>,
+		  <0xdb00 &gic_its 0x036c 0x2>,
+		  <0xdb08 &gic_its 0x036e 0x2>,
+		  <0xdc00 &gic_its 0x0370 0x2>,
+		  <0xdc08 &gic_its 0x0372 0x2>,
+		  <0xdd00 &gic_its 0x0374 0x2>,
+		  <0xdd08 &gic_its 0x0376 0x2>,
+		  <0xde00 &gic_its 0x0378 0x2>,
+		  <0xde08 &gic_its 0x037a 0x2>,
+		  <0xdf00 &gic_its 0x037c 0x2>,
+		  <0xdf08 &gic_its 0x037e 0x2>,
+		  <0xe000 &gic_its 0x0380 0x2>,
+		  <0xe008 &gic_its 0x0382 0x2>,
+		  <0xe100 &gic_its 0x0384 0x2>,
+		  <0xe108 &gic_its 0x0386 0x2>,
+		  <0xe200 &gic_its 0x0388 0x2>,
+		  <0xe208 &gic_its 0x038a 0x2>,
+		  <0xe300 &gic_its 0x038c 0x2>,
+		  <0xe308 &gic_its 0x038e 0x2>,
+		  <0xe400 &gic_its 0x0390 0x2>,
+		  <0xe408 &gic_its 0x0392 0x2>,
+		  <0xe500 &gic_its 0x0394 0x2>,
+		  <0xe508 &gic_its 0x0396 0x2>,
+		  <0xe600 &gic_its 0x0398 0x2>,
+		  <0xe608 &gic_its 0x039a 0x2>,
+		  <0xe700 &gic_its 0x039c 0x2>,
+		  <0xe708 &gic_its 0x039e 0x2>,
+		  <0xe800 &gic_its 0x03a0 0x2>,
+		  <0xe808 &gic_its 0x03a2 0x2>,
+		  <0xe900 &gic_its 0x03a4 0x2>,
+		  <0xe908 &gic_its 0x03a6 0x2>,
+		  <0xea00 &gic_its 0x03a8 0x2>,
+		  <0xea08 &gic_its 0x03aa 0x2>,
+		  <0xeb00 &gic_its 0x03ac 0x2>,
+		  <0xeb08 &gic_its 0x03ae 0x2>,
+		  <0xec00 &gic_its 0x03b0 0x2>,
+		  <0xec08 &gic_its 0x03b2 0x2>,
+		  <0xed00 &gic_its 0x03b4 0x2>,
+		  <0xed08 &gic_its 0x03b6 0x2>,
+		  <0xee00 &gic_its 0x03b8 0x2>,
+		  <0xee08 &gic_its 0x03ba 0x2>,
+		  <0xef00 &gic_its 0x03bc 0x2>,
+		  <0xef08 &gic_its 0x03be 0x2>,
+		  <0xf000 &gic_its 0x03c0 0x2>,
+		  <0xf008 &gic_its 0x03c2 0x2>,
+		  <0xf100 &gic_its 0x03c4 0x2>,
+		  <0xf108 &gic_its 0x03c6 0x2>,
+		  <0xf200 &gic_its 0x03c8 0x2>,
+		  <0xf208 &gic_its 0x03ca 0x2>,
+		  <0xf300 &gic_its 0x03cc 0x2>,
+		  <0xf308 &gic_its 0x03ce 0x2>,
+		  <0xf400 &gic_its 0x03d0 0x2>,
+		  <0xf408 &gic_its 0x03d2 0x2>,
+		  <0xf500 &gic_its 0x03d4 0x2>,
+		  <0xf508 &gic_its 0x03d6 0x2>,
+		  <0xf600 &gic_its 0x03d8 0x2>,
+		  <0xf608 &gic_its 0x03da 0x2>,
+		  <0xf700 &gic_its 0x03dc 0x2>,
+		  <0xf708 &gic_its 0x03de 0x2>,
+		  <0xf800 &gic_its 0x03e0 0x2>,
+		  <0xf808 &gic_its 0x03e2 0x2>,
+		  <0xf900 &gic_its 0x03e4 0x2>,
+		  <0xf908 &gic_its 0x03e6 0x2>,
+		  <0xfa00 &gic_its 0x03e8 0x2>,
+		  <0xfa08 &gic_its 0x03ea 0x2>,
+		  <0xfb00 &gic_its 0x03ec 0x2>,
+		  <0xfb08 &gic_its 0x03ee 0x2>,
+		  <0xfc00 &gic_its 0x03f0 0x2>,
+		  <0xfc08 &gic_its 0x03f2 0x2>,
+		  <0xfd00 &gic_its 0x03f4 0x2>,
+		  <0xfd08 &gic_its 0x03f6 0x2>,
+		  <0xfe00 &gic_its 0x03f8 0x2>,
+		  <0xfe08 &gic_its 0x03fa 0x2>,
+		  <0xff00 &gic_its 0x03fc 0x2>,
+		  <0xff08 &gic_its 0x03fe 0x2>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x0000 0x2>,
+		    <0x0008 &smmu 0x0002 0x2>,
+		    <0x0100 &smmu 0x0004 0x2>,
+		    <0x0108 &smmu 0x0006 0x2>,
+		    <0x0200 &smmu 0x0008 0x2>,
+		    <0x0208 &smmu 0x000a 0x2>,
+		    <0x0300 &smmu 0x000c 0x2>,
+		    <0x0308 &smmu 0x000e 0x2>,
+		    <0x0400 &smmu 0x0010 0x2>,
+		    <0x0408 &smmu 0x0012 0x2>,
+		    <0x0500 &smmu 0x0014 0x2>,
+		    <0x0508 &smmu 0x0016 0x2>,
+		    <0x0600 &smmu 0x0018 0x2>,
+		    <0x0608 &smmu 0x001a 0x2>,
+		    <0x0700 &smmu 0x001c 0x2>,
+		    <0x0708 &smmu 0x001e 0x2>,
+		    <0x0800 &smmu 0x0020 0x2>,
+		    <0x0808 &smmu 0x0022 0x2>,
+		    <0x0900 &smmu 0x0024 0x2>,
+		    <0x0908 &smmu 0x0026 0x2>,
+		    <0x0a00 &smmu 0x0028 0x2>,
+		    <0x0a08 &smmu 0x002a 0x2>,
+		    <0x0b00 &smmu 0x002c 0x2>,
+		    <0x0b08 &smmu 0x002e 0x2>,
+		    <0x0c00 &smmu 0x0030 0x2>,
+		    <0x0c08 &smmu 0x0032 0x2>,
+		    <0x0d00 &smmu 0x0034 0x2>,
+		    <0x0d08 &smmu 0x0036 0x2>,
+		    <0x0e00 &smmu 0x0038 0x2>,
+		    <0x0e08 &smmu 0x003a 0x2>,
+		    <0x0f00 &smmu 0x003c 0x2>,
+		    <0x0f08 &smmu 0x003e 0x2>,
+		    <0x1000 &smmu 0x0040 0x2>,
+		    <0x1008 &smmu 0x0042 0x2>,
+		    <0x1100 &smmu 0x0044 0x2>,
+		    <0x1108 &smmu 0x0046 0x2>,
+		    <0x1200 &smmu 0x0048 0x2>,
+		    <0x1208 &smmu 0x004a 0x2>,
+		    <0x1300 &smmu 0x004c 0x2>,
+		    <0x1308 &smmu 0x004e 0x2>,
+		    <0x1400 &smmu 0x0050 0x2>,
+		    <0x1408 &smmu 0x0052 0x2>,
+		    <0x1500 &smmu 0x0054 0x2>,
+		    <0x1508 &smmu 0x0056 0x2>,
+		    <0x1600 &smmu 0x0058 0x2>,
+		    <0x1608 &smmu 0x005a 0x2>,
+		    <0x1700 &smmu 0x005c 0x2>,
+		    <0x1708 &smmu 0x005e 0x2>,
+		    <0x1800 &smmu 0x0060 0x2>,
+		    <0x1808 &smmu 0x0062 0x2>,
+		    <0x1900 &smmu 0x0064 0x2>,
+		    <0x1908 &smmu 0x0066 0x2>,
+		    <0x1a00 &smmu 0x0068 0x2>,
+		    <0x1a08 &smmu 0x006a 0x2>,
+		    <0x1b00 &smmu 0x006c 0x2>,
+		    <0x1b08 &smmu 0x006e 0x2>,
+		    <0x1c00 &smmu 0x0070 0x2>,
+		    <0x1c08 &smmu 0x0072 0x2>,
+		    <0x1d00 &smmu 0x0074 0x2>,
+		    <0x1d08 &smmu 0x0076 0x2>,
+		    <0x1e00 &smmu 0x0078 0x2>,
+		    <0x1e08 &smmu 0x007a 0x2>,
+		    <0x1f00 &smmu 0x007c 0x2>,
+		    <0x1f08 &smmu 0x007e 0x2>,
+		    <0x2000 &smmu 0x0080 0x2>,
+		    <0x2008 &smmu 0x0082 0x2>,
+		    <0x2100 &smmu 0x0084 0x2>,
+		    <0x2108 &smmu 0x0086 0x2>,
+		    <0x2200 &smmu 0x0088 0x2>,
+		    <0x2208 &smmu 0x008a 0x2>,
+		    <0x2300 &smmu 0x008c 0x2>,
+		    <0x2308 &smmu 0x008e 0x2>,
+		    <0x2400 &smmu 0x0090 0x2>,
+		    <0x2408 &smmu 0x0092 0x2>,
+		    <0x2500 &smmu 0x0094 0x2>,
+		    <0x2508 &smmu 0x0096 0x2>,
+		    <0x2600 &smmu 0x0098 0x2>,
+		    <0x2608 &smmu 0x009a 0x2>,
+		    <0x2700 &smmu 0x009c 0x2>,
+		    <0x2708 &smmu 0x009e 0x2>,
+		    <0x2800 &smmu 0x00a0 0x2>,
+		    <0x2808 &smmu 0x00a2 0x2>,
+		    <0x2900 &smmu 0x00a4 0x2>,
+		    <0x2908 &smmu 0x00a6 0x2>,
+		    <0x2a00 &smmu 0x00a8 0x2>,
+		    <0x2a08 &smmu 0x00aa 0x2>,
+		    <0x2b00 &smmu 0x00ac 0x2>,
+		    <0x2b08 &smmu 0x00ae 0x2>,
+		    <0x2c00 &smmu 0x00b0 0x2>,
+		    <0x2c08 &smmu 0x00b2 0x2>,
+		    <0x2d00 &smmu 0x00b4 0x2>,
+		    <0x2d08 &smmu 0x00b6 0x2>,
+		    <0x2e00 &smmu 0x00b8 0x2>,
+		    <0x2e08 &smmu 0x00ba 0x2>,
+		    <0x2f00 &smmu 0x00bc 0x2>,
+		    <0x2f08 &smmu 0x00be 0x2>,
+		    <0x3000 &smmu 0x00c0 0x2>,
+		    <0x3008 &smmu 0x00c2 0x2>,
+		    <0x3100 &smmu 0x00c4 0x2>,
+		    <0x3108 &smmu 0x00c6 0x2>,
+		    <0x3200 &smmu 0x00c8 0x2>,
+		    <0x3208 &smmu 0x00ca 0x2>,
+		    <0x3300 &smmu 0x00cc 0x2>,
+		    <0x3308 &smmu 0x00ce 0x2>,
+		    <0x3400 &smmu 0x00d0 0x2>,
+		    <0x3408 &smmu 0x00d2 0x2>,
+		    <0x3500 &smmu 0x00d4 0x2>,
+		    <0x3508 &smmu 0x00d6 0x2>,
+		    <0x3600 &smmu 0x00d8 0x2>,
+		    <0x3608 &smmu 0x00da 0x2>,
+		    <0x3700 &smmu 0x00dc 0x2>,
+		    <0x3708 &smmu 0x00de 0x2>,
+		    <0x3800 &smmu 0x00e0 0x2>,
+		    <0x3808 &smmu 0x00e2 0x2>,
+		    <0x3900 &smmu 0x00e4 0x2>,
+		    <0x3908 &smmu 0x00e6 0x2>,
+		    <0x3a00 &smmu 0x00e8 0x2>,
+		    <0x3a08 &smmu 0x00ea 0x2>,
+		    <0x3b00 &smmu 0x00ec 0x2>,
+		    <0x3b08 &smmu 0x00ee 0x2>,
+		    <0x3c00 &smmu 0x00f0 0x2>,
+		    <0x3c08 &smmu 0x00f2 0x2>,
+		    <0x3d00 &smmu 0x00f4 0x2>,
+		    <0x3d08 &smmu 0x00f6 0x2>,
+		    <0x3e00 &smmu 0x00f8 0x2>,
+		    <0x3e08 &smmu 0x00fa 0x2>,
+		    <0x3f00 &smmu 0x00fc 0x2>,
+		    <0x3f08 &smmu 0x00fe 0x2>,
+		    <0x4000 &smmu 0x0100 0x2>,
+		    <0x4008 &smmu 0x0102 0x2>,
+		    <0x4100 &smmu 0x0104 0x2>,
+		    <0x4108 &smmu 0x0106 0x2>,
+		    <0x4200 &smmu 0x0108 0x2>,
+		    <0x4208 &smmu 0x010a 0x2>,
+		    <0x4300 &smmu 0x010c 0x2>,
+		    <0x4308 &smmu 0x010e 0x2>,
+		    <0x4400 &smmu 0x0110 0x2>,
+		    <0x4408 &smmu 0x0112 0x2>,
+		    <0x4500 &smmu 0x0114 0x2>,
+		    <0x4508 &smmu 0x0116 0x2>,
+		    <0x4600 &smmu 0x0118 0x2>,
+		    <0x4608 &smmu 0x011a 0x2>,
+		    <0x4700 &smmu 0x011c 0x2>,
+		    <0x4708 &smmu 0x011e 0x2>,
+		    <0x4800 &smmu 0x0120 0x2>,
+		    <0x4808 &smmu 0x0122 0x2>,
+		    <0x4900 &smmu 0x0124 0x2>,
+		    <0x4908 &smmu 0x0126 0x2>,
+		    <0x4a00 &smmu 0x0128 0x2>,
+		    <0x4a08 &smmu 0x012a 0x2>,
+		    <0x4b00 &smmu 0x012c 0x2>,
+		    <0x4b08 &smmu 0x012e 0x2>,
+		    <0x4c00 &smmu 0x0130 0x2>,
+		    <0x4c08 &smmu 0x0132 0x2>,
+		    <0x4d00 &smmu 0x0134 0x2>,
+		    <0x4d08 &smmu 0x0136 0x2>,
+		    <0x4e00 &smmu 0x0138 0x2>,
+		    <0x4e08 &smmu 0x013a 0x2>,
+		    <0x4f00 &smmu 0x013c 0x2>,
+		    <0x4f08 &smmu 0x013e 0x2>,
+		    <0x5000 &smmu 0x0140 0x2>,
+		    <0x5008 &smmu 0x0142 0x2>,
+		    <0x5100 &smmu 0x0144 0x2>,
+		    <0x5108 &smmu 0x0146 0x2>,
+		    <0x5200 &smmu 0x0148 0x2>,
+		    <0x5208 &smmu 0x014a 0x2>,
+		    <0x5300 &smmu 0x014c 0x2>,
+		    <0x5308 &smmu 0x014e 0x2>,
+		    <0x5400 &smmu 0x0150 0x2>,
+		    <0x5408 &smmu 0x0152 0x2>,
+		    <0x5500 &smmu 0x0154 0x2>,
+		    <0x5508 &smmu 0x0156 0x2>,
+		    <0x5600 &smmu 0x0158 0x2>,
+		    <0x5608 &smmu 0x015a 0x2>,
+		    <0x5700 &smmu 0x015c 0x2>,
+		    <0x5708 &smmu 0x015e 0x2>,
+		    <0x5800 &smmu 0x0160 0x2>,
+		    <0x5808 &smmu 0x0162 0x2>,
+		    <0x5900 &smmu 0x0164 0x2>,
+		    <0x5908 &smmu 0x0166 0x2>,
+		    <0x5a00 &smmu 0x0168 0x2>,
+		    <0x5a08 &smmu 0x016a 0x2>,
+		    <0x5b00 &smmu 0x016c 0x2>,
+		    <0x5b08 &smmu 0x016e 0x2>,
+		    <0x5c00 &smmu 0x0170 0x2>,
+		    <0x5c08 &smmu 0x0172 0x2>,
+		    <0x5d00 &smmu 0x0174 0x2>,
+		    <0x5d08 &smmu 0x0176 0x2>,
+		    <0x5e00 &smmu 0x0178 0x2>,
+		    <0x5e08 &smmu 0x017a 0x2>,
+		    <0x5f00 &smmu 0x017c 0x2>,
+		    <0x5f08 &smmu 0x017e 0x2>,
+		    <0x6000 &smmu 0x0180 0x2>,
+		    <0x6008 &smmu 0x0182 0x2>,
+		    <0x6100 &smmu 0x0184 0x2>,
+		    <0x6108 &smmu 0x0186 0x2>,
+		    <0x6200 &smmu 0x0188 0x2>,
+		    <0x6208 &smmu 0x018a 0x2>,
+		    <0x6300 &smmu 0x018c 0x2>,
+		    <0x6308 &smmu 0x018e 0x2>,
+		    <0x6400 &smmu 0x0190 0x2>,
+		    <0x6408 &smmu 0x0192 0x2>,
+		    <0x6500 &smmu 0x0194 0x2>,
+		    <0x6508 &smmu 0x0196 0x2>,
+		    <0x6600 &smmu 0x0198 0x2>,
+		    <0x6608 &smmu 0x019a 0x2>,
+		    <0x6700 &smmu 0x019c 0x2>,
+		    <0x6708 &smmu 0x019e 0x2>,
+		    <0x6800 &smmu 0x01a0 0x2>,
+		    <0x6808 &smmu 0x01a2 0x2>,
+		    <0x6900 &smmu 0x01a4 0x2>,
+		    <0x6908 &smmu 0x01a6 0x2>,
+		    <0x6a00 &smmu 0x01a8 0x2>,
+		    <0x6a08 &smmu 0x01aa 0x2>,
+		    <0x6b00 &smmu 0x01ac 0x2>,
+		    <0x6b08 &smmu 0x01ae 0x2>,
+		    <0x6c00 &smmu 0x01b0 0x2>,
+		    <0x6c08 &smmu 0x01b2 0x2>,
+		    <0x6d00 &smmu 0x01b4 0x2>,
+		    <0x6d08 &smmu 0x01b6 0x2>,
+		    <0x6e00 &smmu 0x01b8 0x2>,
+		    <0x6e08 &smmu 0x01ba 0x2>,
+		    <0x6f00 &smmu 0x01bc 0x2>,
+		    <0x6f08 &smmu 0x01be 0x2>,
+		    <0x7000 &smmu 0x01c0 0x2>,
+		    <0x7008 &smmu 0x01c2 0x2>,
+		    <0x7100 &smmu 0x01c4 0x2>,
+		    <0x7108 &smmu 0x01c6 0x2>,
+		    <0x7200 &smmu 0x01c8 0x2>,
+		    <0x7208 &smmu 0x01ca 0x2>,
+		    <0x7300 &smmu 0x01cc 0x2>,
+		    <0x7308 &smmu 0x01ce 0x2>,
+		    <0x7400 &smmu 0x01d0 0x2>,
+		    <0x7408 &smmu 0x01d2 0x2>,
+		    <0x7500 &smmu 0x01d4 0x2>,
+		    <0x7508 &smmu 0x01d6 0x2>,
+		    <0x7600 &smmu 0x01d8 0x2>,
+		    <0x7608 &smmu 0x01da 0x2>,
+		    <0x7700 &smmu 0x01dc 0x2>,
+		    <0x7708 &smmu 0x01de 0x2>,
+		    <0x7800 &smmu 0x01e0 0x2>,
+		    <0x7808 &smmu 0x01e2 0x2>,
+		    <0x7900 &smmu 0x01e4 0x2>,
+		    <0x7908 &smmu 0x01e6 0x2>,
+		    <0x7a00 &smmu 0x01e8 0x2>,
+		    <0x7a08 &smmu 0x01ea 0x2>,
+		    <0x7b00 &smmu 0x01ec 0x2>,
+		    <0x7b08 &smmu 0x01ee 0x2>,
+		    <0x7c00 &smmu 0x01f0 0x2>,
+		    <0x7c08 &smmu 0x01f2 0x2>,
+		    <0x7d00 &smmu 0x01f4 0x2>,
+		    <0x7d08 &smmu 0x01f6 0x2>,
+		    <0x7e00 &smmu 0x01f8 0x2>,
+		    <0x7e08 &smmu 0x01fa 0x2>,
+		    <0x7f00 &smmu 0x01fc 0x2>,
+		    <0x7f08 &smmu 0x01fe 0x2>,
+		    <0x8000 &smmu 0x0200 0x2>,
+		    <0x8008 &smmu 0x0202 0x2>,
+		    <0x8100 &smmu 0x0204 0x2>,
+		    <0x8108 &smmu 0x0206 0x2>,
+		    <0x8200 &smmu 0x0208 0x2>,
+		    <0x8208 &smmu 0x020a 0x2>,
+		    <0x8300 &smmu 0x020c 0x2>,
+		    <0x8308 &smmu 0x020e 0x2>,
+		    <0x8400 &smmu 0x0210 0x2>,
+		    <0x8408 &smmu 0x0212 0x2>,
+		    <0x8500 &smmu 0x0214 0x2>,
+		    <0x8508 &smmu 0x0216 0x2>,
+		    <0x8600 &smmu 0x0218 0x2>,
+		    <0x8608 &smmu 0x021a 0x2>,
+		    <0x8700 &smmu 0x021c 0x2>,
+		    <0x8708 &smmu 0x021e 0x2>,
+		    <0x8800 &smmu 0x0220 0x2>,
+		    <0x8808 &smmu 0x0222 0x2>,
+		    <0x8900 &smmu 0x0224 0x2>,
+		    <0x8908 &smmu 0x0226 0x2>,
+		    <0x8a00 &smmu 0x0228 0x2>,
+		    <0x8a08 &smmu 0x022a 0x2>,
+		    <0x8b00 &smmu 0x022c 0x2>,
+		    <0x8b08 &smmu 0x022e 0x2>,
+		    <0x8c00 &smmu 0x0230 0x2>,
+		    <0x8c08 &smmu 0x0232 0x2>,
+		    <0x8d00 &smmu 0x0234 0x2>,
+		    <0x8d08 &smmu 0x0236 0x2>,
+		    <0x8e00 &smmu 0x0238 0x2>,
+		    <0x8e08 &smmu 0x023a 0x2>,
+		    <0x8f00 &smmu 0x023c 0x2>,
+		    <0x8f08 &smmu 0x023e 0x2>,
+		    <0x9000 &smmu 0x0240 0x2>,
+		    <0x9008 &smmu 0x0242 0x2>,
+		    <0x9100 &smmu 0x0244 0x2>,
+		    <0x9108 &smmu 0x0246 0x2>,
+		    <0x9200 &smmu 0x0248 0x2>,
+		    <0x9208 &smmu 0x024a 0x2>,
+		    <0x9300 &smmu 0x024c 0x2>,
+		    <0x9308 &smmu 0x024e 0x2>,
+		    <0x9400 &smmu 0x0250 0x2>,
+		    <0x9408 &smmu 0x0252 0x2>,
+		    <0x9500 &smmu 0x0254 0x2>,
+		    <0x9508 &smmu 0x0256 0x2>,
+		    <0x9600 &smmu 0x0258 0x2>,
+		    <0x9608 &smmu 0x025a 0x2>,
+		    <0x9700 &smmu 0x025c 0x2>,
+		    <0x9708 &smmu 0x025e 0x2>,
+		    <0x9800 &smmu 0x0260 0x2>,
+		    <0x9808 &smmu 0x0262 0x2>,
+		    <0x9900 &smmu 0x0264 0x2>,
+		    <0x9908 &smmu 0x0266 0x2>,
+		    <0x9a00 &smmu 0x0268 0x2>,
+		    <0x9a08 &smmu 0x026a 0x2>,
+		    <0x9b00 &smmu 0x026c 0x2>,
+		    <0x9b08 &smmu 0x026e 0x2>,
+		    <0x9c00 &smmu 0x0270 0x2>,
+		    <0x9c08 &smmu 0x0272 0x2>,
+		    <0x9d00 &smmu 0x0274 0x2>,
+		    <0x9d08 &smmu 0x0276 0x2>,
+		    <0x9e00 &smmu 0x0278 0x2>,
+		    <0x9e08 &smmu 0x027a 0x2>,
+		    <0x9f00 &smmu 0x027c 0x2>,
+		    <0x9f08 &smmu 0x027e 0x2>,
+		    <0xa000 &smmu 0x0280 0x2>,
+		    <0xa008 &smmu 0x0282 0x2>,
+		    <0xa100 &smmu 0x0284 0x2>,
+		    <0xa108 &smmu 0x0286 0x2>,
+		    <0xa200 &smmu 0x0288 0x2>,
+		    <0xa208 &smmu 0x028a 0x2>,
+		    <0xa300 &smmu 0x028c 0x2>,
+		    <0xa308 &smmu 0x028e 0x2>,
+		    <0xa400 &smmu 0x0290 0x2>,
+		    <0xa408 &smmu 0x0292 0x2>,
+		    <0xa500 &smmu 0x0294 0x2>,
+		    <0xa508 &smmu 0x0296 0x2>,
+		    <0xa600 &smmu 0x0298 0x2>,
+		    <0xa608 &smmu 0x029a 0x2>,
+		    <0xa700 &smmu 0x029c 0x2>,
+		    <0xa708 &smmu 0x029e 0x2>,
+		    <0xa800 &smmu 0x02a0 0x2>,
+		    <0xa808 &smmu 0x02a2 0x2>,
+		    <0xa900 &smmu 0x02a4 0x2>,
+		    <0xa908 &smmu 0x02a6 0x2>,
+		    <0xaa00 &smmu 0x02a8 0x2>,
+		    <0xaa08 &smmu 0x02aa 0x2>,
+		    <0xab00 &smmu 0x02ac 0x2>,
+		    <0xab08 &smmu 0x02ae 0x2>,
+		    <0xac00 &smmu 0x02b0 0x2>,
+		    <0xac08 &smmu 0x02b2 0x2>,
+		    <0xad00 &smmu 0x02b4 0x2>,
+		    <0xad08 &smmu 0x02b6 0x2>,
+		    <0xae00 &smmu 0x02b8 0x2>,
+		    <0xae08 &smmu 0x02ba 0x2>,
+		    <0xaf00 &smmu 0x02bc 0x2>,
+		    <0xaf08 &smmu 0x02be 0x2>,
+		    <0xb000 &smmu 0x02c0 0x2>,
+		    <0xb008 &smmu 0x02c2 0x2>,
+		    <0xb100 &smmu 0x02c4 0x2>,
+		    <0xb108 &smmu 0x02c6 0x2>,
+		    <0xb200 &smmu 0x02c8 0x2>,
+		    <0xb208 &smmu 0x02ca 0x2>,
+		    <0xb300 &smmu 0x02cc 0x2>,
+		    <0xb308 &smmu 0x02ce 0x2>,
+		    <0xb400 &smmu 0x02d0 0x2>,
+		    <0xb408 &smmu 0x02d2 0x2>,
+		    <0xb500 &smmu 0x02d4 0x2>,
+		    <0xb508 &smmu 0x02d6 0x2>,
+		    <0xb600 &smmu 0x02d8 0x2>,
+		    <0xb608 &smmu 0x02da 0x2>,
+		    <0xb700 &smmu 0x02dc 0x2>,
+		    <0xb708 &smmu 0x02de 0x2>,
+		    <0xb800 &smmu 0x02e0 0x2>,
+		    <0xb808 &smmu 0x02e2 0x2>,
+		    <0xb900 &smmu 0x02e4 0x2>,
+		    <0xb908 &smmu 0x02e6 0x2>,
+		    <0xba00 &smmu 0x02e8 0x2>,
+		    <0xba08 &smmu 0x02ea 0x2>,
+		    <0xbb00 &smmu 0x02ec 0x2>,
+		    <0xbb08 &smmu 0x02ee 0x2>,
+		    <0xbc00 &smmu 0x02f0 0x2>,
+		    <0xbc08 &smmu 0x02f2 0x2>,
+		    <0xbd00 &smmu 0x02f4 0x2>,
+		    <0xbd08 &smmu 0x02f6 0x2>,
+		    <0xbe00 &smmu 0x02f8 0x2>,
+		    <0xbe08 &smmu 0x02fa 0x2>,
+		    <0xbf00 &smmu 0x02fc 0x2>,
+		    <0xbf08 &smmu 0x02fe 0x2>,
+		    <0xc000 &smmu 0x0300 0x2>,
+		    <0xc008 &smmu 0x0302 0x2>,
+		    <0xc100 &smmu 0x0304 0x2>,
+		    <0xc108 &smmu 0x0306 0x2>,
+		    <0xc200 &smmu 0x0308 0x2>,
+		    <0xc208 &smmu 0x030a 0x2>,
+		    <0xc300 &smmu 0x030c 0x2>,
+		    <0xc308 &smmu 0x030e 0x2>,
+		    <0xc400 &smmu 0x0310 0x2>,
+		    <0xc408 &smmu 0x0312 0x2>,
+		    <0xc500 &smmu 0x0314 0x2>,
+		    <0xc508 &smmu 0x0316 0x2>,
+		    <0xc600 &smmu 0x0318 0x2>,
+		    <0xc608 &smmu 0x031a 0x2>,
+		    <0xc700 &smmu 0x031c 0x2>,
+		    <0xc708 &smmu 0x031e 0x2>,
+		    <0xc800 &smmu 0x0320 0x2>,
+		    <0xc808 &smmu 0x0322 0x2>,
+		    <0xc900 &smmu 0x0324 0x2>,
+		    <0xc908 &smmu 0x0326 0x2>,
+		    <0xca00 &smmu 0x0328 0x2>,
+		    <0xca08 &smmu 0x032a 0x2>,
+		    <0xcb00 &smmu 0x032c 0x2>,
+		    <0xcb08 &smmu 0x032e 0x2>,
+		    <0xcc00 &smmu 0x0330 0x2>,
+		    <0xcc08 &smmu 0x0332 0x2>,
+		    <0xcd00 &smmu 0x0334 0x2>,
+		    <0xcd08 &smmu 0x0336 0x2>,
+		    <0xce00 &smmu 0x0338 0x2>,
+		    <0xce08 &smmu 0x033a 0x2>,
+		    <0xcf00 &smmu 0x033c 0x2>,
+		    <0xcf08 &smmu 0x033e 0x2>,
+		    <0xd000 &smmu 0x0340 0x2>,
+		    <0xd008 &smmu 0x0342 0x2>,
+		    <0xd100 &smmu 0x0344 0x2>,
+		    <0xd108 &smmu 0x0346 0x2>,
+		    <0xd200 &smmu 0x0348 0x2>,
+		    <0xd208 &smmu 0x034a 0x2>,
+		    <0xd300 &smmu 0x034c 0x2>,
+		    <0xd308 &smmu 0x034e 0x2>,
+		    <0xd400 &smmu 0x0350 0x2>,
+		    <0xd408 &smmu 0x0352 0x2>,
+		    <0xd500 &smmu 0x0354 0x2>,
+		    <0xd508 &smmu 0x0356 0x2>,
+		    <0xd600 &smmu 0x0358 0x2>,
+		    <0xd608 &smmu 0x035a 0x2>,
+		    <0xd700 &smmu 0x035c 0x2>,
+		    <0xd708 &smmu 0x035e 0x2>,
+		    <0xd800 &smmu 0x0360 0x2>,
+		    <0xd808 &smmu 0x0362 0x2>,
+		    <0xd900 &smmu 0x0364 0x2>,
+		    <0xd908 &smmu 0x0366 0x2>,
+		    <0xda00 &smmu 0x0368 0x2>,
+		    <0xda08 &smmu 0x036a 0x2>,
+		    <0xdb00 &smmu 0x036c 0x2>,
+		    <0xdb08 &smmu 0x036e 0x2>,
+		    <0xdc00 &smmu 0x0370 0x2>,
+		    <0xdc08 &smmu 0x0372 0x2>,
+		    <0xdd00 &smmu 0x0374 0x2>,
+		    <0xdd08 &smmu 0x0376 0x2>,
+		    <0xde00 &smmu 0x0378 0x2>,
+		    <0xde08 &smmu 0x037a 0x2>,
+		    <0xdf00 &smmu 0x037c 0x2>,
+		    <0xdf08 &smmu 0x037e 0x2>,
+		    <0xe000 &smmu 0x0380 0x2>,
+		    <0xe008 &smmu 0x0382 0x2>,
+		    <0xe100 &smmu 0x0384 0x2>,
+		    <0xe108 &smmu 0x0386 0x2>,
+		    <0xe200 &smmu 0x0388 0x2>,
+		    <0xe208 &smmu 0x038a 0x2>,
+		    <0xe300 &smmu 0x038c 0x2>,
+		    <0xe308 &smmu 0x038e 0x2>,
+		    <0xe400 &smmu 0x0390 0x2>,
+		    <0xe408 &smmu 0x0392 0x2>,
+		    <0xe500 &smmu 0x0394 0x2>,
+		    <0xe508 &smmu 0x0396 0x2>,
+		    <0xe600 &smmu 0x0398 0x2>,
+		    <0xe608 &smmu 0x039a 0x2>,
+		    <0xe700 &smmu 0x039c 0x2>,
+		    <0xe708 &smmu 0x039e 0x2>,
+		    <0xe800 &smmu 0x03a0 0x2>,
+		    <0xe808 &smmu 0x03a2 0x2>,
+		    <0xe900 &smmu 0x03a4 0x2>,
+		    <0xe908 &smmu 0x03a6 0x2>,
+		    <0xea00 &smmu 0x03a8 0x2>,
+		    <0xea08 &smmu 0x03aa 0x2>,
+		    <0xeb00 &smmu 0x03ac 0x2>,
+		    <0xeb08 &smmu 0x03ae 0x2>,
+		    <0xec00 &smmu 0x03b0 0x2>,
+		    <0xec08 &smmu 0x03b2 0x2>,
+		    <0xed00 &smmu 0x03b4 0x2>,
+		    <0xed08 &smmu 0x03b6 0x2>,
+		    <0xee00 &smmu 0x03b8 0x2>,
+		    <0xee08 &smmu 0x03ba 0x2>,
+		    <0xef00 &smmu 0x03bc 0x2>,
+		    <0xef08 &smmu 0x03be 0x2>,
+		    <0xf000 &smmu 0x03c0 0x2>,
+		    <0xf008 &smmu 0x03c2 0x2>,
+		    <0xf100 &smmu 0x03c4 0x2>,
+		    <0xf108 &smmu 0x03c6 0x2>,
+		    <0xf200 &smmu 0x03c8 0x2>,
+		    <0xf208 &smmu 0x03ca 0x2>,
+		    <0xf300 &smmu 0x03cc 0x2>,
+		    <0xf308 &smmu 0x03ce 0x2>,
+		    <0xf400 &smmu 0x03d0 0x2>,
+		    <0xf408 &smmu 0x03d2 0x2>,
+		    <0xf500 &smmu 0x03d4 0x2>,
+		    <0xf508 &smmu 0x03d6 0x2>,
+		    <0xf600 &smmu 0x03d8 0x2>,
+		    <0xf608 &smmu 0x03da 0x2>,
+		    <0xf700 &smmu 0x03dc 0x2>,
+		    <0xf708 &smmu 0x03de 0x2>,
+		    <0xf800 &smmu 0x03e0 0x2>,
+		    <0xf808 &smmu 0x03e2 0x2>,
+		    <0xf900 &smmu 0x03e4 0x2>,
+		    <0xf908 &smmu 0x03e6 0x2>,
+		    <0xfa00 &smmu 0x03e8 0x2>,
+		    <0xfa08 &smmu 0x03ea 0x2>,
+		    <0xfb00 &smmu 0x03ec 0x2>,
+		    <0xfb08 &smmu 0x03ee 0x2>,
+		    <0xfc00 &smmu 0x03f0 0x2>,
+		    <0xfc08 &smmu 0x03f2 0x2>,
+		    <0xfd00 &smmu 0x03f4 0x2>,
+		    <0xfd08 &smmu 0x03f6 0x2>,
+		    <0xfe00 &smmu 0x03f8 0x2>,
+		    <0xfe08 &smmu 0x03fa 0x2>,
+		    <0xff00 &smmu 0x03fc 0x2>,
+		    <0xff08 &smmu 0x03fe 0x2>;
+#endif
+};
+
+&pcie1 {
+	msi-map = <0x0000 &gic_its 0x0400 0x2>,
+		  <0x0008 &gic_its 0x0402 0x2>,
+		  <0x0100 &gic_its 0x0404 0x2>,
+		  <0x0108 &gic_its 0x0406 0x2>,
+		  <0x0200 &gic_its 0x0408 0x2>,
+		  <0x0208 &gic_its 0x040a 0x2>,
+		  <0x0300 &gic_its 0x040c 0x2>,
+		  <0x0308 &gic_its 0x040e 0x2>,
+		  <0x0400 &gic_its 0x0410 0x2>,
+		  <0x0408 &gic_its 0x0412 0x2>,
+		  <0x0500 &gic_its 0x0414 0x2>,
+		  <0x0508 &gic_its 0x0416 0x2>,
+		  <0x0600 &gic_its 0x0418 0x2>,
+		  <0x0608 &gic_its 0x041a 0x2>,
+		  <0x0700 &gic_its 0x041c 0x2>,
+		  <0x0708 &gic_its 0x041e 0x2>,
+		  <0x0800 &gic_its 0x0420 0x2>,
+		  <0x0808 &gic_its 0x0422 0x2>,
+		  <0x0900 &gic_its 0x0424 0x2>,
+		  <0x0908 &gic_its 0x0426 0x2>,
+		  <0x0a00 &gic_its 0x0428 0x2>,
+		  <0x0a08 &gic_its 0x042a 0x2>,
+		  <0x0b00 &gic_its 0x042c 0x2>,
+		  <0x0b08 &gic_its 0x042e 0x2>,
+		  <0x0c00 &gic_its 0x0430 0x2>,
+		  <0x0c08 &gic_its 0x0432 0x2>,
+		  <0x0d00 &gic_its 0x0434 0x2>,
+		  <0x0d08 &gic_its 0x0436 0x2>,
+		  <0x0e00 &gic_its 0x0438 0x2>,
+		  <0x0e08 &gic_its 0x043a 0x2>,
+		  <0x0f00 &gic_its 0x043c 0x2>,
+		  <0x0f08 &gic_its 0x043e 0x2>,
+		  <0x1000 &gic_its 0x0440 0x2>,
+		  <0x1008 &gic_its 0x0442 0x2>,
+		  <0x1100 &gic_its 0x0444 0x2>,
+		  <0x1108 &gic_its 0x0446 0x2>,
+		  <0x1200 &gic_its 0x0448 0x2>,
+		  <0x1208 &gic_its 0x044a 0x2>,
+		  <0x1300 &gic_its 0x044c 0x2>,
+		  <0x1308 &gic_its 0x044e 0x2>,
+		  <0x1400 &gic_its 0x0450 0x2>,
+		  <0x1408 &gic_its 0x0452 0x2>,
+		  <0x1500 &gic_its 0x0454 0x2>,
+		  <0x1508 &gic_its 0x0456 0x2>,
+		  <0x1600 &gic_its 0x0458 0x2>,
+		  <0x1608 &gic_its 0x045a 0x2>,
+		  <0x1700 &gic_its 0x045c 0x2>,
+		  <0x1708 &gic_its 0x045e 0x2>,
+		  <0x1800 &gic_its 0x0460 0x2>,
+		  <0x1808 &gic_its 0x0462 0x2>,
+		  <0x1900 &gic_its 0x0464 0x2>,
+		  <0x1908 &gic_its 0x0466 0x2>,
+		  <0x1a00 &gic_its 0x0468 0x2>,
+		  <0x1a08 &gic_its 0x046a 0x2>,
+		  <0x1b00 &gic_its 0x046c 0x2>,
+		  <0x1b08 &gic_its 0x046e 0x2>,
+		  <0x1c00 &gic_its 0x0470 0x2>,
+		  <0x1c08 &gic_its 0x0472 0x2>,
+		  <0x1d00 &gic_its 0x0474 0x2>,
+		  <0x1d08 &gic_its 0x0476 0x2>,
+		  <0x1e00 &gic_its 0x0478 0x2>,
+		  <0x1e08 &gic_its 0x047a 0x2>,
+		  <0x1f00 &gic_its 0x047c 0x2>,
+		  <0x1f08 &gic_its 0x047e 0x2>,
+		  <0x2000 &gic_its 0x0480 0x2>,
+		  <0x2008 &gic_its 0x0482 0x2>,
+		  <0x2100 &gic_its 0x0484 0x2>,
+		  <0x2108 &gic_its 0x0486 0x2>,
+		  <0x2200 &gic_its 0x0488 0x2>,
+		  <0x2208 &gic_its 0x048a 0x2>,
+		  <0x2300 &gic_its 0x048c 0x2>,
+		  <0x2308 &gic_its 0x048e 0x2>,
+		  <0x2400 &gic_its 0x0490 0x2>,
+		  <0x2408 &gic_its 0x0492 0x2>,
+		  <0x2500 &gic_its 0x0494 0x2>,
+		  <0x2508 &gic_its 0x0496 0x2>,
+		  <0x2600 &gic_its 0x0498 0x2>,
+		  <0x2608 &gic_its 0x049a 0x2>,
+		  <0x2700 &gic_its 0x049c 0x2>,
+		  <0x2708 &gic_its 0x049e 0x2>,
+		  <0x2800 &gic_its 0x04a0 0x2>,
+		  <0x2808 &gic_its 0x04a2 0x2>,
+		  <0x2900 &gic_its 0x04a4 0x2>,
+		  <0x2908 &gic_its 0x04a6 0x2>,
+		  <0x2a00 &gic_its 0x04a8 0x2>,
+		  <0x2a08 &gic_its 0x04aa 0x2>,
+		  <0x2b00 &gic_its 0x04ac 0x2>,
+		  <0x2b08 &gic_its 0x04ae 0x2>,
+		  <0x2c00 &gic_its 0x04b0 0x2>,
+		  <0x2c08 &gic_its 0x04b2 0x2>,
+		  <0x2d00 &gic_its 0x04b4 0x2>,
+		  <0x2d08 &gic_its 0x04b6 0x2>,
+		  <0x2e00 &gic_its 0x04b8 0x2>,
+		  <0x2e08 &gic_its 0x04ba 0x2>,
+		  <0x2f00 &gic_its 0x04bc 0x2>,
+		  <0x2f08 &gic_its 0x04be 0x2>,
+		  <0x3000 &gic_its 0x04c0 0x2>,
+		  <0x3008 &gic_its 0x04c2 0x2>,
+		  <0x3100 &gic_its 0x04c4 0x2>,
+		  <0x3108 &gic_its 0x04c6 0x2>,
+		  <0x3200 &gic_its 0x04c8 0x2>,
+		  <0x3208 &gic_its 0x04ca 0x2>,
+		  <0x3300 &gic_its 0x04cc 0x2>,
+		  <0x3308 &gic_its 0x04ce 0x2>,
+		  <0x3400 &gic_its 0x04d0 0x2>,
+		  <0x3408 &gic_its 0x04d2 0x2>,
+		  <0x3500 &gic_its 0x04d4 0x2>,
+		  <0x3508 &gic_its 0x04d6 0x2>,
+		  <0x3600 &gic_its 0x04d8 0x2>,
+		  <0x3608 &gic_its 0x04da 0x2>,
+		  <0x3700 &gic_its 0x04dc 0x2>,
+		  <0x3708 &gic_its 0x04de 0x2>,
+		  <0x3800 &gic_its 0x04e0 0x2>,
+		  <0x3808 &gic_its 0x04e2 0x2>,
+		  <0x3900 &gic_its 0x04e4 0x2>,
+		  <0x3908 &gic_its 0x04e6 0x2>,
+		  <0x3a00 &gic_its 0x04e8 0x2>,
+		  <0x3a08 &gic_its 0x04ea 0x2>,
+		  <0x3b00 &gic_its 0x04ec 0x2>,
+		  <0x3b08 &gic_its 0x04ee 0x2>,
+		  <0x3c00 &gic_its 0x04f0 0x2>,
+		  <0x3c08 &gic_its 0x04f2 0x2>,
+		  <0x3d00 &gic_its 0x04f4 0x2>,
+		  <0x3d08 &gic_its 0x04f6 0x2>,
+		  <0x3e00 &gic_its 0x04f8 0x2>,
+		  <0x3e08 &gic_its 0x04fa 0x2>,
+		  <0x3f00 &gic_its 0x04fc 0x2>,
+		  <0x3f08 &gic_its 0x04fe 0x2>,
+		  <0x4000 &gic_its 0x0500 0x2>,
+		  <0x4008 &gic_its 0x0502 0x2>,
+		  <0x4100 &gic_its 0x0504 0x2>,
+		  <0x4108 &gic_its 0x0506 0x2>,
+		  <0x4200 &gic_its 0x0508 0x2>,
+		  <0x4208 &gic_its 0x050a 0x2>,
+		  <0x4300 &gic_its 0x050c 0x2>,
+		  <0x4308 &gic_its 0x050e 0x2>,
+		  <0x4400 &gic_its 0x0510 0x2>,
+		  <0x4408 &gic_its 0x0512 0x2>,
+		  <0x4500 &gic_its 0x0514 0x2>,
+		  <0x4508 &gic_its 0x0516 0x2>,
+		  <0x4600 &gic_its 0x0518 0x2>,
+		  <0x4608 &gic_its 0x051a 0x2>,
+		  <0x4700 &gic_its 0x051c 0x2>,
+		  <0x4708 &gic_its 0x051e 0x2>,
+		  <0x4800 &gic_its 0x0520 0x2>,
+		  <0x4808 &gic_its 0x0522 0x2>,
+		  <0x4900 &gic_its 0x0524 0x2>,
+		  <0x4908 &gic_its 0x0526 0x2>,
+		  <0x4a00 &gic_its 0x0528 0x2>,
+		  <0x4a08 &gic_its 0x052a 0x2>,
+		  <0x4b00 &gic_its 0x052c 0x2>,
+		  <0x4b08 &gic_its 0x052e 0x2>,
+		  <0x4c00 &gic_its 0x0530 0x2>,
+		  <0x4c08 &gic_its 0x0532 0x2>,
+		  <0x4d00 &gic_its 0x0534 0x2>,
+		  <0x4d08 &gic_its 0x0536 0x2>,
+		  <0x4e00 &gic_its 0x0538 0x2>,
+		  <0x4e08 &gic_its 0x053a 0x2>,
+		  <0x4f00 &gic_its 0x053c 0x2>,
+		  <0x4f08 &gic_its 0x053e 0x2>,
+		  <0x5000 &gic_its 0x0540 0x2>,
+		  <0x5008 &gic_its 0x0542 0x2>,
+		  <0x5100 &gic_its 0x0544 0x2>,
+		  <0x5108 &gic_its 0x0546 0x2>,
+		  <0x5200 &gic_its 0x0548 0x2>,
+		  <0x5208 &gic_its 0x054a 0x2>,
+		  <0x5300 &gic_its 0x054c 0x2>,
+		  <0x5308 &gic_its 0x054e 0x2>,
+		  <0x5400 &gic_its 0x0550 0x2>,
+		  <0x5408 &gic_its 0x0552 0x2>,
+		  <0x5500 &gic_its 0x0554 0x2>,
+		  <0x5508 &gic_its 0x0556 0x2>,
+		  <0x5600 &gic_its 0x0558 0x2>,
+		  <0x5608 &gic_its 0x055a 0x2>,
+		  <0x5700 &gic_its 0x055c 0x2>,
+		  <0x5708 &gic_its 0x055e 0x2>,
+		  <0x5800 &gic_its 0x0560 0x2>,
+		  <0x5808 &gic_its 0x0562 0x2>,
+		  <0x5900 &gic_its 0x0564 0x2>,
+		  <0x5908 &gic_its 0x0566 0x2>,
+		  <0x5a00 &gic_its 0x0568 0x2>,
+		  <0x5a08 &gic_its 0x056a 0x2>,
+		  <0x5b00 &gic_its 0x056c 0x2>,
+		  <0x5b08 &gic_its 0x056e 0x2>,
+		  <0x5c00 &gic_its 0x0570 0x2>,
+		  <0x5c08 &gic_its 0x0572 0x2>,
+		  <0x5d00 &gic_its 0x0574 0x2>,
+		  <0x5d08 &gic_its 0x0576 0x2>,
+		  <0x5e00 &gic_its 0x0578 0x2>,
+		  <0x5e08 &gic_its 0x057a 0x2>,
+		  <0x5f00 &gic_its 0x057c 0x2>,
+		  <0x5f08 &gic_its 0x057e 0x2>,
+		  <0x6000 &gic_its 0x0580 0x2>,
+		  <0x6008 &gic_its 0x0582 0x2>,
+		  <0x6100 &gic_its 0x0584 0x2>,
+		  <0x6108 &gic_its 0x0586 0x2>,
+		  <0x6200 &gic_its 0x0588 0x2>,
+		  <0x6208 &gic_its 0x058a 0x2>,
+		  <0x6300 &gic_its 0x058c 0x2>,
+		  <0x6308 &gic_its 0x058e 0x2>,
+		  <0x6400 &gic_its 0x0590 0x2>,
+		  <0x6408 &gic_its 0x0592 0x2>,
+		  <0x6500 &gic_its 0x0594 0x2>,
+		  <0x6508 &gic_its 0x0596 0x2>,
+		  <0x6600 &gic_its 0x0598 0x2>,
+		  <0x6608 &gic_its 0x059a 0x2>,
+		  <0x6700 &gic_its 0x059c 0x2>,
+		  <0x6708 &gic_its 0x059e 0x2>,
+		  <0x6800 &gic_its 0x05a0 0x2>,
+		  <0x6808 &gic_its 0x05a2 0x2>,
+		  <0x6900 &gic_its 0x05a4 0x2>,
+		  <0x6908 &gic_its 0x05a6 0x2>,
+		  <0x6a00 &gic_its 0x05a8 0x2>,
+		  <0x6a08 &gic_its 0x05aa 0x2>,
+		  <0x6b00 &gic_its 0x05ac 0x2>,
+		  <0x6b08 &gic_its 0x05ae 0x2>,
+		  <0x6c00 &gic_its 0x05b0 0x2>,
+		  <0x6c08 &gic_its 0x05b2 0x2>,
+		  <0x6d00 &gic_its 0x05b4 0x2>,
+		  <0x6d08 &gic_its 0x05b6 0x2>,
+		  <0x6e00 &gic_its 0x05b8 0x2>,
+		  <0x6e08 &gic_its 0x05ba 0x2>,
+		  <0x6f00 &gic_its 0x05bc 0x2>,
+		  <0x6f08 &gic_its 0x05be 0x2>,
+		  <0x7000 &gic_its 0x05c0 0x2>,
+		  <0x7008 &gic_its 0x05c2 0x2>,
+		  <0x7100 &gic_its 0x05c4 0x2>,
+		  <0x7108 &gic_its 0x05c6 0x2>,
+		  <0x7200 &gic_its 0x05c8 0x2>,
+		  <0x7208 &gic_its 0x05ca 0x2>,
+		  <0x7300 &gic_its 0x05cc 0x2>,
+		  <0x7308 &gic_its 0x05ce 0x2>,
+		  <0x7400 &gic_its 0x05d0 0x2>,
+		  <0x7408 &gic_its 0x05d2 0x2>,
+		  <0x7500 &gic_its 0x05d4 0x2>,
+		  <0x7508 &gic_its 0x05d6 0x2>,
+		  <0x7600 &gic_its 0x05d8 0x2>,
+		  <0x7608 &gic_its 0x05da 0x2>,
+		  <0x7700 &gic_its 0x05dc 0x2>,
+		  <0x7708 &gic_its 0x05de 0x2>,
+		  <0x7800 &gic_its 0x05e0 0x2>,
+		  <0x7808 &gic_its 0x05e2 0x2>,
+		  <0x7900 &gic_its 0x05e4 0x2>,
+		  <0x7908 &gic_its 0x05e6 0x2>,
+		  <0x7a00 &gic_its 0x05e8 0x2>,
+		  <0x7a08 &gic_its 0x05ea 0x2>,
+		  <0x7b00 &gic_its 0x05ec 0x2>,
+		  <0x7b08 &gic_its 0x05ee 0x2>,
+		  <0x7c00 &gic_its 0x05f0 0x2>,
+		  <0x7c08 &gic_its 0x05f2 0x2>,
+		  <0x7d00 &gic_its 0x05f4 0x2>,
+		  <0x7d08 &gic_its 0x05f6 0x2>,
+		  <0x7e00 &gic_its 0x05f8 0x2>,
+		  <0x7e08 &gic_its 0x05fa 0x2>,
+		  <0x7f00 &gic_its 0x05fc 0x2>,
+		  <0x7f08 &gic_its 0x05fe 0x2>,
+		  <0x8000 &gic_its 0x0600 0x2>,
+		  <0x8008 &gic_its 0x0602 0x2>,
+		  <0x8100 &gic_its 0x0604 0x2>,
+		  <0x8108 &gic_its 0x0606 0x2>,
+		  <0x8200 &gic_its 0x0608 0x2>,
+		  <0x8208 &gic_its 0x060a 0x2>,
+		  <0x8300 &gic_its 0x060c 0x2>,
+		  <0x8308 &gic_its 0x060e 0x2>,
+		  <0x8400 &gic_its 0x0610 0x2>,
+		  <0x8408 &gic_its 0x0612 0x2>,
+		  <0x8500 &gic_its 0x0614 0x2>,
+		  <0x8508 &gic_its 0x0616 0x2>,
+		  <0x8600 &gic_its 0x0618 0x2>,
+		  <0x8608 &gic_its 0x061a 0x2>,
+		  <0x8700 &gic_its 0x061c 0x2>,
+		  <0x8708 &gic_its 0x061e 0x2>,
+		  <0x8800 &gic_its 0x0620 0x2>,
+		  <0x8808 &gic_its 0x0622 0x2>,
+		  <0x8900 &gic_its 0x0624 0x2>,
+		  <0x8908 &gic_its 0x0626 0x2>,
+		  <0x8a00 &gic_its 0x0628 0x2>,
+		  <0x8a08 &gic_its 0x062a 0x2>,
+		  <0x8b00 &gic_its 0x062c 0x2>,
+		  <0x8b08 &gic_its 0x062e 0x2>,
+		  <0x8c00 &gic_its 0x0630 0x2>,
+		  <0x8c08 &gic_its 0x0632 0x2>,
+		  <0x8d00 &gic_its 0x0634 0x2>,
+		  <0x8d08 &gic_its 0x0636 0x2>,
+		  <0x8e00 &gic_its 0x0638 0x2>,
+		  <0x8e08 &gic_its 0x063a 0x2>,
+		  <0x8f00 &gic_its 0x063c 0x2>,
+		  <0x8f08 &gic_its 0x063e 0x2>,
+		  <0x9000 &gic_its 0x0640 0x2>,
+		  <0x9008 &gic_its 0x0642 0x2>,
+		  <0x9100 &gic_its 0x0644 0x2>,
+		  <0x9108 &gic_its 0x0646 0x2>,
+		  <0x9200 &gic_its 0x0648 0x2>,
+		  <0x9208 &gic_its 0x064a 0x2>,
+		  <0x9300 &gic_its 0x064c 0x2>,
+		  <0x9308 &gic_its 0x064e 0x2>,
+		  <0x9400 &gic_its 0x0650 0x2>,
+		  <0x9408 &gic_its 0x0652 0x2>,
+		  <0x9500 &gic_its 0x0654 0x2>,
+		  <0x9508 &gic_its 0x0656 0x2>,
+		  <0x9600 &gic_its 0x0658 0x2>,
+		  <0x9608 &gic_its 0x065a 0x2>,
+		  <0x9700 &gic_its 0x065c 0x2>,
+		  <0x9708 &gic_its 0x065e 0x2>,
+		  <0x9800 &gic_its 0x0660 0x2>,
+		  <0x9808 &gic_its 0x0662 0x2>,
+		  <0x9900 &gic_its 0x0664 0x2>,
+		  <0x9908 &gic_its 0x0666 0x2>,
+		  <0x9a00 &gic_its 0x0668 0x2>,
+		  <0x9a08 &gic_its 0x066a 0x2>,
+		  <0x9b00 &gic_its 0x066c 0x2>,
+		  <0x9b08 &gic_its 0x066e 0x2>,
+		  <0x9c00 &gic_its 0x0670 0x2>,
+		  <0x9c08 &gic_its 0x0672 0x2>,
+		  <0x9d00 &gic_its 0x0674 0x2>,
+		  <0x9d08 &gic_its 0x0676 0x2>,
+		  <0x9e00 &gic_its 0x0678 0x2>,
+		  <0x9e08 &gic_its 0x067a 0x2>,
+		  <0x9f00 &gic_its 0x067c 0x2>,
+		  <0x9f08 &gic_its 0x067e 0x2>,
+		  <0xa000 &gic_its 0x0680 0x2>,
+		  <0xa008 &gic_its 0x0682 0x2>,
+		  <0xa100 &gic_its 0x0684 0x2>,
+		  <0xa108 &gic_its 0x0686 0x2>,
+		  <0xa200 &gic_its 0x0688 0x2>,
+		  <0xa208 &gic_its 0x068a 0x2>,
+		  <0xa300 &gic_its 0x068c 0x2>,
+		  <0xa308 &gic_its 0x068e 0x2>,
+		  <0xa400 &gic_its 0x0690 0x2>,
+		  <0xa408 &gic_its 0x0692 0x2>,
+		  <0xa500 &gic_its 0x0694 0x2>,
+		  <0xa508 &gic_its 0x0696 0x2>,
+		  <0xa600 &gic_its 0x0698 0x2>,
+		  <0xa608 &gic_its 0x069a 0x2>,
+		  <0xa700 &gic_its 0x069c 0x2>,
+		  <0xa708 &gic_its 0x069e 0x2>,
+		  <0xa800 &gic_its 0x06a0 0x2>,
+		  <0xa808 &gic_its 0x06a2 0x2>,
+		  <0xa900 &gic_its 0x06a4 0x2>,
+		  <0xa908 &gic_its 0x06a6 0x2>,
+		  <0xaa00 &gic_its 0x06a8 0x2>,
+		  <0xaa08 &gic_its 0x06aa 0x2>,
+		  <0xab00 &gic_its 0x06ac 0x2>,
+		  <0xab08 &gic_its 0x06ae 0x2>,
+		  <0xac00 &gic_its 0x06b0 0x2>,
+		  <0xac08 &gic_its 0x06b2 0x2>,
+		  <0xad00 &gic_its 0x06b4 0x2>,
+		  <0xad08 &gic_its 0x06b6 0x2>,
+		  <0xae00 &gic_its 0x06b8 0x2>,
+		  <0xae08 &gic_its 0x06ba 0x2>,
+		  <0xaf00 &gic_its 0x06bc 0x2>,
+		  <0xaf08 &gic_its 0x06be 0x2>,
+		  <0xb000 &gic_its 0x06c0 0x2>,
+		  <0xb008 &gic_its 0x06c2 0x2>,
+		  <0xb100 &gic_its 0x06c4 0x2>,
+		  <0xb108 &gic_its 0x06c6 0x2>,
+		  <0xb200 &gic_its 0x06c8 0x2>,
+		  <0xb208 &gic_its 0x06ca 0x2>,
+		  <0xb300 &gic_its 0x06cc 0x2>,
+		  <0xb308 &gic_its 0x06ce 0x2>,
+		  <0xb400 &gic_its 0x06d0 0x2>,
+		  <0xb408 &gic_its 0x06d2 0x2>,
+		  <0xb500 &gic_its 0x06d4 0x2>,
+		  <0xb508 &gic_its 0x06d6 0x2>,
+		  <0xb600 &gic_its 0x06d8 0x2>,
+		  <0xb608 &gic_its 0x06da 0x2>,
+		  <0xb700 &gic_its 0x06dc 0x2>,
+		  <0xb708 &gic_its 0x06de 0x2>,
+		  <0xb800 &gic_its 0x06e0 0x2>,
+		  <0xb808 &gic_its 0x06e2 0x2>,
+		  <0xb900 &gic_its 0x06e4 0x2>,
+		  <0xb908 &gic_its 0x06e6 0x2>,
+		  <0xba00 &gic_its 0x06e8 0x2>,
+		  <0xba08 &gic_its 0x06ea 0x2>,
+		  <0xbb00 &gic_its 0x06ec 0x2>,
+		  <0xbb08 &gic_its 0x06ee 0x2>,
+		  <0xbc00 &gic_its 0x06f0 0x2>,
+		  <0xbc08 &gic_its 0x06f2 0x2>,
+		  <0xbd00 &gic_its 0x06f4 0x2>,
+		  <0xbd08 &gic_its 0x06f6 0x2>,
+		  <0xbe00 &gic_its 0x06f8 0x2>,
+		  <0xbe08 &gic_its 0x06fa 0x2>,
+		  <0xbf00 &gic_its 0x06fc 0x2>,
+		  <0xbf08 &gic_its 0x06fe 0x2>,
+		  <0xc000 &gic_its 0x0700 0x2>,
+		  <0xc008 &gic_its 0x0702 0x2>,
+		  <0xc100 &gic_its 0x0704 0x2>,
+		  <0xc108 &gic_its 0x0706 0x2>,
+		  <0xc200 &gic_its 0x0708 0x2>,
+		  <0xc208 &gic_its 0x070a 0x2>,
+		  <0xc300 &gic_its 0x070c 0x2>,
+		  <0xc308 &gic_its 0x070e 0x2>,
+		  <0xc400 &gic_its 0x0710 0x2>,
+		  <0xc408 &gic_its 0x0712 0x2>,
+		  <0xc500 &gic_its 0x0714 0x2>,
+		  <0xc508 &gic_its 0x0716 0x2>,
+		  <0xc600 &gic_its 0x0718 0x2>,
+		  <0xc608 &gic_its 0x071a 0x2>,
+		  <0xc700 &gic_its 0x071c 0x2>,
+		  <0xc708 &gic_its 0x071e 0x2>,
+		  <0xc800 &gic_its 0x0720 0x2>,
+		  <0xc808 &gic_its 0x0722 0x2>,
+		  <0xc900 &gic_its 0x0724 0x2>,
+		  <0xc908 &gic_its 0x0726 0x2>,
+		  <0xca00 &gic_its 0x0728 0x2>,
+		  <0xca08 &gic_its 0x072a 0x2>,
+		  <0xcb00 &gic_its 0x072c 0x2>,
+		  <0xcb08 &gic_its 0x072e 0x2>,
+		  <0xcc00 &gic_its 0x0730 0x2>,
+		  <0xcc08 &gic_its 0x0732 0x2>,
+		  <0xcd00 &gic_its 0x0734 0x2>,
+		  <0xcd08 &gic_its 0x0736 0x2>,
+		  <0xce00 &gic_its 0x0738 0x2>,
+		  <0xce08 &gic_its 0x073a 0x2>,
+		  <0xcf00 &gic_its 0x073c 0x2>,
+		  <0xcf08 &gic_its 0x073e 0x2>,
+		  <0xd000 &gic_its 0x0740 0x2>,
+		  <0xd008 &gic_its 0x0742 0x2>,
+		  <0xd100 &gic_its 0x0744 0x2>,
+		  <0xd108 &gic_its 0x0746 0x2>,
+		  <0xd200 &gic_its 0x0748 0x2>,
+		  <0xd208 &gic_its 0x074a 0x2>,
+		  <0xd300 &gic_its 0x074c 0x2>,
+		  <0xd308 &gic_its 0x074e 0x2>,
+		  <0xd400 &gic_its 0x0750 0x2>,
+		  <0xd408 &gic_its 0x0752 0x2>,
+		  <0xd500 &gic_its 0x0754 0x2>,
+		  <0xd508 &gic_its 0x0756 0x2>,
+		  <0xd600 &gic_its 0x0758 0x2>,
+		  <0xd608 &gic_its 0x075a 0x2>,
+		  <0xd700 &gic_its 0x075c 0x2>,
+		  <0xd708 &gic_its 0x075e 0x2>,
+		  <0xd800 &gic_its 0x0760 0x2>,
+		  <0xd808 &gic_its 0x0762 0x2>,
+		  <0xd900 &gic_its 0x0764 0x2>,
+		  <0xd908 &gic_its 0x0766 0x2>,
+		  <0xda00 &gic_its 0x0768 0x2>,
+		  <0xda08 &gic_its 0x076a 0x2>,
+		  <0xdb00 &gic_its 0x076c 0x2>,
+		  <0xdb08 &gic_its 0x076e 0x2>,
+		  <0xdc00 &gic_its 0x0770 0x2>,
+		  <0xdc08 &gic_its 0x0772 0x2>,
+		  <0xdd00 &gic_its 0x0774 0x2>,
+		  <0xdd08 &gic_its 0x0776 0x2>,
+		  <0xde00 &gic_its 0x0778 0x2>,
+		  <0xde08 &gic_its 0x077a 0x2>,
+		  <0xdf00 &gic_its 0x077c 0x2>,
+		  <0xdf08 &gic_its 0x077e 0x2>,
+		  <0xe000 &gic_its 0x0780 0x2>,
+		  <0xe008 &gic_its 0x0782 0x2>,
+		  <0xe100 &gic_its 0x0784 0x2>,
+		  <0xe108 &gic_its 0x0786 0x2>,
+		  <0xe200 &gic_its 0x0788 0x2>,
+		  <0xe208 &gic_its 0x078a 0x2>,
+		  <0xe300 &gic_its 0x078c 0x2>,
+		  <0xe308 &gic_its 0x078e 0x2>,
+		  <0xe400 &gic_its 0x0790 0x2>,
+		  <0xe408 &gic_its 0x0792 0x2>,
+		  <0xe500 &gic_its 0x0794 0x2>,
+		  <0xe508 &gic_its 0x0796 0x2>,
+		  <0xe600 &gic_its 0x0798 0x2>,
+		  <0xe608 &gic_its 0x079a 0x2>,
+		  <0xe700 &gic_its 0x079c 0x2>,
+		  <0xe708 &gic_its 0x079e 0x2>,
+		  <0xe800 &gic_its 0x07a0 0x2>,
+		  <0xe808 &gic_its 0x07a2 0x2>,
+		  <0xe900 &gic_its 0x07a4 0x2>,
+		  <0xe908 &gic_its 0x07a6 0x2>,
+		  <0xea00 &gic_its 0x07a8 0x2>,
+		  <0xea08 &gic_its 0x07aa 0x2>,
+		  <0xeb00 &gic_its 0x07ac 0x2>,
+		  <0xeb08 &gic_its 0x07ae 0x2>,
+		  <0xec00 &gic_its 0x07b0 0x2>,
+		  <0xec08 &gic_its 0x07b2 0x2>,
+		  <0xed00 &gic_its 0x07b4 0x2>,
+		  <0xed08 &gic_its 0x07b6 0x2>,
+		  <0xee00 &gic_its 0x07b8 0x2>,
+		  <0xee08 &gic_its 0x07ba 0x2>,
+		  <0xef00 &gic_its 0x07bc 0x2>,
+		  <0xef08 &gic_its 0x07be 0x2>,
+		  <0xf000 &gic_its 0x07c0 0x2>,
+		  <0xf008 &gic_its 0x07c2 0x2>,
+		  <0xf100 &gic_its 0x07c4 0x2>,
+		  <0xf108 &gic_its 0x07c6 0x2>,
+		  <0xf200 &gic_its 0x07c8 0x2>,
+		  <0xf208 &gic_its 0x07ca 0x2>,
+		  <0xf300 &gic_its 0x07cc 0x2>,
+		  <0xf308 &gic_its 0x07ce 0x2>,
+		  <0xf400 &gic_its 0x07d0 0x2>,
+		  <0xf408 &gic_its 0x07d2 0x2>,
+		  <0xf500 &gic_its 0x07d4 0x2>,
+		  <0xf508 &gic_its 0x07d6 0x2>,
+		  <0xf600 &gic_its 0x07d8 0x2>,
+		  <0xf608 &gic_its 0x07da 0x2>,
+		  <0xf700 &gic_its 0x07dc 0x2>,
+		  <0xf708 &gic_its 0x07de 0x2>,
+		  <0xf800 &gic_its 0x07e0 0x2>,
+		  <0xf808 &gic_its 0x07e2 0x2>,
+		  <0xf900 &gic_its 0x07e4 0x2>,
+		  <0xf908 &gic_its 0x07e6 0x2>,
+		  <0xfa00 &gic_its 0x07e8 0x2>,
+		  <0xfa08 &gic_its 0x07ea 0x2>,
+		  <0xfb00 &gic_its 0x07ec 0x2>,
+		  <0xfb08 &gic_its 0x07ee 0x2>,
+		  <0xfc00 &gic_its 0x07f0 0x2>,
+		  <0xfc08 &gic_its 0x07f2 0x2>,
+		  <0xfd00 &gic_its 0x07f4 0x2>,
+		  <0xfd08 &gic_its 0x07f6 0x2>,
+		  <0xfe00 &gic_its 0x07f8 0x2>,
+		  <0xfe08 &gic_its 0x07fa 0x2>,
+		  <0xff00 &gic_its 0x07fc 0x2>,
+		  <0xff08 &gic_its 0x07fe 0x2>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x0400 0x2>,
+		    <0x0008 &smmu 0x0402 0x2>,
+		    <0x0100 &smmu 0x0404 0x2>,
+		    <0x0108 &smmu 0x0406 0x2>,
+		    <0x0200 &smmu 0x0408 0x2>,
+		    <0x0208 &smmu 0x040a 0x2>,
+		    <0x0300 &smmu 0x040c 0x2>,
+		    <0x0308 &smmu 0x040e 0x2>,
+		    <0x0400 &smmu 0x0410 0x2>,
+		    <0x0408 &smmu 0x0412 0x2>,
+		    <0x0500 &smmu 0x0414 0x2>,
+		    <0x0508 &smmu 0x0416 0x2>,
+		    <0x0600 &smmu 0x0418 0x2>,
+		    <0x0608 &smmu 0x041a 0x2>,
+		    <0x0700 &smmu 0x041c 0x2>,
+		    <0x0708 &smmu 0x041e 0x2>,
+		    <0x0800 &smmu 0x0420 0x2>,
+		    <0x0808 &smmu 0x0422 0x2>,
+		    <0x0900 &smmu 0x0424 0x2>,
+		    <0x0908 &smmu 0x0426 0x2>,
+		    <0x0a00 &smmu 0x0428 0x2>,
+		    <0x0a08 &smmu 0x042a 0x2>,
+		    <0x0b00 &smmu 0x042c 0x2>,
+		    <0x0b08 &smmu 0x042e 0x2>,
+		    <0x0c00 &smmu 0x0430 0x2>,
+		    <0x0c08 &smmu 0x0432 0x2>,
+		    <0x0d00 &smmu 0x0434 0x2>,
+		    <0x0d08 &smmu 0x0436 0x2>,
+		    <0x0e00 &smmu 0x0438 0x2>,
+		    <0x0e08 &smmu 0x043a 0x2>,
+		    <0x0f00 &smmu 0x043c 0x2>,
+		    <0x0f08 &smmu 0x043e 0x2>,
+		    <0x1000 &smmu 0x0440 0x2>,
+		    <0x1008 &smmu 0x0442 0x2>,
+		    <0x1100 &smmu 0x0444 0x2>,
+		    <0x1108 &smmu 0x0446 0x2>,
+		    <0x1200 &smmu 0x0448 0x2>,
+		    <0x1208 &smmu 0x044a 0x2>,
+		    <0x1300 &smmu 0x044c 0x2>,
+		    <0x1308 &smmu 0x044e 0x2>,
+		    <0x1400 &smmu 0x0450 0x2>,
+		    <0x1408 &smmu 0x0452 0x2>,
+		    <0x1500 &smmu 0x0454 0x2>,
+		    <0x1508 &smmu 0x0456 0x2>,
+		    <0x1600 &smmu 0x0458 0x2>,
+		    <0x1608 &smmu 0x045a 0x2>,
+		    <0x1700 &smmu 0x045c 0x2>,
+		    <0x1708 &smmu 0x045e 0x2>,
+		    <0x1800 &smmu 0x0460 0x2>,
+		    <0x1808 &smmu 0x0462 0x2>,
+		    <0x1900 &smmu 0x0464 0x2>,
+		    <0x1908 &smmu 0x0466 0x2>,
+		    <0x1a00 &smmu 0x0468 0x2>,
+		    <0x1a08 &smmu 0x046a 0x2>,
+		    <0x1b00 &smmu 0x046c 0x2>,
+		    <0x1b08 &smmu 0x046e 0x2>,
+		    <0x1c00 &smmu 0x0470 0x2>,
+		    <0x1c08 &smmu 0x0472 0x2>,
+		    <0x1d00 &smmu 0x0474 0x2>,
+		    <0x1d08 &smmu 0x0476 0x2>,
+		    <0x1e00 &smmu 0x0478 0x2>,
+		    <0x1e08 &smmu 0x047a 0x2>,
+		    <0x1f00 &smmu 0x047c 0x2>,
+		    <0x1f08 &smmu 0x047e 0x2>,
+		    <0x2000 &smmu 0x0480 0x2>,
+		    <0x2008 &smmu 0x0482 0x2>,
+		    <0x2100 &smmu 0x0484 0x2>,
+		    <0x2108 &smmu 0x0486 0x2>,
+		    <0x2200 &smmu 0x0488 0x2>,
+		    <0x2208 &smmu 0x048a 0x2>,
+		    <0x2300 &smmu 0x048c 0x2>,
+		    <0x2308 &smmu 0x048e 0x2>,
+		    <0x2400 &smmu 0x0490 0x2>,
+		    <0x2408 &smmu 0x0492 0x2>,
+		    <0x2500 &smmu 0x0494 0x2>,
+		    <0x2508 &smmu 0x0496 0x2>,
+		    <0x2600 &smmu 0x0498 0x2>,
+		    <0x2608 &smmu 0x049a 0x2>,
+		    <0x2700 &smmu 0x049c 0x2>,
+		    <0x2708 &smmu 0x049e 0x2>,
+		    <0x2800 &smmu 0x04a0 0x2>,
+		    <0x2808 &smmu 0x04a2 0x2>,
+		    <0x2900 &smmu 0x04a4 0x2>,
+		    <0x2908 &smmu 0x04a6 0x2>,
+		    <0x2a00 &smmu 0x04a8 0x2>,
+		    <0x2a08 &smmu 0x04aa 0x2>,
+		    <0x2b00 &smmu 0x04ac 0x2>,
+		    <0x2b08 &smmu 0x04ae 0x2>,
+		    <0x2c00 &smmu 0x04b0 0x2>,
+		    <0x2c08 &smmu 0x04b2 0x2>,
+		    <0x2d00 &smmu 0x04b4 0x2>,
+		    <0x2d08 &smmu 0x04b6 0x2>,
+		    <0x2e00 &smmu 0x04b8 0x2>,
+		    <0x2e08 &smmu 0x04ba 0x2>,
+		    <0x2f00 &smmu 0x04bc 0x2>,
+		    <0x2f08 &smmu 0x04be 0x2>,
+		    <0x3000 &smmu 0x04c0 0x2>,
+		    <0x3008 &smmu 0x04c2 0x2>,
+		    <0x3100 &smmu 0x04c4 0x2>,
+		    <0x3108 &smmu 0x04c6 0x2>,
+		    <0x3200 &smmu 0x04c8 0x2>,
+		    <0x3208 &smmu 0x04ca 0x2>,
+		    <0x3300 &smmu 0x04cc 0x2>,
+		    <0x3308 &smmu 0x04ce 0x2>,
+		    <0x3400 &smmu 0x04d0 0x2>,
+		    <0x3408 &smmu 0x04d2 0x2>,
+		    <0x3500 &smmu 0x04d4 0x2>,
+		    <0x3508 &smmu 0x04d6 0x2>,
+		    <0x3600 &smmu 0x04d8 0x2>,
+		    <0x3608 &smmu 0x04da 0x2>,
+		    <0x3700 &smmu 0x04dc 0x2>,
+		    <0x3708 &smmu 0x04de 0x2>,
+		    <0x3800 &smmu 0x04e0 0x2>,
+		    <0x3808 &smmu 0x04e2 0x2>,
+		    <0x3900 &smmu 0x04e4 0x2>,
+		    <0x3908 &smmu 0x04e6 0x2>,
+		    <0x3a00 &smmu 0x04e8 0x2>,
+		    <0x3a08 &smmu 0x04ea 0x2>,
+		    <0x3b00 &smmu 0x04ec 0x2>,
+		    <0x3b08 &smmu 0x04ee 0x2>,
+		    <0x3c00 &smmu 0x04f0 0x2>,
+		    <0x3c08 &smmu 0x04f2 0x2>,
+		    <0x3d00 &smmu 0x04f4 0x2>,
+		    <0x3d08 &smmu 0x04f6 0x2>,
+		    <0x3e00 &smmu 0x04f8 0x2>,
+		    <0x3e08 &smmu 0x04fa 0x2>,
+		    <0x3f00 &smmu 0x04fc 0x2>,
+		    <0x3f08 &smmu 0x04fe 0x2>,
+		    <0x4000 &smmu 0x0500 0x2>,
+		    <0x4008 &smmu 0x0502 0x2>,
+		    <0x4100 &smmu 0x0504 0x2>,
+		    <0x4108 &smmu 0x0506 0x2>,
+		    <0x4200 &smmu 0x0508 0x2>,
+		    <0x4208 &smmu 0x050a 0x2>,
+		    <0x4300 &smmu 0x050c 0x2>,
+		    <0x4308 &smmu 0x050e 0x2>,
+		    <0x4400 &smmu 0x0510 0x2>,
+		    <0x4408 &smmu 0x0512 0x2>,
+		    <0x4500 &smmu 0x0514 0x2>,
+		    <0x4508 &smmu 0x0516 0x2>,
+		    <0x4600 &smmu 0x0518 0x2>,
+		    <0x4608 &smmu 0x051a 0x2>,
+		    <0x4700 &smmu 0x051c 0x2>,
+		    <0x4708 &smmu 0x051e 0x2>,
+		    <0x4800 &smmu 0x0520 0x2>,
+		    <0x4808 &smmu 0x0522 0x2>,
+		    <0x4900 &smmu 0x0524 0x2>,
+		    <0x4908 &smmu 0x0526 0x2>,
+		    <0x4a00 &smmu 0x0528 0x2>,
+		    <0x4a08 &smmu 0x052a 0x2>,
+		    <0x4b00 &smmu 0x052c 0x2>,
+		    <0x4b08 &smmu 0x052e 0x2>,
+		    <0x4c00 &smmu 0x0530 0x2>,
+		    <0x4c08 &smmu 0x0532 0x2>,
+		    <0x4d00 &smmu 0x0534 0x2>,
+		    <0x4d08 &smmu 0x0536 0x2>,
+		    <0x4e00 &smmu 0x0538 0x2>,
+		    <0x4e08 &smmu 0x053a 0x2>,
+		    <0x4f00 &smmu 0x053c 0x2>,
+		    <0x4f08 &smmu 0x053e 0x2>,
+		    <0x5000 &smmu 0x0540 0x2>,
+		    <0x5008 &smmu 0x0542 0x2>,
+		    <0x5100 &smmu 0x0544 0x2>,
+		    <0x5108 &smmu 0x0546 0x2>,
+		    <0x5200 &smmu 0x0548 0x2>,
+		    <0x5208 &smmu 0x054a 0x2>,
+		    <0x5300 &smmu 0x054c 0x2>,
+		    <0x5308 &smmu 0x054e 0x2>,
+		    <0x5400 &smmu 0x0550 0x2>,
+		    <0x5408 &smmu 0x0552 0x2>,
+		    <0x5500 &smmu 0x0554 0x2>,
+		    <0x5508 &smmu 0x0556 0x2>,
+		    <0x5600 &smmu 0x0558 0x2>,
+		    <0x5608 &smmu 0x055a 0x2>,
+		    <0x5700 &smmu 0x055c 0x2>,
+		    <0x5708 &smmu 0x055e 0x2>,
+		    <0x5800 &smmu 0x0560 0x2>,
+		    <0x5808 &smmu 0x0562 0x2>,
+		    <0x5900 &smmu 0x0564 0x2>,
+		    <0x5908 &smmu 0x0566 0x2>,
+		    <0x5a00 &smmu 0x0568 0x2>,
+		    <0x5a08 &smmu 0x056a 0x2>,
+		    <0x5b00 &smmu 0x056c 0x2>,
+		    <0x5b08 &smmu 0x056e 0x2>,
+		    <0x5c00 &smmu 0x0570 0x2>,
+		    <0x5c08 &smmu 0x0572 0x2>,
+		    <0x5d00 &smmu 0x0574 0x2>,
+		    <0x5d08 &smmu 0x0576 0x2>,
+		    <0x5e00 &smmu 0x0578 0x2>,
+		    <0x5e08 &smmu 0x057a 0x2>,
+		    <0x5f00 &smmu 0x057c 0x2>,
+		    <0x5f08 &smmu 0x057e 0x2>,
+		    <0x6000 &smmu 0x0580 0x2>,
+		    <0x6008 &smmu 0x0582 0x2>,
+		    <0x6100 &smmu 0x0584 0x2>,
+		    <0x6108 &smmu 0x0586 0x2>,
+		    <0x6200 &smmu 0x0588 0x2>,
+		    <0x6208 &smmu 0x058a 0x2>,
+		    <0x6300 &smmu 0x058c 0x2>,
+		    <0x6308 &smmu 0x058e 0x2>,
+		    <0x6400 &smmu 0x0590 0x2>,
+		    <0x6408 &smmu 0x0592 0x2>,
+		    <0x6500 &smmu 0x0594 0x2>,
+		    <0x6508 &smmu 0x0596 0x2>,
+		    <0x6600 &smmu 0x0598 0x2>,
+		    <0x6608 &smmu 0x059a 0x2>,
+		    <0x6700 &smmu 0x059c 0x2>,
+		    <0x6708 &smmu 0x059e 0x2>,
+		    <0x6800 &smmu 0x05a0 0x2>,
+		    <0x6808 &smmu 0x05a2 0x2>,
+		    <0x6900 &smmu 0x05a4 0x2>,
+		    <0x6908 &smmu 0x05a6 0x2>,
+		    <0x6a00 &smmu 0x05a8 0x2>,
+		    <0x6a08 &smmu 0x05aa 0x2>,
+		    <0x6b00 &smmu 0x05ac 0x2>,
+		    <0x6b08 &smmu 0x05ae 0x2>,
+		    <0x6c00 &smmu 0x05b0 0x2>,
+		    <0x6c08 &smmu 0x05b2 0x2>,
+		    <0x6d00 &smmu 0x05b4 0x2>,
+		    <0x6d08 &smmu 0x05b6 0x2>,
+		    <0x6e00 &smmu 0x05b8 0x2>,
+		    <0x6e08 &smmu 0x05ba 0x2>,
+		    <0x6f00 &smmu 0x05bc 0x2>,
+		    <0x6f08 &smmu 0x05be 0x2>,
+		    <0x7000 &smmu 0x05c0 0x2>,
+		    <0x7008 &smmu 0x05c2 0x2>,
+		    <0x7100 &smmu 0x05c4 0x2>,
+		    <0x7108 &smmu 0x05c6 0x2>,
+		    <0x7200 &smmu 0x05c8 0x2>,
+		    <0x7208 &smmu 0x05ca 0x2>,
+		    <0x7300 &smmu 0x05cc 0x2>,
+		    <0x7308 &smmu 0x05ce 0x2>,
+		    <0x7400 &smmu 0x05d0 0x2>,
+		    <0x7408 &smmu 0x05d2 0x2>,
+		    <0x7500 &smmu 0x05d4 0x2>,
+		    <0x7508 &smmu 0x05d6 0x2>,
+		    <0x7600 &smmu 0x05d8 0x2>,
+		    <0x7608 &smmu 0x05da 0x2>,
+		    <0x7700 &smmu 0x05dc 0x2>,
+		    <0x7708 &smmu 0x05de 0x2>,
+		    <0x7800 &smmu 0x05e0 0x2>,
+		    <0x7808 &smmu 0x05e2 0x2>,
+		    <0x7900 &smmu 0x05e4 0x2>,
+		    <0x7908 &smmu 0x05e6 0x2>,
+		    <0x7a00 &smmu 0x05e8 0x2>,
+		    <0x7a08 &smmu 0x05ea 0x2>,
+		    <0x7b00 &smmu 0x05ec 0x2>,
+		    <0x7b08 &smmu 0x05ee 0x2>,
+		    <0x7c00 &smmu 0x05f0 0x2>,
+		    <0x7c08 &smmu 0x05f2 0x2>,
+		    <0x7d00 &smmu 0x05f4 0x2>,
+		    <0x7d08 &smmu 0x05f6 0x2>,
+		    <0x7e00 &smmu 0x05f8 0x2>,
+		    <0x7e08 &smmu 0x05fa 0x2>,
+		    <0x7f00 &smmu 0x05fc 0x2>,
+		    <0x7f08 &smmu 0x05fe 0x2>,
+		    <0x8000 &smmu 0x0600 0x2>,
+		    <0x8008 &smmu 0x0602 0x2>,
+		    <0x8100 &smmu 0x0604 0x2>,
+		    <0x8108 &smmu 0x0606 0x2>,
+		    <0x8200 &smmu 0x0608 0x2>,
+		    <0x8208 &smmu 0x060a 0x2>,
+		    <0x8300 &smmu 0x060c 0x2>,
+		    <0x8308 &smmu 0x060e 0x2>,
+		    <0x8400 &smmu 0x0610 0x2>,
+		    <0x8408 &smmu 0x0612 0x2>,
+		    <0x8500 &smmu 0x0614 0x2>,
+		    <0x8508 &smmu 0x0616 0x2>,
+		    <0x8600 &smmu 0x0618 0x2>,
+		    <0x8608 &smmu 0x061a 0x2>,
+		    <0x8700 &smmu 0x061c 0x2>,
+		    <0x8708 &smmu 0x061e 0x2>,
+		    <0x8800 &smmu 0x0620 0x2>,
+		    <0x8808 &smmu 0x0622 0x2>,
+		    <0x8900 &smmu 0x0624 0x2>,
+		    <0x8908 &smmu 0x0626 0x2>,
+		    <0x8a00 &smmu 0x0628 0x2>,
+		    <0x8a08 &smmu 0x062a 0x2>,
+		    <0x8b00 &smmu 0x062c 0x2>,
+		    <0x8b08 &smmu 0x062e 0x2>,
+		    <0x8c00 &smmu 0x0630 0x2>,
+		    <0x8c08 &smmu 0x0632 0x2>,
+		    <0x8d00 &smmu 0x0634 0x2>,
+		    <0x8d08 &smmu 0x0636 0x2>,
+		    <0x8e00 &smmu 0x0638 0x2>,
+		    <0x8e08 &smmu 0x063a 0x2>,
+		    <0x8f00 &smmu 0x063c 0x2>,
+		    <0x8f08 &smmu 0x063e 0x2>,
+		    <0x9000 &smmu 0x0640 0x2>,
+		    <0x9008 &smmu 0x0642 0x2>,
+		    <0x9100 &smmu 0x0644 0x2>,
+		    <0x9108 &smmu 0x0646 0x2>,
+		    <0x9200 &smmu 0x0648 0x2>,
+		    <0x9208 &smmu 0x064a 0x2>,
+		    <0x9300 &smmu 0x064c 0x2>,
+		    <0x9308 &smmu 0x064e 0x2>,
+		    <0x9400 &smmu 0x0650 0x2>,
+		    <0x9408 &smmu 0x0652 0x2>,
+		    <0x9500 &smmu 0x0654 0x2>,
+		    <0x9508 &smmu 0x0656 0x2>,
+		    <0x9600 &smmu 0x0658 0x2>,
+		    <0x9608 &smmu 0x065a 0x2>,
+		    <0x9700 &smmu 0x065c 0x2>,
+		    <0x9708 &smmu 0x065e 0x2>,
+		    <0x9800 &smmu 0x0660 0x2>,
+		    <0x9808 &smmu 0x0662 0x2>,
+		    <0x9900 &smmu 0x0664 0x2>,
+		    <0x9908 &smmu 0x0666 0x2>,
+		    <0x9a00 &smmu 0x0668 0x2>,
+		    <0x9a08 &smmu 0x066a 0x2>,
+		    <0x9b00 &smmu 0x066c 0x2>,
+		    <0x9b08 &smmu 0x066e 0x2>,
+		    <0x9c00 &smmu 0x0670 0x2>,
+		    <0x9c08 &smmu 0x0672 0x2>,
+		    <0x9d00 &smmu 0x0674 0x2>,
+		    <0x9d08 &smmu 0x0676 0x2>,
+		    <0x9e00 &smmu 0x0678 0x2>,
+		    <0x9e08 &smmu 0x067a 0x2>,
+		    <0x9f00 &smmu 0x067c 0x2>,
+		    <0x9f08 &smmu 0x067e 0x2>,
+		    <0xa000 &smmu 0x0680 0x2>,
+		    <0xa008 &smmu 0x0682 0x2>,
+		    <0xa100 &smmu 0x0684 0x2>,
+		    <0xa108 &smmu 0x0686 0x2>,
+		    <0xa200 &smmu 0x0688 0x2>,
+		    <0xa208 &smmu 0x068a 0x2>,
+		    <0xa300 &smmu 0x068c 0x2>,
+		    <0xa308 &smmu 0x068e 0x2>,
+		    <0xa400 &smmu 0x0690 0x2>,
+		    <0xa408 &smmu 0x0692 0x2>,
+		    <0xa500 &smmu 0x0694 0x2>,
+		    <0xa508 &smmu 0x0696 0x2>,
+		    <0xa600 &smmu 0x0698 0x2>,
+		    <0xa608 &smmu 0x069a 0x2>,
+		    <0xa700 &smmu 0x069c 0x2>,
+		    <0xa708 &smmu 0x069e 0x2>,
+		    <0xa800 &smmu 0x06a0 0x2>,
+		    <0xa808 &smmu 0x06a2 0x2>,
+		    <0xa900 &smmu 0x06a4 0x2>,
+		    <0xa908 &smmu 0x06a6 0x2>,
+		    <0xaa00 &smmu 0x06a8 0x2>,
+		    <0xaa08 &smmu 0x06aa 0x2>,
+		    <0xab00 &smmu 0x06ac 0x2>,
+		    <0xab08 &smmu 0x06ae 0x2>,
+		    <0xac00 &smmu 0x06b0 0x2>,
+		    <0xac08 &smmu 0x06b2 0x2>,
+		    <0xad00 &smmu 0x06b4 0x2>,
+		    <0xad08 &smmu 0x06b6 0x2>,
+		    <0xae00 &smmu 0x06b8 0x2>,
+		    <0xae08 &smmu 0x06ba 0x2>,
+		    <0xaf00 &smmu 0x06bc 0x2>,
+		    <0xaf08 &smmu 0x06be 0x2>,
+		    <0xb000 &smmu 0x06c0 0x2>,
+		    <0xb008 &smmu 0x06c2 0x2>,
+		    <0xb100 &smmu 0x06c4 0x2>,
+		    <0xb108 &smmu 0x06c6 0x2>,
+		    <0xb200 &smmu 0x06c8 0x2>,
+		    <0xb208 &smmu 0x06ca 0x2>,
+		    <0xb300 &smmu 0x06cc 0x2>,
+		    <0xb308 &smmu 0x06ce 0x2>,
+		    <0xb400 &smmu 0x06d0 0x2>,
+		    <0xb408 &smmu 0x06d2 0x2>,
+		    <0xb500 &smmu 0x06d4 0x2>,
+		    <0xb508 &smmu 0x06d6 0x2>,
+		    <0xb600 &smmu 0x06d8 0x2>,
+		    <0xb608 &smmu 0x06da 0x2>,
+		    <0xb700 &smmu 0x06dc 0x2>,
+		    <0xb708 &smmu 0x06de 0x2>,
+		    <0xb800 &smmu 0x06e0 0x2>,
+		    <0xb808 &smmu 0x06e2 0x2>,
+		    <0xb900 &smmu 0x06e4 0x2>,
+		    <0xb908 &smmu 0x06e6 0x2>,
+		    <0xba00 &smmu 0x06e8 0x2>,
+		    <0xba08 &smmu 0x06ea 0x2>,
+		    <0xbb00 &smmu 0x06ec 0x2>,
+		    <0xbb08 &smmu 0x06ee 0x2>,
+		    <0xbc00 &smmu 0x06f0 0x2>,
+		    <0xbc08 &smmu 0x06f2 0x2>,
+		    <0xbd00 &smmu 0x06f4 0x2>,
+		    <0xbd08 &smmu 0x06f6 0x2>,
+		    <0xbe00 &smmu 0x06f8 0x2>,
+		    <0xbe08 &smmu 0x06fa 0x2>,
+		    <0xbf00 &smmu 0x06fc 0x2>,
+		    <0xbf08 &smmu 0x06fe 0x2>,
+		    <0xc000 &smmu 0x0700 0x2>,
+		    <0xc008 &smmu 0x0702 0x2>,
+		    <0xc100 &smmu 0x0704 0x2>,
+		    <0xc108 &smmu 0x0706 0x2>,
+		    <0xc200 &smmu 0x0708 0x2>,
+		    <0xc208 &smmu 0x070a 0x2>,
+		    <0xc300 &smmu 0x070c 0x2>,
+		    <0xc308 &smmu 0x070e 0x2>,
+		    <0xc400 &smmu 0x0710 0x2>,
+		    <0xc408 &smmu 0x0712 0x2>,
+		    <0xc500 &smmu 0x0714 0x2>,
+		    <0xc508 &smmu 0x0716 0x2>,
+		    <0xc600 &smmu 0x0718 0x2>,
+		    <0xc608 &smmu 0x071a 0x2>,
+		    <0xc700 &smmu 0x071c 0x2>,
+		    <0xc708 &smmu 0x071e 0x2>,
+		    <0xc800 &smmu 0x0720 0x2>,
+		    <0xc808 &smmu 0x0722 0x2>,
+		    <0xc900 &smmu 0x0724 0x2>,
+		    <0xc908 &smmu 0x0726 0x2>,
+		    <0xca00 &smmu 0x0728 0x2>,
+		    <0xca08 &smmu 0x072a 0x2>,
+		    <0xcb00 &smmu 0x072c 0x2>,
+		    <0xcb08 &smmu 0x072e 0x2>,
+		    <0xcc00 &smmu 0x0730 0x2>,
+		    <0xcc08 &smmu 0x0732 0x2>,
+		    <0xcd00 &smmu 0x0734 0x2>,
+		    <0xcd08 &smmu 0x0736 0x2>,
+		    <0xce00 &smmu 0x0738 0x2>,
+		    <0xce08 &smmu 0x073a 0x2>,
+		    <0xcf00 &smmu 0x073c 0x2>,
+		    <0xcf08 &smmu 0x073e 0x2>,
+		    <0xd000 &smmu 0x0740 0x2>,
+		    <0xd008 &smmu 0x0742 0x2>,
+		    <0xd100 &smmu 0x0744 0x2>,
+		    <0xd108 &smmu 0x0746 0x2>,
+		    <0xd200 &smmu 0x0748 0x2>,
+		    <0xd208 &smmu 0x074a 0x2>,
+		    <0xd300 &smmu 0x074c 0x2>,
+		    <0xd308 &smmu 0x074e 0x2>,
+		    <0xd400 &smmu 0x0750 0x2>,
+		    <0xd408 &smmu 0x0752 0x2>,
+		    <0xd500 &smmu 0x0754 0x2>,
+		    <0xd508 &smmu 0x0756 0x2>,
+		    <0xd600 &smmu 0x0758 0x2>,
+		    <0xd608 &smmu 0x075a 0x2>,
+		    <0xd700 &smmu 0x075c 0x2>,
+		    <0xd708 &smmu 0x075e 0x2>,
+		    <0xd800 &smmu 0x0760 0x2>,
+		    <0xd808 &smmu 0x0762 0x2>,
+		    <0xd900 &smmu 0x0764 0x2>,
+		    <0xd908 &smmu 0x0766 0x2>,
+		    <0xda00 &smmu 0x0768 0x2>,
+		    <0xda08 &smmu 0x076a 0x2>,
+		    <0xdb00 &smmu 0x076c 0x2>,
+		    <0xdb08 &smmu 0x076e 0x2>,
+		    <0xdc00 &smmu 0x0770 0x2>,
+		    <0xdc08 &smmu 0x0772 0x2>,
+		    <0xdd00 &smmu 0x0774 0x2>,
+		    <0xdd08 &smmu 0x0776 0x2>,
+		    <0xde00 &smmu 0x0778 0x2>,
+		    <0xde08 &smmu 0x077a 0x2>,
+		    <0xdf00 &smmu 0x077c 0x2>,
+		    <0xdf08 &smmu 0x077e 0x2>,
+		    <0xe000 &smmu 0x0780 0x2>,
+		    <0xe008 &smmu 0x0782 0x2>,
+		    <0xe100 &smmu 0x0784 0x2>,
+		    <0xe108 &smmu 0x0786 0x2>,
+		    <0xe200 &smmu 0x0788 0x2>,
+		    <0xe208 &smmu 0x078a 0x2>,
+		    <0xe300 &smmu 0x078c 0x2>,
+		    <0xe308 &smmu 0x078e 0x2>,
+		    <0xe400 &smmu 0x0790 0x2>,
+		    <0xe408 &smmu 0x0792 0x2>,
+		    <0xe500 &smmu 0x0794 0x2>,
+		    <0xe508 &smmu 0x0796 0x2>,
+		    <0xe600 &smmu 0x0798 0x2>,
+		    <0xe608 &smmu 0x079a 0x2>,
+		    <0xe700 &smmu 0x079c 0x2>,
+		    <0xe708 &smmu 0x079e 0x2>,
+		    <0xe800 &smmu 0x07a0 0x2>,
+		    <0xe808 &smmu 0x07a2 0x2>,
+		    <0xe900 &smmu 0x07a4 0x2>,
+		    <0xe908 &smmu 0x07a6 0x2>,
+		    <0xea00 &smmu 0x07a8 0x2>,
+		    <0xea08 &smmu 0x07aa 0x2>,
+		    <0xeb00 &smmu 0x07ac 0x2>,
+		    <0xeb08 &smmu 0x07ae 0x2>,
+		    <0xec00 &smmu 0x07b0 0x2>,
+		    <0xec08 &smmu 0x07b2 0x2>,
+		    <0xed00 &smmu 0x07b4 0x2>,
+		    <0xed08 &smmu 0x07b6 0x2>,
+		    <0xee00 &smmu 0x07b8 0x2>,
+		    <0xee08 &smmu 0x07ba 0x2>,
+		    <0xef00 &smmu 0x07bc 0x2>,
+		    <0xef08 &smmu 0x07be 0x2>,
+		    <0xf000 &smmu 0x07c0 0x2>,
+		    <0xf008 &smmu 0x07c2 0x2>,
+		    <0xf100 &smmu 0x07c4 0x2>,
+		    <0xf108 &smmu 0x07c6 0x2>,
+		    <0xf200 &smmu 0x07c8 0x2>,
+		    <0xf208 &smmu 0x07ca 0x2>,
+		    <0xf300 &smmu 0x07cc 0x2>,
+		    <0xf308 &smmu 0x07ce 0x2>,
+		    <0xf400 &smmu 0x07d0 0x2>,
+		    <0xf408 &smmu 0x07d2 0x2>,
+		    <0xf500 &smmu 0x07d4 0x2>,
+		    <0xf508 &smmu 0x07d6 0x2>,
+		    <0xf600 &smmu 0x07d8 0x2>,
+		    <0xf608 &smmu 0x07da 0x2>,
+		    <0xf700 &smmu 0x07dc 0x2>,
+		    <0xf708 &smmu 0x07de 0x2>,
+		    <0xf800 &smmu 0x07e0 0x2>,
+		    <0xf808 &smmu 0x07e2 0x2>,
+		    <0xf900 &smmu 0x07e4 0x2>,
+		    <0xf908 &smmu 0x07e6 0x2>,
+		    <0xfa00 &smmu 0x07e8 0x2>,
+		    <0xfa08 &smmu 0x07ea 0x2>,
+		    <0xfb00 &smmu 0x07ec 0x2>,
+		    <0xfb08 &smmu 0x07ee 0x2>,
+		    <0xfc00 &smmu 0x07f0 0x2>,
+		    <0xfc08 &smmu 0x07f2 0x2>,
+		    <0xfd00 &smmu 0x07f4 0x2>,
+		    <0xfd08 &smmu 0x07f6 0x2>,
+		    <0xfe00 &smmu 0x07f8 0x2>,
+		    <0xfe08 &smmu 0x07fa 0x2>,
+		    <0xff00 &smmu 0x07fc 0x2>,
+		    <0xff08 &smmu 0x07fe 0x2>;
+#endif
+};
+
+&pcie2 {
+	msi-map = <0x0000 &gic_its 0x0800 0x2>,
+		  <0x0008 &gic_its 0x0802 0x2>,
+		  <0x0100 &gic_its 0x0804 0x2>,
+		  <0x0108 &gic_its 0x0806 0x2>,
+		  <0x0200 &gic_its 0x0808 0x2>,
+		  <0x0208 &gic_its 0x080a 0x2>,
+		  <0x0300 &gic_its 0x080c 0x2>,
+		  <0x0308 &gic_its 0x080e 0x2>,
+		  <0x0400 &gic_its 0x0810 0x2>,
+		  <0x0408 &gic_its 0x0812 0x2>,
+		  <0x0500 &gic_its 0x0814 0x2>,
+		  <0x0508 &gic_its 0x0816 0x2>,
+		  <0x0600 &gic_its 0x0818 0x2>,
+		  <0x0608 &gic_its 0x081a 0x2>,
+		  <0x0700 &gic_its 0x081c 0x2>,
+		  <0x0708 &gic_its 0x081e 0x2>,
+		  <0x0800 &gic_its 0x0820 0x2>,
+		  <0x0808 &gic_its 0x0822 0x2>,
+		  <0x0900 &gic_its 0x0824 0x2>,
+		  <0x0908 &gic_its 0x0826 0x2>,
+		  <0x0a00 &gic_its 0x0828 0x2>,
+		  <0x0a08 &gic_its 0x082a 0x2>,
+		  <0x0b00 &gic_its 0x082c 0x2>,
+		  <0x0b08 &gic_its 0x082e 0x2>,
+		  <0x0c00 &gic_its 0x0830 0x2>,
+		  <0x0c08 &gic_its 0x0832 0x2>,
+		  <0x0d00 &gic_its 0x0834 0x2>,
+		  <0x0d08 &gic_its 0x0836 0x2>,
+		  <0x0e00 &gic_its 0x0838 0x2>,
+		  <0x0e08 &gic_its 0x083a 0x2>,
+		  <0x0f00 &gic_its 0x083c 0x2>,
+		  <0x0f08 &gic_its 0x083e 0x2>,
+		  <0x1000 &gic_its 0x0840 0x2>,
+		  <0x1008 &gic_its 0x0842 0x2>,
+		  <0x1100 &gic_its 0x0844 0x2>,
+		  <0x1108 &gic_its 0x0846 0x2>,
+		  <0x1200 &gic_its 0x0848 0x2>,
+		  <0x1208 &gic_its 0x084a 0x2>,
+		  <0x1300 &gic_its 0x084c 0x2>,
+		  <0x1308 &gic_its 0x084e 0x2>,
+		  <0x1400 &gic_its 0x0850 0x2>,
+		  <0x1408 &gic_its 0x0852 0x2>,
+		  <0x1500 &gic_its 0x0854 0x2>,
+		  <0x1508 &gic_its 0x0856 0x2>,
+		  <0x1600 &gic_its 0x0858 0x2>,
+		  <0x1608 &gic_its 0x085a 0x2>,
+		  <0x1700 &gic_its 0x085c 0x2>,
+		  <0x1708 &gic_its 0x085e 0x2>,
+		  <0x1800 &gic_its 0x0860 0x2>,
+		  <0x1808 &gic_its 0x0862 0x2>,
+		  <0x1900 &gic_its 0x0864 0x2>,
+		  <0x1908 &gic_its 0x0866 0x2>,
+		  <0x1a00 &gic_its 0x0868 0x2>,
+		  <0x1a08 &gic_its 0x086a 0x2>,
+		  <0x1b00 &gic_its 0x086c 0x2>,
+		  <0x1b08 &gic_its 0x086e 0x2>,
+		  <0x1c00 &gic_its 0x0870 0x2>,
+		  <0x1c08 &gic_its 0x0872 0x2>,
+		  <0x1d00 &gic_its 0x0874 0x2>,
+		  <0x1d08 &gic_its 0x0876 0x2>,
+		  <0x1e00 &gic_its 0x0878 0x2>,
+		  <0x1e08 &gic_its 0x087a 0x2>,
+		  <0x1f00 &gic_its 0x087c 0x2>,
+		  <0x1f08 &gic_its 0x087e 0x2>,
+		  <0x2000 &gic_its 0x0880 0x2>,
+		  <0x2008 &gic_its 0x0882 0x2>,
+		  <0x2100 &gic_its 0x0884 0x2>,
+		  <0x2108 &gic_its 0x0886 0x2>,
+		  <0x2200 &gic_its 0x0888 0x2>,
+		  <0x2208 &gic_its 0x088a 0x2>,
+		  <0x2300 &gic_its 0x088c 0x2>,
+		  <0x2308 &gic_its 0x088e 0x2>,
+		  <0x2400 &gic_its 0x0890 0x2>,
+		  <0x2408 &gic_its 0x0892 0x2>,
+		  <0x2500 &gic_its 0x0894 0x2>,
+		  <0x2508 &gic_its 0x0896 0x2>,
+		  <0x2600 &gic_its 0x0898 0x2>,
+		  <0x2608 &gic_its 0x089a 0x2>,
+		  <0x2700 &gic_its 0x089c 0x2>,
+		  <0x2708 &gic_its 0x089e 0x2>,
+		  <0x2800 &gic_its 0x08a0 0x2>,
+		  <0x2808 &gic_its 0x08a2 0x2>,
+		  <0x2900 &gic_its 0x08a4 0x2>,
+		  <0x2908 &gic_its 0x08a6 0x2>,
+		  <0x2a00 &gic_its 0x08a8 0x2>,
+		  <0x2a08 &gic_its 0x08aa 0x2>,
+		  <0x2b00 &gic_its 0x08ac 0x2>,
+		  <0x2b08 &gic_its 0x08ae 0x2>,
+		  <0x2c00 &gic_its 0x08b0 0x2>,
+		  <0x2c08 &gic_its 0x08b2 0x2>,
+		  <0x2d00 &gic_its 0x08b4 0x2>,
+		  <0x2d08 &gic_its 0x08b6 0x2>,
+		  <0x2e00 &gic_its 0x08b8 0x2>,
+		  <0x2e08 &gic_its 0x08ba 0x2>,
+		  <0x2f00 &gic_its 0x08bc 0x2>,
+		  <0x2f08 &gic_its 0x08be 0x2>,
+		  <0x3000 &gic_its 0x08c0 0x2>,
+		  <0x3008 &gic_its 0x08c2 0x2>,
+		  <0x3100 &gic_its 0x08c4 0x2>,
+		  <0x3108 &gic_its 0x08c6 0x2>,
+		  <0x3200 &gic_its 0x08c8 0x2>,
+		  <0x3208 &gic_its 0x08ca 0x2>,
+		  <0x3300 &gic_its 0x08cc 0x2>,
+		  <0x3308 &gic_its 0x08ce 0x2>,
+		  <0x3400 &gic_its 0x08d0 0x2>,
+		  <0x3408 &gic_its 0x08d2 0x2>,
+		  <0x3500 &gic_its 0x08d4 0x2>,
+		  <0x3508 &gic_its 0x08d6 0x2>,
+		  <0x3600 &gic_its 0x08d8 0x2>,
+		  <0x3608 &gic_its 0x08da 0x2>,
+		  <0x3700 &gic_its 0x08dc 0x2>,
+		  <0x3708 &gic_its 0x08de 0x2>,
+		  <0x3800 &gic_its 0x08e0 0x2>,
+		  <0x3808 &gic_its 0x08e2 0x2>,
+		  <0x3900 &gic_its 0x08e4 0x2>,
+		  <0x3908 &gic_its 0x08e6 0x2>,
+		  <0x3a00 &gic_its 0x08e8 0x2>,
+		  <0x3a08 &gic_its 0x08ea 0x2>,
+		  <0x3b00 &gic_its 0x08ec 0x2>,
+		  <0x3b08 &gic_its 0x08ee 0x2>,
+		  <0x3c00 &gic_its 0x08f0 0x2>,
+		  <0x3c08 &gic_its 0x08f2 0x2>,
+		  <0x3d00 &gic_its 0x08f4 0x2>,
+		  <0x3d08 &gic_its 0x08f6 0x2>,
+		  <0x3e00 &gic_its 0x08f8 0x2>,
+		  <0x3e08 &gic_its 0x08fa 0x2>,
+		  <0x3f00 &gic_its 0x08fc 0x2>,
+		  <0x3f08 &gic_its 0x08fe 0x2>,
+		  <0x4000 &gic_its 0x0900 0x2>,
+		  <0x4008 &gic_its 0x0902 0x2>,
+		  <0x4100 &gic_its 0x0904 0x2>,
+		  <0x4108 &gic_its 0x0906 0x2>,
+		  <0x4200 &gic_its 0x0908 0x2>,
+		  <0x4208 &gic_its 0x090a 0x2>,
+		  <0x4300 &gic_its 0x090c 0x2>,
+		  <0x4308 &gic_its 0x090e 0x2>,
+		  <0x4400 &gic_its 0x0910 0x2>,
+		  <0x4408 &gic_its 0x0912 0x2>,
+		  <0x4500 &gic_its 0x0914 0x2>,
+		  <0x4508 &gic_its 0x0916 0x2>,
+		  <0x4600 &gic_its 0x0918 0x2>,
+		  <0x4608 &gic_its 0x091a 0x2>,
+		  <0x4700 &gic_its 0x091c 0x2>,
+		  <0x4708 &gic_its 0x091e 0x2>,
+		  <0x4800 &gic_its 0x0920 0x2>,
+		  <0x4808 &gic_its 0x0922 0x2>,
+		  <0x4900 &gic_its 0x0924 0x2>,
+		  <0x4908 &gic_its 0x0926 0x2>,
+		  <0x4a00 &gic_its 0x0928 0x2>,
+		  <0x4a08 &gic_its 0x092a 0x2>,
+		  <0x4b00 &gic_its 0x092c 0x2>,
+		  <0x4b08 &gic_its 0x092e 0x2>,
+		  <0x4c00 &gic_its 0x0930 0x2>,
+		  <0x4c08 &gic_its 0x0932 0x2>,
+		  <0x4d00 &gic_its 0x0934 0x2>,
+		  <0x4d08 &gic_its 0x0936 0x2>,
+		  <0x4e00 &gic_its 0x0938 0x2>,
+		  <0x4e08 &gic_its 0x093a 0x2>,
+		  <0x4f00 &gic_its 0x093c 0x2>,
+		  <0x4f08 &gic_its 0x093e 0x2>,
+		  <0x5000 &gic_its 0x0940 0x2>,
+		  <0x5008 &gic_its 0x0942 0x2>,
+		  <0x5100 &gic_its 0x0944 0x2>,
+		  <0x5108 &gic_its 0x0946 0x2>,
+		  <0x5200 &gic_its 0x0948 0x2>,
+		  <0x5208 &gic_its 0x094a 0x2>,
+		  <0x5300 &gic_its 0x094c 0x2>,
+		  <0x5308 &gic_its 0x094e 0x2>,
+		  <0x5400 &gic_its 0x0950 0x2>,
+		  <0x5408 &gic_its 0x0952 0x2>,
+		  <0x5500 &gic_its 0x0954 0x2>,
+		  <0x5508 &gic_its 0x0956 0x2>,
+		  <0x5600 &gic_its 0x0958 0x2>,
+		  <0x5608 &gic_its 0x095a 0x2>,
+		  <0x5700 &gic_its 0x095c 0x2>,
+		  <0x5708 &gic_its 0x095e 0x2>,
+		  <0x5800 &gic_its 0x0960 0x2>,
+		  <0x5808 &gic_its 0x0962 0x2>,
+		  <0x5900 &gic_its 0x0964 0x2>,
+		  <0x5908 &gic_its 0x0966 0x2>,
+		  <0x5a00 &gic_its 0x0968 0x2>,
+		  <0x5a08 &gic_its 0x096a 0x2>,
+		  <0x5b00 &gic_its 0x096c 0x2>,
+		  <0x5b08 &gic_its 0x096e 0x2>,
+		  <0x5c00 &gic_its 0x0970 0x2>,
+		  <0x5c08 &gic_its 0x0972 0x2>,
+		  <0x5d00 &gic_its 0x0974 0x2>,
+		  <0x5d08 &gic_its 0x0976 0x2>,
+		  <0x5e00 &gic_its 0x0978 0x2>,
+		  <0x5e08 &gic_its 0x097a 0x2>,
+		  <0x5f00 &gic_its 0x097c 0x2>,
+		  <0x5f08 &gic_its 0x097e 0x2>,
+		  <0x6000 &gic_its 0x0980 0x2>,
+		  <0x6008 &gic_its 0x0982 0x2>,
+		  <0x6100 &gic_its 0x0984 0x2>,
+		  <0x6108 &gic_its 0x0986 0x2>,
+		  <0x6200 &gic_its 0x0988 0x2>,
+		  <0x6208 &gic_its 0x098a 0x2>,
+		  <0x6300 &gic_its 0x098c 0x2>,
+		  <0x6308 &gic_its 0x098e 0x2>,
+		  <0x6400 &gic_its 0x0990 0x2>,
+		  <0x6408 &gic_its 0x0992 0x2>,
+		  <0x6500 &gic_its 0x0994 0x2>,
+		  <0x6508 &gic_its 0x0996 0x2>,
+		  <0x6600 &gic_its 0x0998 0x2>,
+		  <0x6608 &gic_its 0x099a 0x2>,
+		  <0x6700 &gic_its 0x099c 0x2>,
+		  <0x6708 &gic_its 0x099e 0x2>,
+		  <0x6800 &gic_its 0x09a0 0x2>,
+		  <0x6808 &gic_its 0x09a2 0x2>,
+		  <0x6900 &gic_its 0x09a4 0x2>,
+		  <0x6908 &gic_its 0x09a6 0x2>,
+		  <0x6a00 &gic_its 0x09a8 0x2>,
+		  <0x6a08 &gic_its 0x09aa 0x2>,
+		  <0x6b00 &gic_its 0x09ac 0x2>,
+		  <0x6b08 &gic_its 0x09ae 0x2>,
+		  <0x6c00 &gic_its 0x09b0 0x2>,
+		  <0x6c08 &gic_its 0x09b2 0x2>,
+		  <0x6d00 &gic_its 0x09b4 0x2>,
+		  <0x6d08 &gic_its 0x09b6 0x2>,
+		  <0x6e00 &gic_its 0x09b8 0x2>,
+		  <0x6e08 &gic_its 0x09ba 0x2>,
+		  <0x6f00 &gic_its 0x09bc 0x2>,
+		  <0x6f08 &gic_its 0x09be 0x2>,
+		  <0x7000 &gic_its 0x09c0 0x2>,
+		  <0x7008 &gic_its 0x09c2 0x2>,
+		  <0x7100 &gic_its 0x09c4 0x2>,
+		  <0x7108 &gic_its 0x09c6 0x2>,
+		  <0x7200 &gic_its 0x09c8 0x2>,
+		  <0x7208 &gic_its 0x09ca 0x2>,
+		  <0x7300 &gic_its 0x09cc 0x2>,
+		  <0x7308 &gic_its 0x09ce 0x2>,
+		  <0x7400 &gic_its 0x09d0 0x2>,
+		  <0x7408 &gic_its 0x09d2 0x2>,
+		  <0x7500 &gic_its 0x09d4 0x2>,
+		  <0x7508 &gic_its 0x09d6 0x2>,
+		  <0x7600 &gic_its 0x09d8 0x2>,
+		  <0x7608 &gic_its 0x09da 0x2>,
+		  <0x7700 &gic_its 0x09dc 0x2>,
+		  <0x7708 &gic_its 0x09de 0x2>,
+		  <0x7800 &gic_its 0x09e0 0x2>,
+		  <0x7808 &gic_its 0x09e2 0x2>,
+		  <0x7900 &gic_its 0x09e4 0x2>,
+		  <0x7908 &gic_its 0x09e6 0x2>,
+		  <0x7a00 &gic_its 0x09e8 0x2>,
+		  <0x7a08 &gic_its 0x09ea 0x2>,
+		  <0x7b00 &gic_its 0x09ec 0x2>,
+		  <0x7b08 &gic_its 0x09ee 0x2>,
+		  <0x7c00 &gic_its 0x09f0 0x2>,
+		  <0x7c08 &gic_its 0x09f2 0x2>,
+		  <0x7d00 &gic_its 0x09f4 0x2>,
+		  <0x7d08 &gic_its 0x09f6 0x2>,
+		  <0x7e00 &gic_its 0x09f8 0x2>,
+		  <0x7e08 &gic_its 0x09fa 0x2>,
+		  <0x7f00 &gic_its 0x09fc 0x2>,
+		  <0x7f08 &gic_its 0x09fe 0x2>,
+		  <0x8000 &gic_its 0x0a00 0x2>,
+		  <0x8008 &gic_its 0x0a02 0x2>,
+		  <0x8100 &gic_its 0x0a04 0x2>,
+		  <0x8108 &gic_its 0x0a06 0x2>,
+		  <0x8200 &gic_its 0x0a08 0x2>,
+		  <0x8208 &gic_its 0x0a0a 0x2>,
+		  <0x8300 &gic_its 0x0a0c 0x2>,
+		  <0x8308 &gic_its 0x0a0e 0x2>,
+		  <0x8400 &gic_its 0x0a10 0x2>,
+		  <0x8408 &gic_its 0x0a12 0x2>,
+		  <0x8500 &gic_its 0x0a14 0x2>,
+		  <0x8508 &gic_its 0x0a16 0x2>,
+		  <0x8600 &gic_its 0x0a18 0x2>,
+		  <0x8608 &gic_its 0x0a1a 0x2>,
+		  <0x8700 &gic_its 0x0a1c 0x2>,
+		  <0x8708 &gic_its 0x0a1e 0x2>,
+		  <0x8800 &gic_its 0x0a20 0x2>,
+		  <0x8808 &gic_its 0x0a22 0x2>,
+		  <0x8900 &gic_its 0x0a24 0x2>,
+		  <0x8908 &gic_its 0x0a26 0x2>,
+		  <0x8a00 &gic_its 0x0a28 0x2>,
+		  <0x8a08 &gic_its 0x0a2a 0x2>,
+		  <0x8b00 &gic_its 0x0a2c 0x2>,
+		  <0x8b08 &gic_its 0x0a2e 0x2>,
+		  <0x8c00 &gic_its 0x0a30 0x2>,
+		  <0x8c08 &gic_its 0x0a32 0x2>,
+		  <0x8d00 &gic_its 0x0a34 0x2>,
+		  <0x8d08 &gic_its 0x0a36 0x2>,
+		  <0x8e00 &gic_its 0x0a38 0x2>,
+		  <0x8e08 &gic_its 0x0a3a 0x2>,
+		  <0x8f00 &gic_its 0x0a3c 0x2>,
+		  <0x8f08 &gic_its 0x0a3e 0x2>,
+		  <0x9000 &gic_its 0x0a40 0x2>,
+		  <0x9008 &gic_its 0x0a42 0x2>,
+		  <0x9100 &gic_its 0x0a44 0x2>,
+		  <0x9108 &gic_its 0x0a46 0x2>,
+		  <0x9200 &gic_its 0x0a48 0x2>,
+		  <0x9208 &gic_its 0x0a4a 0x2>,
+		  <0x9300 &gic_its 0x0a4c 0x2>,
+		  <0x9308 &gic_its 0x0a4e 0x2>,
+		  <0x9400 &gic_its 0x0a50 0x2>,
+		  <0x9408 &gic_its 0x0a52 0x2>,
+		  <0x9500 &gic_its 0x0a54 0x2>,
+		  <0x9508 &gic_its 0x0a56 0x2>,
+		  <0x9600 &gic_its 0x0a58 0x2>,
+		  <0x9608 &gic_its 0x0a5a 0x2>,
+		  <0x9700 &gic_its 0x0a5c 0x2>,
+		  <0x9708 &gic_its 0x0a5e 0x2>,
+		  <0x9800 &gic_its 0x0a60 0x2>,
+		  <0x9808 &gic_its 0x0a62 0x2>,
+		  <0x9900 &gic_its 0x0a64 0x2>,
+		  <0x9908 &gic_its 0x0a66 0x2>,
+		  <0x9a00 &gic_its 0x0a68 0x2>,
+		  <0x9a08 &gic_its 0x0a6a 0x2>,
+		  <0x9b00 &gic_its 0x0a6c 0x2>,
+		  <0x9b08 &gic_its 0x0a6e 0x2>,
+		  <0x9c00 &gic_its 0x0a70 0x2>,
+		  <0x9c08 &gic_its 0x0a72 0x2>,
+		  <0x9d00 &gic_its 0x0a74 0x2>,
+		  <0x9d08 &gic_its 0x0a76 0x2>,
+		  <0x9e00 &gic_its 0x0a78 0x2>,
+		  <0x9e08 &gic_its 0x0a7a 0x2>,
+		  <0x9f00 &gic_its 0x0a7c 0x2>,
+		  <0x9f08 &gic_its 0x0a7e 0x2>,
+		  <0xa000 &gic_its 0x0a80 0x2>,
+		  <0xa008 &gic_its 0x0a82 0x2>,
+		  <0xa100 &gic_its 0x0a84 0x2>,
+		  <0xa108 &gic_its 0x0a86 0x2>,
+		  <0xa200 &gic_its 0x0a88 0x2>,
+		  <0xa208 &gic_its 0x0a8a 0x2>,
+		  <0xa300 &gic_its 0x0a8c 0x2>,
+		  <0xa308 &gic_its 0x0a8e 0x2>,
+		  <0xa400 &gic_its 0x0a90 0x2>,
+		  <0xa408 &gic_its 0x0a92 0x2>,
+		  <0xa500 &gic_its 0x0a94 0x2>,
+		  <0xa508 &gic_its 0x0a96 0x2>,
+		  <0xa600 &gic_its 0x0a98 0x2>,
+		  <0xa608 &gic_its 0x0a9a 0x2>,
+		  <0xa700 &gic_its 0x0a9c 0x2>,
+		  <0xa708 &gic_its 0x0a9e 0x2>,
+		  <0xa800 &gic_its 0x0aa0 0x2>,
+		  <0xa808 &gic_its 0x0aa2 0x2>,
+		  <0xa900 &gic_its 0x0aa4 0x2>,
+		  <0xa908 &gic_its 0x0aa6 0x2>,
+		  <0xaa00 &gic_its 0x0aa8 0x2>,
+		  <0xaa08 &gic_its 0x0aaa 0x2>,
+		  <0xab00 &gic_its 0x0aac 0x2>,
+		  <0xab08 &gic_its 0x0aae 0x2>,
+		  <0xac00 &gic_its 0x0ab0 0x2>,
+		  <0xac08 &gic_its 0x0ab2 0x2>,
+		  <0xad00 &gic_its 0x0ab4 0x2>,
+		  <0xad08 &gic_its 0x0ab6 0x2>,
+		  <0xae00 &gic_its 0x0ab8 0x2>,
+		  <0xae08 &gic_its 0x0aba 0x2>,
+		  <0xaf00 &gic_its 0x0abc 0x2>,
+		  <0xaf08 &gic_its 0x0abe 0x2>,
+		  <0xb000 &gic_its 0x0ac0 0x2>,
+		  <0xb008 &gic_its 0x0ac2 0x2>,
+		  <0xb100 &gic_its 0x0ac4 0x2>,
+		  <0xb108 &gic_its 0x0ac6 0x2>,
+		  <0xb200 &gic_its 0x0ac8 0x2>,
+		  <0xb208 &gic_its 0x0aca 0x2>,
+		  <0xb300 &gic_its 0x0acc 0x2>,
+		  <0xb308 &gic_its 0x0ace 0x2>,
+		  <0xb400 &gic_its 0x0ad0 0x2>,
+		  <0xb408 &gic_its 0x0ad2 0x2>,
+		  <0xb500 &gic_its 0x0ad4 0x2>,
+		  <0xb508 &gic_its 0x0ad6 0x2>,
+		  <0xb600 &gic_its 0x0ad8 0x2>,
+		  <0xb608 &gic_its 0x0ada 0x2>,
+		  <0xb700 &gic_its 0x0adc 0x2>,
+		  <0xb708 &gic_its 0x0ade 0x2>,
+		  <0xb800 &gic_its 0x0ae0 0x2>,
+		  <0xb808 &gic_its 0x0ae2 0x2>,
+		  <0xb900 &gic_its 0x0ae4 0x2>,
+		  <0xb908 &gic_its 0x0ae6 0x2>,
+		  <0xba00 &gic_its 0x0ae8 0x2>,
+		  <0xba08 &gic_its 0x0aea 0x2>,
+		  <0xbb00 &gic_its 0x0aec 0x2>,
+		  <0xbb08 &gic_its 0x0aee 0x2>,
+		  <0xbc00 &gic_its 0x0af0 0x2>,
+		  <0xbc08 &gic_its 0x0af2 0x2>,
+		  <0xbd00 &gic_its 0x0af4 0x2>,
+		  <0xbd08 &gic_its 0x0af6 0x2>,
+		  <0xbe00 &gic_its 0x0af8 0x2>,
+		  <0xbe08 &gic_its 0x0afa 0x2>,
+		  <0xbf00 &gic_its 0x0afc 0x2>,
+		  <0xbf08 &gic_its 0x0afe 0x2>,
+		  <0xc000 &gic_its 0x0b00 0x2>,
+		  <0xc008 &gic_its 0x0b02 0x2>,
+		  <0xc100 &gic_its 0x0b04 0x2>,
+		  <0xc108 &gic_its 0x0b06 0x2>,
+		  <0xc200 &gic_its 0x0b08 0x2>,
+		  <0xc208 &gic_its 0x0b0a 0x2>,
+		  <0xc300 &gic_its 0x0b0c 0x2>,
+		  <0xc308 &gic_its 0x0b0e 0x2>,
+		  <0xc400 &gic_its 0x0b10 0x2>,
+		  <0xc408 &gic_its 0x0b12 0x2>,
+		  <0xc500 &gic_its 0x0b14 0x2>,
+		  <0xc508 &gic_its 0x0b16 0x2>,
+		  <0xc600 &gic_its 0x0b18 0x2>,
+		  <0xc608 &gic_its 0x0b1a 0x2>,
+		  <0xc700 &gic_its 0x0b1c 0x2>,
+		  <0xc708 &gic_its 0x0b1e 0x2>,
+		  <0xc800 &gic_its 0x0b20 0x2>,
+		  <0xc808 &gic_its 0x0b22 0x2>,
+		  <0xc900 &gic_its 0x0b24 0x2>,
+		  <0xc908 &gic_its 0x0b26 0x2>,
+		  <0xca00 &gic_its 0x0b28 0x2>,
+		  <0xca08 &gic_its 0x0b2a 0x2>,
+		  <0xcb00 &gic_its 0x0b2c 0x2>,
+		  <0xcb08 &gic_its 0x0b2e 0x2>,
+		  <0xcc00 &gic_its 0x0b30 0x2>,
+		  <0xcc08 &gic_its 0x0b32 0x2>,
+		  <0xcd00 &gic_its 0x0b34 0x2>,
+		  <0xcd08 &gic_its 0x0b36 0x2>,
+		  <0xce00 &gic_its 0x0b38 0x2>,
+		  <0xce08 &gic_its 0x0b3a 0x2>,
+		  <0xcf00 &gic_its 0x0b3c 0x2>,
+		  <0xcf08 &gic_its 0x0b3e 0x2>,
+		  <0xd000 &gic_its 0x0b40 0x2>,
+		  <0xd008 &gic_its 0x0b42 0x2>,
+		  <0xd100 &gic_its 0x0b44 0x2>,
+		  <0xd108 &gic_its 0x0b46 0x2>,
+		  <0xd200 &gic_its 0x0b48 0x2>,
+		  <0xd208 &gic_its 0x0b4a 0x2>,
+		  <0xd300 &gic_its 0x0b4c 0x2>,
+		  <0xd308 &gic_its 0x0b4e 0x2>,
+		  <0xd400 &gic_its 0x0b50 0x2>,
+		  <0xd408 &gic_its 0x0b52 0x2>,
+		  <0xd500 &gic_its 0x0b54 0x2>,
+		  <0xd508 &gic_its 0x0b56 0x2>,
+		  <0xd600 &gic_its 0x0b58 0x2>,
+		  <0xd608 &gic_its 0x0b5a 0x2>,
+		  <0xd700 &gic_its 0x0b5c 0x2>,
+		  <0xd708 &gic_its 0x0b5e 0x2>,
+		  <0xd800 &gic_its 0x0b60 0x2>,
+		  <0xd808 &gic_its 0x0b62 0x2>,
+		  <0xd900 &gic_its 0x0b64 0x2>,
+		  <0xd908 &gic_its 0x0b66 0x2>,
+		  <0xda00 &gic_its 0x0b68 0x2>,
+		  <0xda08 &gic_its 0x0b6a 0x2>,
+		  <0xdb00 &gic_its 0x0b6c 0x2>,
+		  <0xdb08 &gic_its 0x0b6e 0x2>,
+		  <0xdc00 &gic_its 0x0b70 0x2>,
+		  <0xdc08 &gic_its 0x0b72 0x2>,
+		  <0xdd00 &gic_its 0x0b74 0x2>,
+		  <0xdd08 &gic_its 0x0b76 0x2>,
+		  <0xde00 &gic_its 0x0b78 0x2>,
+		  <0xde08 &gic_its 0x0b7a 0x2>,
+		  <0xdf00 &gic_its 0x0b7c 0x2>,
+		  <0xdf08 &gic_its 0x0b7e 0x2>,
+		  <0xe000 &gic_its 0x0b80 0x2>,
+		  <0xe008 &gic_its 0x0b82 0x2>,
+		  <0xe100 &gic_its 0x0b84 0x2>,
+		  <0xe108 &gic_its 0x0b86 0x2>,
+		  <0xe200 &gic_its 0x0b88 0x2>,
+		  <0xe208 &gic_its 0x0b8a 0x2>,
+		  <0xe300 &gic_its 0x0b8c 0x2>,
+		  <0xe308 &gic_its 0x0b8e 0x2>,
+		  <0xe400 &gic_its 0x0b90 0x2>,
+		  <0xe408 &gic_its 0x0b92 0x2>,
+		  <0xe500 &gic_its 0x0b94 0x2>,
+		  <0xe508 &gic_its 0x0b96 0x2>,
+		  <0xe600 &gic_its 0x0b98 0x2>,
+		  <0xe608 &gic_its 0x0b9a 0x2>,
+		  <0xe700 &gic_its 0x0b9c 0x2>,
+		  <0xe708 &gic_its 0x0b9e 0x2>,
+		  <0xe800 &gic_its 0x0ba0 0x2>,
+		  <0xe808 &gic_its 0x0ba2 0x2>,
+		  <0xe900 &gic_its 0x0ba4 0x2>,
+		  <0xe908 &gic_its 0x0ba6 0x2>,
+		  <0xea00 &gic_its 0x0ba8 0x2>,
+		  <0xea08 &gic_its 0x0baa 0x2>,
+		  <0xeb00 &gic_its 0x0bac 0x2>,
+		  <0xeb08 &gic_its 0x0bae 0x2>,
+		  <0xec00 &gic_its 0x0bb0 0x2>,
+		  <0xec08 &gic_its 0x0bb2 0x2>,
+		  <0xed00 &gic_its 0x0bb4 0x2>,
+		  <0xed08 &gic_its 0x0bb6 0x2>,
+		  <0xee00 &gic_its 0x0bb8 0x2>,
+		  <0xee08 &gic_its 0x0bba 0x2>,
+		  <0xef00 &gic_its 0x0bbc 0x2>,
+		  <0xef08 &gic_its 0x0bbe 0x2>,
+		  <0xf000 &gic_its 0x0bc0 0x2>,
+		  <0xf008 &gic_its 0x0bc2 0x2>,
+		  <0xf100 &gic_its 0x0bc4 0x2>,
+		  <0xf108 &gic_its 0x0bc6 0x2>,
+		  <0xf200 &gic_its 0x0bc8 0x2>,
+		  <0xf208 &gic_its 0x0bca 0x2>,
+		  <0xf300 &gic_its 0x0bcc 0x2>,
+		  <0xf308 &gic_its 0x0bce 0x2>,
+		  <0xf400 &gic_its 0x0bd0 0x2>,
+		  <0xf408 &gic_its 0x0bd2 0x2>,
+		  <0xf500 &gic_its 0x0bd4 0x2>,
+		  <0xf508 &gic_its 0x0bd6 0x2>,
+		  <0xf600 &gic_its 0x0bd8 0x2>,
+		  <0xf608 &gic_its 0x0bda 0x2>,
+		  <0xf700 &gic_its 0x0bdc 0x2>,
+		  <0xf708 &gic_its 0x0bde 0x2>,
+		  <0xf800 &gic_its 0x0be0 0x2>,
+		  <0xf808 &gic_its 0x0be2 0x2>,
+		  <0xf900 &gic_its 0x0be4 0x2>,
+		  <0xf908 &gic_its 0x0be6 0x2>,
+		  <0xfa00 &gic_its 0x0be8 0x2>,
+		  <0xfa08 &gic_its 0x0bea 0x2>,
+		  <0xfb00 &gic_its 0x0bec 0x2>,
+		  <0xfb08 &gic_its 0x0bee 0x2>,
+		  <0xfc00 &gic_its 0x0bf0 0x2>,
+		  <0xfc08 &gic_its 0x0bf2 0x2>,
+		  <0xfd00 &gic_its 0x0bf4 0x2>,
+		  <0xfd08 &gic_its 0x0bf6 0x2>,
+		  <0xfe00 &gic_its 0x0bf8 0x2>,
+		  <0xfe08 &gic_its 0x0bfa 0x2>,
+		  <0xff00 &gic_its 0x0bfc 0x2>,
+		  <0xff08 &gic_its 0x0bfe 0x2>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x0800 0x2>,
+		    <0x0008 &smmu 0x0802 0x2>,
+		    <0x0100 &smmu 0x0804 0x2>,
+		    <0x0108 &smmu 0x0806 0x2>,
+		    <0x0200 &smmu 0x0808 0x2>,
+		    <0x0208 &smmu 0x080a 0x2>,
+		    <0x0300 &smmu 0x080c 0x2>,
+		    <0x0308 &smmu 0x080e 0x2>,
+		    <0x0400 &smmu 0x0810 0x2>,
+		    <0x0408 &smmu 0x0812 0x2>,
+		    <0x0500 &smmu 0x0814 0x2>,
+		    <0x0508 &smmu 0x0816 0x2>,
+		    <0x0600 &smmu 0x0818 0x2>,
+		    <0x0608 &smmu 0x081a 0x2>,
+		    <0x0700 &smmu 0x081c 0x2>,
+		    <0x0708 &smmu 0x081e 0x2>,
+		    <0x0800 &smmu 0x0820 0x2>,
+		    <0x0808 &smmu 0x0822 0x2>,
+		    <0x0900 &smmu 0x0824 0x2>,
+		    <0x0908 &smmu 0x0826 0x2>,
+		    <0x0a00 &smmu 0x0828 0x2>,
+		    <0x0a08 &smmu 0x082a 0x2>,
+		    <0x0b00 &smmu 0x082c 0x2>,
+		    <0x0b08 &smmu 0x082e 0x2>,
+		    <0x0c00 &smmu 0x0830 0x2>,
+		    <0x0c08 &smmu 0x0832 0x2>,
+		    <0x0d00 &smmu 0x0834 0x2>,
+		    <0x0d08 &smmu 0x0836 0x2>,
+		    <0x0e00 &smmu 0x0838 0x2>,
+		    <0x0e08 &smmu 0x083a 0x2>,
+		    <0x0f00 &smmu 0x083c 0x2>,
+		    <0x0f08 &smmu 0x083e 0x2>,
+		    <0x1000 &smmu 0x0840 0x2>,
+		    <0x1008 &smmu 0x0842 0x2>,
+		    <0x1100 &smmu 0x0844 0x2>,
+		    <0x1108 &smmu 0x0846 0x2>,
+		    <0x1200 &smmu 0x0848 0x2>,
+		    <0x1208 &smmu 0x084a 0x2>,
+		    <0x1300 &smmu 0x084c 0x2>,
+		    <0x1308 &smmu 0x084e 0x2>,
+		    <0x1400 &smmu 0x0850 0x2>,
+		    <0x1408 &smmu 0x0852 0x2>,
+		    <0x1500 &smmu 0x0854 0x2>,
+		    <0x1508 &smmu 0x0856 0x2>,
+		    <0x1600 &smmu 0x0858 0x2>,
+		    <0x1608 &smmu 0x085a 0x2>,
+		    <0x1700 &smmu 0x085c 0x2>,
+		    <0x1708 &smmu 0x085e 0x2>,
+		    <0x1800 &smmu 0x0860 0x2>,
+		    <0x1808 &smmu 0x0862 0x2>,
+		    <0x1900 &smmu 0x0864 0x2>,
+		    <0x1908 &smmu 0x0866 0x2>,
+		    <0x1a00 &smmu 0x0868 0x2>,
+		    <0x1a08 &smmu 0x086a 0x2>,
+		    <0x1b00 &smmu 0x086c 0x2>,
+		    <0x1b08 &smmu 0x086e 0x2>,
+		    <0x1c00 &smmu 0x0870 0x2>,
+		    <0x1c08 &smmu 0x0872 0x2>,
+		    <0x1d00 &smmu 0x0874 0x2>,
+		    <0x1d08 &smmu 0x0876 0x2>,
+		    <0x1e00 &smmu 0x0878 0x2>,
+		    <0x1e08 &smmu 0x087a 0x2>,
+		    <0x1f00 &smmu 0x087c 0x2>,
+		    <0x1f08 &smmu 0x087e 0x2>,
+		    <0x2000 &smmu 0x0880 0x2>,
+		    <0x2008 &smmu 0x0882 0x2>,
+		    <0x2100 &smmu 0x0884 0x2>,
+		    <0x2108 &smmu 0x0886 0x2>,
+		    <0x2200 &smmu 0x0888 0x2>,
+		    <0x2208 &smmu 0x088a 0x2>,
+		    <0x2300 &smmu 0x088c 0x2>,
+		    <0x2308 &smmu 0x088e 0x2>,
+		    <0x2400 &smmu 0x0890 0x2>,
+		    <0x2408 &smmu 0x0892 0x2>,
+		    <0x2500 &smmu 0x0894 0x2>,
+		    <0x2508 &smmu 0x0896 0x2>,
+		    <0x2600 &smmu 0x0898 0x2>,
+		    <0x2608 &smmu 0x089a 0x2>,
+		    <0x2700 &smmu 0x089c 0x2>,
+		    <0x2708 &smmu 0x089e 0x2>,
+		    <0x2800 &smmu 0x08a0 0x2>,
+		    <0x2808 &smmu 0x08a2 0x2>,
+		    <0x2900 &smmu 0x08a4 0x2>,
+		    <0x2908 &smmu 0x08a6 0x2>,
+		    <0x2a00 &smmu 0x08a8 0x2>,
+		    <0x2a08 &smmu 0x08aa 0x2>,
+		    <0x2b00 &smmu 0x08ac 0x2>,
+		    <0x2b08 &smmu 0x08ae 0x2>,
+		    <0x2c00 &smmu 0x08b0 0x2>,
+		    <0x2c08 &smmu 0x08b2 0x2>,
+		    <0x2d00 &smmu 0x08b4 0x2>,
+		    <0x2d08 &smmu 0x08b6 0x2>,
+		    <0x2e00 &smmu 0x08b8 0x2>,
+		    <0x2e08 &smmu 0x08ba 0x2>,
+		    <0x2f00 &smmu 0x08bc 0x2>,
+		    <0x2f08 &smmu 0x08be 0x2>,
+		    <0x3000 &smmu 0x08c0 0x2>,
+		    <0x3008 &smmu 0x08c2 0x2>,
+		    <0x3100 &smmu 0x08c4 0x2>,
+		    <0x3108 &smmu 0x08c6 0x2>,
+		    <0x3200 &smmu 0x08c8 0x2>,
+		    <0x3208 &smmu 0x08ca 0x2>,
+		    <0x3300 &smmu 0x08cc 0x2>,
+		    <0x3308 &smmu 0x08ce 0x2>,
+		    <0x3400 &smmu 0x08d0 0x2>,
+		    <0x3408 &smmu 0x08d2 0x2>,
+		    <0x3500 &smmu 0x08d4 0x2>,
+		    <0x3508 &smmu 0x08d6 0x2>,
+		    <0x3600 &smmu 0x08d8 0x2>,
+		    <0x3608 &smmu 0x08da 0x2>,
+		    <0x3700 &smmu 0x08dc 0x2>,
+		    <0x3708 &smmu 0x08de 0x2>,
+		    <0x3800 &smmu 0x08e0 0x2>,
+		    <0x3808 &smmu 0x08e2 0x2>,
+		    <0x3900 &smmu 0x08e4 0x2>,
+		    <0x3908 &smmu 0x08e6 0x2>,
+		    <0x3a00 &smmu 0x08e8 0x2>,
+		    <0x3a08 &smmu 0x08ea 0x2>,
+		    <0x3b00 &smmu 0x08ec 0x2>,
+		    <0x3b08 &smmu 0x08ee 0x2>,
+		    <0x3c00 &smmu 0x08f0 0x2>,
+		    <0x3c08 &smmu 0x08f2 0x2>,
+		    <0x3d00 &smmu 0x08f4 0x2>,
+		    <0x3d08 &smmu 0x08f6 0x2>,
+		    <0x3e00 &smmu 0x08f8 0x2>,
+		    <0x3e08 &smmu 0x08fa 0x2>,
+		    <0x3f00 &smmu 0x08fc 0x2>,
+		    <0x3f08 &smmu 0x08fe 0x2>,
+		    <0x4000 &smmu 0x0900 0x2>,
+		    <0x4008 &smmu 0x0902 0x2>,
+		    <0x4100 &smmu 0x0904 0x2>,
+		    <0x4108 &smmu 0x0906 0x2>,
+		    <0x4200 &smmu 0x0908 0x2>,
+		    <0x4208 &smmu 0x090a 0x2>,
+		    <0x4300 &smmu 0x090c 0x2>,
+		    <0x4308 &smmu 0x090e 0x2>,
+		    <0x4400 &smmu 0x0910 0x2>,
+		    <0x4408 &smmu 0x0912 0x2>,
+		    <0x4500 &smmu 0x0914 0x2>,
+		    <0x4508 &smmu 0x0916 0x2>,
+		    <0x4600 &smmu 0x0918 0x2>,
+		    <0x4608 &smmu 0x091a 0x2>,
+		    <0x4700 &smmu 0x091c 0x2>,
+		    <0x4708 &smmu 0x091e 0x2>,
+		    <0x4800 &smmu 0x0920 0x2>,
+		    <0x4808 &smmu 0x0922 0x2>,
+		    <0x4900 &smmu 0x0924 0x2>,
+		    <0x4908 &smmu 0x0926 0x2>,
+		    <0x4a00 &smmu 0x0928 0x2>,
+		    <0x4a08 &smmu 0x092a 0x2>,
+		    <0x4b00 &smmu 0x092c 0x2>,
+		    <0x4b08 &smmu 0x092e 0x2>,
+		    <0x4c00 &smmu 0x0930 0x2>,
+		    <0x4c08 &smmu 0x0932 0x2>,
+		    <0x4d00 &smmu 0x0934 0x2>,
+		    <0x4d08 &smmu 0x0936 0x2>,
+		    <0x4e00 &smmu 0x0938 0x2>,
+		    <0x4e08 &smmu 0x093a 0x2>,
+		    <0x4f00 &smmu 0x093c 0x2>,
+		    <0x4f08 &smmu 0x093e 0x2>,
+		    <0x5000 &smmu 0x0940 0x2>,
+		    <0x5008 &smmu 0x0942 0x2>,
+		    <0x5100 &smmu 0x0944 0x2>,
+		    <0x5108 &smmu 0x0946 0x2>,
+		    <0x5200 &smmu 0x0948 0x2>,
+		    <0x5208 &smmu 0x094a 0x2>,
+		    <0x5300 &smmu 0x094c 0x2>,
+		    <0x5308 &smmu 0x094e 0x2>,
+		    <0x5400 &smmu 0x0950 0x2>,
+		    <0x5408 &smmu 0x0952 0x2>,
+		    <0x5500 &smmu 0x0954 0x2>,
+		    <0x5508 &smmu 0x0956 0x2>,
+		    <0x5600 &smmu 0x0958 0x2>,
+		    <0x5608 &smmu 0x095a 0x2>,
+		    <0x5700 &smmu 0x095c 0x2>,
+		    <0x5708 &smmu 0x095e 0x2>,
+		    <0x5800 &smmu 0x0960 0x2>,
+		    <0x5808 &smmu 0x0962 0x2>,
+		    <0x5900 &smmu 0x0964 0x2>,
+		    <0x5908 &smmu 0x0966 0x2>,
+		    <0x5a00 &smmu 0x0968 0x2>,
+		    <0x5a08 &smmu 0x096a 0x2>,
+		    <0x5b00 &smmu 0x096c 0x2>,
+		    <0x5b08 &smmu 0x096e 0x2>,
+		    <0x5c00 &smmu 0x0970 0x2>,
+		    <0x5c08 &smmu 0x0972 0x2>,
+		    <0x5d00 &smmu 0x0974 0x2>,
+		    <0x5d08 &smmu 0x0976 0x2>,
+		    <0x5e00 &smmu 0x0978 0x2>,
+		    <0x5e08 &smmu 0x097a 0x2>,
+		    <0x5f00 &smmu 0x097c 0x2>,
+		    <0x5f08 &smmu 0x097e 0x2>,
+		    <0x6000 &smmu 0x0980 0x2>,
+		    <0x6008 &smmu 0x0982 0x2>,
+		    <0x6100 &smmu 0x0984 0x2>,
+		    <0x6108 &smmu 0x0986 0x2>,
+		    <0x6200 &smmu 0x0988 0x2>,
+		    <0x6208 &smmu 0x098a 0x2>,
+		    <0x6300 &smmu 0x098c 0x2>,
+		    <0x6308 &smmu 0x098e 0x2>,
+		    <0x6400 &smmu 0x0990 0x2>,
+		    <0x6408 &smmu 0x0992 0x2>,
+		    <0x6500 &smmu 0x0994 0x2>,
+		    <0x6508 &smmu 0x0996 0x2>,
+		    <0x6600 &smmu 0x0998 0x2>,
+		    <0x6608 &smmu 0x099a 0x2>,
+		    <0x6700 &smmu 0x099c 0x2>,
+		    <0x6708 &smmu 0x099e 0x2>,
+		    <0x6800 &smmu 0x09a0 0x2>,
+		    <0x6808 &smmu 0x09a2 0x2>,
+		    <0x6900 &smmu 0x09a4 0x2>,
+		    <0x6908 &smmu 0x09a6 0x2>,
+		    <0x6a00 &smmu 0x09a8 0x2>,
+		    <0x6a08 &smmu 0x09aa 0x2>,
+		    <0x6b00 &smmu 0x09ac 0x2>,
+		    <0x6b08 &smmu 0x09ae 0x2>,
+		    <0x6c00 &smmu 0x09b0 0x2>,
+		    <0x6c08 &smmu 0x09b2 0x2>,
+		    <0x6d00 &smmu 0x09b4 0x2>,
+		    <0x6d08 &smmu 0x09b6 0x2>,
+		    <0x6e00 &smmu 0x09b8 0x2>,
+		    <0x6e08 &smmu 0x09ba 0x2>,
+		    <0x6f00 &smmu 0x09bc 0x2>,
+		    <0x6f08 &smmu 0x09be 0x2>,
+		    <0x7000 &smmu 0x09c0 0x2>,
+		    <0x7008 &smmu 0x09c2 0x2>,
+		    <0x7100 &smmu 0x09c4 0x2>,
+		    <0x7108 &smmu 0x09c6 0x2>,
+		    <0x7200 &smmu 0x09c8 0x2>,
+		    <0x7208 &smmu 0x09ca 0x2>,
+		    <0x7300 &smmu 0x09cc 0x2>,
+		    <0x7308 &smmu 0x09ce 0x2>,
+		    <0x7400 &smmu 0x09d0 0x2>,
+		    <0x7408 &smmu 0x09d2 0x2>,
+		    <0x7500 &smmu 0x09d4 0x2>,
+		    <0x7508 &smmu 0x09d6 0x2>,
+		    <0x7600 &smmu 0x09d8 0x2>,
+		    <0x7608 &smmu 0x09da 0x2>,
+		    <0x7700 &smmu 0x09dc 0x2>,
+		    <0x7708 &smmu 0x09de 0x2>,
+		    <0x7800 &smmu 0x09e0 0x2>,
+		    <0x7808 &smmu 0x09e2 0x2>,
+		    <0x7900 &smmu 0x09e4 0x2>,
+		    <0x7908 &smmu 0x09e6 0x2>,
+		    <0x7a00 &smmu 0x09e8 0x2>,
+		    <0x7a08 &smmu 0x09ea 0x2>,
+		    <0x7b00 &smmu 0x09ec 0x2>,
+		    <0x7b08 &smmu 0x09ee 0x2>,
+		    <0x7c00 &smmu 0x09f0 0x2>,
+		    <0x7c08 &smmu 0x09f2 0x2>,
+		    <0x7d00 &smmu 0x09f4 0x2>,
+		    <0x7d08 &smmu 0x09f6 0x2>,
+		    <0x7e00 &smmu 0x09f8 0x2>,
+		    <0x7e08 &smmu 0x09fa 0x2>,
+		    <0x7f00 &smmu 0x09fc 0x2>,
+		    <0x7f08 &smmu 0x09fe 0x2>,
+		    <0x8000 &smmu 0x0a00 0x2>,
+		    <0x8008 &smmu 0x0a02 0x2>,
+		    <0x8100 &smmu 0x0a04 0x2>,
+		    <0x8108 &smmu 0x0a06 0x2>,
+		    <0x8200 &smmu 0x0a08 0x2>,
+		    <0x8208 &smmu 0x0a0a 0x2>,
+		    <0x8300 &smmu 0x0a0c 0x2>,
+		    <0x8308 &smmu 0x0a0e 0x2>,
+		    <0x8400 &smmu 0x0a10 0x2>,
+		    <0x8408 &smmu 0x0a12 0x2>,
+		    <0x8500 &smmu 0x0a14 0x2>,
+		    <0x8508 &smmu 0x0a16 0x2>,
+		    <0x8600 &smmu 0x0a18 0x2>,
+		    <0x8608 &smmu 0x0a1a 0x2>,
+		    <0x8700 &smmu 0x0a1c 0x2>,
+		    <0x8708 &smmu 0x0a1e 0x2>,
+		    <0x8800 &smmu 0x0a20 0x2>,
+		    <0x8808 &smmu 0x0a22 0x2>,
+		    <0x8900 &smmu 0x0a24 0x2>,
+		    <0x8908 &smmu 0x0a26 0x2>,
+		    <0x8a00 &smmu 0x0a28 0x2>,
+		    <0x8a08 &smmu 0x0a2a 0x2>,
+		    <0x8b00 &smmu 0x0a2c 0x2>,
+		    <0x8b08 &smmu 0x0a2e 0x2>,
+		    <0x8c00 &smmu 0x0a30 0x2>,
+		    <0x8c08 &smmu 0x0a32 0x2>,
+		    <0x8d00 &smmu 0x0a34 0x2>,
+		    <0x8d08 &smmu 0x0a36 0x2>,
+		    <0x8e00 &smmu 0x0a38 0x2>,
+		    <0x8e08 &smmu 0x0a3a 0x2>,
+		    <0x8f00 &smmu 0x0a3c 0x2>,
+		    <0x8f08 &smmu 0x0a3e 0x2>,
+		    <0x9000 &smmu 0x0a40 0x2>,
+		    <0x9008 &smmu 0x0a42 0x2>,
+		    <0x9100 &smmu 0x0a44 0x2>,
+		    <0x9108 &smmu 0x0a46 0x2>,
+		    <0x9200 &smmu 0x0a48 0x2>,
+		    <0x9208 &smmu 0x0a4a 0x2>,
+		    <0x9300 &smmu 0x0a4c 0x2>,
+		    <0x9308 &smmu 0x0a4e 0x2>,
+		    <0x9400 &smmu 0x0a50 0x2>,
+		    <0x9408 &smmu 0x0a52 0x2>,
+		    <0x9500 &smmu 0x0a54 0x2>,
+		    <0x9508 &smmu 0x0a56 0x2>,
+		    <0x9600 &smmu 0x0a58 0x2>,
+		    <0x9608 &smmu 0x0a5a 0x2>,
+		    <0x9700 &smmu 0x0a5c 0x2>,
+		    <0x9708 &smmu 0x0a5e 0x2>,
+		    <0x9800 &smmu 0x0a60 0x2>,
+		    <0x9808 &smmu 0x0a62 0x2>,
+		    <0x9900 &smmu 0x0a64 0x2>,
+		    <0x9908 &smmu 0x0a66 0x2>,
+		    <0x9a00 &smmu 0x0a68 0x2>,
+		    <0x9a08 &smmu 0x0a6a 0x2>,
+		    <0x9b00 &smmu 0x0a6c 0x2>,
+		    <0x9b08 &smmu 0x0a6e 0x2>,
+		    <0x9c00 &smmu 0x0a70 0x2>,
+		    <0x9c08 &smmu 0x0a72 0x2>,
+		    <0x9d00 &smmu 0x0a74 0x2>,
+		    <0x9d08 &smmu 0x0a76 0x2>,
+		    <0x9e00 &smmu 0x0a78 0x2>,
+		    <0x9e08 &smmu 0x0a7a 0x2>,
+		    <0x9f00 &smmu 0x0a7c 0x2>,
+		    <0x9f08 &smmu 0x0a7e 0x2>,
+		    <0xa000 &smmu 0x0a80 0x2>,
+		    <0xa008 &smmu 0x0a82 0x2>,
+		    <0xa100 &smmu 0x0a84 0x2>,
+		    <0xa108 &smmu 0x0a86 0x2>,
+		    <0xa200 &smmu 0x0a88 0x2>,
+		    <0xa208 &smmu 0x0a8a 0x2>,
+		    <0xa300 &smmu 0x0a8c 0x2>,
+		    <0xa308 &smmu 0x0a8e 0x2>,
+		    <0xa400 &smmu 0x0a90 0x2>,
+		    <0xa408 &smmu 0x0a92 0x2>,
+		    <0xa500 &smmu 0x0a94 0x2>,
+		    <0xa508 &smmu 0x0a96 0x2>,
+		    <0xa600 &smmu 0x0a98 0x2>,
+		    <0xa608 &smmu 0x0a9a 0x2>,
+		    <0xa700 &smmu 0x0a9c 0x2>,
+		    <0xa708 &smmu 0x0a9e 0x2>,
+		    <0xa800 &smmu 0x0aa0 0x2>,
+		    <0xa808 &smmu 0x0aa2 0x2>,
+		    <0xa900 &smmu 0x0aa4 0x2>,
+		    <0xa908 &smmu 0x0aa6 0x2>,
+		    <0xaa00 &smmu 0x0aa8 0x2>,
+		    <0xaa08 &smmu 0x0aaa 0x2>,
+		    <0xab00 &smmu 0x0aac 0x2>,
+		    <0xab08 &smmu 0x0aae 0x2>,
+		    <0xac00 &smmu 0x0ab0 0x2>,
+		    <0xac08 &smmu 0x0ab2 0x2>,
+		    <0xad00 &smmu 0x0ab4 0x2>,
+		    <0xad08 &smmu 0x0ab6 0x2>,
+		    <0xae00 &smmu 0x0ab8 0x2>,
+		    <0xae08 &smmu 0x0aba 0x2>,
+		    <0xaf00 &smmu 0x0abc 0x2>,
+		    <0xaf08 &smmu 0x0abe 0x2>,
+		    <0xb000 &smmu 0x0ac0 0x2>,
+		    <0xb008 &smmu 0x0ac2 0x2>,
+		    <0xb100 &smmu 0x0ac4 0x2>,
+		    <0xb108 &smmu 0x0ac6 0x2>,
+		    <0xb200 &smmu 0x0ac8 0x2>,
+		    <0xb208 &smmu 0x0aca 0x2>,
+		    <0xb300 &smmu 0x0acc 0x2>,
+		    <0xb308 &smmu 0x0ace 0x2>,
+		    <0xb400 &smmu 0x0ad0 0x2>,
+		    <0xb408 &smmu 0x0ad2 0x2>,
+		    <0xb500 &smmu 0x0ad4 0x2>,
+		    <0xb508 &smmu 0x0ad6 0x2>,
+		    <0xb600 &smmu 0x0ad8 0x2>,
+		    <0xb608 &smmu 0x0ada 0x2>,
+		    <0xb700 &smmu 0x0adc 0x2>,
+		    <0xb708 &smmu 0x0ade 0x2>,
+		    <0xb800 &smmu 0x0ae0 0x2>,
+		    <0xb808 &smmu 0x0ae2 0x2>,
+		    <0xb900 &smmu 0x0ae4 0x2>,
+		    <0xb908 &smmu 0x0ae6 0x2>,
+		    <0xba00 &smmu 0x0ae8 0x2>,
+		    <0xba08 &smmu 0x0aea 0x2>,
+		    <0xbb00 &smmu 0x0aec 0x2>,
+		    <0xbb08 &smmu 0x0aee 0x2>,
+		    <0xbc00 &smmu 0x0af0 0x2>,
+		    <0xbc08 &smmu 0x0af2 0x2>,
+		    <0xbd00 &smmu 0x0af4 0x2>,
+		    <0xbd08 &smmu 0x0af6 0x2>,
+		    <0xbe00 &smmu 0x0af8 0x2>,
+		    <0xbe08 &smmu 0x0afa 0x2>,
+		    <0xbf00 &smmu 0x0afc 0x2>,
+		    <0xbf08 &smmu 0x0afe 0x2>,
+		    <0xc000 &smmu 0x0b00 0x2>,
+		    <0xc008 &smmu 0x0b02 0x2>,
+		    <0xc100 &smmu 0x0b04 0x2>,
+		    <0xc108 &smmu 0x0b06 0x2>,
+		    <0xc200 &smmu 0x0b08 0x2>,
+		    <0xc208 &smmu 0x0b0a 0x2>,
+		    <0xc300 &smmu 0x0b0c 0x2>,
+		    <0xc308 &smmu 0x0b0e 0x2>,
+		    <0xc400 &smmu 0x0b10 0x2>,
+		    <0xc408 &smmu 0x0b12 0x2>,
+		    <0xc500 &smmu 0x0b14 0x2>,
+		    <0xc508 &smmu 0x0b16 0x2>,
+		    <0xc600 &smmu 0x0b18 0x2>,
+		    <0xc608 &smmu 0x0b1a 0x2>,
+		    <0xc700 &smmu 0x0b1c 0x2>,
+		    <0xc708 &smmu 0x0b1e 0x2>,
+		    <0xc800 &smmu 0x0b20 0x2>,
+		    <0xc808 &smmu 0x0b22 0x2>,
+		    <0xc900 &smmu 0x0b24 0x2>,
+		    <0xc908 &smmu 0x0b26 0x2>,
+		    <0xca00 &smmu 0x0b28 0x2>,
+		    <0xca08 &smmu 0x0b2a 0x2>,
+		    <0xcb00 &smmu 0x0b2c 0x2>,
+		    <0xcb08 &smmu 0x0b2e 0x2>,
+		    <0xcc00 &smmu 0x0b30 0x2>,
+		    <0xcc08 &smmu 0x0b32 0x2>,
+		    <0xcd00 &smmu 0x0b34 0x2>,
+		    <0xcd08 &smmu 0x0b36 0x2>,
+		    <0xce00 &smmu 0x0b38 0x2>,
+		    <0xce08 &smmu 0x0b3a 0x2>,
+		    <0xcf00 &smmu 0x0b3c 0x2>,
+		    <0xcf08 &smmu 0x0b3e 0x2>,
+		    <0xd000 &smmu 0x0b40 0x2>,
+		    <0xd008 &smmu 0x0b42 0x2>,
+		    <0xd100 &smmu 0x0b44 0x2>,
+		    <0xd108 &smmu 0x0b46 0x2>,
+		    <0xd200 &smmu 0x0b48 0x2>,
+		    <0xd208 &smmu 0x0b4a 0x2>,
+		    <0xd300 &smmu 0x0b4c 0x2>,
+		    <0xd308 &smmu 0x0b4e 0x2>,
+		    <0xd400 &smmu 0x0b50 0x2>,
+		    <0xd408 &smmu 0x0b52 0x2>,
+		    <0xd500 &smmu 0x0b54 0x2>,
+		    <0xd508 &smmu 0x0b56 0x2>,
+		    <0xd600 &smmu 0x0b58 0x2>,
+		    <0xd608 &smmu 0x0b5a 0x2>,
+		    <0xd700 &smmu 0x0b5c 0x2>,
+		    <0xd708 &smmu 0x0b5e 0x2>,
+		    <0xd800 &smmu 0x0b60 0x2>,
+		    <0xd808 &smmu 0x0b62 0x2>,
+		    <0xd900 &smmu 0x0b64 0x2>,
+		    <0xd908 &smmu 0x0b66 0x2>,
+		    <0xda00 &smmu 0x0b68 0x2>,
+		    <0xda08 &smmu 0x0b6a 0x2>,
+		    <0xdb00 &smmu 0x0b6c 0x2>,
+		    <0xdb08 &smmu 0x0b6e 0x2>,
+		    <0xdc00 &smmu 0x0b70 0x2>,
+		    <0xdc08 &smmu 0x0b72 0x2>,
+		    <0xdd00 &smmu 0x0b74 0x2>,
+		    <0xdd08 &smmu 0x0b76 0x2>,
+		    <0xde00 &smmu 0x0b78 0x2>,
+		    <0xde08 &smmu 0x0b7a 0x2>,
+		    <0xdf00 &smmu 0x0b7c 0x2>,
+		    <0xdf08 &smmu 0x0b7e 0x2>,
+		    <0xe000 &smmu 0x0b80 0x2>,
+		    <0xe008 &smmu 0x0b82 0x2>,
+		    <0xe100 &smmu 0x0b84 0x2>,
+		    <0xe108 &smmu 0x0b86 0x2>,
+		    <0xe200 &smmu 0x0b88 0x2>,
+		    <0xe208 &smmu 0x0b8a 0x2>,
+		    <0xe300 &smmu 0x0b8c 0x2>,
+		    <0xe308 &smmu 0x0b8e 0x2>,
+		    <0xe400 &smmu 0x0b90 0x2>,
+		    <0xe408 &smmu 0x0b92 0x2>,
+		    <0xe500 &smmu 0x0b94 0x2>,
+		    <0xe508 &smmu 0x0b96 0x2>,
+		    <0xe600 &smmu 0x0b98 0x2>,
+		    <0xe608 &smmu 0x0b9a 0x2>,
+		    <0xe700 &smmu 0x0b9c 0x2>,
+		    <0xe708 &smmu 0x0b9e 0x2>,
+		    <0xe800 &smmu 0x0ba0 0x2>,
+		    <0xe808 &smmu 0x0ba2 0x2>,
+		    <0xe900 &smmu 0x0ba4 0x2>,
+		    <0xe908 &smmu 0x0ba6 0x2>,
+		    <0xea00 &smmu 0x0ba8 0x2>,
+		    <0xea08 &smmu 0x0baa 0x2>,
+		    <0xeb00 &smmu 0x0bac 0x2>,
+		    <0xeb08 &smmu 0x0bae 0x2>,
+		    <0xec00 &smmu 0x0bb0 0x2>,
+		    <0xec08 &smmu 0x0bb2 0x2>,
+		    <0xed00 &smmu 0x0bb4 0x2>,
+		    <0xed08 &smmu 0x0bb6 0x2>,
+		    <0xee00 &smmu 0x0bb8 0x2>,
+		    <0xee08 &smmu 0x0bba 0x2>,
+		    <0xef00 &smmu 0x0bbc 0x2>,
+		    <0xef08 &smmu 0x0bbe 0x2>,
+		    <0xf000 &smmu 0x0bc0 0x2>,
+		    <0xf008 &smmu 0x0bc2 0x2>,
+		    <0xf100 &smmu 0x0bc4 0x2>,
+		    <0xf108 &smmu 0x0bc6 0x2>,
+		    <0xf200 &smmu 0x0bc8 0x2>,
+		    <0xf208 &smmu 0x0bca 0x2>,
+		    <0xf300 &smmu 0x0bcc 0x2>,
+		    <0xf308 &smmu 0x0bce 0x2>,
+		    <0xf400 &smmu 0x0bd0 0x2>,
+		    <0xf408 &smmu 0x0bd2 0x2>,
+		    <0xf500 &smmu 0x0bd4 0x2>,
+		    <0xf508 &smmu 0x0bd6 0x2>,
+		    <0xf600 &smmu 0x0bd8 0x2>,
+		    <0xf608 &smmu 0x0bda 0x2>,
+		    <0xf700 &smmu 0x0bdc 0x2>,
+		    <0xf708 &smmu 0x0bde 0x2>,
+		    <0xf800 &smmu 0x0be0 0x2>,
+		    <0xf808 &smmu 0x0be2 0x2>,
+		    <0xf900 &smmu 0x0be4 0x2>,
+		    <0xf908 &smmu 0x0be6 0x2>,
+		    <0xfa00 &smmu 0x0be8 0x2>,
+		    <0xfa08 &smmu 0x0bea 0x2>,
+		    <0xfb00 &smmu 0x0bec 0x2>,
+		    <0xfb08 &smmu 0x0bee 0x2>,
+		    <0xfc00 &smmu 0x0bf0 0x2>,
+		    <0xfc08 &smmu 0x0bf2 0x2>,
+		    <0xfd00 &smmu 0x0bf4 0x2>,
+		    <0xfd08 &smmu 0x0bf6 0x2>,
+		    <0xfe00 &smmu 0x0bf8 0x2>,
+		    <0xfe08 &smmu 0x0bfa 0x2>,
+		    <0xff00 &smmu 0x0bfc 0x2>,
+		    <0xff08 &smmu 0x0bfe 0x2>;
+#endif
+};
+
+&pcie3 {
+	msi-map = <0x0000 &gic_its 0x0c00 0x2>,
+		  <0x0008 &gic_its 0x0c02 0x2>,
+		  <0x0100 &gic_its 0x0c04 0x2>,
+		  <0x0108 &gic_its 0x0c06 0x2>,
+		  <0x0200 &gic_its 0x0c08 0x2>,
+		  <0x0208 &gic_its 0x0c0a 0x2>,
+		  <0x0300 &gic_its 0x0c0c 0x2>,
+		  <0x0308 &gic_its 0x0c0e 0x2>,
+		  <0x0400 &gic_its 0x0c10 0x2>,
+		  <0x0408 &gic_its 0x0c12 0x2>,
+		  <0x0500 &gic_its 0x0c14 0x2>,
+		  <0x0508 &gic_its 0x0c16 0x2>,
+		  <0x0600 &gic_its 0x0c18 0x2>,
+		  <0x0608 &gic_its 0x0c1a 0x2>,
+		  <0x0700 &gic_its 0x0c1c 0x2>,
+		  <0x0708 &gic_its 0x0c1e 0x2>,
+		  <0x0800 &gic_its 0x0c20 0x2>,
+		  <0x0808 &gic_its 0x0c22 0x2>,
+		  <0x0900 &gic_its 0x0c24 0x2>,
+		  <0x0908 &gic_its 0x0c26 0x2>,
+		  <0x0a00 &gic_its 0x0c28 0x2>,
+		  <0x0a08 &gic_its 0x0c2a 0x2>,
+		  <0x0b00 &gic_its 0x0c2c 0x2>,
+		  <0x0b08 &gic_its 0x0c2e 0x2>,
+		  <0x0c00 &gic_its 0x0c30 0x2>,
+		  <0x0c08 &gic_its 0x0c32 0x2>,
+		  <0x0d00 &gic_its 0x0c34 0x2>,
+		  <0x0d08 &gic_its 0x0c36 0x2>,
+		  <0x0e00 &gic_its 0x0c38 0x2>,
+		  <0x0e08 &gic_its 0x0c3a 0x2>,
+		  <0x0f00 &gic_its 0x0c3c 0x2>,
+		  <0x0f08 &gic_its 0x0c3e 0x2>,
+		  <0x1000 &gic_its 0x0c40 0x2>,
+		  <0x1008 &gic_its 0x0c42 0x2>,
+		  <0x1100 &gic_its 0x0c44 0x2>,
+		  <0x1108 &gic_its 0x0c46 0x2>,
+		  <0x1200 &gic_its 0x0c48 0x2>,
+		  <0x1208 &gic_its 0x0c4a 0x2>,
+		  <0x1300 &gic_its 0x0c4c 0x2>,
+		  <0x1308 &gic_its 0x0c4e 0x2>,
+		  <0x1400 &gic_its 0x0c50 0x2>,
+		  <0x1408 &gic_its 0x0c52 0x2>,
+		  <0x1500 &gic_its 0x0c54 0x2>,
+		  <0x1508 &gic_its 0x0c56 0x2>,
+		  <0x1600 &gic_its 0x0c58 0x2>,
+		  <0x1608 &gic_its 0x0c5a 0x2>,
+		  <0x1700 &gic_its 0x0c5c 0x2>,
+		  <0x1708 &gic_its 0x0c5e 0x2>,
+		  <0x1800 &gic_its 0x0c60 0x2>,
+		  <0x1808 &gic_its 0x0c62 0x2>,
+		  <0x1900 &gic_its 0x0c64 0x2>,
+		  <0x1908 &gic_its 0x0c66 0x2>,
+		  <0x1a00 &gic_its 0x0c68 0x2>,
+		  <0x1a08 &gic_its 0x0c6a 0x2>,
+		  <0x1b00 &gic_its 0x0c6c 0x2>,
+		  <0x1b08 &gic_its 0x0c6e 0x2>,
+		  <0x1c00 &gic_its 0x0c70 0x2>,
+		  <0x1c08 &gic_its 0x0c72 0x2>,
+		  <0x1d00 &gic_its 0x0c74 0x2>,
+		  <0x1d08 &gic_its 0x0c76 0x2>,
+		  <0x1e00 &gic_its 0x0c78 0x2>,
+		  <0x1e08 &gic_its 0x0c7a 0x2>,
+		  <0x1f00 &gic_its 0x0c7c 0x2>,
+		  <0x1f08 &gic_its 0x0c7e 0x2>,
+		  <0x2000 &gic_its 0x0c80 0x2>,
+		  <0x2008 &gic_its 0x0c82 0x2>,
+		  <0x2100 &gic_its 0x0c84 0x2>,
+		  <0x2108 &gic_its 0x0c86 0x2>,
+		  <0x2200 &gic_its 0x0c88 0x2>,
+		  <0x2208 &gic_its 0x0c8a 0x2>,
+		  <0x2300 &gic_its 0x0c8c 0x2>,
+		  <0x2308 &gic_its 0x0c8e 0x2>,
+		  <0x2400 &gic_its 0x0c90 0x2>,
+		  <0x2408 &gic_its 0x0c92 0x2>,
+		  <0x2500 &gic_its 0x0c94 0x2>,
+		  <0x2508 &gic_its 0x0c96 0x2>,
+		  <0x2600 &gic_its 0x0c98 0x2>,
+		  <0x2608 &gic_its 0x0c9a 0x2>,
+		  <0x2700 &gic_its 0x0c9c 0x2>,
+		  <0x2708 &gic_its 0x0c9e 0x2>,
+		  <0x2800 &gic_its 0x0ca0 0x2>,
+		  <0x2808 &gic_its 0x0ca2 0x2>,
+		  <0x2900 &gic_its 0x0ca4 0x2>,
+		  <0x2908 &gic_its 0x0ca6 0x2>,
+		  <0x2a00 &gic_its 0x0ca8 0x2>,
+		  <0x2a08 &gic_its 0x0caa 0x2>,
+		  <0x2b00 &gic_its 0x0cac 0x2>,
+		  <0x2b08 &gic_its 0x0cae 0x2>,
+		  <0x2c00 &gic_its 0x0cb0 0x2>,
+		  <0x2c08 &gic_its 0x0cb2 0x2>,
+		  <0x2d00 &gic_its 0x0cb4 0x2>,
+		  <0x2d08 &gic_its 0x0cb6 0x2>,
+		  <0x2e00 &gic_its 0x0cb8 0x2>,
+		  <0x2e08 &gic_its 0x0cba 0x2>,
+		  <0x2f00 &gic_its 0x0cbc 0x2>,
+		  <0x2f08 &gic_its 0x0cbe 0x2>,
+		  <0x3000 &gic_its 0x0cc0 0x2>,
+		  <0x3008 &gic_its 0x0cc2 0x2>,
+		  <0x3100 &gic_its 0x0cc4 0x2>,
+		  <0x3108 &gic_its 0x0cc6 0x2>,
+		  <0x3200 &gic_its 0x0cc8 0x2>,
+		  <0x3208 &gic_its 0x0cca 0x2>,
+		  <0x3300 &gic_its 0x0ccc 0x2>,
+		  <0x3308 &gic_its 0x0cce 0x2>,
+		  <0x3400 &gic_its 0x0cd0 0x2>,
+		  <0x3408 &gic_its 0x0cd2 0x2>,
+		  <0x3500 &gic_its 0x0cd4 0x2>,
+		  <0x3508 &gic_its 0x0cd6 0x2>,
+		  <0x3600 &gic_its 0x0cd8 0x2>,
+		  <0x3608 &gic_its 0x0cda 0x2>,
+		  <0x3700 &gic_its 0x0cdc 0x2>,
+		  <0x3708 &gic_its 0x0cde 0x2>,
+		  <0x3800 &gic_its 0x0ce0 0x2>,
+		  <0x3808 &gic_its 0x0ce2 0x2>,
+		  <0x3900 &gic_its 0x0ce4 0x2>,
+		  <0x3908 &gic_its 0x0ce6 0x2>,
+		  <0x3a00 &gic_its 0x0ce8 0x2>,
+		  <0x3a08 &gic_its 0x0cea 0x2>,
+		  <0x3b00 &gic_its 0x0cec 0x2>,
+		  <0x3b08 &gic_its 0x0cee 0x2>,
+		  <0x3c00 &gic_its 0x0cf0 0x2>,
+		  <0x3c08 &gic_its 0x0cf2 0x2>,
+		  <0x3d00 &gic_its 0x0cf4 0x2>,
+		  <0x3d08 &gic_its 0x0cf6 0x2>,
+		  <0x3e00 &gic_its 0x0cf8 0x2>,
+		  <0x3e08 &gic_its 0x0cfa 0x2>,
+		  <0x3f00 &gic_its 0x0cfc 0x2>,
+		  <0x3f08 &gic_its 0x0cfe 0x2>,
+		  <0x4000 &gic_its 0x0d00 0x2>,
+		  <0x4008 &gic_its 0x0d02 0x2>,
+		  <0x4100 &gic_its 0x0d04 0x2>,
+		  <0x4108 &gic_its 0x0d06 0x2>,
+		  <0x4200 &gic_its 0x0d08 0x2>,
+		  <0x4208 &gic_its 0x0d0a 0x2>,
+		  <0x4300 &gic_its 0x0d0c 0x2>,
+		  <0x4308 &gic_its 0x0d0e 0x2>,
+		  <0x4400 &gic_its 0x0d10 0x2>,
+		  <0x4408 &gic_its 0x0d12 0x2>,
+		  <0x4500 &gic_its 0x0d14 0x2>,
+		  <0x4508 &gic_its 0x0d16 0x2>,
+		  <0x4600 &gic_its 0x0d18 0x2>,
+		  <0x4608 &gic_its 0x0d1a 0x2>,
+		  <0x4700 &gic_its 0x0d1c 0x2>,
+		  <0x4708 &gic_its 0x0d1e 0x2>,
+		  <0x4800 &gic_its 0x0d20 0x2>,
+		  <0x4808 &gic_its 0x0d22 0x2>,
+		  <0x4900 &gic_its 0x0d24 0x2>,
+		  <0x4908 &gic_its 0x0d26 0x2>,
+		  <0x4a00 &gic_its 0x0d28 0x2>,
+		  <0x4a08 &gic_its 0x0d2a 0x2>,
+		  <0x4b00 &gic_its 0x0d2c 0x2>,
+		  <0x4b08 &gic_its 0x0d2e 0x2>,
+		  <0x4c00 &gic_its 0x0d30 0x2>,
+		  <0x4c08 &gic_its 0x0d32 0x2>,
+		  <0x4d00 &gic_its 0x0d34 0x2>,
+		  <0x4d08 &gic_its 0x0d36 0x2>,
+		  <0x4e00 &gic_its 0x0d38 0x2>,
+		  <0x4e08 &gic_its 0x0d3a 0x2>,
+		  <0x4f00 &gic_its 0x0d3c 0x2>,
+		  <0x4f08 &gic_its 0x0d3e 0x2>,
+		  <0x5000 &gic_its 0x0d40 0x2>,
+		  <0x5008 &gic_its 0x0d42 0x2>,
+		  <0x5100 &gic_its 0x0d44 0x2>,
+		  <0x5108 &gic_its 0x0d46 0x2>,
+		  <0x5200 &gic_its 0x0d48 0x2>,
+		  <0x5208 &gic_its 0x0d4a 0x2>,
+		  <0x5300 &gic_its 0x0d4c 0x2>,
+		  <0x5308 &gic_its 0x0d4e 0x2>,
+		  <0x5400 &gic_its 0x0d50 0x2>,
+		  <0x5408 &gic_its 0x0d52 0x2>,
+		  <0x5500 &gic_its 0x0d54 0x2>,
+		  <0x5508 &gic_its 0x0d56 0x2>,
+		  <0x5600 &gic_its 0x0d58 0x2>,
+		  <0x5608 &gic_its 0x0d5a 0x2>,
+		  <0x5700 &gic_its 0x0d5c 0x2>,
+		  <0x5708 &gic_its 0x0d5e 0x2>,
+		  <0x5800 &gic_its 0x0d60 0x2>,
+		  <0x5808 &gic_its 0x0d62 0x2>,
+		  <0x5900 &gic_its 0x0d64 0x2>,
+		  <0x5908 &gic_its 0x0d66 0x2>,
+		  <0x5a00 &gic_its 0x0d68 0x2>,
+		  <0x5a08 &gic_its 0x0d6a 0x2>,
+		  <0x5b00 &gic_its 0x0d6c 0x2>,
+		  <0x5b08 &gic_its 0x0d6e 0x2>,
+		  <0x5c00 &gic_its 0x0d70 0x2>,
+		  <0x5c08 &gic_its 0x0d72 0x2>,
+		  <0x5d00 &gic_its 0x0d74 0x2>,
+		  <0x5d08 &gic_its 0x0d76 0x2>,
+		  <0x5e00 &gic_its 0x0d78 0x2>,
+		  <0x5e08 &gic_its 0x0d7a 0x2>,
+		  <0x5f00 &gic_its 0x0d7c 0x2>,
+		  <0x5f08 &gic_its 0x0d7e 0x2>,
+		  <0x6000 &gic_its 0x0d80 0x2>,
+		  <0x6008 &gic_its 0x0d82 0x2>,
+		  <0x6100 &gic_its 0x0d84 0x2>,
+		  <0x6108 &gic_its 0x0d86 0x2>,
+		  <0x6200 &gic_its 0x0d88 0x2>,
+		  <0x6208 &gic_its 0x0d8a 0x2>,
+		  <0x6300 &gic_its 0x0d8c 0x2>,
+		  <0x6308 &gic_its 0x0d8e 0x2>,
+		  <0x6400 &gic_its 0x0d90 0x2>,
+		  <0x6408 &gic_its 0x0d92 0x2>,
+		  <0x6500 &gic_its 0x0d94 0x2>,
+		  <0x6508 &gic_its 0x0d96 0x2>,
+		  <0x6600 &gic_its 0x0d98 0x2>,
+		  <0x6608 &gic_its 0x0d9a 0x2>,
+		  <0x6700 &gic_its 0x0d9c 0x2>,
+		  <0x6708 &gic_its 0x0d9e 0x2>,
+		  <0x6800 &gic_its 0x0da0 0x2>,
+		  <0x6808 &gic_its 0x0da2 0x2>,
+		  <0x6900 &gic_its 0x0da4 0x2>,
+		  <0x6908 &gic_its 0x0da6 0x2>,
+		  <0x6a00 &gic_its 0x0da8 0x2>,
+		  <0x6a08 &gic_its 0x0daa 0x2>,
+		  <0x6b00 &gic_its 0x0dac 0x2>,
+		  <0x6b08 &gic_its 0x0dae 0x2>,
+		  <0x6c00 &gic_its 0x0db0 0x2>,
+		  <0x6c08 &gic_its 0x0db2 0x2>,
+		  <0x6d00 &gic_its 0x0db4 0x2>,
+		  <0x6d08 &gic_its 0x0db6 0x2>,
+		  <0x6e00 &gic_its 0x0db8 0x2>,
+		  <0x6e08 &gic_its 0x0dba 0x2>,
+		  <0x6f00 &gic_its 0x0dbc 0x2>,
+		  <0x6f08 &gic_its 0x0dbe 0x2>,
+		  <0x7000 &gic_its 0x0dc0 0x2>,
+		  <0x7008 &gic_its 0x0dc2 0x2>,
+		  <0x7100 &gic_its 0x0dc4 0x2>,
+		  <0x7108 &gic_its 0x0dc6 0x2>,
+		  <0x7200 &gic_its 0x0dc8 0x2>,
+		  <0x7208 &gic_its 0x0dca 0x2>,
+		  <0x7300 &gic_its 0x0dcc 0x2>,
+		  <0x7308 &gic_its 0x0dce 0x2>,
+		  <0x7400 &gic_its 0x0dd0 0x2>,
+		  <0x7408 &gic_its 0x0dd2 0x2>,
+		  <0x7500 &gic_its 0x0dd4 0x2>,
+		  <0x7508 &gic_its 0x0dd6 0x2>,
+		  <0x7600 &gic_its 0x0dd8 0x2>,
+		  <0x7608 &gic_its 0x0dda 0x2>,
+		  <0x7700 &gic_its 0x0ddc 0x2>,
+		  <0x7708 &gic_its 0x0dde 0x2>,
+		  <0x7800 &gic_its 0x0de0 0x2>,
+		  <0x7808 &gic_its 0x0de2 0x2>,
+		  <0x7900 &gic_its 0x0de4 0x2>,
+		  <0x7908 &gic_its 0x0de6 0x2>,
+		  <0x7a00 &gic_its 0x0de8 0x2>,
+		  <0x7a08 &gic_its 0x0dea 0x2>,
+		  <0x7b00 &gic_its 0x0dec 0x2>,
+		  <0x7b08 &gic_its 0x0dee 0x2>,
+		  <0x7c00 &gic_its 0x0df0 0x2>,
+		  <0x7c08 &gic_its 0x0df2 0x2>,
+		  <0x7d00 &gic_its 0x0df4 0x2>,
+		  <0x7d08 &gic_its 0x0df6 0x2>,
+		  <0x7e00 &gic_its 0x0df8 0x2>,
+		  <0x7e08 &gic_its 0x0dfa 0x2>,
+		  <0x7f00 &gic_its 0x0dfc 0x2>,
+		  <0x7f08 &gic_its 0x0dfe 0x2>,
+		  <0x8000 &gic_its 0x0e00 0x2>,
+		  <0x8008 &gic_its 0x0e02 0x2>,
+		  <0x8100 &gic_its 0x0e04 0x2>,
+		  <0x8108 &gic_its 0x0e06 0x2>,
+		  <0x8200 &gic_its 0x0e08 0x2>,
+		  <0x8208 &gic_its 0x0e0a 0x2>,
+		  <0x8300 &gic_its 0x0e0c 0x2>,
+		  <0x8308 &gic_its 0x0e0e 0x2>,
+		  <0x8400 &gic_its 0x0e10 0x2>,
+		  <0x8408 &gic_its 0x0e12 0x2>,
+		  <0x8500 &gic_its 0x0e14 0x2>,
+		  <0x8508 &gic_its 0x0e16 0x2>,
+		  <0x8600 &gic_its 0x0e18 0x2>,
+		  <0x8608 &gic_its 0x0e1a 0x2>,
+		  <0x8700 &gic_its 0x0e1c 0x2>,
+		  <0x8708 &gic_its 0x0e1e 0x2>,
+		  <0x8800 &gic_its 0x0e20 0x2>,
+		  <0x8808 &gic_its 0x0e22 0x2>,
+		  <0x8900 &gic_its 0x0e24 0x2>,
+		  <0x8908 &gic_its 0x0e26 0x2>,
+		  <0x8a00 &gic_its 0x0e28 0x2>,
+		  <0x8a08 &gic_its 0x0e2a 0x2>,
+		  <0x8b00 &gic_its 0x0e2c 0x2>,
+		  <0x8b08 &gic_its 0x0e2e 0x2>,
+		  <0x8c00 &gic_its 0x0e30 0x2>,
+		  <0x8c08 &gic_its 0x0e32 0x2>,
+		  <0x8d00 &gic_its 0x0e34 0x2>,
+		  <0x8d08 &gic_its 0x0e36 0x2>,
+		  <0x8e00 &gic_its 0x0e38 0x2>,
+		  <0x8e08 &gic_its 0x0e3a 0x2>,
+		  <0x8f00 &gic_its 0x0e3c 0x2>,
+		  <0x8f08 &gic_its 0x0e3e 0x2>,
+		  <0x9000 &gic_its 0x0e40 0x2>,
+		  <0x9008 &gic_its 0x0e42 0x2>,
+		  <0x9100 &gic_its 0x0e44 0x2>,
+		  <0x9108 &gic_its 0x0e46 0x2>,
+		  <0x9200 &gic_its 0x0e48 0x2>,
+		  <0x9208 &gic_its 0x0e4a 0x2>,
+		  <0x9300 &gic_its 0x0e4c 0x2>,
+		  <0x9308 &gic_its 0x0e4e 0x2>,
+		  <0x9400 &gic_its 0x0e50 0x2>,
+		  <0x9408 &gic_its 0x0e52 0x2>,
+		  <0x9500 &gic_its 0x0e54 0x2>,
+		  <0x9508 &gic_its 0x0e56 0x2>,
+		  <0x9600 &gic_its 0x0e58 0x2>,
+		  <0x9608 &gic_its 0x0e5a 0x2>,
+		  <0x9700 &gic_its 0x0e5c 0x2>,
+		  <0x9708 &gic_its 0x0e5e 0x2>,
+		  <0x9800 &gic_its 0x0e60 0x2>,
+		  <0x9808 &gic_its 0x0e62 0x2>,
+		  <0x9900 &gic_its 0x0e64 0x2>,
+		  <0x9908 &gic_its 0x0e66 0x2>,
+		  <0x9a00 &gic_its 0x0e68 0x2>,
+		  <0x9a08 &gic_its 0x0e6a 0x2>,
+		  <0x9b00 &gic_its 0x0e6c 0x2>,
+		  <0x9b08 &gic_its 0x0e6e 0x2>,
+		  <0x9c00 &gic_its 0x0e70 0x2>,
+		  <0x9c08 &gic_its 0x0e72 0x2>,
+		  <0x9d00 &gic_its 0x0e74 0x2>,
+		  <0x9d08 &gic_its 0x0e76 0x2>,
+		  <0x9e00 &gic_its 0x0e78 0x2>,
+		  <0x9e08 &gic_its 0x0e7a 0x2>,
+		  <0x9f00 &gic_its 0x0e7c 0x2>,
+		  <0x9f08 &gic_its 0x0e7e 0x2>,
+		  <0xa000 &gic_its 0x0e80 0x2>,
+		  <0xa008 &gic_its 0x0e82 0x2>,
+		  <0xa100 &gic_its 0x0e84 0x2>,
+		  <0xa108 &gic_its 0x0e86 0x2>,
+		  <0xa200 &gic_its 0x0e88 0x2>,
+		  <0xa208 &gic_its 0x0e8a 0x2>,
+		  <0xa300 &gic_its 0x0e8c 0x2>,
+		  <0xa308 &gic_its 0x0e8e 0x2>,
+		  <0xa400 &gic_its 0x0e90 0x2>,
+		  <0xa408 &gic_its 0x0e92 0x2>,
+		  <0xa500 &gic_its 0x0e94 0x2>,
+		  <0xa508 &gic_its 0x0e96 0x2>,
+		  <0xa600 &gic_its 0x0e98 0x2>,
+		  <0xa608 &gic_its 0x0e9a 0x2>,
+		  <0xa700 &gic_its 0x0e9c 0x2>,
+		  <0xa708 &gic_its 0x0e9e 0x2>,
+		  <0xa800 &gic_its 0x0ea0 0x2>,
+		  <0xa808 &gic_its 0x0ea2 0x2>,
+		  <0xa900 &gic_its 0x0ea4 0x2>,
+		  <0xa908 &gic_its 0x0ea6 0x2>,
+		  <0xaa00 &gic_its 0x0ea8 0x2>,
+		  <0xaa08 &gic_its 0x0eaa 0x2>,
+		  <0xab00 &gic_its 0x0eac 0x2>,
+		  <0xab08 &gic_its 0x0eae 0x2>,
+		  <0xac00 &gic_its 0x0eb0 0x2>,
+		  <0xac08 &gic_its 0x0eb2 0x2>,
+		  <0xad00 &gic_its 0x0eb4 0x2>,
+		  <0xad08 &gic_its 0x0eb6 0x2>,
+		  <0xae00 &gic_its 0x0eb8 0x2>,
+		  <0xae08 &gic_its 0x0eba 0x2>,
+		  <0xaf00 &gic_its 0x0ebc 0x2>,
+		  <0xaf08 &gic_its 0x0ebe 0x2>,
+		  <0xb000 &gic_its 0x0ec0 0x2>,
+		  <0xb008 &gic_its 0x0ec2 0x2>,
+		  <0xb100 &gic_its 0x0ec4 0x2>,
+		  <0xb108 &gic_its 0x0ec6 0x2>,
+		  <0xb200 &gic_its 0x0ec8 0x2>,
+		  <0xb208 &gic_its 0x0eca 0x2>,
+		  <0xb300 &gic_its 0x0ecc 0x2>,
+		  <0xb308 &gic_its 0x0ece 0x2>,
+		  <0xb400 &gic_its 0x0ed0 0x2>,
+		  <0xb408 &gic_its 0x0ed2 0x2>,
+		  <0xb500 &gic_its 0x0ed4 0x2>,
+		  <0xb508 &gic_its 0x0ed6 0x2>,
+		  <0xb600 &gic_its 0x0ed8 0x2>,
+		  <0xb608 &gic_its 0x0eda 0x2>,
+		  <0xb700 &gic_its 0x0edc 0x2>,
+		  <0xb708 &gic_its 0x0ede 0x2>,
+		  <0xb800 &gic_its 0x0ee0 0x2>,
+		  <0xb808 &gic_its 0x0ee2 0x2>,
+		  <0xb900 &gic_its 0x0ee4 0x2>,
+		  <0xb908 &gic_its 0x0ee6 0x2>,
+		  <0xba00 &gic_its 0x0ee8 0x2>,
+		  <0xba08 &gic_its 0x0eea 0x2>,
+		  <0xbb00 &gic_its 0x0eec 0x2>,
+		  <0xbb08 &gic_its 0x0eee 0x2>,
+		  <0xbc00 &gic_its 0x0ef0 0x2>,
+		  <0xbc08 &gic_its 0x0ef2 0x2>,
+		  <0xbd00 &gic_its 0x0ef4 0x2>,
+		  <0xbd08 &gic_its 0x0ef6 0x2>,
+		  <0xbe00 &gic_its 0x0ef8 0x2>,
+		  <0xbe08 &gic_its 0x0efa 0x2>,
+		  <0xbf00 &gic_its 0x0efc 0x2>,
+		  <0xbf08 &gic_its 0x0efe 0x2>,
+		  <0xc000 &gic_its 0x0f00 0x2>,
+		  <0xc008 &gic_its 0x0f02 0x2>,
+		  <0xc100 &gic_its 0x0f04 0x2>,
+		  <0xc108 &gic_its 0x0f06 0x2>,
+		  <0xc200 &gic_its 0x0f08 0x2>,
+		  <0xc208 &gic_its 0x0f0a 0x2>,
+		  <0xc300 &gic_its 0x0f0c 0x2>,
+		  <0xc308 &gic_its 0x0f0e 0x2>,
+		  <0xc400 &gic_its 0x0f10 0x2>,
+		  <0xc408 &gic_its 0x0f12 0x2>,
+		  <0xc500 &gic_its 0x0f14 0x2>,
+		  <0xc508 &gic_its 0x0f16 0x2>,
+		  <0xc600 &gic_its 0x0f18 0x2>,
+		  <0xc608 &gic_its 0x0f1a 0x2>,
+		  <0xc700 &gic_its 0x0f1c 0x2>,
+		  <0xc708 &gic_its 0x0f1e 0x2>,
+		  <0xc800 &gic_its 0x0f20 0x2>,
+		  <0xc808 &gic_its 0x0f22 0x2>,
+		  <0xc900 &gic_its 0x0f24 0x2>,
+		  <0xc908 &gic_its 0x0f26 0x2>,
+		  <0xca00 &gic_its 0x0f28 0x2>,
+		  <0xca08 &gic_its 0x0f2a 0x2>,
+		  <0xcb00 &gic_its 0x0f2c 0x2>,
+		  <0xcb08 &gic_its 0x0f2e 0x2>,
+		  <0xcc00 &gic_its 0x0f30 0x2>,
+		  <0xcc08 &gic_its 0x0f32 0x2>,
+		  <0xcd00 &gic_its 0x0f34 0x2>,
+		  <0xcd08 &gic_its 0x0f36 0x2>,
+		  <0xce00 &gic_its 0x0f38 0x2>,
+		  <0xce08 &gic_its 0x0f3a 0x2>,
+		  <0xcf00 &gic_its 0x0f3c 0x2>,
+		  <0xcf08 &gic_its 0x0f3e 0x2>,
+		  <0xd000 &gic_its 0x0f40 0x2>,
+		  <0xd008 &gic_its 0x0f42 0x2>,
+		  <0xd100 &gic_its 0x0f44 0x2>,
+		  <0xd108 &gic_its 0x0f46 0x2>,
+		  <0xd200 &gic_its 0x0f48 0x2>,
+		  <0xd208 &gic_its 0x0f4a 0x2>,
+		  <0xd300 &gic_its 0x0f4c 0x2>,
+		  <0xd308 &gic_its 0x0f4e 0x2>,
+		  <0xd400 &gic_its 0x0f50 0x2>,
+		  <0xd408 &gic_its 0x0f52 0x2>,
+		  <0xd500 &gic_its 0x0f54 0x2>,
+		  <0xd508 &gic_its 0x0f56 0x2>,
+		  <0xd600 &gic_its 0x0f58 0x2>,
+		  <0xd608 &gic_its 0x0f5a 0x2>,
+		  <0xd700 &gic_its 0x0f5c 0x2>,
+		  <0xd708 &gic_its 0x0f5e 0x2>,
+		  <0xd800 &gic_its 0x0f60 0x2>,
+		  <0xd808 &gic_its 0x0f62 0x2>,
+		  <0xd900 &gic_its 0x0f64 0x2>,
+		  <0xd908 &gic_its 0x0f66 0x2>,
+		  <0xda00 &gic_its 0x0f68 0x2>,
+		  <0xda08 &gic_its 0x0f6a 0x2>,
+		  <0xdb00 &gic_its 0x0f6c 0x2>,
+		  <0xdb08 &gic_its 0x0f6e 0x2>,
+		  <0xdc00 &gic_its 0x0f70 0x2>,
+		  <0xdc08 &gic_its 0x0f72 0x2>,
+		  <0xdd00 &gic_its 0x0f74 0x2>,
+		  <0xdd08 &gic_its 0x0f76 0x2>,
+		  <0xde00 &gic_its 0x0f78 0x2>,
+		  <0xde08 &gic_its 0x0f7a 0x2>,
+		  <0xdf00 &gic_its 0x0f7c 0x2>,
+		  <0xdf08 &gic_its 0x0f7e 0x2>,
+		  <0xe000 &gic_its 0x0f80 0x2>,
+		  <0xe008 &gic_its 0x0f82 0x2>,
+		  <0xe100 &gic_its 0x0f84 0x2>,
+		  <0xe108 &gic_its 0x0f86 0x2>,
+		  <0xe200 &gic_its 0x0f88 0x2>,
+		  <0xe208 &gic_its 0x0f8a 0x2>,
+		  <0xe300 &gic_its 0x0f8c 0x2>,
+		  <0xe308 &gic_its 0x0f8e 0x2>,
+		  <0xe400 &gic_its 0x0f90 0x2>,
+		  <0xe408 &gic_its 0x0f92 0x2>,
+		  <0xe500 &gic_its 0x0f94 0x2>,
+		  <0xe508 &gic_its 0x0f96 0x2>,
+		  <0xe600 &gic_its 0x0f98 0x2>,
+		  <0xe608 &gic_its 0x0f9a 0x2>,
+		  <0xe700 &gic_its 0x0f9c 0x2>,
+		  <0xe708 &gic_its 0x0f9e 0x2>,
+		  <0xe800 &gic_its 0x0fa0 0x2>,
+		  <0xe808 &gic_its 0x0fa2 0x2>,
+		  <0xe900 &gic_its 0x0fa4 0x2>,
+		  <0xe908 &gic_its 0x0fa6 0x2>,
+		  <0xea00 &gic_its 0x0fa8 0x2>,
+		  <0xea08 &gic_its 0x0faa 0x2>,
+		  <0xeb00 &gic_its 0x0fac 0x2>,
+		  <0xeb08 &gic_its 0x0fae 0x2>,
+		  <0xec00 &gic_its 0x0fb0 0x2>,
+		  <0xec08 &gic_its 0x0fb2 0x2>,
+		  <0xed00 &gic_its 0x0fb4 0x2>,
+		  <0xed08 &gic_its 0x0fb6 0x2>,
+		  <0xee00 &gic_its 0x0fb8 0x2>,
+		  <0xee08 &gic_its 0x0fba 0x2>,
+		  <0xef00 &gic_its 0x0fbc 0x2>,
+		  <0xef08 &gic_its 0x0fbe 0x2>,
+		  <0xf000 &gic_its 0x0fc0 0x2>,
+		  <0xf008 &gic_its 0x0fc2 0x2>,
+		  <0xf100 &gic_its 0x0fc4 0x2>,
+		  <0xf108 &gic_its 0x0fc6 0x2>,
+		  <0xf200 &gic_its 0x0fc8 0x2>,
+		  <0xf208 &gic_its 0x0fca 0x2>,
+		  <0xf300 &gic_its 0x0fcc 0x2>,
+		  <0xf308 &gic_its 0x0fce 0x2>,
+		  <0xf400 &gic_its 0x0fd0 0x2>,
+		  <0xf408 &gic_its 0x0fd2 0x2>,
+		  <0xf500 &gic_its 0x0fd4 0x2>,
+		  <0xf508 &gic_its 0x0fd6 0x2>,
+		  <0xf600 &gic_its 0x0fd8 0x2>,
+		  <0xf608 &gic_its 0x0fda 0x2>,
+		  <0xf700 &gic_its 0x0fdc 0x2>,
+		  <0xf708 &gic_its 0x0fde 0x2>,
+		  <0xf800 &gic_its 0x0fe0 0x2>,
+		  <0xf808 &gic_its 0x0fe2 0x2>,
+		  <0xf900 &gic_its 0x0fe4 0x2>,
+		  <0xf908 &gic_its 0x0fe6 0x2>,
+		  <0xfa00 &gic_its 0x0fe8 0x2>,
+		  <0xfa08 &gic_its 0x0fea 0x2>,
+		  <0xfb00 &gic_its 0x0fec 0x2>,
+		  <0xfb08 &gic_its 0x0fee 0x2>,
+		  <0xfc00 &gic_its 0x0ff0 0x2>,
+		  <0xfc08 &gic_its 0x0ff2 0x2>,
+		  <0xfd00 &gic_its 0x0ff4 0x2>,
+		  <0xfd08 &gic_its 0x0ff6 0x2>,
+		  <0xfe00 &gic_its 0x0ff8 0x2>,
+		  <0xfe08 &gic_its 0x0ffa 0x2>,
+		  <0xff00 &gic_its 0x0ffc 0x2>,
+		  <0xff08 &gic_its 0x0ffe 0x2>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x0c00 0x2>,
+		    <0x0008 &smmu 0x0c02 0x2>,
+		    <0x0100 &smmu 0x0c04 0x2>,
+		    <0x0108 &smmu 0x0c06 0x2>,
+		    <0x0200 &smmu 0x0c08 0x2>,
+		    <0x0208 &smmu 0x0c0a 0x2>,
+		    <0x0300 &smmu 0x0c0c 0x2>,
+		    <0x0308 &smmu 0x0c0e 0x2>,
+		    <0x0400 &smmu 0x0c10 0x2>,
+		    <0x0408 &smmu 0x0c12 0x2>,
+		    <0x0500 &smmu 0x0c14 0x2>,
+		    <0x0508 &smmu 0x0c16 0x2>,
+		    <0x0600 &smmu 0x0c18 0x2>,
+		    <0x0608 &smmu 0x0c1a 0x2>,
+		    <0x0700 &smmu 0x0c1c 0x2>,
+		    <0x0708 &smmu 0x0c1e 0x2>,
+		    <0x0800 &smmu 0x0c20 0x2>,
+		    <0x0808 &smmu 0x0c22 0x2>,
+		    <0x0900 &smmu 0x0c24 0x2>,
+		    <0x0908 &smmu 0x0c26 0x2>,
+		    <0x0a00 &smmu 0x0c28 0x2>,
+		    <0x0a08 &smmu 0x0c2a 0x2>,
+		    <0x0b00 &smmu 0x0c2c 0x2>,
+		    <0x0b08 &smmu 0x0c2e 0x2>,
+		    <0x0c00 &smmu 0x0c30 0x2>,
+		    <0x0c08 &smmu 0x0c32 0x2>,
+		    <0x0d00 &smmu 0x0c34 0x2>,
+		    <0x0d08 &smmu 0x0c36 0x2>,
+		    <0x0e00 &smmu 0x0c38 0x2>,
+		    <0x0e08 &smmu 0x0c3a 0x2>,
+		    <0x0f00 &smmu 0x0c3c 0x2>,
+		    <0x0f08 &smmu 0x0c3e 0x2>,
+		    <0x1000 &smmu 0x0c40 0x2>,
+		    <0x1008 &smmu 0x0c42 0x2>,
+		    <0x1100 &smmu 0x0c44 0x2>,
+		    <0x1108 &smmu 0x0c46 0x2>,
+		    <0x1200 &smmu 0x0c48 0x2>,
+		    <0x1208 &smmu 0x0c4a 0x2>,
+		    <0x1300 &smmu 0x0c4c 0x2>,
+		    <0x1308 &smmu 0x0c4e 0x2>,
+		    <0x1400 &smmu 0x0c50 0x2>,
+		    <0x1408 &smmu 0x0c52 0x2>,
+		    <0x1500 &smmu 0x0c54 0x2>,
+		    <0x1508 &smmu 0x0c56 0x2>,
+		    <0x1600 &smmu 0x0c58 0x2>,
+		    <0x1608 &smmu 0x0c5a 0x2>,
+		    <0x1700 &smmu 0x0c5c 0x2>,
+		    <0x1708 &smmu 0x0c5e 0x2>,
+		    <0x1800 &smmu 0x0c60 0x2>,
+		    <0x1808 &smmu 0x0c62 0x2>,
+		    <0x1900 &smmu 0x0c64 0x2>,
+		    <0x1908 &smmu 0x0c66 0x2>,
+		    <0x1a00 &smmu 0x0c68 0x2>,
+		    <0x1a08 &smmu 0x0c6a 0x2>,
+		    <0x1b00 &smmu 0x0c6c 0x2>,
+		    <0x1b08 &smmu 0x0c6e 0x2>,
+		    <0x1c00 &smmu 0x0c70 0x2>,
+		    <0x1c08 &smmu 0x0c72 0x2>,
+		    <0x1d00 &smmu 0x0c74 0x2>,
+		    <0x1d08 &smmu 0x0c76 0x2>,
+		    <0x1e00 &smmu 0x0c78 0x2>,
+		    <0x1e08 &smmu 0x0c7a 0x2>,
+		    <0x1f00 &smmu 0x0c7c 0x2>,
+		    <0x1f08 &smmu 0x0c7e 0x2>,
+		    <0x2000 &smmu 0x0c80 0x2>,
+		    <0x2008 &smmu 0x0c82 0x2>,
+		    <0x2100 &smmu 0x0c84 0x2>,
+		    <0x2108 &smmu 0x0c86 0x2>,
+		    <0x2200 &smmu 0x0c88 0x2>,
+		    <0x2208 &smmu 0x0c8a 0x2>,
+		    <0x2300 &smmu 0x0c8c 0x2>,
+		    <0x2308 &smmu 0x0c8e 0x2>,
+		    <0x2400 &smmu 0x0c90 0x2>,
+		    <0x2408 &smmu 0x0c92 0x2>,
+		    <0x2500 &smmu 0x0c94 0x2>,
+		    <0x2508 &smmu 0x0c96 0x2>,
+		    <0x2600 &smmu 0x0c98 0x2>,
+		    <0x2608 &smmu 0x0c9a 0x2>,
+		    <0x2700 &smmu 0x0c9c 0x2>,
+		    <0x2708 &smmu 0x0c9e 0x2>,
+		    <0x2800 &smmu 0x0ca0 0x2>,
+		    <0x2808 &smmu 0x0ca2 0x2>,
+		    <0x2900 &smmu 0x0ca4 0x2>,
+		    <0x2908 &smmu 0x0ca6 0x2>,
+		    <0x2a00 &smmu 0x0ca8 0x2>,
+		    <0x2a08 &smmu 0x0caa 0x2>,
+		    <0x2b00 &smmu 0x0cac 0x2>,
+		    <0x2b08 &smmu 0x0cae 0x2>,
+		    <0x2c00 &smmu 0x0cb0 0x2>,
+		    <0x2c08 &smmu 0x0cb2 0x2>,
+		    <0x2d00 &smmu 0x0cb4 0x2>,
+		    <0x2d08 &smmu 0x0cb6 0x2>,
+		    <0x2e00 &smmu 0x0cb8 0x2>,
+		    <0x2e08 &smmu 0x0cba 0x2>,
+		    <0x2f00 &smmu 0x0cbc 0x2>,
+		    <0x2f08 &smmu 0x0cbe 0x2>,
+		    <0x3000 &smmu 0x0cc0 0x2>,
+		    <0x3008 &smmu 0x0cc2 0x2>,
+		    <0x3100 &smmu 0x0cc4 0x2>,
+		    <0x3108 &smmu 0x0cc6 0x2>,
+		    <0x3200 &smmu 0x0cc8 0x2>,
+		    <0x3208 &smmu 0x0cca 0x2>,
+		    <0x3300 &smmu 0x0ccc 0x2>,
+		    <0x3308 &smmu 0x0cce 0x2>,
+		    <0x3400 &smmu 0x0cd0 0x2>,
+		    <0x3408 &smmu 0x0cd2 0x2>,
+		    <0x3500 &smmu 0x0cd4 0x2>,
+		    <0x3508 &smmu 0x0cd6 0x2>,
+		    <0x3600 &smmu 0x0cd8 0x2>,
+		    <0x3608 &smmu 0x0cda 0x2>,
+		    <0x3700 &smmu 0x0cdc 0x2>,
+		    <0x3708 &smmu 0x0cde 0x2>,
+		    <0x3800 &smmu 0x0ce0 0x2>,
+		    <0x3808 &smmu 0x0ce2 0x2>,
+		    <0x3900 &smmu 0x0ce4 0x2>,
+		    <0x3908 &smmu 0x0ce6 0x2>,
+		    <0x3a00 &smmu 0x0ce8 0x2>,
+		    <0x3a08 &smmu 0x0cea 0x2>,
+		    <0x3b00 &smmu 0x0cec 0x2>,
+		    <0x3b08 &smmu 0x0cee 0x2>,
+		    <0x3c00 &smmu 0x0cf0 0x2>,
+		    <0x3c08 &smmu 0x0cf2 0x2>,
+		    <0x3d00 &smmu 0x0cf4 0x2>,
+		    <0x3d08 &smmu 0x0cf6 0x2>,
+		    <0x3e00 &smmu 0x0cf8 0x2>,
+		    <0x3e08 &smmu 0x0cfa 0x2>,
+		    <0x3f00 &smmu 0x0cfc 0x2>,
+		    <0x3f08 &smmu 0x0cfe 0x2>,
+		    <0x4000 &smmu 0x0d00 0x2>,
+		    <0x4008 &smmu 0x0d02 0x2>,
+		    <0x4100 &smmu 0x0d04 0x2>,
+		    <0x4108 &smmu 0x0d06 0x2>,
+		    <0x4200 &smmu 0x0d08 0x2>,
+		    <0x4208 &smmu 0x0d0a 0x2>,
+		    <0x4300 &smmu 0x0d0c 0x2>,
+		    <0x4308 &smmu 0x0d0e 0x2>,
+		    <0x4400 &smmu 0x0d10 0x2>,
+		    <0x4408 &smmu 0x0d12 0x2>,
+		    <0x4500 &smmu 0x0d14 0x2>,
+		    <0x4508 &smmu 0x0d16 0x2>,
+		    <0x4600 &smmu 0x0d18 0x2>,
+		    <0x4608 &smmu 0x0d1a 0x2>,
+		    <0x4700 &smmu 0x0d1c 0x2>,
+		    <0x4708 &smmu 0x0d1e 0x2>,
+		    <0x4800 &smmu 0x0d20 0x2>,
+		    <0x4808 &smmu 0x0d22 0x2>,
+		    <0x4900 &smmu 0x0d24 0x2>,
+		    <0x4908 &smmu 0x0d26 0x2>,
+		    <0x4a00 &smmu 0x0d28 0x2>,
+		    <0x4a08 &smmu 0x0d2a 0x2>,
+		    <0x4b00 &smmu 0x0d2c 0x2>,
+		    <0x4b08 &smmu 0x0d2e 0x2>,
+		    <0x4c00 &smmu 0x0d30 0x2>,
+		    <0x4c08 &smmu 0x0d32 0x2>,
+		    <0x4d00 &smmu 0x0d34 0x2>,
+		    <0x4d08 &smmu 0x0d36 0x2>,
+		    <0x4e00 &smmu 0x0d38 0x2>,
+		    <0x4e08 &smmu 0x0d3a 0x2>,
+		    <0x4f00 &smmu 0x0d3c 0x2>,
+		    <0x4f08 &smmu 0x0d3e 0x2>,
+		    <0x5000 &smmu 0x0d40 0x2>,
+		    <0x5008 &smmu 0x0d42 0x2>,
+		    <0x5100 &smmu 0x0d44 0x2>,
+		    <0x5108 &smmu 0x0d46 0x2>,
+		    <0x5200 &smmu 0x0d48 0x2>,
+		    <0x5208 &smmu 0x0d4a 0x2>,
+		    <0x5300 &smmu 0x0d4c 0x2>,
+		    <0x5308 &smmu 0x0d4e 0x2>,
+		    <0x5400 &smmu 0x0d50 0x2>,
+		    <0x5408 &smmu 0x0d52 0x2>,
+		    <0x5500 &smmu 0x0d54 0x2>,
+		    <0x5508 &smmu 0x0d56 0x2>,
+		    <0x5600 &smmu 0x0d58 0x2>,
+		    <0x5608 &smmu 0x0d5a 0x2>,
+		    <0x5700 &smmu 0x0d5c 0x2>,
+		    <0x5708 &smmu 0x0d5e 0x2>,
+		    <0x5800 &smmu 0x0d60 0x2>,
+		    <0x5808 &smmu 0x0d62 0x2>,
+		    <0x5900 &smmu 0x0d64 0x2>,
+		    <0x5908 &smmu 0x0d66 0x2>,
+		    <0x5a00 &smmu 0x0d68 0x2>,
+		    <0x5a08 &smmu 0x0d6a 0x2>,
+		    <0x5b00 &smmu 0x0d6c 0x2>,
+		    <0x5b08 &smmu 0x0d6e 0x2>,
+		    <0x5c00 &smmu 0x0d70 0x2>,
+		    <0x5c08 &smmu 0x0d72 0x2>,
+		    <0x5d00 &smmu 0x0d74 0x2>,
+		    <0x5d08 &smmu 0x0d76 0x2>,
+		    <0x5e00 &smmu 0x0d78 0x2>,
+		    <0x5e08 &smmu 0x0d7a 0x2>,
+		    <0x5f00 &smmu 0x0d7c 0x2>,
+		    <0x5f08 &smmu 0x0d7e 0x2>,
+		    <0x6000 &smmu 0x0d80 0x2>,
+		    <0x6008 &smmu 0x0d82 0x2>,
+		    <0x6100 &smmu 0x0d84 0x2>,
+		    <0x6108 &smmu 0x0d86 0x2>,
+		    <0x6200 &smmu 0x0d88 0x2>,
+		    <0x6208 &smmu 0x0d8a 0x2>,
+		    <0x6300 &smmu 0x0d8c 0x2>,
+		    <0x6308 &smmu 0x0d8e 0x2>,
+		    <0x6400 &smmu 0x0d90 0x2>,
+		    <0x6408 &smmu 0x0d92 0x2>,
+		    <0x6500 &smmu 0x0d94 0x2>,
+		    <0x6508 &smmu 0x0d96 0x2>,
+		    <0x6600 &smmu 0x0d98 0x2>,
+		    <0x6608 &smmu 0x0d9a 0x2>,
+		    <0x6700 &smmu 0x0d9c 0x2>,
+		    <0x6708 &smmu 0x0d9e 0x2>,
+		    <0x6800 &smmu 0x0da0 0x2>,
+		    <0x6808 &smmu 0x0da2 0x2>,
+		    <0x6900 &smmu 0x0da4 0x2>,
+		    <0x6908 &smmu 0x0da6 0x2>,
+		    <0x6a00 &smmu 0x0da8 0x2>,
+		    <0x6a08 &smmu 0x0daa 0x2>,
+		    <0x6b00 &smmu 0x0dac 0x2>,
+		    <0x6b08 &smmu 0x0dae 0x2>,
+		    <0x6c00 &smmu 0x0db0 0x2>,
+		    <0x6c08 &smmu 0x0db2 0x2>,
+		    <0x6d00 &smmu 0x0db4 0x2>,
+		    <0x6d08 &smmu 0x0db6 0x2>,
+		    <0x6e00 &smmu 0x0db8 0x2>,
+		    <0x6e08 &smmu 0x0dba 0x2>,
+		    <0x6f00 &smmu 0x0dbc 0x2>,
+		    <0x6f08 &smmu 0x0dbe 0x2>,
+		    <0x7000 &smmu 0x0dc0 0x2>,
+		    <0x7008 &smmu 0x0dc2 0x2>,
+		    <0x7100 &smmu 0x0dc4 0x2>,
+		    <0x7108 &smmu 0x0dc6 0x2>,
+		    <0x7200 &smmu 0x0dc8 0x2>,
+		    <0x7208 &smmu 0x0dca 0x2>,
+		    <0x7300 &smmu 0x0dcc 0x2>,
+		    <0x7308 &smmu 0x0dce 0x2>,
+		    <0x7400 &smmu 0x0dd0 0x2>,
+		    <0x7408 &smmu 0x0dd2 0x2>,
+		    <0x7500 &smmu 0x0dd4 0x2>,
+		    <0x7508 &smmu 0x0dd6 0x2>,
+		    <0x7600 &smmu 0x0dd8 0x2>,
+		    <0x7608 &smmu 0x0dda 0x2>,
+		    <0x7700 &smmu 0x0ddc 0x2>,
+		    <0x7708 &smmu 0x0dde 0x2>,
+		    <0x7800 &smmu 0x0de0 0x2>,
+		    <0x7808 &smmu 0x0de2 0x2>,
+		    <0x7900 &smmu 0x0de4 0x2>,
+		    <0x7908 &smmu 0x0de6 0x2>,
+		    <0x7a00 &smmu 0x0de8 0x2>,
+		    <0x7a08 &smmu 0x0dea 0x2>,
+		    <0x7b00 &smmu 0x0dec 0x2>,
+		    <0x7b08 &smmu 0x0dee 0x2>,
+		    <0x7c00 &smmu 0x0df0 0x2>,
+		    <0x7c08 &smmu 0x0df2 0x2>,
+		    <0x7d00 &smmu 0x0df4 0x2>,
+		    <0x7d08 &smmu 0x0df6 0x2>,
+		    <0x7e00 &smmu 0x0df8 0x2>,
+		    <0x7e08 &smmu 0x0dfa 0x2>,
+		    <0x7f00 &smmu 0x0dfc 0x2>,
+		    <0x7f08 &smmu 0x0dfe 0x2>,
+		    <0x8000 &smmu 0x0e00 0x2>,
+		    <0x8008 &smmu 0x0e02 0x2>,
+		    <0x8100 &smmu 0x0e04 0x2>,
+		    <0x8108 &smmu 0x0e06 0x2>,
+		    <0x8200 &smmu 0x0e08 0x2>,
+		    <0x8208 &smmu 0x0e0a 0x2>,
+		    <0x8300 &smmu 0x0e0c 0x2>,
+		    <0x8308 &smmu 0x0e0e 0x2>,
+		    <0x8400 &smmu 0x0e10 0x2>,
+		    <0x8408 &smmu 0x0e12 0x2>,
+		    <0x8500 &smmu 0x0e14 0x2>,
+		    <0x8508 &smmu 0x0e16 0x2>,
+		    <0x8600 &smmu 0x0e18 0x2>,
+		    <0x8608 &smmu 0x0e1a 0x2>,
+		    <0x8700 &smmu 0x0e1c 0x2>,
+		    <0x8708 &smmu 0x0e1e 0x2>,
+		    <0x8800 &smmu 0x0e20 0x2>,
+		    <0x8808 &smmu 0x0e22 0x2>,
+		    <0x8900 &smmu 0x0e24 0x2>,
+		    <0x8908 &smmu 0x0e26 0x2>,
+		    <0x8a00 &smmu 0x0e28 0x2>,
+		    <0x8a08 &smmu 0x0e2a 0x2>,
+		    <0x8b00 &smmu 0x0e2c 0x2>,
+		    <0x8b08 &smmu 0x0e2e 0x2>,
+		    <0x8c00 &smmu 0x0e30 0x2>,
+		    <0x8c08 &smmu 0x0e32 0x2>,
+		    <0x8d00 &smmu 0x0e34 0x2>,
+		    <0x8d08 &smmu 0x0e36 0x2>,
+		    <0x8e00 &smmu 0x0e38 0x2>,
+		    <0x8e08 &smmu 0x0e3a 0x2>,
+		    <0x8f00 &smmu 0x0e3c 0x2>,
+		    <0x8f08 &smmu 0x0e3e 0x2>,
+		    <0x9000 &smmu 0x0e40 0x2>,
+		    <0x9008 &smmu 0x0e42 0x2>,
+		    <0x9100 &smmu 0x0e44 0x2>,
+		    <0x9108 &smmu 0x0e46 0x2>,
+		    <0x9200 &smmu 0x0e48 0x2>,
+		    <0x9208 &smmu 0x0e4a 0x2>,
+		    <0x9300 &smmu 0x0e4c 0x2>,
+		    <0x9308 &smmu 0x0e4e 0x2>,
+		    <0x9400 &smmu 0x0e50 0x2>,
+		    <0x9408 &smmu 0x0e52 0x2>,
+		    <0x9500 &smmu 0x0e54 0x2>,
+		    <0x9508 &smmu 0x0e56 0x2>,
+		    <0x9600 &smmu 0x0e58 0x2>,
+		    <0x9608 &smmu 0x0e5a 0x2>,
+		    <0x9700 &smmu 0x0e5c 0x2>,
+		    <0x9708 &smmu 0x0e5e 0x2>,
+		    <0x9800 &smmu 0x0e60 0x2>,
+		    <0x9808 &smmu 0x0e62 0x2>,
+		    <0x9900 &smmu 0x0e64 0x2>,
+		    <0x9908 &smmu 0x0e66 0x2>,
+		    <0x9a00 &smmu 0x0e68 0x2>,
+		    <0x9a08 &smmu 0x0e6a 0x2>,
+		    <0x9b00 &smmu 0x0e6c 0x2>,
+		    <0x9b08 &smmu 0x0e6e 0x2>,
+		    <0x9c00 &smmu 0x0e70 0x2>,
+		    <0x9c08 &smmu 0x0e72 0x2>,
+		    <0x9d00 &smmu 0x0e74 0x2>,
+		    <0x9d08 &smmu 0x0e76 0x2>,
+		    <0x9e00 &smmu 0x0e78 0x2>,
+		    <0x9e08 &smmu 0x0e7a 0x2>,
+		    <0x9f00 &smmu 0x0e7c 0x2>,
+		    <0x9f08 &smmu 0x0e7e 0x2>,
+		    <0xa000 &smmu 0x0e80 0x2>,
+		    <0xa008 &smmu 0x0e82 0x2>,
+		    <0xa100 &smmu 0x0e84 0x2>,
+		    <0xa108 &smmu 0x0e86 0x2>,
+		    <0xa200 &smmu 0x0e88 0x2>,
+		    <0xa208 &smmu 0x0e8a 0x2>,
+		    <0xa300 &smmu 0x0e8c 0x2>,
+		    <0xa308 &smmu 0x0e8e 0x2>,
+		    <0xa400 &smmu 0x0e90 0x2>,
+		    <0xa408 &smmu 0x0e92 0x2>,
+		    <0xa500 &smmu 0x0e94 0x2>,
+		    <0xa508 &smmu 0x0e96 0x2>,
+		    <0xa600 &smmu 0x0e98 0x2>,
+		    <0xa608 &smmu 0x0e9a 0x2>,
+		    <0xa700 &smmu 0x0e9c 0x2>,
+		    <0xa708 &smmu 0x0e9e 0x2>,
+		    <0xa800 &smmu 0x0ea0 0x2>,
+		    <0xa808 &smmu 0x0ea2 0x2>,
+		    <0xa900 &smmu 0x0ea4 0x2>,
+		    <0xa908 &smmu 0x0ea6 0x2>,
+		    <0xaa00 &smmu 0x0ea8 0x2>,
+		    <0xaa08 &smmu 0x0eaa 0x2>,
+		    <0xab00 &smmu 0x0eac 0x2>,
+		    <0xab08 &smmu 0x0eae 0x2>,
+		    <0xac00 &smmu 0x0eb0 0x2>,
+		    <0xac08 &smmu 0x0eb2 0x2>,
+		    <0xad00 &smmu 0x0eb4 0x2>,
+		    <0xad08 &smmu 0x0eb6 0x2>,
+		    <0xae00 &smmu 0x0eb8 0x2>,
+		    <0xae08 &smmu 0x0eba 0x2>,
+		    <0xaf00 &smmu 0x0ebc 0x2>,
+		    <0xaf08 &smmu 0x0ebe 0x2>,
+		    <0xb000 &smmu 0x0ec0 0x2>,
+		    <0xb008 &smmu 0x0ec2 0x2>,
+		    <0xb100 &smmu 0x0ec4 0x2>,
+		    <0xb108 &smmu 0x0ec6 0x2>,
+		    <0xb200 &smmu 0x0ec8 0x2>,
+		    <0xb208 &smmu 0x0eca 0x2>,
+		    <0xb300 &smmu 0x0ecc 0x2>,
+		    <0xb308 &smmu 0x0ece 0x2>,
+		    <0xb400 &smmu 0x0ed0 0x2>,
+		    <0xb408 &smmu 0x0ed2 0x2>,
+		    <0xb500 &smmu 0x0ed4 0x2>,
+		    <0xb508 &smmu 0x0ed6 0x2>,
+		    <0xb600 &smmu 0x0ed8 0x2>,
+		    <0xb608 &smmu 0x0eda 0x2>,
+		    <0xb700 &smmu 0x0edc 0x2>,
+		    <0xb708 &smmu 0x0ede 0x2>,
+		    <0xb800 &smmu 0x0ee0 0x2>,
+		    <0xb808 &smmu 0x0ee2 0x2>,
+		    <0xb900 &smmu 0x0ee4 0x2>,
+		    <0xb908 &smmu 0x0ee6 0x2>,
+		    <0xba00 &smmu 0x0ee8 0x2>,
+		    <0xba08 &smmu 0x0eea 0x2>,
+		    <0xbb00 &smmu 0x0eec 0x2>,
+		    <0xbb08 &smmu 0x0eee 0x2>,
+		    <0xbc00 &smmu 0x0ef0 0x2>,
+		    <0xbc08 &smmu 0x0ef2 0x2>,
+		    <0xbd00 &smmu 0x0ef4 0x2>,
+		    <0xbd08 &smmu 0x0ef6 0x2>,
+		    <0xbe00 &smmu 0x0ef8 0x2>,
+		    <0xbe08 &smmu 0x0efa 0x2>,
+		    <0xbf00 &smmu 0x0efc 0x2>,
+		    <0xbf08 &smmu 0x0efe 0x2>,
+		    <0xc000 &smmu 0x0f00 0x2>,
+		    <0xc008 &smmu 0x0f02 0x2>,
+		    <0xc100 &smmu 0x0f04 0x2>,
+		    <0xc108 &smmu 0x0f06 0x2>,
+		    <0xc200 &smmu 0x0f08 0x2>,
+		    <0xc208 &smmu 0x0f0a 0x2>,
+		    <0xc300 &smmu 0x0f0c 0x2>,
+		    <0xc308 &smmu 0x0f0e 0x2>,
+		    <0xc400 &smmu 0x0f10 0x2>,
+		    <0xc408 &smmu 0x0f12 0x2>,
+		    <0xc500 &smmu 0x0f14 0x2>,
+		    <0xc508 &smmu 0x0f16 0x2>,
+		    <0xc600 &smmu 0x0f18 0x2>,
+		    <0xc608 &smmu 0x0f1a 0x2>,
+		    <0xc700 &smmu 0x0f1c 0x2>,
+		    <0xc708 &smmu 0x0f1e 0x2>,
+		    <0xc800 &smmu 0x0f20 0x2>,
+		    <0xc808 &smmu 0x0f22 0x2>,
+		    <0xc900 &smmu 0x0f24 0x2>,
+		    <0xc908 &smmu 0x0f26 0x2>,
+		    <0xca00 &smmu 0x0f28 0x2>,
+		    <0xca08 &smmu 0x0f2a 0x2>,
+		    <0xcb00 &smmu 0x0f2c 0x2>,
+		    <0xcb08 &smmu 0x0f2e 0x2>,
+		    <0xcc00 &smmu 0x0f30 0x2>,
+		    <0xcc08 &smmu 0x0f32 0x2>,
+		    <0xcd00 &smmu 0x0f34 0x2>,
+		    <0xcd08 &smmu 0x0f36 0x2>,
+		    <0xce00 &smmu 0x0f38 0x2>,
+		    <0xce08 &smmu 0x0f3a 0x2>,
+		    <0xcf00 &smmu 0x0f3c 0x2>,
+		    <0xcf08 &smmu 0x0f3e 0x2>,
+		    <0xd000 &smmu 0x0f40 0x2>,
+		    <0xd008 &smmu 0x0f42 0x2>,
+		    <0xd100 &smmu 0x0f44 0x2>,
+		    <0xd108 &smmu 0x0f46 0x2>,
+		    <0xd200 &smmu 0x0f48 0x2>,
+		    <0xd208 &smmu 0x0f4a 0x2>,
+		    <0xd300 &smmu 0x0f4c 0x2>,
+		    <0xd308 &smmu 0x0f4e 0x2>,
+		    <0xd400 &smmu 0x0f50 0x2>,
+		    <0xd408 &smmu 0x0f52 0x2>,
+		    <0xd500 &smmu 0x0f54 0x2>,
+		    <0xd508 &smmu 0x0f56 0x2>,
+		    <0xd600 &smmu 0x0f58 0x2>,
+		    <0xd608 &smmu 0x0f5a 0x2>,
+		    <0xd700 &smmu 0x0f5c 0x2>,
+		    <0xd708 &smmu 0x0f5e 0x2>,
+		    <0xd800 &smmu 0x0f60 0x2>,
+		    <0xd808 &smmu 0x0f62 0x2>,
+		    <0xd900 &smmu 0x0f64 0x2>,
+		    <0xd908 &smmu 0x0f66 0x2>,
+		    <0xda00 &smmu 0x0f68 0x2>,
+		    <0xda08 &smmu 0x0f6a 0x2>,
+		    <0xdb00 &smmu 0x0f6c 0x2>,
+		    <0xdb08 &smmu 0x0f6e 0x2>,
+		    <0xdc00 &smmu 0x0f70 0x2>,
+		    <0xdc08 &smmu 0x0f72 0x2>,
+		    <0xdd00 &smmu 0x0f74 0x2>,
+		    <0xdd08 &smmu 0x0f76 0x2>,
+		    <0xde00 &smmu 0x0f78 0x2>,
+		    <0xde08 &smmu 0x0f7a 0x2>,
+		    <0xdf00 &smmu 0x0f7c 0x2>,
+		    <0xdf08 &smmu 0x0f7e 0x2>,
+		    <0xe000 &smmu 0x0f80 0x2>,
+		    <0xe008 &smmu 0x0f82 0x2>,
+		    <0xe100 &smmu 0x0f84 0x2>,
+		    <0xe108 &smmu 0x0f86 0x2>,
+		    <0xe200 &smmu 0x0f88 0x2>,
+		    <0xe208 &smmu 0x0f8a 0x2>,
+		    <0xe300 &smmu 0x0f8c 0x2>,
+		    <0xe308 &smmu 0x0f8e 0x2>,
+		    <0xe400 &smmu 0x0f90 0x2>,
+		    <0xe408 &smmu 0x0f92 0x2>,
+		    <0xe500 &smmu 0x0f94 0x2>,
+		    <0xe508 &smmu 0x0f96 0x2>,
+		    <0xe600 &smmu 0x0f98 0x2>,
+		    <0xe608 &smmu 0x0f9a 0x2>,
+		    <0xe700 &smmu 0x0f9c 0x2>,
+		    <0xe708 &smmu 0x0f9e 0x2>,
+		    <0xe800 &smmu 0x0fa0 0x2>,
+		    <0xe808 &smmu 0x0fa2 0x2>,
+		    <0xe900 &smmu 0x0fa4 0x2>,
+		    <0xe908 &smmu 0x0fa6 0x2>,
+		    <0xea00 &smmu 0x0fa8 0x2>,
+		    <0xea08 &smmu 0x0faa 0x2>,
+		    <0xeb00 &smmu 0x0fac 0x2>,
+		    <0xeb08 &smmu 0x0fae 0x2>,
+		    <0xec00 &smmu 0x0fb0 0x2>,
+		    <0xec08 &smmu 0x0fb2 0x2>,
+		    <0xed00 &smmu 0x0fb4 0x2>,
+		    <0xed08 &smmu 0x0fb6 0x2>,
+		    <0xee00 &smmu 0x0fb8 0x2>,
+		    <0xee08 &smmu 0x0fba 0x2>,
+		    <0xef00 &smmu 0x0fbc 0x2>,
+		    <0xef08 &smmu 0x0fbe 0x2>,
+		    <0xf000 &smmu 0x0fc0 0x2>,
+		    <0xf008 &smmu 0x0fc2 0x2>,
+		    <0xf100 &smmu 0x0fc4 0x2>,
+		    <0xf108 &smmu 0x0fc6 0x2>,
+		    <0xf200 &smmu 0x0fc8 0x2>,
+		    <0xf208 &smmu 0x0fca 0x2>,
+		    <0xf300 &smmu 0x0fcc 0x2>,
+		    <0xf308 &smmu 0x0fce 0x2>,
+		    <0xf400 &smmu 0x0fd0 0x2>,
+		    <0xf408 &smmu 0x0fd2 0x2>,
+		    <0xf500 &smmu 0x0fd4 0x2>,
+		    <0xf508 &smmu 0x0fd6 0x2>,
+		    <0xf600 &smmu 0x0fd8 0x2>,
+		    <0xf608 &smmu 0x0fda 0x2>,
+		    <0xf700 &smmu 0x0fdc 0x2>,
+		    <0xf708 &smmu 0x0fde 0x2>,
+		    <0xf800 &smmu 0x0fe0 0x2>,
+		    <0xf808 &smmu 0x0fe2 0x2>,
+		    <0xf900 &smmu 0x0fe4 0x2>,
+		    <0xf908 &smmu 0x0fe6 0x2>,
+		    <0xfa00 &smmu 0x0fe8 0x2>,
+		    <0xfa08 &smmu 0x0fea 0x2>,
+		    <0xfb00 &smmu 0x0fec 0x2>,
+		    <0xfb08 &smmu 0x0fee 0x2>,
+		    <0xfc00 &smmu 0x0ff0 0x2>,
+		    <0xfc08 &smmu 0x0ff2 0x2>,
+		    <0xfd00 &smmu 0x0ff4 0x2>,
+		    <0xfd08 &smmu 0x0ff6 0x2>,
+		    <0xfe00 &smmu 0x0ff8 0x2>,
+		    <0xfe08 &smmu 0x0ffa 0x2>,
+		    <0xff00 &smmu 0x0ffc 0x2>,
+		    <0xff08 &smmu 0x0ffe 0x2>;
+#endif
+};
+
+&pcie4 {
+	msi-map = <0x0000 &gic_its 0x1000 0x2>,
+		  <0x0008 &gic_its 0x1002 0x2>,
+		  <0x0100 &gic_its 0x1004 0x2>,
+		  <0x0108 &gic_its 0x1006 0x2>,
+		  <0x0200 &gic_its 0x1008 0x2>,
+		  <0x0208 &gic_its 0x100a 0x2>,
+		  <0x0300 &gic_its 0x100c 0x2>,
+		  <0x0308 &gic_its 0x100e 0x2>,
+		  <0x0400 &gic_its 0x1010 0x2>,
+		  <0x0408 &gic_its 0x1012 0x2>,
+		  <0x0500 &gic_its 0x1014 0x2>,
+		  <0x0508 &gic_its 0x1016 0x2>,
+		  <0x0600 &gic_its 0x1018 0x2>,
+		  <0x0608 &gic_its 0x101a 0x2>,
+		  <0x0700 &gic_its 0x101c 0x2>,
+		  <0x0708 &gic_its 0x101e 0x2>,
+		  <0x0800 &gic_its 0x1020 0x2>,
+		  <0x0808 &gic_its 0x1022 0x2>,
+		  <0x0900 &gic_its 0x1024 0x2>,
+		  <0x0908 &gic_its 0x1026 0x2>,
+		  <0x0a00 &gic_its 0x1028 0x2>,
+		  <0x0a08 &gic_its 0x102a 0x2>,
+		  <0x0b00 &gic_its 0x102c 0x2>,
+		  <0x0b08 &gic_its 0x102e 0x2>,
+		  <0x0c00 &gic_its 0x1030 0x2>,
+		  <0x0c08 &gic_its 0x1032 0x2>,
+		  <0x0d00 &gic_its 0x1034 0x2>,
+		  <0x0d08 &gic_its 0x1036 0x2>,
+		  <0x0e00 &gic_its 0x1038 0x2>,
+		  <0x0e08 &gic_its 0x103a 0x2>,
+		  <0x0f00 &gic_its 0x103c 0x2>,
+		  <0x0f08 &gic_its 0x103e 0x2>,
+		  <0x1000 &gic_its 0x1040 0x2>,
+		  <0x1008 &gic_its 0x1042 0x2>,
+		  <0x1100 &gic_its 0x1044 0x2>,
+		  <0x1108 &gic_its 0x1046 0x2>,
+		  <0x1200 &gic_its 0x1048 0x2>,
+		  <0x1208 &gic_its 0x104a 0x2>,
+		  <0x1300 &gic_its 0x104c 0x2>,
+		  <0x1308 &gic_its 0x104e 0x2>,
+		  <0x1400 &gic_its 0x1050 0x2>,
+		  <0x1408 &gic_its 0x1052 0x2>,
+		  <0x1500 &gic_its 0x1054 0x2>,
+		  <0x1508 &gic_its 0x1056 0x2>,
+		  <0x1600 &gic_its 0x1058 0x2>,
+		  <0x1608 &gic_its 0x105a 0x2>,
+		  <0x1700 &gic_its 0x105c 0x2>,
+		  <0x1708 &gic_its 0x105e 0x2>,
+		  <0x1800 &gic_its 0x1060 0x2>,
+		  <0x1808 &gic_its 0x1062 0x2>,
+		  <0x1900 &gic_its 0x1064 0x2>,
+		  <0x1908 &gic_its 0x1066 0x2>,
+		  <0x1a00 &gic_its 0x1068 0x2>,
+		  <0x1a08 &gic_its 0x106a 0x2>,
+		  <0x1b00 &gic_its 0x106c 0x2>,
+		  <0x1b08 &gic_its 0x106e 0x2>,
+		  <0x1c00 &gic_its 0x1070 0x2>,
+		  <0x1c08 &gic_its 0x1072 0x2>,
+		  <0x1d00 &gic_its 0x1074 0x2>,
+		  <0x1d08 &gic_its 0x1076 0x2>,
+		  <0x1e00 &gic_its 0x1078 0x2>,
+		  <0x1e08 &gic_its 0x107a 0x2>,
+		  <0x1f00 &gic_its 0x107c 0x2>,
+		  <0x1f08 &gic_its 0x107e 0x2>,
+		  <0x2000 &gic_its 0x1080 0x2>,
+		  <0x2008 &gic_its 0x1082 0x2>,
+		  <0x2100 &gic_its 0x1084 0x2>,
+		  <0x2108 &gic_its 0x1086 0x2>,
+		  <0x2200 &gic_its 0x1088 0x2>,
+		  <0x2208 &gic_its 0x108a 0x2>,
+		  <0x2300 &gic_its 0x108c 0x2>,
+		  <0x2308 &gic_its 0x108e 0x2>,
+		  <0x2400 &gic_its 0x1090 0x2>,
+		  <0x2408 &gic_its 0x1092 0x2>,
+		  <0x2500 &gic_its 0x1094 0x2>,
+		  <0x2508 &gic_its 0x1096 0x2>,
+		  <0x2600 &gic_its 0x1098 0x2>,
+		  <0x2608 &gic_its 0x109a 0x2>,
+		  <0x2700 &gic_its 0x109c 0x2>,
+		  <0x2708 &gic_its 0x109e 0x2>,
+		  <0x2800 &gic_its 0x10a0 0x2>,
+		  <0x2808 &gic_its 0x10a2 0x2>,
+		  <0x2900 &gic_its 0x10a4 0x2>,
+		  <0x2908 &gic_its 0x10a6 0x2>,
+		  <0x2a00 &gic_its 0x10a8 0x2>,
+		  <0x2a08 &gic_its 0x10aa 0x2>,
+		  <0x2b00 &gic_its 0x10ac 0x2>,
+		  <0x2b08 &gic_its 0x10ae 0x2>,
+		  <0x2c00 &gic_its 0x10b0 0x2>,
+		  <0x2c08 &gic_its 0x10b2 0x2>,
+		  <0x2d00 &gic_its 0x10b4 0x2>,
+		  <0x2d08 &gic_its 0x10b6 0x2>,
+		  <0x2e00 &gic_its 0x10b8 0x2>,
+		  <0x2e08 &gic_its 0x10ba 0x2>,
+		  <0x2f00 &gic_its 0x10bc 0x2>,
+		  <0x2f08 &gic_its 0x10be 0x2>,
+		  <0x3000 &gic_its 0x10c0 0x2>,
+		  <0x3008 &gic_its 0x10c2 0x2>,
+		  <0x3100 &gic_its 0x10c4 0x2>,
+		  <0x3108 &gic_its 0x10c6 0x2>,
+		  <0x3200 &gic_its 0x10c8 0x2>,
+		  <0x3208 &gic_its 0x10ca 0x2>,
+		  <0x3300 &gic_its 0x10cc 0x2>,
+		  <0x3308 &gic_its 0x10ce 0x2>,
+		  <0x3400 &gic_its 0x10d0 0x2>,
+		  <0x3408 &gic_its 0x10d2 0x2>,
+		  <0x3500 &gic_its 0x10d4 0x2>,
+		  <0x3508 &gic_its 0x10d6 0x2>,
+		  <0x3600 &gic_its 0x10d8 0x2>,
+		  <0x3608 &gic_its 0x10da 0x2>,
+		  <0x3700 &gic_its 0x10dc 0x2>,
+		  <0x3708 &gic_its 0x10de 0x2>,
+		  <0x3800 &gic_its 0x10e0 0x2>,
+		  <0x3808 &gic_its 0x10e2 0x2>,
+		  <0x3900 &gic_its 0x10e4 0x2>,
+		  <0x3908 &gic_its 0x10e6 0x2>,
+		  <0x3a00 &gic_its 0x10e8 0x2>,
+		  <0x3a08 &gic_its 0x10ea 0x2>,
+		  <0x3b00 &gic_its 0x10ec 0x2>,
+		  <0x3b08 &gic_its 0x10ee 0x2>,
+		  <0x3c00 &gic_its 0x10f0 0x2>,
+		  <0x3c08 &gic_its 0x10f2 0x2>,
+		  <0x3d00 &gic_its 0x10f4 0x2>,
+		  <0x3d08 &gic_its 0x10f6 0x2>,
+		  <0x3e00 &gic_its 0x10f8 0x2>,
+		  <0x3e08 &gic_its 0x10fa 0x2>,
+		  <0x3f00 &gic_its 0x10fc 0x2>,
+		  <0x3f08 &gic_its 0x10fe 0x2>,
+		  <0x4000 &gic_its 0x1100 0x2>,
+		  <0x4008 &gic_its 0x1102 0x2>,
+		  <0x4100 &gic_its 0x1104 0x2>,
+		  <0x4108 &gic_its 0x1106 0x2>,
+		  <0x4200 &gic_its 0x1108 0x2>,
+		  <0x4208 &gic_its 0x110a 0x2>,
+		  <0x4300 &gic_its 0x110c 0x2>,
+		  <0x4308 &gic_its 0x110e 0x2>,
+		  <0x4400 &gic_its 0x1110 0x2>,
+		  <0x4408 &gic_its 0x1112 0x2>,
+		  <0x4500 &gic_its 0x1114 0x2>,
+		  <0x4508 &gic_its 0x1116 0x2>,
+		  <0x4600 &gic_its 0x1118 0x2>,
+		  <0x4608 &gic_its 0x111a 0x2>,
+		  <0x4700 &gic_its 0x111c 0x2>,
+		  <0x4708 &gic_its 0x111e 0x2>,
+		  <0x4800 &gic_its 0x1120 0x2>,
+		  <0x4808 &gic_its 0x1122 0x2>,
+		  <0x4900 &gic_its 0x1124 0x2>,
+		  <0x4908 &gic_its 0x1126 0x2>,
+		  <0x4a00 &gic_its 0x1128 0x2>,
+		  <0x4a08 &gic_its 0x112a 0x2>,
+		  <0x4b00 &gic_its 0x112c 0x2>,
+		  <0x4b08 &gic_its 0x112e 0x2>,
+		  <0x4c00 &gic_its 0x1130 0x2>,
+		  <0x4c08 &gic_its 0x1132 0x2>,
+		  <0x4d00 &gic_its 0x1134 0x2>,
+		  <0x4d08 &gic_its 0x1136 0x2>,
+		  <0x4e00 &gic_its 0x1138 0x2>,
+		  <0x4e08 &gic_its 0x113a 0x2>,
+		  <0x4f00 &gic_its 0x113c 0x2>,
+		  <0x4f08 &gic_its 0x113e 0x2>,
+		  <0x5000 &gic_its 0x1140 0x2>,
+		  <0x5008 &gic_its 0x1142 0x2>,
+		  <0x5100 &gic_its 0x1144 0x2>,
+		  <0x5108 &gic_its 0x1146 0x2>,
+		  <0x5200 &gic_its 0x1148 0x2>,
+		  <0x5208 &gic_its 0x114a 0x2>,
+		  <0x5300 &gic_its 0x114c 0x2>,
+		  <0x5308 &gic_its 0x114e 0x2>,
+		  <0x5400 &gic_its 0x1150 0x2>,
+		  <0x5408 &gic_its 0x1152 0x2>,
+		  <0x5500 &gic_its 0x1154 0x2>,
+		  <0x5508 &gic_its 0x1156 0x2>,
+		  <0x5600 &gic_its 0x1158 0x2>,
+		  <0x5608 &gic_its 0x115a 0x2>,
+		  <0x5700 &gic_its 0x115c 0x2>,
+		  <0x5708 &gic_its 0x115e 0x2>,
+		  <0x5800 &gic_its 0x1160 0x2>,
+		  <0x5808 &gic_its 0x1162 0x2>,
+		  <0x5900 &gic_its 0x1164 0x2>,
+		  <0x5908 &gic_its 0x1166 0x2>,
+		  <0x5a00 &gic_its 0x1168 0x2>,
+		  <0x5a08 &gic_its 0x116a 0x2>,
+		  <0x5b00 &gic_its 0x116c 0x2>,
+		  <0x5b08 &gic_its 0x116e 0x2>,
+		  <0x5c00 &gic_its 0x1170 0x2>,
+		  <0x5c08 &gic_its 0x1172 0x2>,
+		  <0x5d00 &gic_its 0x1174 0x2>,
+		  <0x5d08 &gic_its 0x1176 0x2>,
+		  <0x5e00 &gic_its 0x1178 0x2>,
+		  <0x5e08 &gic_its 0x117a 0x2>,
+		  <0x5f00 &gic_its 0x117c 0x2>,
+		  <0x5f08 &gic_its 0x117e 0x2>,
+		  <0x6000 &gic_its 0x1180 0x2>,
+		  <0x6008 &gic_its 0x1182 0x2>,
+		  <0x6100 &gic_its 0x1184 0x2>,
+		  <0x6108 &gic_its 0x1186 0x2>,
+		  <0x6200 &gic_its 0x1188 0x2>,
+		  <0x6208 &gic_its 0x118a 0x2>,
+		  <0x6300 &gic_its 0x118c 0x2>,
+		  <0x6308 &gic_its 0x118e 0x2>,
+		  <0x6400 &gic_its 0x1190 0x2>,
+		  <0x6408 &gic_its 0x1192 0x2>,
+		  <0x6500 &gic_its 0x1194 0x2>,
+		  <0x6508 &gic_its 0x1196 0x2>,
+		  <0x6600 &gic_its 0x1198 0x2>,
+		  <0x6608 &gic_its 0x119a 0x2>,
+		  <0x6700 &gic_its 0x119c 0x2>,
+		  <0x6708 &gic_its 0x119e 0x2>,
+		  <0x6800 &gic_its 0x11a0 0x2>,
+		  <0x6808 &gic_its 0x11a2 0x2>,
+		  <0x6900 &gic_its 0x11a4 0x2>,
+		  <0x6908 &gic_its 0x11a6 0x2>,
+		  <0x6a00 &gic_its 0x11a8 0x2>,
+		  <0x6a08 &gic_its 0x11aa 0x2>,
+		  <0x6b00 &gic_its 0x11ac 0x2>,
+		  <0x6b08 &gic_its 0x11ae 0x2>,
+		  <0x6c00 &gic_its 0x11b0 0x2>,
+		  <0x6c08 &gic_its 0x11b2 0x2>,
+		  <0x6d00 &gic_its 0x11b4 0x2>,
+		  <0x6d08 &gic_its 0x11b6 0x2>,
+		  <0x6e00 &gic_its 0x11b8 0x2>,
+		  <0x6e08 &gic_its 0x11ba 0x2>,
+		  <0x6f00 &gic_its 0x11bc 0x2>,
+		  <0x6f08 &gic_its 0x11be 0x2>,
+		  <0x7000 &gic_its 0x11c0 0x2>,
+		  <0x7008 &gic_its 0x11c2 0x2>,
+		  <0x7100 &gic_its 0x11c4 0x2>,
+		  <0x7108 &gic_its 0x11c6 0x2>,
+		  <0x7200 &gic_its 0x11c8 0x2>,
+		  <0x7208 &gic_its 0x11ca 0x2>,
+		  <0x7300 &gic_its 0x11cc 0x2>,
+		  <0x7308 &gic_its 0x11ce 0x2>,
+		  <0x7400 &gic_its 0x11d0 0x2>,
+		  <0x7408 &gic_its 0x11d2 0x2>,
+		  <0x7500 &gic_its 0x11d4 0x2>,
+		  <0x7508 &gic_its 0x11d6 0x2>,
+		  <0x7600 &gic_its 0x11d8 0x2>,
+		  <0x7608 &gic_its 0x11da 0x2>,
+		  <0x7700 &gic_its 0x11dc 0x2>,
+		  <0x7708 &gic_its 0x11de 0x2>,
+		  <0x7800 &gic_its 0x11e0 0x2>,
+		  <0x7808 &gic_its 0x11e2 0x2>,
+		  <0x7900 &gic_its 0x11e4 0x2>,
+		  <0x7908 &gic_its 0x11e6 0x2>,
+		  <0x7a00 &gic_its 0x11e8 0x2>,
+		  <0x7a08 &gic_its 0x11ea 0x2>,
+		  <0x7b00 &gic_its 0x11ec 0x2>,
+		  <0x7b08 &gic_its 0x11ee 0x2>,
+		  <0x7c00 &gic_its 0x11f0 0x2>,
+		  <0x7c08 &gic_its 0x11f2 0x2>,
+		  <0x7d00 &gic_its 0x11f4 0x2>,
+		  <0x7d08 &gic_its 0x11f6 0x2>,
+		  <0x7e00 &gic_its 0x11f8 0x2>,
+		  <0x7e08 &gic_its 0x11fa 0x2>,
+		  <0x7f00 &gic_its 0x11fc 0x2>,
+		  <0x7f08 &gic_its 0x11fe 0x2>,
+		  <0x8000 &gic_its 0x1200 0x2>,
+		  <0x8008 &gic_its 0x1202 0x2>,
+		  <0x8100 &gic_its 0x1204 0x2>,
+		  <0x8108 &gic_its 0x1206 0x2>,
+		  <0x8200 &gic_its 0x1208 0x2>,
+		  <0x8208 &gic_its 0x120a 0x2>,
+		  <0x8300 &gic_its 0x120c 0x2>,
+		  <0x8308 &gic_its 0x120e 0x2>,
+		  <0x8400 &gic_its 0x1210 0x2>,
+		  <0x8408 &gic_its 0x1212 0x2>,
+		  <0x8500 &gic_its 0x1214 0x2>,
+		  <0x8508 &gic_its 0x1216 0x2>,
+		  <0x8600 &gic_its 0x1218 0x2>,
+		  <0x8608 &gic_its 0x121a 0x2>,
+		  <0x8700 &gic_its 0x121c 0x2>,
+		  <0x8708 &gic_its 0x121e 0x2>,
+		  <0x8800 &gic_its 0x1220 0x2>,
+		  <0x8808 &gic_its 0x1222 0x2>,
+		  <0x8900 &gic_its 0x1224 0x2>,
+		  <0x8908 &gic_its 0x1226 0x2>,
+		  <0x8a00 &gic_its 0x1228 0x2>,
+		  <0x8a08 &gic_its 0x122a 0x2>,
+		  <0x8b00 &gic_its 0x122c 0x2>,
+		  <0x8b08 &gic_its 0x122e 0x2>,
+		  <0x8c00 &gic_its 0x1230 0x2>,
+		  <0x8c08 &gic_its 0x1232 0x2>,
+		  <0x8d00 &gic_its 0x1234 0x2>,
+		  <0x8d08 &gic_its 0x1236 0x2>,
+		  <0x8e00 &gic_its 0x1238 0x2>,
+		  <0x8e08 &gic_its 0x123a 0x2>,
+		  <0x8f00 &gic_its 0x123c 0x2>,
+		  <0x8f08 &gic_its 0x123e 0x2>,
+		  <0x9000 &gic_its 0x1240 0x2>,
+		  <0x9008 &gic_its 0x1242 0x2>,
+		  <0x9100 &gic_its 0x1244 0x2>,
+		  <0x9108 &gic_its 0x1246 0x2>,
+		  <0x9200 &gic_its 0x1248 0x2>,
+		  <0x9208 &gic_its 0x124a 0x2>,
+		  <0x9300 &gic_its 0x124c 0x2>,
+		  <0x9308 &gic_its 0x124e 0x2>,
+		  <0x9400 &gic_its 0x1250 0x2>,
+		  <0x9408 &gic_its 0x1252 0x2>,
+		  <0x9500 &gic_its 0x1254 0x2>,
+		  <0x9508 &gic_its 0x1256 0x2>,
+		  <0x9600 &gic_its 0x1258 0x2>,
+		  <0x9608 &gic_its 0x125a 0x2>,
+		  <0x9700 &gic_its 0x125c 0x2>,
+		  <0x9708 &gic_its 0x125e 0x2>,
+		  <0x9800 &gic_its 0x1260 0x2>,
+		  <0x9808 &gic_its 0x1262 0x2>,
+		  <0x9900 &gic_its 0x1264 0x2>,
+		  <0x9908 &gic_its 0x1266 0x2>,
+		  <0x9a00 &gic_its 0x1268 0x2>,
+		  <0x9a08 &gic_its 0x126a 0x2>,
+		  <0x9b00 &gic_its 0x126c 0x2>,
+		  <0x9b08 &gic_its 0x126e 0x2>,
+		  <0x9c00 &gic_its 0x1270 0x2>,
+		  <0x9c08 &gic_its 0x1272 0x2>,
+		  <0x9d00 &gic_its 0x1274 0x2>,
+		  <0x9d08 &gic_its 0x1276 0x2>,
+		  <0x9e00 &gic_its 0x1278 0x2>,
+		  <0x9e08 &gic_its 0x127a 0x2>,
+		  <0x9f00 &gic_its 0x127c 0x2>,
+		  <0x9f08 &gic_its 0x127e 0x2>,
+		  <0xa000 &gic_its 0x1280 0x2>,
+		  <0xa008 &gic_its 0x1282 0x2>,
+		  <0xa100 &gic_its 0x1284 0x2>,
+		  <0xa108 &gic_its 0x1286 0x2>,
+		  <0xa200 &gic_its 0x1288 0x2>,
+		  <0xa208 &gic_its 0x128a 0x2>,
+		  <0xa300 &gic_its 0x128c 0x2>,
+		  <0xa308 &gic_its 0x128e 0x2>,
+		  <0xa400 &gic_its 0x1290 0x2>,
+		  <0xa408 &gic_its 0x1292 0x2>,
+		  <0xa500 &gic_its 0x1294 0x2>,
+		  <0xa508 &gic_its 0x1296 0x2>,
+		  <0xa600 &gic_its 0x1298 0x2>,
+		  <0xa608 &gic_its 0x129a 0x2>,
+		  <0xa700 &gic_its 0x129c 0x2>,
+		  <0xa708 &gic_its 0x129e 0x2>,
+		  <0xa800 &gic_its 0x12a0 0x2>,
+		  <0xa808 &gic_its 0x12a2 0x2>,
+		  <0xa900 &gic_its 0x12a4 0x2>,
+		  <0xa908 &gic_its 0x12a6 0x2>,
+		  <0xaa00 &gic_its 0x12a8 0x2>,
+		  <0xaa08 &gic_its 0x12aa 0x2>,
+		  <0xab00 &gic_its 0x12ac 0x2>,
+		  <0xab08 &gic_its 0x12ae 0x2>,
+		  <0xac00 &gic_its 0x12b0 0x2>,
+		  <0xac08 &gic_its 0x12b2 0x2>,
+		  <0xad00 &gic_its 0x12b4 0x2>,
+		  <0xad08 &gic_its 0x12b6 0x2>,
+		  <0xae00 &gic_its 0x12b8 0x2>,
+		  <0xae08 &gic_its 0x12ba 0x2>,
+		  <0xaf00 &gic_its 0x12bc 0x2>,
+		  <0xaf08 &gic_its 0x12be 0x2>,
+		  <0xb000 &gic_its 0x12c0 0x2>,
+		  <0xb008 &gic_its 0x12c2 0x2>,
+		  <0xb100 &gic_its 0x12c4 0x2>,
+		  <0xb108 &gic_its 0x12c6 0x2>,
+		  <0xb200 &gic_its 0x12c8 0x2>,
+		  <0xb208 &gic_its 0x12ca 0x2>,
+		  <0xb300 &gic_its 0x12cc 0x2>,
+		  <0xb308 &gic_its 0x12ce 0x2>,
+		  <0xb400 &gic_its 0x12d0 0x2>,
+		  <0xb408 &gic_its 0x12d2 0x2>,
+		  <0xb500 &gic_its 0x12d4 0x2>,
+		  <0xb508 &gic_its 0x12d6 0x2>,
+		  <0xb600 &gic_its 0x12d8 0x2>,
+		  <0xb608 &gic_its 0x12da 0x2>,
+		  <0xb700 &gic_its 0x12dc 0x2>,
+		  <0xb708 &gic_its 0x12de 0x2>,
+		  <0xb800 &gic_its 0x12e0 0x2>,
+		  <0xb808 &gic_its 0x12e2 0x2>,
+		  <0xb900 &gic_its 0x12e4 0x2>,
+		  <0xb908 &gic_its 0x12e6 0x2>,
+		  <0xba00 &gic_its 0x12e8 0x2>,
+		  <0xba08 &gic_its 0x12ea 0x2>,
+		  <0xbb00 &gic_its 0x12ec 0x2>,
+		  <0xbb08 &gic_its 0x12ee 0x2>,
+		  <0xbc00 &gic_its 0x12f0 0x2>,
+		  <0xbc08 &gic_its 0x12f2 0x2>,
+		  <0xbd00 &gic_its 0x12f4 0x2>,
+		  <0xbd08 &gic_its 0x12f6 0x2>,
+		  <0xbe00 &gic_its 0x12f8 0x2>,
+		  <0xbe08 &gic_its 0x12fa 0x2>,
+		  <0xbf00 &gic_its 0x12fc 0x2>,
+		  <0xbf08 &gic_its 0x12fe 0x2>,
+		  <0xc000 &gic_its 0x1300 0x2>,
+		  <0xc008 &gic_its 0x1302 0x2>,
+		  <0xc100 &gic_its 0x1304 0x2>,
+		  <0xc108 &gic_its 0x1306 0x2>,
+		  <0xc200 &gic_its 0x1308 0x2>,
+		  <0xc208 &gic_its 0x130a 0x2>,
+		  <0xc300 &gic_its 0x130c 0x2>,
+		  <0xc308 &gic_its 0x130e 0x2>,
+		  <0xc400 &gic_its 0x1310 0x2>,
+		  <0xc408 &gic_its 0x1312 0x2>,
+		  <0xc500 &gic_its 0x1314 0x2>,
+		  <0xc508 &gic_its 0x1316 0x2>,
+		  <0xc600 &gic_its 0x1318 0x2>,
+		  <0xc608 &gic_its 0x131a 0x2>,
+		  <0xc700 &gic_its 0x131c 0x2>,
+		  <0xc708 &gic_its 0x131e 0x2>,
+		  <0xc800 &gic_its 0x1320 0x2>,
+		  <0xc808 &gic_its 0x1322 0x2>,
+		  <0xc900 &gic_its 0x1324 0x2>,
+		  <0xc908 &gic_its 0x1326 0x2>,
+		  <0xca00 &gic_its 0x1328 0x2>,
+		  <0xca08 &gic_its 0x132a 0x2>,
+		  <0xcb00 &gic_its 0x132c 0x2>,
+		  <0xcb08 &gic_its 0x132e 0x2>,
+		  <0xcc00 &gic_its 0x1330 0x2>,
+		  <0xcc08 &gic_its 0x1332 0x2>,
+		  <0xcd00 &gic_its 0x1334 0x2>,
+		  <0xcd08 &gic_its 0x1336 0x2>,
+		  <0xce00 &gic_its 0x1338 0x2>,
+		  <0xce08 &gic_its 0x133a 0x2>,
+		  <0xcf00 &gic_its 0x133c 0x2>,
+		  <0xcf08 &gic_its 0x133e 0x2>,
+		  <0xd000 &gic_its 0x1340 0x2>,
+		  <0xd008 &gic_its 0x1342 0x2>,
+		  <0xd100 &gic_its 0x1344 0x2>,
+		  <0xd108 &gic_its 0x1346 0x2>,
+		  <0xd200 &gic_its 0x1348 0x2>,
+		  <0xd208 &gic_its 0x134a 0x2>,
+		  <0xd300 &gic_its 0x134c 0x2>,
+		  <0xd308 &gic_its 0x134e 0x2>,
+		  <0xd400 &gic_its 0x1350 0x2>,
+		  <0xd408 &gic_its 0x1352 0x2>,
+		  <0xd500 &gic_its 0x1354 0x2>,
+		  <0xd508 &gic_its 0x1356 0x2>,
+		  <0xd600 &gic_its 0x1358 0x2>,
+		  <0xd608 &gic_its 0x135a 0x2>,
+		  <0xd700 &gic_its 0x135c 0x2>,
+		  <0xd708 &gic_its 0x135e 0x2>,
+		  <0xd800 &gic_its 0x1360 0x2>,
+		  <0xd808 &gic_its 0x1362 0x2>,
+		  <0xd900 &gic_its 0x1364 0x2>,
+		  <0xd908 &gic_its 0x1366 0x2>,
+		  <0xda00 &gic_its 0x1368 0x2>,
+		  <0xda08 &gic_its 0x136a 0x2>,
+		  <0xdb00 &gic_its 0x136c 0x2>,
+		  <0xdb08 &gic_its 0x136e 0x2>,
+		  <0xdc00 &gic_its 0x1370 0x2>,
+		  <0xdc08 &gic_its 0x1372 0x2>,
+		  <0xdd00 &gic_its 0x1374 0x2>,
+		  <0xdd08 &gic_its 0x1376 0x2>,
+		  <0xde00 &gic_its 0x1378 0x2>,
+		  <0xde08 &gic_its 0x137a 0x2>,
+		  <0xdf00 &gic_its 0x137c 0x2>,
+		  <0xdf08 &gic_its 0x137e 0x2>,
+		  <0xe000 &gic_its 0x1380 0x2>,
+		  <0xe008 &gic_its 0x1382 0x2>,
+		  <0xe100 &gic_its 0x1384 0x2>,
+		  <0xe108 &gic_its 0x1386 0x2>,
+		  <0xe200 &gic_its 0x1388 0x2>,
+		  <0xe208 &gic_its 0x138a 0x2>,
+		  <0xe300 &gic_its 0x138c 0x2>,
+		  <0xe308 &gic_its 0x138e 0x2>,
+		  <0xe400 &gic_its 0x1390 0x2>,
+		  <0xe408 &gic_its 0x1392 0x2>,
+		  <0xe500 &gic_its 0x1394 0x2>,
+		  <0xe508 &gic_its 0x1396 0x2>,
+		  <0xe600 &gic_its 0x1398 0x2>,
+		  <0xe608 &gic_its 0x139a 0x2>,
+		  <0xe700 &gic_its 0x139c 0x2>,
+		  <0xe708 &gic_its 0x139e 0x2>,
+		  <0xe800 &gic_its 0x13a0 0x2>,
+		  <0xe808 &gic_its 0x13a2 0x2>,
+		  <0xe900 &gic_its 0x13a4 0x2>,
+		  <0xe908 &gic_its 0x13a6 0x2>,
+		  <0xea00 &gic_its 0x13a8 0x2>,
+		  <0xea08 &gic_its 0x13aa 0x2>,
+		  <0xeb00 &gic_its 0x13ac 0x2>,
+		  <0xeb08 &gic_its 0x13ae 0x2>,
+		  <0xec00 &gic_its 0x13b0 0x2>,
+		  <0xec08 &gic_its 0x13b2 0x2>,
+		  <0xed00 &gic_its 0x13b4 0x2>,
+		  <0xed08 &gic_its 0x13b6 0x2>,
+		  <0xee00 &gic_its 0x13b8 0x2>,
+		  <0xee08 &gic_its 0x13ba 0x2>,
+		  <0xef00 &gic_its 0x13bc 0x2>,
+		  <0xef08 &gic_its 0x13be 0x2>,
+		  <0xf000 &gic_its 0x13c0 0x2>,
+		  <0xf008 &gic_its 0x13c2 0x2>,
+		  <0xf100 &gic_its 0x13c4 0x2>,
+		  <0xf108 &gic_its 0x13c6 0x2>,
+		  <0xf200 &gic_its 0x13c8 0x2>,
+		  <0xf208 &gic_its 0x13ca 0x2>,
+		  <0xf300 &gic_its 0x13cc 0x2>,
+		  <0xf308 &gic_its 0x13ce 0x2>,
+		  <0xf400 &gic_its 0x13d0 0x2>,
+		  <0xf408 &gic_its 0x13d2 0x2>,
+		  <0xf500 &gic_its 0x13d4 0x2>,
+		  <0xf508 &gic_its 0x13d6 0x2>,
+		  <0xf600 &gic_its 0x13d8 0x2>,
+		  <0xf608 &gic_its 0x13da 0x2>,
+		  <0xf700 &gic_its 0x13dc 0x2>,
+		  <0xf708 &gic_its 0x13de 0x2>,
+		  <0xf800 &gic_its 0x13e0 0x2>,
+		  <0xf808 &gic_its 0x13e2 0x2>,
+		  <0xf900 &gic_its 0x13e4 0x2>,
+		  <0xf908 &gic_its 0x13e6 0x2>,
+		  <0xfa00 &gic_its 0x13e8 0x2>,
+		  <0xfa08 &gic_its 0x13ea 0x2>,
+		  <0xfb00 &gic_its 0x13ec 0x2>,
+		  <0xfb08 &gic_its 0x13ee 0x2>,
+		  <0xfc00 &gic_its 0x13f0 0x2>,
+		  <0xfc08 &gic_its 0x13f2 0x2>,
+		  <0xfd00 &gic_its 0x13f4 0x2>,
+		  <0xfd08 &gic_its 0x13f6 0x2>,
+		  <0xfe00 &gic_its 0x13f8 0x2>,
+		  <0xfe08 &gic_its 0x13fa 0x2>,
+		  <0xff00 &gic_its 0x13fc 0x2>,
+		  <0xff08 &gic_its 0x13fe 0x2>;
+#if (ENABLE_PAXB_IOMMU == 1)
+		iommu-map = <0x0000 &smmu 0x1000 0x2>,
+			    <0x0008 &smmu 0x1002 0x2>,
+			    <0x0100 &smmu 0x1004 0x2>,
+			    <0x0108 &smmu 0x1006 0x2>,
+			    <0x0200 &smmu 0x1008 0x2>,
+			    <0x0208 &smmu 0x100a 0x2>,
+			    <0x0300 &smmu 0x100c 0x2>,
+			    <0x0308 &smmu 0x100e 0x2>,
+			    <0x0400 &smmu 0x1010 0x2>,
+			    <0x0408 &smmu 0x1012 0x2>,
+			    <0x0500 &smmu 0x1014 0x2>,
+			    <0x0508 &smmu 0x1016 0x2>,
+			    <0x0600 &smmu 0x1018 0x2>,
+			    <0x0608 &smmu 0x101a 0x2>,
+			    <0x0700 &smmu 0x101c 0x2>,
+			    <0x0708 &smmu 0x101e 0x2>,
+			    <0x0800 &smmu 0x1020 0x2>,
+			    <0x0808 &smmu 0x1022 0x2>,
+			    <0x0900 &smmu 0x1024 0x2>,
+			    <0x0908 &smmu 0x1026 0x2>,
+			    <0x0a00 &smmu 0x1028 0x2>,
+			    <0x0a08 &smmu 0x102a 0x2>,
+			    <0x0b00 &smmu 0x102c 0x2>,
+			    <0x0b08 &smmu 0x102e 0x2>,
+			    <0x0c00 &smmu 0x1030 0x2>,
+			    <0x0c08 &smmu 0x1032 0x2>,
+			    <0x0d00 &smmu 0x1034 0x2>,
+			    <0x0d08 &smmu 0x1036 0x2>,
+			    <0x0e00 &smmu 0x1038 0x2>,
+			    <0x0e08 &smmu 0x103a 0x2>,
+			    <0x0f00 &smmu 0x103c 0x2>,
+			    <0x0f08 &smmu 0x103e 0x2>,
+			    <0x1000 &smmu 0x1040 0x2>,
+			    <0x1008 &smmu 0x1042 0x2>,
+			    <0x1100 &smmu 0x1044 0x2>,
+			    <0x1108 &smmu 0x1046 0x2>,
+			    <0x1200 &smmu 0x1048 0x2>,
+			    <0x1208 &smmu 0x104a 0x2>,
+			    <0x1300 &smmu 0x104c 0x2>,
+			    <0x1308 &smmu 0x104e 0x2>,
+			    <0x1400 &smmu 0x1050 0x2>,
+			    <0x1408 &smmu 0x1052 0x2>,
+			    <0x1500 &smmu 0x1054 0x2>,
+			    <0x1508 &smmu 0x1056 0x2>,
+			    <0x1600 &smmu 0x1058 0x2>,
+			    <0x1608 &smmu 0x105a 0x2>,
+			    <0x1700 &smmu 0x105c 0x2>,
+			    <0x1708 &smmu 0x105e 0x2>,
+			    <0x1800 &smmu 0x1060 0x2>,
+			    <0x1808 &smmu 0x1062 0x2>,
+			    <0x1900 &smmu 0x1064 0x2>,
+			    <0x1908 &smmu 0x1066 0x2>,
+			    <0x1a00 &smmu 0x1068 0x2>,
+			    <0x1a08 &smmu 0x106a 0x2>,
+			    <0x1b00 &smmu 0x106c 0x2>,
+			    <0x1b08 &smmu 0x106e 0x2>,
+			    <0x1c00 &smmu 0x1070 0x2>,
+			    <0x1c08 &smmu 0x1072 0x2>,
+			    <0x1d00 &smmu 0x1074 0x2>,
+			    <0x1d08 &smmu 0x1076 0x2>,
+			    <0x1e00 &smmu 0x1078 0x2>,
+			    <0x1e08 &smmu 0x107a 0x2>,
+			    <0x1f00 &smmu 0x107c 0x2>,
+			    <0x1f08 &smmu 0x107e 0x2>,
+			    <0x2000 &smmu 0x1080 0x2>,
+			    <0x2008 &smmu 0x1082 0x2>,
+			    <0x2100 &smmu 0x1084 0x2>,
+			    <0x2108 &smmu 0x1086 0x2>,
+			    <0x2200 &smmu 0x1088 0x2>,
+			    <0x2208 &smmu 0x108a 0x2>,
+			    <0x2300 &smmu 0x108c 0x2>,
+			    <0x2308 &smmu 0x108e 0x2>,
+			    <0x2400 &smmu 0x1090 0x2>,
+			    <0x2408 &smmu 0x1092 0x2>,
+			    <0x2500 &smmu 0x1094 0x2>,
+			    <0x2508 &smmu 0x1096 0x2>,
+			    <0x2600 &smmu 0x1098 0x2>,
+			    <0x2608 &smmu 0x109a 0x2>,
+			    <0x2700 &smmu 0x109c 0x2>,
+			    <0x2708 &smmu 0x109e 0x2>,
+			    <0x2800 &smmu 0x10a0 0x2>,
+			    <0x2808 &smmu 0x10a2 0x2>,
+			    <0x2900 &smmu 0x10a4 0x2>,
+			    <0x2908 &smmu 0x10a6 0x2>,
+			    <0x2a00 &smmu 0x10a8 0x2>,
+			    <0x2a08 &smmu 0x10aa 0x2>,
+			    <0x2b00 &smmu 0x10ac 0x2>,
+			    <0x2b08 &smmu 0x10ae 0x2>,
+			    <0x2c00 &smmu 0x10b0 0x2>,
+			    <0x2c08 &smmu 0x10b2 0x2>,
+			    <0x2d00 &smmu 0x10b4 0x2>,
+			    <0x2d08 &smmu 0x10b6 0x2>,
+			    <0x2e00 &smmu 0x10b8 0x2>,
+			    <0x2e08 &smmu 0x10ba 0x2>,
+			    <0x2f00 &smmu 0x10bc 0x2>,
+			    <0x2f08 &smmu 0x10be 0x2>,
+			    <0x3000 &smmu 0x10c0 0x2>,
+			    <0x3008 &smmu 0x10c2 0x2>,
+			    <0x3100 &smmu 0x10c4 0x2>,
+			    <0x3108 &smmu 0x10c6 0x2>,
+			    <0x3200 &smmu 0x10c8 0x2>,
+			    <0x3208 &smmu 0x10ca 0x2>,
+			    <0x3300 &smmu 0x10cc 0x2>,
+			    <0x3308 &smmu 0x10ce 0x2>,
+			    <0x3400 &smmu 0x10d0 0x2>,
+			    <0x3408 &smmu 0x10d2 0x2>,
+			    <0x3500 &smmu 0x10d4 0x2>,
+			    <0x3508 &smmu 0x10d6 0x2>,
+			    <0x3600 &smmu 0x10d8 0x2>,
+			    <0x3608 &smmu 0x10da 0x2>,
+			    <0x3700 &smmu 0x10dc 0x2>,
+			    <0x3708 &smmu 0x10de 0x2>,
+			    <0x3800 &smmu 0x10e0 0x2>,
+			    <0x3808 &smmu 0x10e2 0x2>,
+			    <0x3900 &smmu 0x10e4 0x2>,
+			    <0x3908 &smmu 0x10e6 0x2>,
+			    <0x3a00 &smmu 0x10e8 0x2>,
+			    <0x3a08 &smmu 0x10ea 0x2>,
+			    <0x3b00 &smmu 0x10ec 0x2>,
+			    <0x3b08 &smmu 0x10ee 0x2>,
+			    <0x3c00 &smmu 0x10f0 0x2>,
+			    <0x3c08 &smmu 0x10f2 0x2>,
+			    <0x3d00 &smmu 0x10f4 0x2>,
+			    <0x3d08 &smmu 0x10f6 0x2>,
+			    <0x3e00 &smmu 0x10f8 0x2>,
+			    <0x3e08 &smmu 0x10fa 0x2>,
+			    <0x3f00 &smmu 0x10fc 0x2>,
+			    <0x3f08 &smmu 0x10fe 0x2>,
+			    <0x4000 &smmu 0x1100 0x2>,
+			    <0x4008 &smmu 0x1102 0x2>,
+			    <0x4100 &smmu 0x1104 0x2>,
+			    <0x4108 &smmu 0x1106 0x2>,
+			    <0x4200 &smmu 0x1108 0x2>,
+			    <0x4208 &smmu 0x110a 0x2>,
+			    <0x4300 &smmu 0x110c 0x2>,
+			    <0x4308 &smmu 0x110e 0x2>,
+			    <0x4400 &smmu 0x1110 0x2>,
+			    <0x4408 &smmu 0x1112 0x2>,
+			    <0x4500 &smmu 0x1114 0x2>,
+			    <0x4508 &smmu 0x1116 0x2>,
+			    <0x4600 &smmu 0x1118 0x2>,
+			    <0x4608 &smmu 0x111a 0x2>,
+			    <0x4700 &smmu 0x111c 0x2>,
+			    <0x4708 &smmu 0x111e 0x2>,
+			    <0x4800 &smmu 0x1120 0x2>,
+			    <0x4808 &smmu 0x1122 0x2>,
+			    <0x4900 &smmu 0x1124 0x2>,
+			    <0x4908 &smmu 0x1126 0x2>,
+			    <0x4a00 &smmu 0x1128 0x2>,
+			    <0x4a08 &smmu 0x112a 0x2>,
+			    <0x4b00 &smmu 0x112c 0x2>,
+			    <0x4b08 &smmu 0x112e 0x2>,
+			    <0x4c00 &smmu 0x1130 0x2>,
+			    <0x4c08 &smmu 0x1132 0x2>,
+			    <0x4d00 &smmu 0x1134 0x2>,
+			    <0x4d08 &smmu 0x1136 0x2>,
+			    <0x4e00 &smmu 0x1138 0x2>,
+			    <0x4e08 &smmu 0x113a 0x2>,
+			    <0x4f00 &smmu 0x113c 0x2>,
+			    <0x4f08 &smmu 0x113e 0x2>,
+			    <0x5000 &smmu 0x1140 0x2>,
+			    <0x5008 &smmu 0x1142 0x2>,
+			    <0x5100 &smmu 0x1144 0x2>,
+			    <0x5108 &smmu 0x1146 0x2>,
+			    <0x5200 &smmu 0x1148 0x2>,
+			    <0x5208 &smmu 0x114a 0x2>,
+			    <0x5300 &smmu 0x114c 0x2>,
+			    <0x5308 &smmu 0x114e 0x2>,
+			    <0x5400 &smmu 0x1150 0x2>,
+			    <0x5408 &smmu 0x1152 0x2>,
+			    <0x5500 &smmu 0x1154 0x2>,
+			    <0x5508 &smmu 0x1156 0x2>,
+			    <0x5600 &smmu 0x1158 0x2>,
+			    <0x5608 &smmu 0x115a 0x2>,
+			    <0x5700 &smmu 0x115c 0x2>,
+			    <0x5708 &smmu 0x115e 0x2>,
+			    <0x5800 &smmu 0x1160 0x2>,
+			    <0x5808 &smmu 0x1162 0x2>,
+			    <0x5900 &smmu 0x1164 0x2>,
+			    <0x5908 &smmu 0x1166 0x2>,
+			    <0x5a00 &smmu 0x1168 0x2>,
+			    <0x5a08 &smmu 0x116a 0x2>,
+			    <0x5b00 &smmu 0x116c 0x2>,
+			    <0x5b08 &smmu 0x116e 0x2>,
+			    <0x5c00 &smmu 0x1170 0x2>,
+			    <0x5c08 &smmu 0x1172 0x2>,
+			    <0x5d00 &smmu 0x1174 0x2>,
+			    <0x5d08 &smmu 0x1176 0x2>,
+			    <0x5e00 &smmu 0x1178 0x2>,
+			    <0x5e08 &smmu 0x117a 0x2>,
+			    <0x5f00 &smmu 0x117c 0x2>,
+			    <0x5f08 &smmu 0x117e 0x2>,
+			    <0x6000 &smmu 0x1180 0x2>,
+			    <0x6008 &smmu 0x1182 0x2>,
+			    <0x6100 &smmu 0x1184 0x2>,
+			    <0x6108 &smmu 0x1186 0x2>,
+			    <0x6200 &smmu 0x1188 0x2>,
+			    <0x6208 &smmu 0x118a 0x2>,
+			    <0x6300 &smmu 0x118c 0x2>,
+			    <0x6308 &smmu 0x118e 0x2>,
+			    <0x6400 &smmu 0x1190 0x2>,
+			    <0x6408 &smmu 0x1192 0x2>,
+			    <0x6500 &smmu 0x1194 0x2>,
+			    <0x6508 &smmu 0x1196 0x2>,
+			    <0x6600 &smmu 0x1198 0x2>,
+			    <0x6608 &smmu 0x119a 0x2>,
+			    <0x6700 &smmu 0x119c 0x2>,
+			    <0x6708 &smmu 0x119e 0x2>,
+			    <0x6800 &smmu 0x11a0 0x2>,
+			    <0x6808 &smmu 0x11a2 0x2>,
+			    <0x6900 &smmu 0x11a4 0x2>,
+			    <0x6908 &smmu 0x11a6 0x2>,
+			    <0x6a00 &smmu 0x11a8 0x2>,
+			    <0x6a08 &smmu 0x11aa 0x2>,
+			    <0x6b00 &smmu 0x11ac 0x2>,
+			    <0x6b08 &smmu 0x11ae 0x2>,
+			    <0x6c00 &smmu 0x11b0 0x2>,
+			    <0x6c08 &smmu 0x11b2 0x2>,
+			    <0x6d00 &smmu 0x11b4 0x2>,
+			    <0x6d08 &smmu 0x11b6 0x2>,
+			    <0x6e00 &smmu 0x11b8 0x2>,
+			    <0x6e08 &smmu 0x11ba 0x2>,
+			    <0x6f00 &smmu 0x11bc 0x2>,
+			    <0x6f08 &smmu 0x11be 0x2>,
+			    <0x7000 &smmu 0x11c0 0x2>,
+			    <0x7008 &smmu 0x11c2 0x2>,
+			    <0x7100 &smmu 0x11c4 0x2>,
+			    <0x7108 &smmu 0x11c6 0x2>,
+			    <0x7200 &smmu 0x11c8 0x2>,
+			    <0x7208 &smmu 0x11ca 0x2>,
+			    <0x7300 &smmu 0x11cc 0x2>,
+			    <0x7308 &smmu 0x11ce 0x2>,
+			    <0x7400 &smmu 0x11d0 0x2>,
+			    <0x7408 &smmu 0x11d2 0x2>,
+			    <0x7500 &smmu 0x11d4 0x2>,
+			    <0x7508 &smmu 0x11d6 0x2>,
+			    <0x7600 &smmu 0x11d8 0x2>,
+			    <0x7608 &smmu 0x11da 0x2>,
+			    <0x7700 &smmu 0x11dc 0x2>,
+			    <0x7708 &smmu 0x11de 0x2>,
+			    <0x7800 &smmu 0x11e0 0x2>,
+			    <0x7808 &smmu 0x11e2 0x2>,
+			    <0x7900 &smmu 0x11e4 0x2>,
+			    <0x7908 &smmu 0x11e6 0x2>,
+			    <0x7a00 &smmu 0x11e8 0x2>,
+			    <0x7a08 &smmu 0x11ea 0x2>,
+			    <0x7b00 &smmu 0x11ec 0x2>,
+			    <0x7b08 &smmu 0x11ee 0x2>,
+			    <0x7c00 &smmu 0x11f0 0x2>,
+			    <0x7c08 &smmu 0x11f2 0x2>,
+			    <0x7d00 &smmu 0x11f4 0x2>,
+			    <0x7d08 &smmu 0x11f6 0x2>,
+			    <0x7e00 &smmu 0x11f8 0x2>,
+			    <0x7e08 &smmu 0x11fa 0x2>,
+			    <0x7f00 &smmu 0x11fc 0x2>,
+			    <0x7f08 &smmu 0x11fe 0x2>,
+			    <0x8000 &smmu 0x1200 0x2>,
+			    <0x8008 &smmu 0x1202 0x2>,
+			    <0x8100 &smmu 0x1204 0x2>,
+			    <0x8108 &smmu 0x1206 0x2>,
+			    <0x8200 &smmu 0x1208 0x2>,
+			    <0x8208 &smmu 0x120a 0x2>,
+			    <0x8300 &smmu 0x120c 0x2>,
+			    <0x8308 &smmu 0x120e 0x2>,
+			    <0x8400 &smmu 0x1210 0x2>,
+			    <0x8408 &smmu 0x1212 0x2>,
+			    <0x8500 &smmu 0x1214 0x2>,
+			    <0x8508 &smmu 0x1216 0x2>,
+			    <0x8600 &smmu 0x1218 0x2>,
+			    <0x8608 &smmu 0x121a 0x2>,
+			    <0x8700 &smmu 0x121c 0x2>,
+			    <0x8708 &smmu 0x121e 0x2>,
+			    <0x8800 &smmu 0x1220 0x2>,
+			    <0x8808 &smmu 0x1222 0x2>,
+			    <0x8900 &smmu 0x1224 0x2>,
+			    <0x8908 &smmu 0x1226 0x2>,
+			    <0x8a00 &smmu 0x1228 0x2>,
+			    <0x8a08 &smmu 0x122a 0x2>,
+			    <0x8b00 &smmu 0x122c 0x2>,
+			    <0x8b08 &smmu 0x122e 0x2>,
+			    <0x8c00 &smmu 0x1230 0x2>,
+			    <0x8c08 &smmu 0x1232 0x2>,
+			    <0x8d00 &smmu 0x1234 0x2>,
+			    <0x8d08 &smmu 0x1236 0x2>,
+			    <0x8e00 &smmu 0x1238 0x2>,
+			    <0x8e08 &smmu 0x123a 0x2>,
+			    <0x8f00 &smmu 0x123c 0x2>,
+			    <0x8f08 &smmu 0x123e 0x2>,
+			    <0x9000 &smmu 0x1240 0x2>,
+			    <0x9008 &smmu 0x1242 0x2>,
+			    <0x9100 &smmu 0x1244 0x2>,
+			    <0x9108 &smmu 0x1246 0x2>,
+			    <0x9200 &smmu 0x1248 0x2>,
+			    <0x9208 &smmu 0x124a 0x2>,
+			    <0x9300 &smmu 0x124c 0x2>,
+			    <0x9308 &smmu 0x124e 0x2>,
+			    <0x9400 &smmu 0x1250 0x2>,
+			    <0x9408 &smmu 0x1252 0x2>,
+			    <0x9500 &smmu 0x1254 0x2>,
+			    <0x9508 &smmu 0x1256 0x2>,
+			    <0x9600 &smmu 0x1258 0x2>,
+			    <0x9608 &smmu 0x125a 0x2>,
+			    <0x9700 &smmu 0x125c 0x2>,
+			    <0x9708 &smmu 0x125e 0x2>,
+			    <0x9800 &smmu 0x1260 0x2>,
+			    <0x9808 &smmu 0x1262 0x2>,
+			    <0x9900 &smmu 0x1264 0x2>,
+			    <0x9908 &smmu 0x1266 0x2>,
+			    <0x9a00 &smmu 0x1268 0x2>,
+			    <0x9a08 &smmu 0x126a 0x2>,
+			    <0x9b00 &smmu 0x126c 0x2>,
+			    <0x9b08 &smmu 0x126e 0x2>,
+			    <0x9c00 &smmu 0x1270 0x2>,
+			    <0x9c08 &smmu 0x1272 0x2>,
+			    <0x9d00 &smmu 0x1274 0x2>,
+			    <0x9d08 &smmu 0x1276 0x2>,
+			    <0x9e00 &smmu 0x1278 0x2>,
+			    <0x9e08 &smmu 0x127a 0x2>,
+			    <0x9f00 &smmu 0x127c 0x2>,
+			    <0x9f08 &smmu 0x127e 0x2>,
+			    <0xa000 &smmu 0x1280 0x2>,
+			    <0xa008 &smmu 0x1282 0x2>,
+			    <0xa100 &smmu 0x1284 0x2>,
+			    <0xa108 &smmu 0x1286 0x2>,
+			    <0xa200 &smmu 0x1288 0x2>,
+			    <0xa208 &smmu 0x128a 0x2>,
+			    <0xa300 &smmu 0x128c 0x2>,
+			    <0xa308 &smmu 0x128e 0x2>,
+			    <0xa400 &smmu 0x1290 0x2>,
+			    <0xa408 &smmu 0x1292 0x2>,
+			    <0xa500 &smmu 0x1294 0x2>,
+			    <0xa508 &smmu 0x1296 0x2>,
+			    <0xa600 &smmu 0x1298 0x2>,
+			    <0xa608 &smmu 0x129a 0x2>,
+			    <0xa700 &smmu 0x129c 0x2>,
+			    <0xa708 &smmu 0x129e 0x2>,
+			    <0xa800 &smmu 0x12a0 0x2>,
+			    <0xa808 &smmu 0x12a2 0x2>,
+			    <0xa900 &smmu 0x12a4 0x2>,
+			    <0xa908 &smmu 0x12a6 0x2>,
+			    <0xaa00 &smmu 0x12a8 0x2>,
+			    <0xaa08 &smmu 0x12aa 0x2>,
+			    <0xab00 &smmu 0x12ac 0x2>,
+			    <0xab08 &smmu 0x12ae 0x2>,
+			    <0xac00 &smmu 0x12b0 0x2>,
+			    <0xac08 &smmu 0x12b2 0x2>,
+			    <0xad00 &smmu 0x12b4 0x2>,
+			    <0xad08 &smmu 0x12b6 0x2>,
+			    <0xae00 &smmu 0x12b8 0x2>,
+			    <0xae08 &smmu 0x12ba 0x2>,
+			    <0xaf00 &smmu 0x12bc 0x2>,
+			    <0xaf08 &smmu 0x12be 0x2>,
+			    <0xb000 &smmu 0x12c0 0x2>,
+			    <0xb008 &smmu 0x12c2 0x2>,
+			    <0xb100 &smmu 0x12c4 0x2>,
+			    <0xb108 &smmu 0x12c6 0x2>,
+			    <0xb200 &smmu 0x12c8 0x2>,
+			    <0xb208 &smmu 0x12ca 0x2>,
+			    <0xb300 &smmu 0x12cc 0x2>,
+			    <0xb308 &smmu 0x12ce 0x2>,
+			    <0xb400 &smmu 0x12d0 0x2>,
+			    <0xb408 &smmu 0x12d2 0x2>,
+			    <0xb500 &smmu 0x12d4 0x2>,
+			    <0xb508 &smmu 0x12d6 0x2>,
+			    <0xb600 &smmu 0x12d8 0x2>,
+			    <0xb608 &smmu 0x12da 0x2>,
+			    <0xb700 &smmu 0x12dc 0x2>,
+			    <0xb708 &smmu 0x12de 0x2>,
+			    <0xb800 &smmu 0x12e0 0x2>,
+			    <0xb808 &smmu 0x12e2 0x2>,
+			    <0xb900 &smmu 0x12e4 0x2>,
+			    <0xb908 &smmu 0x12e6 0x2>,
+			    <0xba00 &smmu 0x12e8 0x2>,
+			    <0xba08 &smmu 0x12ea 0x2>,
+			    <0xbb00 &smmu 0x12ec 0x2>,
+			    <0xbb08 &smmu 0x12ee 0x2>,
+			    <0xbc00 &smmu 0x12f0 0x2>,
+			    <0xbc08 &smmu 0x12f2 0x2>,
+			    <0xbd00 &smmu 0x12f4 0x2>,
+			    <0xbd08 &smmu 0x12f6 0x2>,
+			    <0xbe00 &smmu 0x12f8 0x2>,
+			    <0xbe08 &smmu 0x12fa 0x2>,
+			    <0xbf00 &smmu 0x12fc 0x2>,
+			    <0xbf08 &smmu 0x12fe 0x2>,
+			    <0xc000 &smmu 0x1300 0x2>,
+			    <0xc008 &smmu 0x1302 0x2>,
+			    <0xc100 &smmu 0x1304 0x2>,
+			    <0xc108 &smmu 0x1306 0x2>,
+			    <0xc200 &smmu 0x1308 0x2>,
+			    <0xc208 &smmu 0x130a 0x2>,
+			    <0xc300 &smmu 0x130c 0x2>,
+			    <0xc308 &smmu 0x130e 0x2>,
+			    <0xc400 &smmu 0x1310 0x2>,
+			    <0xc408 &smmu 0x1312 0x2>,
+			    <0xc500 &smmu 0x1314 0x2>,
+			    <0xc508 &smmu 0x1316 0x2>,
+			    <0xc600 &smmu 0x1318 0x2>,
+			    <0xc608 &smmu 0x131a 0x2>,
+			    <0xc700 &smmu 0x131c 0x2>,
+			    <0xc708 &smmu 0x131e 0x2>,
+			    <0xc800 &smmu 0x1320 0x2>,
+			    <0xc808 &smmu 0x1322 0x2>,
+			    <0xc900 &smmu 0x1324 0x2>,
+			    <0xc908 &smmu 0x1326 0x2>,
+			    <0xca00 &smmu 0x1328 0x2>,
+			    <0xca08 &smmu 0x132a 0x2>,
+			    <0xcb00 &smmu 0x132c 0x2>,
+			    <0xcb08 &smmu 0x132e 0x2>,
+			    <0xcc00 &smmu 0x1330 0x2>,
+			    <0xcc08 &smmu 0x1332 0x2>,
+			    <0xcd00 &smmu 0x1334 0x2>,
+			    <0xcd08 &smmu 0x1336 0x2>,
+			    <0xce00 &smmu 0x1338 0x2>,
+			    <0xce08 &smmu 0x133a 0x2>,
+			    <0xcf00 &smmu 0x133c 0x2>,
+			    <0xcf08 &smmu 0x133e 0x2>,
+			    <0xd000 &smmu 0x1340 0x2>,
+			    <0xd008 &smmu 0x1342 0x2>,
+			    <0xd100 &smmu 0x1344 0x2>,
+			    <0xd108 &smmu 0x1346 0x2>,
+			    <0xd200 &smmu 0x1348 0x2>,
+			    <0xd208 &smmu 0x134a 0x2>,
+			    <0xd300 &smmu 0x134c 0x2>,
+			    <0xd308 &smmu 0x134e 0x2>,
+			    <0xd400 &smmu 0x1350 0x2>,
+			    <0xd408 &smmu 0x1352 0x2>,
+			    <0xd500 &smmu 0x1354 0x2>,
+			    <0xd508 &smmu 0x1356 0x2>,
+			    <0xd600 &smmu 0x1358 0x2>,
+			    <0xd608 &smmu 0x135a 0x2>,
+			    <0xd700 &smmu 0x135c 0x2>,
+			    <0xd708 &smmu 0x135e 0x2>,
+			    <0xd800 &smmu 0x1360 0x2>,
+			    <0xd808 &smmu 0x1362 0x2>,
+			    <0xd900 &smmu 0x1364 0x2>,
+			    <0xd908 &smmu 0x1366 0x2>,
+			    <0xda00 &smmu 0x1368 0x2>,
+			    <0xda08 &smmu 0x136a 0x2>,
+			    <0xdb00 &smmu 0x136c 0x2>,
+			    <0xdb08 &smmu 0x136e 0x2>,
+			    <0xdc00 &smmu 0x1370 0x2>,
+			    <0xdc08 &smmu 0x1372 0x2>,
+			    <0xdd00 &smmu 0x1374 0x2>,
+			    <0xdd08 &smmu 0x1376 0x2>,
+			    <0xde00 &smmu 0x1378 0x2>,
+			    <0xde08 &smmu 0x137a 0x2>,
+			    <0xdf00 &smmu 0x137c 0x2>,
+			    <0xdf08 &smmu 0x137e 0x2>,
+			    <0xe000 &smmu 0x1380 0x2>,
+			    <0xe008 &smmu 0x1382 0x2>,
+			    <0xe100 &smmu 0x1384 0x2>,
+			    <0xe108 &smmu 0x1386 0x2>,
+			    <0xe200 &smmu 0x1388 0x2>,
+			    <0xe208 &smmu 0x138a 0x2>,
+			    <0xe300 &smmu 0x138c 0x2>,
+			    <0xe308 &smmu 0x138e 0x2>,
+			    <0xe400 &smmu 0x1390 0x2>,
+			    <0xe408 &smmu 0x1392 0x2>,
+			    <0xe500 &smmu 0x1394 0x2>,
+			    <0xe508 &smmu 0x1396 0x2>,
+			    <0xe600 &smmu 0x1398 0x2>,
+			    <0xe608 &smmu 0x139a 0x2>,
+			    <0xe700 &smmu 0x139c 0x2>,
+			    <0xe708 &smmu 0x139e 0x2>,
+			    <0xe800 &smmu 0x13a0 0x2>,
+			    <0xe808 &smmu 0x13a2 0x2>,
+			    <0xe900 &smmu 0x13a4 0x2>,
+			    <0xe908 &smmu 0x13a6 0x2>,
+			    <0xea00 &smmu 0x13a8 0x2>,
+			    <0xea08 &smmu 0x13aa 0x2>,
+			    <0xeb00 &smmu 0x13ac 0x2>,
+			    <0xeb08 &smmu 0x13ae 0x2>,
+			    <0xec00 &smmu 0x13b0 0x2>,
+			    <0xec08 &smmu 0x13b2 0x2>,
+			    <0xed00 &smmu 0x13b4 0x2>,
+			    <0xed08 &smmu 0x13b6 0x2>,
+			    <0xee00 &smmu 0x13b8 0x2>,
+			    <0xee08 &smmu 0x13ba 0x2>,
+			    <0xef00 &smmu 0x13bc 0x2>,
+			    <0xef08 &smmu 0x13be 0x2>,
+			    <0xf000 &smmu 0x13c0 0x2>,
+			    <0xf008 &smmu 0x13c2 0x2>,
+			    <0xf100 &smmu 0x13c4 0x2>,
+			    <0xf108 &smmu 0x13c6 0x2>,
+			    <0xf200 &smmu 0x13c8 0x2>,
+			    <0xf208 &smmu 0x13ca 0x2>,
+			    <0xf300 &smmu 0x13cc 0x2>,
+			    <0xf308 &smmu 0x13ce 0x2>,
+			    <0xf400 &smmu 0x13d0 0x2>,
+			    <0xf408 &smmu 0x13d2 0x2>,
+			    <0xf500 &smmu 0x13d4 0x2>,
+			    <0xf508 &smmu 0x13d6 0x2>,
+			    <0xf600 &smmu 0x13d8 0x2>,
+			    <0xf608 &smmu 0x13da 0x2>,
+			    <0xf700 &smmu 0x13dc 0x2>,
+			    <0xf708 &smmu 0x13de 0x2>,
+			    <0xf800 &smmu 0x13e0 0x2>,
+			    <0xf808 &smmu 0x13e2 0x2>,
+			    <0xf900 &smmu 0x13e4 0x2>,
+			    <0xf908 &smmu 0x13e6 0x2>,
+			    <0xfa00 &smmu 0x13e8 0x2>,
+			    <0xfa08 &smmu 0x13ea 0x2>,
+			    <0xfb00 &smmu 0x13ec 0x2>,
+			    <0xfb08 &smmu 0x13ee 0x2>,
+			    <0xfc00 &smmu 0x13f0 0x2>,
+			    <0xfc08 &smmu 0x13f2 0x2>,
+			    <0xfd00 &smmu 0x13f4 0x2>,
+			    <0xfd08 &smmu 0x13f6 0x2>,
+			    <0xfe00 &smmu 0x13f8 0x2>,
+			    <0xfe08 &smmu 0x13fa 0x2>,
+			    <0xff00 &smmu 0x13fc 0x2>,
+			    <0xff08 &smmu 0x13fe 0x2>;
+#endif
+};
+
+&pcie5 {
+	msi-map = <0x0000 &gic_its 0x1400 0x2>,
+		  <0x0008 &gic_its 0x1402 0x2>,
+		  <0x0100 &gic_its 0x1404 0x2>,
+		  <0x0108 &gic_its 0x1406 0x2>,
+		  <0x0200 &gic_its 0x1408 0x2>,
+		  <0x0208 &gic_its 0x140a 0x2>,
+		  <0x0300 &gic_its 0x140c 0x2>,
+		  <0x0308 &gic_its 0x140e 0x2>,
+		  <0x0400 &gic_its 0x1410 0x2>,
+		  <0x0408 &gic_its 0x1412 0x2>,
+		  <0x0500 &gic_its 0x1414 0x2>,
+		  <0x0508 &gic_its 0x1416 0x2>,
+		  <0x0600 &gic_its 0x1418 0x2>,
+		  <0x0608 &gic_its 0x141a 0x2>,
+		  <0x0700 &gic_its 0x141c 0x2>,
+		  <0x0708 &gic_its 0x141e 0x2>,
+		  <0x0800 &gic_its 0x1420 0x2>,
+		  <0x0808 &gic_its 0x1422 0x2>,
+		  <0x0900 &gic_its 0x1424 0x2>,
+		  <0x0908 &gic_its 0x1426 0x2>,
+		  <0x0a00 &gic_its 0x1428 0x2>,
+		  <0x0a08 &gic_its 0x142a 0x2>,
+		  <0x0b00 &gic_its 0x142c 0x2>,
+		  <0x0b08 &gic_its 0x142e 0x2>,
+		  <0x0c00 &gic_its 0x1430 0x2>,
+		  <0x0c08 &gic_its 0x1432 0x2>,
+		  <0x0d00 &gic_its 0x1434 0x2>,
+		  <0x0d08 &gic_its 0x1436 0x2>,
+		  <0x0e00 &gic_its 0x1438 0x2>,
+		  <0x0e08 &gic_its 0x143a 0x2>,
+		  <0x0f00 &gic_its 0x143c 0x2>,
+		  <0x0f08 &gic_its 0x143e 0x2>,
+		  <0x1000 &gic_its 0x1440 0x2>,
+		  <0x1008 &gic_its 0x1442 0x2>,
+		  <0x1100 &gic_its 0x1444 0x2>,
+		  <0x1108 &gic_its 0x1446 0x2>,
+		  <0x1200 &gic_its 0x1448 0x2>,
+		  <0x1208 &gic_its 0x144a 0x2>,
+		  <0x1300 &gic_its 0x144c 0x2>,
+		  <0x1308 &gic_its 0x144e 0x2>,
+		  <0x1400 &gic_its 0x1450 0x2>,
+		  <0x1408 &gic_its 0x1452 0x2>,
+		  <0x1500 &gic_its 0x1454 0x2>,
+		  <0x1508 &gic_its 0x1456 0x2>,
+		  <0x1600 &gic_its 0x1458 0x2>,
+		  <0x1608 &gic_its 0x145a 0x2>,
+		  <0x1700 &gic_its 0x145c 0x2>,
+		  <0x1708 &gic_its 0x145e 0x2>,
+		  <0x1800 &gic_its 0x1460 0x2>,
+		  <0x1808 &gic_its 0x1462 0x2>,
+		  <0x1900 &gic_its 0x1464 0x2>,
+		  <0x1908 &gic_its 0x1466 0x2>,
+		  <0x1a00 &gic_its 0x1468 0x2>,
+		  <0x1a08 &gic_its 0x146a 0x2>,
+		  <0x1b00 &gic_its 0x146c 0x2>,
+		  <0x1b08 &gic_its 0x146e 0x2>,
+		  <0x1c00 &gic_its 0x1470 0x2>,
+		  <0x1c08 &gic_its 0x1472 0x2>,
+		  <0x1d00 &gic_its 0x1474 0x2>,
+		  <0x1d08 &gic_its 0x1476 0x2>,
+		  <0x1e00 &gic_its 0x1478 0x2>,
+		  <0x1e08 &gic_its 0x147a 0x2>,
+		  <0x1f00 &gic_its 0x147c 0x2>,
+		  <0x1f08 &gic_its 0x147e 0x2>,
+		  <0x2000 &gic_its 0x1480 0x2>,
+		  <0x2008 &gic_its 0x1482 0x2>,
+		  <0x2100 &gic_its 0x1484 0x2>,
+		  <0x2108 &gic_its 0x1486 0x2>,
+		  <0x2200 &gic_its 0x1488 0x2>,
+		  <0x2208 &gic_its 0x148a 0x2>,
+		  <0x2300 &gic_its 0x148c 0x2>,
+		  <0x2308 &gic_its 0x148e 0x2>,
+		  <0x2400 &gic_its 0x1490 0x2>,
+		  <0x2408 &gic_its 0x1492 0x2>,
+		  <0x2500 &gic_its 0x1494 0x2>,
+		  <0x2508 &gic_its 0x1496 0x2>,
+		  <0x2600 &gic_its 0x1498 0x2>,
+		  <0x2608 &gic_its 0x149a 0x2>,
+		  <0x2700 &gic_its 0x149c 0x2>,
+		  <0x2708 &gic_its 0x149e 0x2>,
+		  <0x2800 &gic_its 0x14a0 0x2>,
+		  <0x2808 &gic_its 0x14a2 0x2>,
+		  <0x2900 &gic_its 0x14a4 0x2>,
+		  <0x2908 &gic_its 0x14a6 0x2>,
+		  <0x2a00 &gic_its 0x14a8 0x2>,
+		  <0x2a08 &gic_its 0x14aa 0x2>,
+		  <0x2b00 &gic_its 0x14ac 0x2>,
+		  <0x2b08 &gic_its 0x14ae 0x2>,
+		  <0x2c00 &gic_its 0x14b0 0x2>,
+		  <0x2c08 &gic_its 0x14b2 0x2>,
+		  <0x2d00 &gic_its 0x14b4 0x2>,
+		  <0x2d08 &gic_its 0x14b6 0x2>,
+		  <0x2e00 &gic_its 0x14b8 0x2>,
+		  <0x2e08 &gic_its 0x14ba 0x2>,
+		  <0x2f00 &gic_its 0x14bc 0x2>,
+		  <0x2f08 &gic_its 0x14be 0x2>,
+		  <0x3000 &gic_its 0x14c0 0x2>,
+		  <0x3008 &gic_its 0x14c2 0x2>,
+		  <0x3100 &gic_its 0x14c4 0x2>,
+		  <0x3108 &gic_its 0x14c6 0x2>,
+		  <0x3200 &gic_its 0x14c8 0x2>,
+		  <0x3208 &gic_its 0x14ca 0x2>,
+		  <0x3300 &gic_its 0x14cc 0x2>,
+		  <0x3308 &gic_its 0x14ce 0x2>,
+		  <0x3400 &gic_its 0x14d0 0x2>,
+		  <0x3408 &gic_its 0x14d2 0x2>,
+		  <0x3500 &gic_its 0x14d4 0x2>,
+		  <0x3508 &gic_its 0x14d6 0x2>,
+		  <0x3600 &gic_its 0x14d8 0x2>,
+		  <0x3608 &gic_its 0x14da 0x2>,
+		  <0x3700 &gic_its 0x14dc 0x2>,
+		  <0x3708 &gic_its 0x14de 0x2>,
+		  <0x3800 &gic_its 0x14e0 0x2>,
+		  <0x3808 &gic_its 0x14e2 0x2>,
+		  <0x3900 &gic_its 0x14e4 0x2>,
+		  <0x3908 &gic_its 0x14e6 0x2>,
+		  <0x3a00 &gic_its 0x14e8 0x2>,
+		  <0x3a08 &gic_its 0x14ea 0x2>,
+		  <0x3b00 &gic_its 0x14ec 0x2>,
+		  <0x3b08 &gic_its 0x14ee 0x2>,
+		  <0x3c00 &gic_its 0x14f0 0x2>,
+		  <0x3c08 &gic_its 0x14f2 0x2>,
+		  <0x3d00 &gic_its 0x14f4 0x2>,
+		  <0x3d08 &gic_its 0x14f6 0x2>,
+		  <0x3e00 &gic_its 0x14f8 0x2>,
+		  <0x3e08 &gic_its 0x14fa 0x2>,
+		  <0x3f00 &gic_its 0x14fc 0x2>,
+		  <0x3f08 &gic_its 0x14fe 0x2>,
+		  <0x4000 &gic_its 0x1500 0x2>,
+		  <0x4008 &gic_its 0x1502 0x2>,
+		  <0x4100 &gic_its 0x1504 0x2>,
+		  <0x4108 &gic_its 0x1506 0x2>,
+		  <0x4200 &gic_its 0x1508 0x2>,
+		  <0x4208 &gic_its 0x150a 0x2>,
+		  <0x4300 &gic_its 0x150c 0x2>,
+		  <0x4308 &gic_its 0x150e 0x2>,
+		  <0x4400 &gic_its 0x1510 0x2>,
+		  <0x4408 &gic_its 0x1512 0x2>,
+		  <0x4500 &gic_its 0x1514 0x2>,
+		  <0x4508 &gic_its 0x1516 0x2>,
+		  <0x4600 &gic_its 0x1518 0x2>,
+		  <0x4608 &gic_its 0x151a 0x2>,
+		  <0x4700 &gic_its 0x151c 0x2>,
+		  <0x4708 &gic_its 0x151e 0x2>,
+		  <0x4800 &gic_its 0x1520 0x2>,
+		  <0x4808 &gic_its 0x1522 0x2>,
+		  <0x4900 &gic_its 0x1524 0x2>,
+		  <0x4908 &gic_its 0x1526 0x2>,
+		  <0x4a00 &gic_its 0x1528 0x2>,
+		  <0x4a08 &gic_its 0x152a 0x2>,
+		  <0x4b00 &gic_its 0x152c 0x2>,
+		  <0x4b08 &gic_its 0x152e 0x2>,
+		  <0x4c00 &gic_its 0x1530 0x2>,
+		  <0x4c08 &gic_its 0x1532 0x2>,
+		  <0x4d00 &gic_its 0x1534 0x2>,
+		  <0x4d08 &gic_its 0x1536 0x2>,
+		  <0x4e00 &gic_its 0x1538 0x2>,
+		  <0x4e08 &gic_its 0x153a 0x2>,
+		  <0x4f00 &gic_its 0x153c 0x2>,
+		  <0x4f08 &gic_its 0x153e 0x2>,
+		  <0x5000 &gic_its 0x1540 0x2>,
+		  <0x5008 &gic_its 0x1542 0x2>,
+		  <0x5100 &gic_its 0x1544 0x2>,
+		  <0x5108 &gic_its 0x1546 0x2>,
+		  <0x5200 &gic_its 0x1548 0x2>,
+		  <0x5208 &gic_its 0x154a 0x2>,
+		  <0x5300 &gic_its 0x154c 0x2>,
+		  <0x5308 &gic_its 0x154e 0x2>,
+		  <0x5400 &gic_its 0x1550 0x2>,
+		  <0x5408 &gic_its 0x1552 0x2>,
+		  <0x5500 &gic_its 0x1554 0x2>,
+		  <0x5508 &gic_its 0x1556 0x2>,
+		  <0x5600 &gic_its 0x1558 0x2>,
+		  <0x5608 &gic_its 0x155a 0x2>,
+		  <0x5700 &gic_its 0x155c 0x2>,
+		  <0x5708 &gic_its 0x155e 0x2>,
+		  <0x5800 &gic_its 0x1560 0x2>,
+		  <0x5808 &gic_its 0x1562 0x2>,
+		  <0x5900 &gic_its 0x1564 0x2>,
+		  <0x5908 &gic_its 0x1566 0x2>,
+		  <0x5a00 &gic_its 0x1568 0x2>,
+		  <0x5a08 &gic_its 0x156a 0x2>,
+		  <0x5b00 &gic_its 0x156c 0x2>,
+		  <0x5b08 &gic_its 0x156e 0x2>,
+		  <0x5c00 &gic_its 0x1570 0x2>,
+		  <0x5c08 &gic_its 0x1572 0x2>,
+		  <0x5d00 &gic_its 0x1574 0x2>,
+		  <0x5d08 &gic_its 0x1576 0x2>,
+		  <0x5e00 &gic_its 0x1578 0x2>,
+		  <0x5e08 &gic_its 0x157a 0x2>,
+		  <0x5f00 &gic_its 0x157c 0x2>,
+		  <0x5f08 &gic_its 0x157e 0x2>,
+		  <0x6000 &gic_its 0x1580 0x2>,
+		  <0x6008 &gic_its 0x1582 0x2>,
+		  <0x6100 &gic_its 0x1584 0x2>,
+		  <0x6108 &gic_its 0x1586 0x2>,
+		  <0x6200 &gic_its 0x1588 0x2>,
+		  <0x6208 &gic_its 0x158a 0x2>,
+		  <0x6300 &gic_its 0x158c 0x2>,
+		  <0x6308 &gic_its 0x158e 0x2>,
+		  <0x6400 &gic_its 0x1590 0x2>,
+		  <0x6408 &gic_its 0x1592 0x2>,
+		  <0x6500 &gic_its 0x1594 0x2>,
+		  <0x6508 &gic_its 0x1596 0x2>,
+		  <0x6600 &gic_its 0x1598 0x2>,
+		  <0x6608 &gic_its 0x159a 0x2>,
+		  <0x6700 &gic_its 0x159c 0x2>,
+		  <0x6708 &gic_its 0x159e 0x2>,
+		  <0x6800 &gic_its 0x15a0 0x2>,
+		  <0x6808 &gic_its 0x15a2 0x2>,
+		  <0x6900 &gic_its 0x15a4 0x2>,
+		  <0x6908 &gic_its 0x15a6 0x2>,
+		  <0x6a00 &gic_its 0x15a8 0x2>,
+		  <0x6a08 &gic_its 0x15aa 0x2>,
+		  <0x6b00 &gic_its 0x15ac 0x2>,
+		  <0x6b08 &gic_its 0x15ae 0x2>,
+		  <0x6c00 &gic_its 0x15b0 0x2>,
+		  <0x6c08 &gic_its 0x15b2 0x2>,
+		  <0x6d00 &gic_its 0x15b4 0x2>,
+		  <0x6d08 &gic_its 0x15b6 0x2>,
+		  <0x6e00 &gic_its 0x15b8 0x2>,
+		  <0x6e08 &gic_its 0x15ba 0x2>,
+		  <0x6f00 &gic_its 0x15bc 0x2>,
+		  <0x6f08 &gic_its 0x15be 0x2>,
+		  <0x7000 &gic_its 0x15c0 0x2>,
+		  <0x7008 &gic_its 0x15c2 0x2>,
+		  <0x7100 &gic_its 0x15c4 0x2>,
+		  <0x7108 &gic_its 0x15c6 0x2>,
+		  <0x7200 &gic_its 0x15c8 0x2>,
+		  <0x7208 &gic_its 0x15ca 0x2>,
+		  <0x7300 &gic_its 0x15cc 0x2>,
+		  <0x7308 &gic_its 0x15ce 0x2>,
+		  <0x7400 &gic_its 0x15d0 0x2>,
+		  <0x7408 &gic_its 0x15d2 0x2>,
+		  <0x7500 &gic_its 0x15d4 0x2>,
+		  <0x7508 &gic_its 0x15d6 0x2>,
+		  <0x7600 &gic_its 0x15d8 0x2>,
+		  <0x7608 &gic_its 0x15da 0x2>,
+		  <0x7700 &gic_its 0x15dc 0x2>,
+		  <0x7708 &gic_its 0x15de 0x2>,
+		  <0x7800 &gic_its 0x15e0 0x2>,
+		  <0x7808 &gic_its 0x15e2 0x2>,
+		  <0x7900 &gic_its 0x15e4 0x2>,
+		  <0x7908 &gic_its 0x15e6 0x2>,
+		  <0x7a00 &gic_its 0x15e8 0x2>,
+		  <0x7a08 &gic_its 0x15ea 0x2>,
+		  <0x7b00 &gic_its 0x15ec 0x2>,
+		  <0x7b08 &gic_its 0x15ee 0x2>,
+		  <0x7c00 &gic_its 0x15f0 0x2>,
+		  <0x7c08 &gic_its 0x15f2 0x2>,
+		  <0x7d00 &gic_its 0x15f4 0x2>,
+		  <0x7d08 &gic_its 0x15f6 0x2>,
+		  <0x7e00 &gic_its 0x15f8 0x2>,
+		  <0x7e08 &gic_its 0x15fa 0x2>,
+		  <0x7f00 &gic_its 0x15fc 0x2>,
+		  <0x7f08 &gic_its 0x15fe 0x2>,
+		  <0x8000 &gic_its 0x1600 0x2>,
+		  <0x8008 &gic_its 0x1602 0x2>,
+		  <0x8100 &gic_its 0x1604 0x2>,
+		  <0x8108 &gic_its 0x1606 0x2>,
+		  <0x8200 &gic_its 0x1608 0x2>,
+		  <0x8208 &gic_its 0x160a 0x2>,
+		  <0x8300 &gic_its 0x160c 0x2>,
+		  <0x8308 &gic_its 0x160e 0x2>,
+		  <0x8400 &gic_its 0x1610 0x2>,
+		  <0x8408 &gic_its 0x1612 0x2>,
+		  <0x8500 &gic_its 0x1614 0x2>,
+		  <0x8508 &gic_its 0x1616 0x2>,
+		  <0x8600 &gic_its 0x1618 0x2>,
+		  <0x8608 &gic_its 0x161a 0x2>,
+		  <0x8700 &gic_its 0x161c 0x2>,
+		  <0x8708 &gic_its 0x161e 0x2>,
+		  <0x8800 &gic_its 0x1620 0x2>,
+		  <0x8808 &gic_its 0x1622 0x2>,
+		  <0x8900 &gic_its 0x1624 0x2>,
+		  <0x8908 &gic_its 0x1626 0x2>,
+		  <0x8a00 &gic_its 0x1628 0x2>,
+		  <0x8a08 &gic_its 0x162a 0x2>,
+		  <0x8b00 &gic_its 0x162c 0x2>,
+		  <0x8b08 &gic_its 0x162e 0x2>,
+		  <0x8c00 &gic_its 0x1630 0x2>,
+		  <0x8c08 &gic_its 0x1632 0x2>,
+		  <0x8d00 &gic_its 0x1634 0x2>,
+		  <0x8d08 &gic_its 0x1636 0x2>,
+		  <0x8e00 &gic_its 0x1638 0x2>,
+		  <0x8e08 &gic_its 0x163a 0x2>,
+		  <0x8f00 &gic_its 0x163c 0x2>,
+		  <0x8f08 &gic_its 0x163e 0x2>,
+		  <0x9000 &gic_its 0x1640 0x2>,
+		  <0x9008 &gic_its 0x1642 0x2>,
+		  <0x9100 &gic_its 0x1644 0x2>,
+		  <0x9108 &gic_its 0x1646 0x2>,
+		  <0x9200 &gic_its 0x1648 0x2>,
+		  <0x9208 &gic_its 0x164a 0x2>,
+		  <0x9300 &gic_its 0x164c 0x2>,
+		  <0x9308 &gic_its 0x164e 0x2>,
+		  <0x9400 &gic_its 0x1650 0x2>,
+		  <0x9408 &gic_its 0x1652 0x2>,
+		  <0x9500 &gic_its 0x1654 0x2>,
+		  <0x9508 &gic_its 0x1656 0x2>,
+		  <0x9600 &gic_its 0x1658 0x2>,
+		  <0x9608 &gic_its 0x165a 0x2>,
+		  <0x9700 &gic_its 0x165c 0x2>,
+		  <0x9708 &gic_its 0x165e 0x2>,
+		  <0x9800 &gic_its 0x1660 0x2>,
+		  <0x9808 &gic_its 0x1662 0x2>,
+		  <0x9900 &gic_its 0x1664 0x2>,
+		  <0x9908 &gic_its 0x1666 0x2>,
+		  <0x9a00 &gic_its 0x1668 0x2>,
+		  <0x9a08 &gic_its 0x166a 0x2>,
+		  <0x9b00 &gic_its 0x166c 0x2>,
+		  <0x9b08 &gic_its 0x166e 0x2>,
+		  <0x9c00 &gic_its 0x1670 0x2>,
+		  <0x9c08 &gic_its 0x1672 0x2>,
+		  <0x9d00 &gic_its 0x1674 0x2>,
+		  <0x9d08 &gic_its 0x1676 0x2>,
+		  <0x9e00 &gic_its 0x1678 0x2>,
+		  <0x9e08 &gic_its 0x167a 0x2>,
+		  <0x9f00 &gic_its 0x167c 0x2>,
+		  <0x9f08 &gic_its 0x167e 0x2>,
+		  <0xa000 &gic_its 0x1680 0x2>,
+		  <0xa008 &gic_its 0x1682 0x2>,
+		  <0xa100 &gic_its 0x1684 0x2>,
+		  <0xa108 &gic_its 0x1686 0x2>,
+		  <0xa200 &gic_its 0x1688 0x2>,
+		  <0xa208 &gic_its 0x168a 0x2>,
+		  <0xa300 &gic_its 0x168c 0x2>,
+		  <0xa308 &gic_its 0x168e 0x2>,
+		  <0xa400 &gic_its 0x1690 0x2>,
+		  <0xa408 &gic_its 0x1692 0x2>,
+		  <0xa500 &gic_its 0x1694 0x2>,
+		  <0xa508 &gic_its 0x1696 0x2>,
+		  <0xa600 &gic_its 0x1698 0x2>,
+		  <0xa608 &gic_its 0x169a 0x2>,
+		  <0xa700 &gic_its 0x169c 0x2>,
+		  <0xa708 &gic_its 0x169e 0x2>,
+		  <0xa800 &gic_its 0x16a0 0x2>,
+		  <0xa808 &gic_its 0x16a2 0x2>,
+		  <0xa900 &gic_its 0x16a4 0x2>,
+		  <0xa908 &gic_its 0x16a6 0x2>,
+		  <0xaa00 &gic_its 0x16a8 0x2>,
+		  <0xaa08 &gic_its 0x16aa 0x2>,
+		  <0xab00 &gic_its 0x16ac 0x2>,
+		  <0xab08 &gic_its 0x16ae 0x2>,
+		  <0xac00 &gic_its 0x16b0 0x2>,
+		  <0xac08 &gic_its 0x16b2 0x2>,
+		  <0xad00 &gic_its 0x16b4 0x2>,
+		  <0xad08 &gic_its 0x16b6 0x2>,
+		  <0xae00 &gic_its 0x16b8 0x2>,
+		  <0xae08 &gic_its 0x16ba 0x2>,
+		  <0xaf00 &gic_its 0x16bc 0x2>,
+		  <0xaf08 &gic_its 0x16be 0x2>,
+		  <0xb000 &gic_its 0x16c0 0x2>,
+		  <0xb008 &gic_its 0x16c2 0x2>,
+		  <0xb100 &gic_its 0x16c4 0x2>,
+		  <0xb108 &gic_its 0x16c6 0x2>,
+		  <0xb200 &gic_its 0x16c8 0x2>,
+		  <0xb208 &gic_its 0x16ca 0x2>,
+		  <0xb300 &gic_its 0x16cc 0x2>,
+		  <0xb308 &gic_its 0x16ce 0x2>,
+		  <0xb400 &gic_its 0x16d0 0x2>,
+		  <0xb408 &gic_its 0x16d2 0x2>,
+		  <0xb500 &gic_its 0x16d4 0x2>,
+		  <0xb508 &gic_its 0x16d6 0x2>,
+		  <0xb600 &gic_its 0x16d8 0x2>,
+		  <0xb608 &gic_its 0x16da 0x2>,
+		  <0xb700 &gic_its 0x16dc 0x2>,
+		  <0xb708 &gic_its 0x16de 0x2>,
+		  <0xb800 &gic_its 0x16e0 0x2>,
+		  <0xb808 &gic_its 0x16e2 0x2>,
+		  <0xb900 &gic_its 0x16e4 0x2>,
+		  <0xb908 &gic_its 0x16e6 0x2>,
+		  <0xba00 &gic_its 0x16e8 0x2>,
+		  <0xba08 &gic_its 0x16ea 0x2>,
+		  <0xbb00 &gic_its 0x16ec 0x2>,
+		  <0xbb08 &gic_its 0x16ee 0x2>,
+		  <0xbc00 &gic_its 0x16f0 0x2>,
+		  <0xbc08 &gic_its 0x16f2 0x2>,
+		  <0xbd00 &gic_its 0x16f4 0x2>,
+		  <0xbd08 &gic_its 0x16f6 0x2>,
+		  <0xbe00 &gic_its 0x16f8 0x2>,
+		  <0xbe08 &gic_its 0x16fa 0x2>,
+		  <0xbf00 &gic_its 0x16fc 0x2>,
+		  <0xbf08 &gic_its 0x16fe 0x2>,
+		  <0xc000 &gic_its 0x1700 0x2>,
+		  <0xc008 &gic_its 0x1702 0x2>,
+		  <0xc100 &gic_its 0x1704 0x2>,
+		  <0xc108 &gic_its 0x1706 0x2>,
+		  <0xc200 &gic_its 0x1708 0x2>,
+		  <0xc208 &gic_its 0x170a 0x2>,
+		  <0xc300 &gic_its 0x170c 0x2>,
+		  <0xc308 &gic_its 0x170e 0x2>,
+		  <0xc400 &gic_its 0x1710 0x2>,
+		  <0xc408 &gic_its 0x1712 0x2>,
+		  <0xc500 &gic_its 0x1714 0x2>,
+		  <0xc508 &gic_its 0x1716 0x2>,
+		  <0xc600 &gic_its 0x1718 0x2>,
+		  <0xc608 &gic_its 0x171a 0x2>,
+		  <0xc700 &gic_its 0x171c 0x2>,
+		  <0xc708 &gic_its 0x171e 0x2>,
+		  <0xc800 &gic_its 0x1720 0x2>,
+		  <0xc808 &gic_its 0x1722 0x2>,
+		  <0xc900 &gic_its 0x1724 0x2>,
+		  <0xc908 &gic_its 0x1726 0x2>,
+		  <0xca00 &gic_its 0x1728 0x2>,
+		  <0xca08 &gic_its 0x172a 0x2>,
+		  <0xcb00 &gic_its 0x172c 0x2>,
+		  <0xcb08 &gic_its 0x172e 0x2>,
+		  <0xcc00 &gic_its 0x1730 0x2>,
+		  <0xcc08 &gic_its 0x1732 0x2>,
+		  <0xcd00 &gic_its 0x1734 0x2>,
+		  <0xcd08 &gic_its 0x1736 0x2>,
+		  <0xce00 &gic_its 0x1738 0x2>,
+		  <0xce08 &gic_its 0x173a 0x2>,
+		  <0xcf00 &gic_its 0x173c 0x2>,
+		  <0xcf08 &gic_its 0x173e 0x2>,
+		  <0xd000 &gic_its 0x1740 0x2>,
+		  <0xd008 &gic_its 0x1742 0x2>,
+		  <0xd100 &gic_its 0x1744 0x2>,
+		  <0xd108 &gic_its 0x1746 0x2>,
+		  <0xd200 &gic_its 0x1748 0x2>,
+		  <0xd208 &gic_its 0x174a 0x2>,
+		  <0xd300 &gic_its 0x174c 0x2>,
+		  <0xd308 &gic_its 0x174e 0x2>,
+		  <0xd400 &gic_its 0x1750 0x2>,
+		  <0xd408 &gic_its 0x1752 0x2>,
+		  <0xd500 &gic_its 0x1754 0x2>,
+		  <0xd508 &gic_its 0x1756 0x2>,
+		  <0xd600 &gic_its 0x1758 0x2>,
+		  <0xd608 &gic_its 0x175a 0x2>,
+		  <0xd700 &gic_its 0x175c 0x2>,
+		  <0xd708 &gic_its 0x175e 0x2>,
+		  <0xd800 &gic_its 0x1760 0x2>,
+		  <0xd808 &gic_its 0x1762 0x2>,
+		  <0xd900 &gic_its 0x1764 0x2>,
+		  <0xd908 &gic_its 0x1766 0x2>,
+		  <0xda00 &gic_its 0x1768 0x2>,
+		  <0xda08 &gic_its 0x176a 0x2>,
+		  <0xdb00 &gic_its 0x176c 0x2>,
+		  <0xdb08 &gic_its 0x176e 0x2>,
+		  <0xdc00 &gic_its 0x1770 0x2>,
+		  <0xdc08 &gic_its 0x1772 0x2>,
+		  <0xdd00 &gic_its 0x1774 0x2>,
+		  <0xdd08 &gic_its 0x1776 0x2>,
+		  <0xde00 &gic_its 0x1778 0x2>,
+		  <0xde08 &gic_its 0x177a 0x2>,
+		  <0xdf00 &gic_its 0x177c 0x2>,
+		  <0xdf08 &gic_its 0x177e 0x2>,
+		  <0xe000 &gic_its 0x1780 0x2>,
+		  <0xe008 &gic_its 0x1782 0x2>,
+		  <0xe100 &gic_its 0x1784 0x2>,
+		  <0xe108 &gic_its 0x1786 0x2>,
+		  <0xe200 &gic_its 0x1788 0x2>,
+		  <0xe208 &gic_its 0x178a 0x2>,
+		  <0xe300 &gic_its 0x178c 0x2>,
+		  <0xe308 &gic_its 0x178e 0x2>,
+		  <0xe400 &gic_its 0x1790 0x2>,
+		  <0xe408 &gic_its 0x1792 0x2>,
+		  <0xe500 &gic_its 0x1794 0x2>,
+		  <0xe508 &gic_its 0x1796 0x2>,
+		  <0xe600 &gic_its 0x1798 0x2>,
+		  <0xe608 &gic_its 0x179a 0x2>,
+		  <0xe700 &gic_its 0x179c 0x2>,
+		  <0xe708 &gic_its 0x179e 0x2>,
+		  <0xe800 &gic_its 0x17a0 0x2>,
+		  <0xe808 &gic_its 0x17a2 0x2>,
+		  <0xe900 &gic_its 0x17a4 0x2>,
+		  <0xe908 &gic_its 0x17a6 0x2>,
+		  <0xea00 &gic_its 0x17a8 0x2>,
+		  <0xea08 &gic_its 0x17aa 0x2>,
+		  <0xeb00 &gic_its 0x17ac 0x2>,
+		  <0xeb08 &gic_its 0x17ae 0x2>,
+		  <0xec00 &gic_its 0x17b0 0x2>,
+		  <0xec08 &gic_its 0x17b2 0x2>,
+		  <0xed00 &gic_its 0x17b4 0x2>,
+		  <0xed08 &gic_its 0x17b6 0x2>,
+		  <0xee00 &gic_its 0x17b8 0x2>,
+		  <0xee08 &gic_its 0x17ba 0x2>,
+		  <0xef00 &gic_its 0x17bc 0x2>,
+		  <0xef08 &gic_its 0x17be 0x2>,
+		  <0xf000 &gic_its 0x17c0 0x2>,
+		  <0xf008 &gic_its 0x17c2 0x2>,
+		  <0xf100 &gic_its 0x17c4 0x2>,
+		  <0xf108 &gic_its 0x17c6 0x2>,
+		  <0xf200 &gic_its 0x17c8 0x2>,
+		  <0xf208 &gic_its 0x17ca 0x2>,
+		  <0xf300 &gic_its 0x17cc 0x2>,
+		  <0xf308 &gic_its 0x17ce 0x2>,
+		  <0xf400 &gic_its 0x17d0 0x2>,
+		  <0xf408 &gic_its 0x17d2 0x2>,
+		  <0xf500 &gic_its 0x17d4 0x2>,
+		  <0xf508 &gic_its 0x17d6 0x2>,
+		  <0xf600 &gic_its 0x17d8 0x2>,
+		  <0xf608 &gic_its 0x17da 0x2>,
+		  <0xf700 &gic_its 0x17dc 0x2>,
+		  <0xf708 &gic_its 0x17de 0x2>,
+		  <0xf800 &gic_its 0x17e0 0x2>,
+		  <0xf808 &gic_its 0x17e2 0x2>,
+		  <0xf900 &gic_its 0x17e4 0x2>,
+		  <0xf908 &gic_its 0x17e6 0x2>,
+		  <0xfa00 &gic_its 0x17e8 0x2>,
+		  <0xfa08 &gic_its 0x17ea 0x2>,
+		  <0xfb00 &gic_its 0x17ec 0x2>,
+		  <0xfb08 &gic_its 0x17ee 0x2>,
+		  <0xfc00 &gic_its 0x17f0 0x2>,
+		  <0xfc08 &gic_its 0x17f2 0x2>,
+		  <0xfd00 &gic_its 0x17f4 0x2>,
+		  <0xfd08 &gic_its 0x17f6 0x2>,
+		  <0xfe00 &gic_its 0x17f8 0x2>,
+		  <0xfe08 &gic_its 0x17fa 0x2>,
+		  <0xff00 &gic_its 0x17fc 0x2>,
+		  <0xff08 &gic_its 0x17fe 0x2>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x1400 0x2>,
+		    <0x0008 &smmu 0x1402 0x2>,
+		    <0x0100 &smmu 0x1404 0x2>,
+		    <0x0108 &smmu 0x1406 0x2>,
+		    <0x0200 &smmu 0x1408 0x2>,
+		    <0x0208 &smmu 0x140a 0x2>,
+		    <0x0300 &smmu 0x140c 0x2>,
+		    <0x0308 &smmu 0x140e 0x2>,
+		    <0x0400 &smmu 0x1410 0x2>,
+		    <0x0408 &smmu 0x1412 0x2>,
+		    <0x0500 &smmu 0x1414 0x2>,
+		    <0x0508 &smmu 0x1416 0x2>,
+		    <0x0600 &smmu 0x1418 0x2>,
+		    <0x0608 &smmu 0x141a 0x2>,
+		    <0x0700 &smmu 0x141c 0x2>,
+		    <0x0708 &smmu 0x141e 0x2>,
+		    <0x0800 &smmu 0x1420 0x2>,
+		    <0x0808 &smmu 0x1422 0x2>,
+		    <0x0900 &smmu 0x1424 0x2>,
+		    <0x0908 &smmu 0x1426 0x2>,
+		    <0x0a00 &smmu 0x1428 0x2>,
+		    <0x0a08 &smmu 0x142a 0x2>,
+		    <0x0b00 &smmu 0x142c 0x2>,
+		    <0x0b08 &smmu 0x142e 0x2>,
+		    <0x0c00 &smmu 0x1430 0x2>,
+		    <0x0c08 &smmu 0x1432 0x2>,
+		    <0x0d00 &smmu 0x1434 0x2>,
+		    <0x0d08 &smmu 0x1436 0x2>,
+		    <0x0e00 &smmu 0x1438 0x2>,
+		    <0x0e08 &smmu 0x143a 0x2>,
+		    <0x0f00 &smmu 0x143c 0x2>,
+		    <0x0f08 &smmu 0x143e 0x2>,
+		    <0x1000 &smmu 0x1440 0x2>,
+		    <0x1008 &smmu 0x1442 0x2>,
+		    <0x1100 &smmu 0x1444 0x2>,
+		    <0x1108 &smmu 0x1446 0x2>,
+		    <0x1200 &smmu 0x1448 0x2>,
+		    <0x1208 &smmu 0x144a 0x2>,
+		    <0x1300 &smmu 0x144c 0x2>,
+		    <0x1308 &smmu 0x144e 0x2>,
+		    <0x1400 &smmu 0x1450 0x2>,
+		    <0x1408 &smmu 0x1452 0x2>,
+		    <0x1500 &smmu 0x1454 0x2>,
+		    <0x1508 &smmu 0x1456 0x2>,
+		    <0x1600 &smmu 0x1458 0x2>,
+		    <0x1608 &smmu 0x145a 0x2>,
+		    <0x1700 &smmu 0x145c 0x2>,
+		    <0x1708 &smmu 0x145e 0x2>,
+		    <0x1800 &smmu 0x1460 0x2>,
+		    <0x1808 &smmu 0x1462 0x2>,
+		    <0x1900 &smmu 0x1464 0x2>,
+		    <0x1908 &smmu 0x1466 0x2>,
+		    <0x1a00 &smmu 0x1468 0x2>,
+		    <0x1a08 &smmu 0x146a 0x2>,
+		    <0x1b00 &smmu 0x146c 0x2>,
+		    <0x1b08 &smmu 0x146e 0x2>,
+		    <0x1c00 &smmu 0x1470 0x2>,
+		    <0x1c08 &smmu 0x1472 0x2>,
+		    <0x1d00 &smmu 0x1474 0x2>,
+		    <0x1d08 &smmu 0x1476 0x2>,
+		    <0x1e00 &smmu 0x1478 0x2>,
+		    <0x1e08 &smmu 0x147a 0x2>,
+		    <0x1f00 &smmu 0x147c 0x2>,
+		    <0x1f08 &smmu 0x147e 0x2>,
+		    <0x2000 &smmu 0x1480 0x2>,
+		    <0x2008 &smmu 0x1482 0x2>,
+		    <0x2100 &smmu 0x1484 0x2>,
+		    <0x2108 &smmu 0x1486 0x2>,
+		    <0x2200 &smmu 0x1488 0x2>,
+		    <0x2208 &smmu 0x148a 0x2>,
+		    <0x2300 &smmu 0x148c 0x2>,
+		    <0x2308 &smmu 0x148e 0x2>,
+		    <0x2400 &smmu 0x1490 0x2>,
+		    <0x2408 &smmu 0x1492 0x2>,
+		    <0x2500 &smmu 0x1494 0x2>,
+		    <0x2508 &smmu 0x1496 0x2>,
+		    <0x2600 &smmu 0x1498 0x2>,
+		    <0x2608 &smmu 0x149a 0x2>,
+		    <0x2700 &smmu 0x149c 0x2>,
+		    <0x2708 &smmu 0x149e 0x2>,
+		    <0x2800 &smmu 0x14a0 0x2>,
+		    <0x2808 &smmu 0x14a2 0x2>,
+		    <0x2900 &smmu 0x14a4 0x2>,
+		    <0x2908 &smmu 0x14a6 0x2>,
+		    <0x2a00 &smmu 0x14a8 0x2>,
+		    <0x2a08 &smmu 0x14aa 0x2>,
+		    <0x2b00 &smmu 0x14ac 0x2>,
+		    <0x2b08 &smmu 0x14ae 0x2>,
+		    <0x2c00 &smmu 0x14b0 0x2>,
+		    <0x2c08 &smmu 0x14b2 0x2>,
+		    <0x2d00 &smmu 0x14b4 0x2>,
+		    <0x2d08 &smmu 0x14b6 0x2>,
+		    <0x2e00 &smmu 0x14b8 0x2>,
+		    <0x2e08 &smmu 0x14ba 0x2>,
+		    <0x2f00 &smmu 0x14bc 0x2>,
+		    <0x2f08 &smmu 0x14be 0x2>,
+		    <0x3000 &smmu 0x14c0 0x2>,
+		    <0x3008 &smmu 0x14c2 0x2>,
+		    <0x3100 &smmu 0x14c4 0x2>,
+		    <0x3108 &smmu 0x14c6 0x2>,
+		    <0x3200 &smmu 0x14c8 0x2>,
+		    <0x3208 &smmu 0x14ca 0x2>,
+		    <0x3300 &smmu 0x14cc 0x2>,
+		    <0x3308 &smmu 0x14ce 0x2>,
+		    <0x3400 &smmu 0x14d0 0x2>,
+		    <0x3408 &smmu 0x14d2 0x2>,
+		    <0x3500 &smmu 0x14d4 0x2>,
+		    <0x3508 &smmu 0x14d6 0x2>,
+		    <0x3600 &smmu 0x14d8 0x2>,
+		    <0x3608 &smmu 0x14da 0x2>,
+		    <0x3700 &smmu 0x14dc 0x2>,
+		    <0x3708 &smmu 0x14de 0x2>,
+		    <0x3800 &smmu 0x14e0 0x2>,
+		    <0x3808 &smmu 0x14e2 0x2>,
+		    <0x3900 &smmu 0x14e4 0x2>,
+		    <0x3908 &smmu 0x14e6 0x2>,
+		    <0x3a00 &smmu 0x14e8 0x2>,
+		    <0x3a08 &smmu 0x14ea 0x2>,
+		    <0x3b00 &smmu 0x14ec 0x2>,
+		    <0x3b08 &smmu 0x14ee 0x2>,
+		    <0x3c00 &smmu 0x14f0 0x2>,
+		    <0x3c08 &smmu 0x14f2 0x2>,
+		    <0x3d00 &smmu 0x14f4 0x2>,
+		    <0x3d08 &smmu 0x14f6 0x2>,
+		    <0x3e00 &smmu 0x14f8 0x2>,
+		    <0x3e08 &smmu 0x14fa 0x2>,
+		    <0x3f00 &smmu 0x14fc 0x2>,
+		    <0x3f08 &smmu 0x14fe 0x2>,
+		    <0x4000 &smmu 0x1500 0x2>,
+		    <0x4008 &smmu 0x1502 0x2>,
+		    <0x4100 &smmu 0x1504 0x2>,
+		    <0x4108 &smmu 0x1506 0x2>,
+		    <0x4200 &smmu 0x1508 0x2>,
+		    <0x4208 &smmu 0x150a 0x2>,
+		    <0x4300 &smmu 0x150c 0x2>,
+		    <0x4308 &smmu 0x150e 0x2>,
+		    <0x4400 &smmu 0x1510 0x2>,
+		    <0x4408 &smmu 0x1512 0x2>,
+		    <0x4500 &smmu 0x1514 0x2>,
+		    <0x4508 &smmu 0x1516 0x2>,
+		    <0x4600 &smmu 0x1518 0x2>,
+		    <0x4608 &smmu 0x151a 0x2>,
+		    <0x4700 &smmu 0x151c 0x2>,
+		    <0x4708 &smmu 0x151e 0x2>,
+		    <0x4800 &smmu 0x1520 0x2>,
+		    <0x4808 &smmu 0x1522 0x2>,
+		    <0x4900 &smmu 0x1524 0x2>,
+		    <0x4908 &smmu 0x1526 0x2>,
+		    <0x4a00 &smmu 0x1528 0x2>,
+		    <0x4a08 &smmu 0x152a 0x2>,
+		    <0x4b00 &smmu 0x152c 0x2>,
+		    <0x4b08 &smmu 0x152e 0x2>,
+		    <0x4c00 &smmu 0x1530 0x2>,
+		    <0x4c08 &smmu 0x1532 0x2>,
+		    <0x4d00 &smmu 0x1534 0x2>,
+		    <0x4d08 &smmu 0x1536 0x2>,
+		    <0x4e00 &smmu 0x1538 0x2>,
+		    <0x4e08 &smmu 0x153a 0x2>,
+		    <0x4f00 &smmu 0x153c 0x2>,
+		    <0x4f08 &smmu 0x153e 0x2>,
+		    <0x5000 &smmu 0x1540 0x2>,
+		    <0x5008 &smmu 0x1542 0x2>,
+		    <0x5100 &smmu 0x1544 0x2>,
+		    <0x5108 &smmu 0x1546 0x2>,
+		    <0x5200 &smmu 0x1548 0x2>,
+		    <0x5208 &smmu 0x154a 0x2>,
+		    <0x5300 &smmu 0x154c 0x2>,
+		    <0x5308 &smmu 0x154e 0x2>,
+		    <0x5400 &smmu 0x1550 0x2>,
+		    <0x5408 &smmu 0x1552 0x2>,
+		    <0x5500 &smmu 0x1554 0x2>,
+		    <0x5508 &smmu 0x1556 0x2>,
+		    <0x5600 &smmu 0x1558 0x2>,
+		    <0x5608 &smmu 0x155a 0x2>,
+		    <0x5700 &smmu 0x155c 0x2>,
+		    <0x5708 &smmu 0x155e 0x2>,
+		    <0x5800 &smmu 0x1560 0x2>,
+		    <0x5808 &smmu 0x1562 0x2>,
+		    <0x5900 &smmu 0x1564 0x2>,
+		    <0x5908 &smmu 0x1566 0x2>,
+		    <0x5a00 &smmu 0x1568 0x2>,
+		    <0x5a08 &smmu 0x156a 0x2>,
+		    <0x5b00 &smmu 0x156c 0x2>,
+		    <0x5b08 &smmu 0x156e 0x2>,
+		    <0x5c00 &smmu 0x1570 0x2>,
+		    <0x5c08 &smmu 0x1572 0x2>,
+		    <0x5d00 &smmu 0x1574 0x2>,
+		    <0x5d08 &smmu 0x1576 0x2>,
+		    <0x5e00 &smmu 0x1578 0x2>,
+		    <0x5e08 &smmu 0x157a 0x2>,
+		    <0x5f00 &smmu 0x157c 0x2>,
+		    <0x5f08 &smmu 0x157e 0x2>,
+		    <0x6000 &smmu 0x1580 0x2>,
+		    <0x6008 &smmu 0x1582 0x2>,
+		    <0x6100 &smmu 0x1584 0x2>,
+		    <0x6108 &smmu 0x1586 0x2>,
+		    <0x6200 &smmu 0x1588 0x2>,
+		    <0x6208 &smmu 0x158a 0x2>,
+		    <0x6300 &smmu 0x158c 0x2>,
+		    <0x6308 &smmu 0x158e 0x2>,
+		    <0x6400 &smmu 0x1590 0x2>,
+		    <0x6408 &smmu 0x1592 0x2>,
+		    <0x6500 &smmu 0x1594 0x2>,
+		    <0x6508 &smmu 0x1596 0x2>,
+		    <0x6600 &smmu 0x1598 0x2>,
+		    <0x6608 &smmu 0x159a 0x2>,
+		    <0x6700 &smmu 0x159c 0x2>,
+		    <0x6708 &smmu 0x159e 0x2>,
+		    <0x6800 &smmu 0x15a0 0x2>,
+		    <0x6808 &smmu 0x15a2 0x2>,
+		    <0x6900 &smmu 0x15a4 0x2>,
+		    <0x6908 &smmu 0x15a6 0x2>,
+		    <0x6a00 &smmu 0x15a8 0x2>,
+		    <0x6a08 &smmu 0x15aa 0x2>,
+		    <0x6b00 &smmu 0x15ac 0x2>,
+		    <0x6b08 &smmu 0x15ae 0x2>,
+		    <0x6c00 &smmu 0x15b0 0x2>,
+		    <0x6c08 &smmu 0x15b2 0x2>,
+		    <0x6d00 &smmu 0x15b4 0x2>,
+		    <0x6d08 &smmu 0x15b6 0x2>,
+		    <0x6e00 &smmu 0x15b8 0x2>,
+		    <0x6e08 &smmu 0x15ba 0x2>,
+		    <0x6f00 &smmu 0x15bc 0x2>,
+		    <0x6f08 &smmu 0x15be 0x2>,
+		    <0x7000 &smmu 0x15c0 0x2>,
+		    <0x7008 &smmu 0x15c2 0x2>,
+		    <0x7100 &smmu 0x15c4 0x2>,
+		    <0x7108 &smmu 0x15c6 0x2>,
+		    <0x7200 &smmu 0x15c8 0x2>,
+		    <0x7208 &smmu 0x15ca 0x2>,
+		    <0x7300 &smmu 0x15cc 0x2>,
+		    <0x7308 &smmu 0x15ce 0x2>,
+		    <0x7400 &smmu 0x15d0 0x2>,
+		    <0x7408 &smmu 0x15d2 0x2>,
+		    <0x7500 &smmu 0x15d4 0x2>,
+		    <0x7508 &smmu 0x15d6 0x2>,
+		    <0x7600 &smmu 0x15d8 0x2>,
+		    <0x7608 &smmu 0x15da 0x2>,
+		    <0x7700 &smmu 0x15dc 0x2>,
+		    <0x7708 &smmu 0x15de 0x2>,
+		    <0x7800 &smmu 0x15e0 0x2>,
+		    <0x7808 &smmu 0x15e2 0x2>,
+		    <0x7900 &smmu 0x15e4 0x2>,
+		    <0x7908 &smmu 0x15e6 0x2>,
+		    <0x7a00 &smmu 0x15e8 0x2>,
+		    <0x7a08 &smmu 0x15ea 0x2>,
+		    <0x7b00 &smmu 0x15ec 0x2>,
+		    <0x7b08 &smmu 0x15ee 0x2>,
+		    <0x7c00 &smmu 0x15f0 0x2>,
+		    <0x7c08 &smmu 0x15f2 0x2>,
+		    <0x7d00 &smmu 0x15f4 0x2>,
+		    <0x7d08 &smmu 0x15f6 0x2>,
+		    <0x7e00 &smmu 0x15f8 0x2>,
+		    <0x7e08 &smmu 0x15fa 0x2>,
+		    <0x7f00 &smmu 0x15fc 0x2>,
+		    <0x7f08 &smmu 0x15fe 0x2>,
+		    <0x8000 &smmu 0x1600 0x2>,
+		    <0x8008 &smmu 0x1602 0x2>,
+		    <0x8100 &smmu 0x1604 0x2>,
+		    <0x8108 &smmu 0x1606 0x2>,
+		    <0x8200 &smmu 0x1608 0x2>,
+		    <0x8208 &smmu 0x160a 0x2>,
+		    <0x8300 &smmu 0x160c 0x2>,
+		    <0x8308 &smmu 0x160e 0x2>,
+		    <0x8400 &smmu 0x1610 0x2>,
+		    <0x8408 &smmu 0x1612 0x2>,
+		    <0x8500 &smmu 0x1614 0x2>,
+		    <0x8508 &smmu 0x1616 0x2>,
+		    <0x8600 &smmu 0x1618 0x2>,
+		    <0x8608 &smmu 0x161a 0x2>,
+		    <0x8700 &smmu 0x161c 0x2>,
+		    <0x8708 &smmu 0x161e 0x2>,
+		    <0x8800 &smmu 0x1620 0x2>,
+		    <0x8808 &smmu 0x1622 0x2>,
+		    <0x8900 &smmu 0x1624 0x2>,
+		    <0x8908 &smmu 0x1626 0x2>,
+		    <0x8a00 &smmu 0x1628 0x2>,
+		    <0x8a08 &smmu 0x162a 0x2>,
+		    <0x8b00 &smmu 0x162c 0x2>,
+		    <0x8b08 &smmu 0x162e 0x2>,
+		    <0x8c00 &smmu 0x1630 0x2>,
+		    <0x8c08 &smmu 0x1632 0x2>,
+		    <0x8d00 &smmu 0x1634 0x2>,
+		    <0x8d08 &smmu 0x1636 0x2>,
+		    <0x8e00 &smmu 0x1638 0x2>,
+		    <0x8e08 &smmu 0x163a 0x2>,
+		    <0x8f00 &smmu 0x163c 0x2>,
+		    <0x8f08 &smmu 0x163e 0x2>,
+		    <0x9000 &smmu 0x1640 0x2>,
+		    <0x9008 &smmu 0x1642 0x2>,
+		    <0x9100 &smmu 0x1644 0x2>,
+		    <0x9108 &smmu 0x1646 0x2>,
+		    <0x9200 &smmu 0x1648 0x2>,
+		    <0x9208 &smmu 0x164a 0x2>,
+		    <0x9300 &smmu 0x164c 0x2>,
+		    <0x9308 &smmu 0x164e 0x2>,
+		    <0x9400 &smmu 0x1650 0x2>,
+		    <0x9408 &smmu 0x1652 0x2>,
+		    <0x9500 &smmu 0x1654 0x2>,
+		    <0x9508 &smmu 0x1656 0x2>,
+		    <0x9600 &smmu 0x1658 0x2>,
+		    <0x9608 &smmu 0x165a 0x2>,
+		    <0x9700 &smmu 0x165c 0x2>,
+		    <0x9708 &smmu 0x165e 0x2>,
+		    <0x9800 &smmu 0x1660 0x2>,
+		    <0x9808 &smmu 0x1662 0x2>,
+		    <0x9900 &smmu 0x1664 0x2>,
+		    <0x9908 &smmu 0x1666 0x2>,
+		    <0x9a00 &smmu 0x1668 0x2>,
+		    <0x9a08 &smmu 0x166a 0x2>,
+		    <0x9b00 &smmu 0x166c 0x2>,
+		    <0x9b08 &smmu 0x166e 0x2>,
+		    <0x9c00 &smmu 0x1670 0x2>,
+		    <0x9c08 &smmu 0x1672 0x2>,
+		    <0x9d00 &smmu 0x1674 0x2>,
+		    <0x9d08 &smmu 0x1676 0x2>,
+		    <0x9e00 &smmu 0x1678 0x2>,
+		    <0x9e08 &smmu 0x167a 0x2>,
+		    <0x9f00 &smmu 0x167c 0x2>,
+		    <0x9f08 &smmu 0x167e 0x2>,
+		    <0xa000 &smmu 0x1680 0x2>,
+		    <0xa008 &smmu 0x1682 0x2>,
+		    <0xa100 &smmu 0x1684 0x2>,
+		    <0xa108 &smmu 0x1686 0x2>,
+		    <0xa200 &smmu 0x1688 0x2>,
+		    <0xa208 &smmu 0x168a 0x2>,
+		    <0xa300 &smmu 0x168c 0x2>,
+		    <0xa308 &smmu 0x168e 0x2>,
+		    <0xa400 &smmu 0x1690 0x2>,
+		    <0xa408 &smmu 0x1692 0x2>,
+		    <0xa500 &smmu 0x1694 0x2>,
+		    <0xa508 &smmu 0x1696 0x2>,
+		    <0xa600 &smmu 0x1698 0x2>,
+		    <0xa608 &smmu 0x169a 0x2>,
+		    <0xa700 &smmu 0x169c 0x2>,
+		    <0xa708 &smmu 0x169e 0x2>,
+		    <0xa800 &smmu 0x16a0 0x2>,
+		    <0xa808 &smmu 0x16a2 0x2>,
+		    <0xa900 &smmu 0x16a4 0x2>,
+		    <0xa908 &smmu 0x16a6 0x2>,
+		    <0xaa00 &smmu 0x16a8 0x2>,
+		    <0xaa08 &smmu 0x16aa 0x2>,
+		    <0xab00 &smmu 0x16ac 0x2>,
+		    <0xab08 &smmu 0x16ae 0x2>,
+		    <0xac00 &smmu 0x16b0 0x2>,
+		    <0xac08 &smmu 0x16b2 0x2>,
+		    <0xad00 &smmu 0x16b4 0x2>,
+		    <0xad08 &smmu 0x16b6 0x2>,
+		    <0xae00 &smmu 0x16b8 0x2>,
+		    <0xae08 &smmu 0x16ba 0x2>,
+		    <0xaf00 &smmu 0x16bc 0x2>,
+		    <0xaf08 &smmu 0x16be 0x2>,
+		    <0xb000 &smmu 0x16c0 0x2>,
+		    <0xb008 &smmu 0x16c2 0x2>,
+		    <0xb100 &smmu 0x16c4 0x2>,
+		    <0xb108 &smmu 0x16c6 0x2>,
+		    <0xb200 &smmu 0x16c8 0x2>,
+		    <0xb208 &smmu 0x16ca 0x2>,
+		    <0xb300 &smmu 0x16cc 0x2>,
+		    <0xb308 &smmu 0x16ce 0x2>,
+		    <0xb400 &smmu 0x16d0 0x2>,
+		    <0xb408 &smmu 0x16d2 0x2>,
+		    <0xb500 &smmu 0x16d4 0x2>,
+		    <0xb508 &smmu 0x16d6 0x2>,
+		    <0xb600 &smmu 0x16d8 0x2>,
+		    <0xb608 &smmu 0x16da 0x2>,
+		    <0xb700 &smmu 0x16dc 0x2>,
+		    <0xb708 &smmu 0x16de 0x2>,
+		    <0xb800 &smmu 0x16e0 0x2>,
+		    <0xb808 &smmu 0x16e2 0x2>,
+		    <0xb900 &smmu 0x16e4 0x2>,
+		    <0xb908 &smmu 0x16e6 0x2>,
+		    <0xba00 &smmu 0x16e8 0x2>,
+		    <0xba08 &smmu 0x16ea 0x2>,
+		    <0xbb00 &smmu 0x16ec 0x2>,
+		    <0xbb08 &smmu 0x16ee 0x2>,
+		    <0xbc00 &smmu 0x16f0 0x2>,
+		    <0xbc08 &smmu 0x16f2 0x2>,
+		    <0xbd00 &smmu 0x16f4 0x2>,
+		    <0xbd08 &smmu 0x16f6 0x2>,
+		    <0xbe00 &smmu 0x16f8 0x2>,
+		    <0xbe08 &smmu 0x16fa 0x2>,
+		    <0xbf00 &smmu 0x16fc 0x2>,
+		    <0xbf08 &smmu 0x16fe 0x2>,
+		    <0xc000 &smmu 0x1700 0x2>,
+		    <0xc008 &smmu 0x1702 0x2>,
+		    <0xc100 &smmu 0x1704 0x2>,
+		    <0xc108 &smmu 0x1706 0x2>,
+		    <0xc200 &smmu 0x1708 0x2>,
+		    <0xc208 &smmu 0x170a 0x2>,
+		    <0xc300 &smmu 0x170c 0x2>,
+		    <0xc308 &smmu 0x170e 0x2>,
+		    <0xc400 &smmu 0x1710 0x2>,
+		    <0xc408 &smmu 0x1712 0x2>,
+		    <0xc500 &smmu 0x1714 0x2>,
+		    <0xc508 &smmu 0x1716 0x2>,
+		    <0xc600 &smmu 0x1718 0x2>,
+		    <0xc608 &smmu 0x171a 0x2>,
+		    <0xc700 &smmu 0x171c 0x2>,
+		    <0xc708 &smmu 0x171e 0x2>,
+		    <0xc800 &smmu 0x1720 0x2>,
+		    <0xc808 &smmu 0x1722 0x2>,
+		    <0xc900 &smmu 0x1724 0x2>,
+		    <0xc908 &smmu 0x1726 0x2>,
+		    <0xca00 &smmu 0x1728 0x2>,
+		    <0xca08 &smmu 0x172a 0x2>,
+		    <0xcb00 &smmu 0x172c 0x2>,
+		    <0xcb08 &smmu 0x172e 0x2>,
+		    <0xcc00 &smmu 0x1730 0x2>,
+		    <0xcc08 &smmu 0x1732 0x2>,
+		    <0xcd00 &smmu 0x1734 0x2>,
+		    <0xcd08 &smmu 0x1736 0x2>,
+		    <0xce00 &smmu 0x1738 0x2>,
+		    <0xce08 &smmu 0x173a 0x2>,
+		    <0xcf00 &smmu 0x173c 0x2>,
+		    <0xcf08 &smmu 0x173e 0x2>,
+		    <0xd000 &smmu 0x1740 0x2>,
+		    <0xd008 &smmu 0x1742 0x2>,
+		    <0xd100 &smmu 0x1744 0x2>,
+		    <0xd108 &smmu 0x1746 0x2>,
+		    <0xd200 &smmu 0x1748 0x2>,
+		    <0xd208 &smmu 0x174a 0x2>,
+		    <0xd300 &smmu 0x174c 0x2>,
+		    <0xd308 &smmu 0x174e 0x2>,
+		    <0xd400 &smmu 0x1750 0x2>,
+		    <0xd408 &smmu 0x1752 0x2>,
+		    <0xd500 &smmu 0x1754 0x2>,
+		    <0xd508 &smmu 0x1756 0x2>,
+		    <0xd600 &smmu 0x1758 0x2>,
+		    <0xd608 &smmu 0x175a 0x2>,
+		    <0xd700 &smmu 0x175c 0x2>,
+		    <0xd708 &smmu 0x175e 0x2>,
+		    <0xd800 &smmu 0x1760 0x2>,
+		    <0xd808 &smmu 0x1762 0x2>,
+		    <0xd900 &smmu 0x1764 0x2>,
+		    <0xd908 &smmu 0x1766 0x2>,
+		    <0xda00 &smmu 0x1768 0x2>,
+		    <0xda08 &smmu 0x176a 0x2>,
+		    <0xdb00 &smmu 0x176c 0x2>,
+		    <0xdb08 &smmu 0x176e 0x2>,
+		    <0xdc00 &smmu 0x1770 0x2>,
+		    <0xdc08 &smmu 0x1772 0x2>,
+		    <0xdd00 &smmu 0x1774 0x2>,
+		    <0xdd08 &smmu 0x1776 0x2>,
+		    <0xde00 &smmu 0x1778 0x2>,
+		    <0xde08 &smmu 0x177a 0x2>,
+		    <0xdf00 &smmu 0x177c 0x2>,
+		    <0xdf08 &smmu 0x177e 0x2>,
+		    <0xe000 &smmu 0x1780 0x2>,
+		    <0xe008 &smmu 0x1782 0x2>,
+		    <0xe100 &smmu 0x1784 0x2>,
+		    <0xe108 &smmu 0x1786 0x2>,
+		    <0xe200 &smmu 0x1788 0x2>,
+		    <0xe208 &smmu 0x178a 0x2>,
+		    <0xe300 &smmu 0x178c 0x2>,
+		    <0xe308 &smmu 0x178e 0x2>,
+		    <0xe400 &smmu 0x1790 0x2>,
+		    <0xe408 &smmu 0x1792 0x2>,
+		    <0xe500 &smmu 0x1794 0x2>,
+		    <0xe508 &smmu 0x1796 0x2>,
+		    <0xe600 &smmu 0x1798 0x2>,
+		    <0xe608 &smmu 0x179a 0x2>,
+		    <0xe700 &smmu 0x179c 0x2>,
+		    <0xe708 &smmu 0x179e 0x2>,
+		    <0xe800 &smmu 0x17a0 0x2>,
+		    <0xe808 &smmu 0x17a2 0x2>,
+		    <0xe900 &smmu 0x17a4 0x2>,
+		    <0xe908 &smmu 0x17a6 0x2>,
+		    <0xea00 &smmu 0x17a8 0x2>,
+		    <0xea08 &smmu 0x17aa 0x2>,
+		    <0xeb00 &smmu 0x17ac 0x2>,
+		    <0xeb08 &smmu 0x17ae 0x2>,
+		    <0xec00 &smmu 0x17b0 0x2>,
+		    <0xec08 &smmu 0x17b2 0x2>,
+		    <0xed00 &smmu 0x17b4 0x2>,
+		    <0xed08 &smmu 0x17b6 0x2>,
+		    <0xee00 &smmu 0x17b8 0x2>,
+		    <0xee08 &smmu 0x17ba 0x2>,
+		    <0xef00 &smmu 0x17bc 0x2>,
+		    <0xef08 &smmu 0x17be 0x2>,
+		    <0xf000 &smmu 0x17c0 0x2>,
+		    <0xf008 &smmu 0x17c2 0x2>,
+		    <0xf100 &smmu 0x17c4 0x2>,
+		    <0xf108 &smmu 0x17c6 0x2>,
+		    <0xf200 &smmu 0x17c8 0x2>,
+		    <0xf208 &smmu 0x17ca 0x2>,
+		    <0xf300 &smmu 0x17cc 0x2>,
+		    <0xf308 &smmu 0x17ce 0x2>,
+		    <0xf400 &smmu 0x17d0 0x2>,
+		    <0xf408 &smmu 0x17d2 0x2>,
+		    <0xf500 &smmu 0x17d4 0x2>,
+		    <0xf508 &smmu 0x17d6 0x2>,
+		    <0xf600 &smmu 0x17d8 0x2>,
+		    <0xf608 &smmu 0x17da 0x2>,
+		    <0xf700 &smmu 0x17dc 0x2>,
+		    <0xf708 &smmu 0x17de 0x2>,
+		    <0xf800 &smmu 0x17e0 0x2>,
+		    <0xf808 &smmu 0x17e2 0x2>,
+		    <0xf900 &smmu 0x17e4 0x2>,
+		    <0xf908 &smmu 0x17e6 0x2>,
+		    <0xfa00 &smmu 0x17e8 0x2>,
+		    <0xfa08 &smmu 0x17ea 0x2>,
+		    <0xfb00 &smmu 0x17ec 0x2>,
+		    <0xfb08 &smmu 0x17ee 0x2>,
+		    <0xfc00 &smmu 0x17f0 0x2>,
+		    <0xfc08 &smmu 0x17f2 0x2>,
+		    <0xfd00 &smmu 0x17f4 0x2>,
+		    <0xfd08 &smmu 0x17f6 0x2>,
+		    <0xfe00 &smmu 0x17f8 0x2>,
+		    <0xfe08 &smmu 0x17fa 0x2>,
+		    <0xff00 &smmu 0x17fc 0x2>,
+		    <0xff08 &smmu 0x17fe 0x2>;
+#endif
+};
+
+&pcie6 {
+	msi-map = <0x0000 &gic_its 0x1800 0x2>,
+		  <0x0008 &gic_its 0x1802 0x2>,
+		  <0x0100 &gic_its 0x1804 0x2>,
+		  <0x0108 &gic_its 0x1806 0x2>,
+		  <0x0200 &gic_its 0x1808 0x2>,
+		  <0x0208 &gic_its 0x180a 0x2>,
+		  <0x0300 &gic_its 0x180c 0x2>,
+		  <0x0308 &gic_its 0x180e 0x2>,
+		  <0x0400 &gic_its 0x1810 0x2>,
+		  <0x0408 &gic_its 0x1812 0x2>,
+		  <0x0500 &gic_its 0x1814 0x2>,
+		  <0x0508 &gic_its 0x1816 0x2>,
+		  <0x0600 &gic_its 0x1818 0x2>,
+		  <0x0608 &gic_its 0x181a 0x2>,
+		  <0x0700 &gic_its 0x181c 0x2>,
+		  <0x0708 &gic_its 0x181e 0x2>,
+		  <0x0800 &gic_its 0x1820 0x2>,
+		  <0x0808 &gic_its 0x1822 0x2>,
+		  <0x0900 &gic_its 0x1824 0x2>,
+		  <0x0908 &gic_its 0x1826 0x2>,
+		  <0x0a00 &gic_its 0x1828 0x2>,
+		  <0x0a08 &gic_its 0x182a 0x2>,
+		  <0x0b00 &gic_its 0x182c 0x2>,
+		  <0x0b08 &gic_its 0x182e 0x2>,
+		  <0x0c00 &gic_its 0x1830 0x2>,
+		  <0x0c08 &gic_its 0x1832 0x2>,
+		  <0x0d00 &gic_its 0x1834 0x2>,
+		  <0x0d08 &gic_its 0x1836 0x2>,
+		  <0x0e00 &gic_its 0x1838 0x2>,
+		  <0x0e08 &gic_its 0x183a 0x2>,
+		  <0x0f00 &gic_its 0x183c 0x2>,
+		  <0x0f08 &gic_its 0x183e 0x2>,
+		  <0x1000 &gic_its 0x1840 0x2>,
+		  <0x1008 &gic_its 0x1842 0x2>,
+		  <0x1100 &gic_its 0x1844 0x2>,
+		  <0x1108 &gic_its 0x1846 0x2>,
+		  <0x1200 &gic_its 0x1848 0x2>,
+		  <0x1208 &gic_its 0x184a 0x2>,
+		  <0x1300 &gic_its 0x184c 0x2>,
+		  <0x1308 &gic_its 0x184e 0x2>,
+		  <0x1400 &gic_its 0x1850 0x2>,
+		  <0x1408 &gic_its 0x1852 0x2>,
+		  <0x1500 &gic_its 0x1854 0x2>,
+		  <0x1508 &gic_its 0x1856 0x2>,
+		  <0x1600 &gic_its 0x1858 0x2>,
+		  <0x1608 &gic_its 0x185a 0x2>,
+		  <0x1700 &gic_its 0x185c 0x2>,
+		  <0x1708 &gic_its 0x185e 0x2>,
+		  <0x1800 &gic_its 0x1860 0x2>,
+		  <0x1808 &gic_its 0x1862 0x2>,
+		  <0x1900 &gic_its 0x1864 0x2>,
+		  <0x1908 &gic_its 0x1866 0x2>,
+		  <0x1a00 &gic_its 0x1868 0x2>,
+		  <0x1a08 &gic_its 0x186a 0x2>,
+		  <0x1b00 &gic_its 0x186c 0x2>,
+		  <0x1b08 &gic_its 0x186e 0x2>,
+		  <0x1c00 &gic_its 0x1870 0x2>,
+		  <0x1c08 &gic_its 0x1872 0x2>,
+		  <0x1d00 &gic_its 0x1874 0x2>,
+		  <0x1d08 &gic_its 0x1876 0x2>,
+		  <0x1e00 &gic_its 0x1878 0x2>,
+		  <0x1e08 &gic_its 0x187a 0x2>,
+		  <0x1f00 &gic_its 0x187c 0x2>,
+		  <0x1f08 &gic_its 0x187e 0x2>,
+		  <0x2000 &gic_its 0x1880 0x2>,
+		  <0x2008 &gic_its 0x1882 0x2>,
+		  <0x2100 &gic_its 0x1884 0x2>,
+		  <0x2108 &gic_its 0x1886 0x2>,
+		  <0x2200 &gic_its 0x1888 0x2>,
+		  <0x2208 &gic_its 0x188a 0x2>,
+		  <0x2300 &gic_its 0x188c 0x2>,
+		  <0x2308 &gic_its 0x188e 0x2>,
+		  <0x2400 &gic_its 0x1890 0x2>,
+		  <0x2408 &gic_its 0x1892 0x2>,
+		  <0x2500 &gic_its 0x1894 0x2>,
+		  <0x2508 &gic_its 0x1896 0x2>,
+		  <0x2600 &gic_its 0x1898 0x2>,
+		  <0x2608 &gic_its 0x189a 0x2>,
+		  <0x2700 &gic_its 0x189c 0x2>,
+		  <0x2708 &gic_its 0x189e 0x2>,
+		  <0x2800 &gic_its 0x18a0 0x2>,
+		  <0x2808 &gic_its 0x18a2 0x2>,
+		  <0x2900 &gic_its 0x18a4 0x2>,
+		  <0x2908 &gic_its 0x18a6 0x2>,
+		  <0x2a00 &gic_its 0x18a8 0x2>,
+		  <0x2a08 &gic_its 0x18aa 0x2>,
+		  <0x2b00 &gic_its 0x18ac 0x2>,
+		  <0x2b08 &gic_its 0x18ae 0x2>,
+		  <0x2c00 &gic_its 0x18b0 0x2>,
+		  <0x2c08 &gic_its 0x18b2 0x2>,
+		  <0x2d00 &gic_its 0x18b4 0x2>,
+		  <0x2d08 &gic_its 0x18b6 0x2>,
+		  <0x2e00 &gic_its 0x18b8 0x2>,
+		  <0x2e08 &gic_its 0x18ba 0x2>,
+		  <0x2f00 &gic_its 0x18bc 0x2>,
+		  <0x2f08 &gic_its 0x18be 0x2>,
+		  <0x3000 &gic_its 0x18c0 0x2>,
+		  <0x3008 &gic_its 0x18c2 0x2>,
+		  <0x3100 &gic_its 0x18c4 0x2>,
+		  <0x3108 &gic_its 0x18c6 0x2>,
+		  <0x3200 &gic_its 0x18c8 0x2>,
+		  <0x3208 &gic_its 0x18ca 0x2>,
+		  <0x3300 &gic_its 0x18cc 0x2>,
+		  <0x3308 &gic_its 0x18ce 0x2>,
+		  <0x3400 &gic_its 0x18d0 0x2>,
+		  <0x3408 &gic_its 0x18d2 0x2>,
+		  <0x3500 &gic_its 0x18d4 0x2>,
+		  <0x3508 &gic_its 0x18d6 0x2>,
+		  <0x3600 &gic_its 0x18d8 0x2>,
+		  <0x3608 &gic_its 0x18da 0x2>,
+		  <0x3700 &gic_its 0x18dc 0x2>,
+		  <0x3708 &gic_its 0x18de 0x2>,
+		  <0x3800 &gic_its 0x18e0 0x2>,
+		  <0x3808 &gic_its 0x18e2 0x2>,
+		  <0x3900 &gic_its 0x18e4 0x2>,
+		  <0x3908 &gic_its 0x18e6 0x2>,
+		  <0x3a00 &gic_its 0x18e8 0x2>,
+		  <0x3a08 &gic_its 0x18ea 0x2>,
+		  <0x3b00 &gic_its 0x18ec 0x2>,
+		  <0x3b08 &gic_its 0x18ee 0x2>,
+		  <0x3c00 &gic_its 0x18f0 0x2>,
+		  <0x3c08 &gic_its 0x18f2 0x2>,
+		  <0x3d00 &gic_its 0x18f4 0x2>,
+		  <0x3d08 &gic_its 0x18f6 0x2>,
+		  <0x3e00 &gic_its 0x18f8 0x2>,
+		  <0x3e08 &gic_its 0x18fa 0x2>,
+		  <0x3f00 &gic_its 0x18fc 0x2>,
+		  <0x3f08 &gic_its 0x18fe 0x2>,
+		  <0x4000 &gic_its 0x1900 0x2>,
+		  <0x4008 &gic_its 0x1902 0x2>,
+		  <0x4100 &gic_its 0x1904 0x2>,
+		  <0x4108 &gic_its 0x1906 0x2>,
+		  <0x4200 &gic_its 0x1908 0x2>,
+		  <0x4208 &gic_its 0x190a 0x2>,
+		  <0x4300 &gic_its 0x190c 0x2>,
+		  <0x4308 &gic_its 0x190e 0x2>,
+		  <0x4400 &gic_its 0x1910 0x2>,
+		  <0x4408 &gic_its 0x1912 0x2>,
+		  <0x4500 &gic_its 0x1914 0x2>,
+		  <0x4508 &gic_its 0x1916 0x2>,
+		  <0x4600 &gic_its 0x1918 0x2>,
+		  <0x4608 &gic_its 0x191a 0x2>,
+		  <0x4700 &gic_its 0x191c 0x2>,
+		  <0x4708 &gic_its 0x191e 0x2>,
+		  <0x4800 &gic_its 0x1920 0x2>,
+		  <0x4808 &gic_its 0x1922 0x2>,
+		  <0x4900 &gic_its 0x1924 0x2>,
+		  <0x4908 &gic_its 0x1926 0x2>,
+		  <0x4a00 &gic_its 0x1928 0x2>,
+		  <0x4a08 &gic_its 0x192a 0x2>,
+		  <0x4b00 &gic_its 0x192c 0x2>,
+		  <0x4b08 &gic_its 0x192e 0x2>,
+		  <0x4c00 &gic_its 0x1930 0x2>,
+		  <0x4c08 &gic_its 0x1932 0x2>,
+		  <0x4d00 &gic_its 0x1934 0x2>,
+		  <0x4d08 &gic_its 0x1936 0x2>,
+		  <0x4e00 &gic_its 0x1938 0x2>,
+		  <0x4e08 &gic_its 0x193a 0x2>,
+		  <0x4f00 &gic_its 0x193c 0x2>,
+		  <0x4f08 &gic_its 0x193e 0x2>,
+		  <0x5000 &gic_its 0x1940 0x2>,
+		  <0x5008 &gic_its 0x1942 0x2>,
+		  <0x5100 &gic_its 0x1944 0x2>,
+		  <0x5108 &gic_its 0x1946 0x2>,
+		  <0x5200 &gic_its 0x1948 0x2>,
+		  <0x5208 &gic_its 0x194a 0x2>,
+		  <0x5300 &gic_its 0x194c 0x2>,
+		  <0x5308 &gic_its 0x194e 0x2>,
+		  <0x5400 &gic_its 0x1950 0x2>,
+		  <0x5408 &gic_its 0x1952 0x2>,
+		  <0x5500 &gic_its 0x1954 0x2>,
+		  <0x5508 &gic_its 0x1956 0x2>,
+		  <0x5600 &gic_its 0x1958 0x2>,
+		  <0x5608 &gic_its 0x195a 0x2>,
+		  <0x5700 &gic_its 0x195c 0x2>,
+		  <0x5708 &gic_its 0x195e 0x2>,
+		  <0x5800 &gic_its 0x1960 0x2>,
+		  <0x5808 &gic_its 0x1962 0x2>,
+		  <0x5900 &gic_its 0x1964 0x2>,
+		  <0x5908 &gic_its 0x1966 0x2>,
+		  <0x5a00 &gic_its 0x1968 0x2>,
+		  <0x5a08 &gic_its 0x196a 0x2>,
+		  <0x5b00 &gic_its 0x196c 0x2>,
+		  <0x5b08 &gic_its 0x196e 0x2>,
+		  <0x5c00 &gic_its 0x1970 0x2>,
+		  <0x5c08 &gic_its 0x1972 0x2>,
+		  <0x5d00 &gic_its 0x1974 0x2>,
+		  <0x5d08 &gic_its 0x1976 0x2>,
+		  <0x5e00 &gic_its 0x1978 0x2>,
+		  <0x5e08 &gic_its 0x197a 0x2>,
+		  <0x5f00 &gic_its 0x197c 0x2>,
+		  <0x5f08 &gic_its 0x197e 0x2>,
+		  <0x6000 &gic_its 0x1980 0x2>,
+		  <0x6008 &gic_its 0x1982 0x2>,
+		  <0x6100 &gic_its 0x1984 0x2>,
+		  <0x6108 &gic_its 0x1986 0x2>,
+		  <0x6200 &gic_its 0x1988 0x2>,
+		  <0x6208 &gic_its 0x198a 0x2>,
+		  <0x6300 &gic_its 0x198c 0x2>,
+		  <0x6308 &gic_its 0x198e 0x2>,
+		  <0x6400 &gic_its 0x1990 0x2>,
+		  <0x6408 &gic_its 0x1992 0x2>,
+		  <0x6500 &gic_its 0x1994 0x2>,
+		  <0x6508 &gic_its 0x1996 0x2>,
+		  <0x6600 &gic_its 0x1998 0x2>,
+		  <0x6608 &gic_its 0x199a 0x2>,
+		  <0x6700 &gic_its 0x199c 0x2>,
+		  <0x6708 &gic_its 0x199e 0x2>,
+		  <0x6800 &gic_its 0x19a0 0x2>,
+		  <0x6808 &gic_its 0x19a2 0x2>,
+		  <0x6900 &gic_its 0x19a4 0x2>,
+		  <0x6908 &gic_its 0x19a6 0x2>,
+		  <0x6a00 &gic_its 0x19a8 0x2>,
+		  <0x6a08 &gic_its 0x19aa 0x2>,
+		  <0x6b00 &gic_its 0x19ac 0x2>,
+		  <0x6b08 &gic_its 0x19ae 0x2>,
+		  <0x6c00 &gic_its 0x19b0 0x2>,
+		  <0x6c08 &gic_its 0x19b2 0x2>,
+		  <0x6d00 &gic_its 0x19b4 0x2>,
+		  <0x6d08 &gic_its 0x19b6 0x2>,
+		  <0x6e00 &gic_its 0x19b8 0x2>,
+		  <0x6e08 &gic_its 0x19ba 0x2>,
+		  <0x6f00 &gic_its 0x19bc 0x2>,
+		  <0x6f08 &gic_its 0x19be 0x2>,
+		  <0x7000 &gic_its 0x19c0 0x2>,
+		  <0x7008 &gic_its 0x19c2 0x2>,
+		  <0x7100 &gic_its 0x19c4 0x2>,
+		  <0x7108 &gic_its 0x19c6 0x2>,
+		  <0x7200 &gic_its 0x19c8 0x2>,
+		  <0x7208 &gic_its 0x19ca 0x2>,
+		  <0x7300 &gic_its 0x19cc 0x2>,
+		  <0x7308 &gic_its 0x19ce 0x2>,
+		  <0x7400 &gic_its 0x19d0 0x2>,
+		  <0x7408 &gic_its 0x19d2 0x2>,
+		  <0x7500 &gic_its 0x19d4 0x2>,
+		  <0x7508 &gic_its 0x19d6 0x2>,
+		  <0x7600 &gic_its 0x19d8 0x2>,
+		  <0x7608 &gic_its 0x19da 0x2>,
+		  <0x7700 &gic_its 0x19dc 0x2>,
+		  <0x7708 &gic_its 0x19de 0x2>,
+		  <0x7800 &gic_its 0x19e0 0x2>,
+		  <0x7808 &gic_its 0x19e2 0x2>,
+		  <0x7900 &gic_its 0x19e4 0x2>,
+		  <0x7908 &gic_its 0x19e6 0x2>,
+		  <0x7a00 &gic_its 0x19e8 0x2>,
+		  <0x7a08 &gic_its 0x19ea 0x2>,
+		  <0x7b00 &gic_its 0x19ec 0x2>,
+		  <0x7b08 &gic_its 0x19ee 0x2>,
+		  <0x7c00 &gic_its 0x19f0 0x2>,
+		  <0x7c08 &gic_its 0x19f2 0x2>,
+		  <0x7d00 &gic_its 0x19f4 0x2>,
+		  <0x7d08 &gic_its 0x19f6 0x2>,
+		  <0x7e00 &gic_its 0x19f8 0x2>,
+		  <0x7e08 &gic_its 0x19fa 0x2>,
+		  <0x7f00 &gic_its 0x19fc 0x2>,
+		  <0x7f08 &gic_its 0x19fe 0x2>,
+		  <0x8000 &gic_its 0x1a00 0x2>,
+		  <0x8008 &gic_its 0x1a02 0x2>,
+		  <0x8100 &gic_its 0x1a04 0x2>,
+		  <0x8108 &gic_its 0x1a06 0x2>,
+		  <0x8200 &gic_its 0x1a08 0x2>,
+		  <0x8208 &gic_its 0x1a0a 0x2>,
+		  <0x8300 &gic_its 0x1a0c 0x2>,
+		  <0x8308 &gic_its 0x1a0e 0x2>,
+		  <0x8400 &gic_its 0x1a10 0x2>,
+		  <0x8408 &gic_its 0x1a12 0x2>,
+		  <0x8500 &gic_its 0x1a14 0x2>,
+		  <0x8508 &gic_its 0x1a16 0x2>,
+		  <0x8600 &gic_its 0x1a18 0x2>,
+		  <0x8608 &gic_its 0x1a1a 0x2>,
+		  <0x8700 &gic_its 0x1a1c 0x2>,
+		  <0x8708 &gic_its 0x1a1e 0x2>,
+		  <0x8800 &gic_its 0x1a20 0x2>,
+		  <0x8808 &gic_its 0x1a22 0x2>,
+		  <0x8900 &gic_its 0x1a24 0x2>,
+		  <0x8908 &gic_its 0x1a26 0x2>,
+		  <0x8a00 &gic_its 0x1a28 0x2>,
+		  <0x8a08 &gic_its 0x1a2a 0x2>,
+		  <0x8b00 &gic_its 0x1a2c 0x2>,
+		  <0x8b08 &gic_its 0x1a2e 0x2>,
+		  <0x8c00 &gic_its 0x1a30 0x2>,
+		  <0x8c08 &gic_its 0x1a32 0x2>,
+		  <0x8d00 &gic_its 0x1a34 0x2>,
+		  <0x8d08 &gic_its 0x1a36 0x2>,
+		  <0x8e00 &gic_its 0x1a38 0x2>,
+		  <0x8e08 &gic_its 0x1a3a 0x2>,
+		  <0x8f00 &gic_its 0x1a3c 0x2>,
+		  <0x8f08 &gic_its 0x1a3e 0x2>,
+		  <0x9000 &gic_its 0x1a40 0x2>,
+		  <0x9008 &gic_its 0x1a42 0x2>,
+		  <0x9100 &gic_its 0x1a44 0x2>,
+		  <0x9108 &gic_its 0x1a46 0x2>,
+		  <0x9200 &gic_its 0x1a48 0x2>,
+		  <0x9208 &gic_its 0x1a4a 0x2>,
+		  <0x9300 &gic_its 0x1a4c 0x2>,
+		  <0x9308 &gic_its 0x1a4e 0x2>,
+		  <0x9400 &gic_its 0x1a50 0x2>,
+		  <0x9408 &gic_its 0x1a52 0x2>,
+		  <0x9500 &gic_its 0x1a54 0x2>,
+		  <0x9508 &gic_its 0x1a56 0x2>,
+		  <0x9600 &gic_its 0x1a58 0x2>,
+		  <0x9608 &gic_its 0x1a5a 0x2>,
+		  <0x9700 &gic_its 0x1a5c 0x2>,
+		  <0x9708 &gic_its 0x1a5e 0x2>,
+		  <0x9800 &gic_its 0x1a60 0x2>,
+		  <0x9808 &gic_its 0x1a62 0x2>,
+		  <0x9900 &gic_its 0x1a64 0x2>,
+		  <0x9908 &gic_its 0x1a66 0x2>,
+		  <0x9a00 &gic_its 0x1a68 0x2>,
+		  <0x9a08 &gic_its 0x1a6a 0x2>,
+		  <0x9b00 &gic_its 0x1a6c 0x2>,
+		  <0x9b08 &gic_its 0x1a6e 0x2>,
+		  <0x9c00 &gic_its 0x1a70 0x2>,
+		  <0x9c08 &gic_its 0x1a72 0x2>,
+		  <0x9d00 &gic_its 0x1a74 0x2>,
+		  <0x9d08 &gic_its 0x1a76 0x2>,
+		  <0x9e00 &gic_its 0x1a78 0x2>,
+		  <0x9e08 &gic_its 0x1a7a 0x2>,
+		  <0x9f00 &gic_its 0x1a7c 0x2>,
+		  <0x9f08 &gic_its 0x1a7e 0x2>,
+		  <0xa000 &gic_its 0x1a80 0x2>,
+		  <0xa008 &gic_its 0x1a82 0x2>,
+		  <0xa100 &gic_its 0x1a84 0x2>,
+		  <0xa108 &gic_its 0x1a86 0x2>,
+		  <0xa200 &gic_its 0x1a88 0x2>,
+		  <0xa208 &gic_its 0x1a8a 0x2>,
+		  <0xa300 &gic_its 0x1a8c 0x2>,
+		  <0xa308 &gic_its 0x1a8e 0x2>,
+		  <0xa400 &gic_its 0x1a90 0x2>,
+		  <0xa408 &gic_its 0x1a92 0x2>,
+		  <0xa500 &gic_its 0x1a94 0x2>,
+		  <0xa508 &gic_its 0x1a96 0x2>,
+		  <0xa600 &gic_its 0x1a98 0x2>,
+		  <0xa608 &gic_its 0x1a9a 0x2>,
+		  <0xa700 &gic_its 0x1a9c 0x2>,
+		  <0xa708 &gic_its 0x1a9e 0x2>,
+		  <0xa800 &gic_its 0x1aa0 0x2>,
+		  <0xa808 &gic_its 0x1aa2 0x2>,
+		  <0xa900 &gic_its 0x1aa4 0x2>,
+		  <0xa908 &gic_its 0x1aa6 0x2>,
+		  <0xaa00 &gic_its 0x1aa8 0x2>,
+		  <0xaa08 &gic_its 0x1aaa 0x2>,
+		  <0xab00 &gic_its 0x1aac 0x2>,
+		  <0xab08 &gic_its 0x1aae 0x2>,
+		  <0xac00 &gic_its 0x1ab0 0x2>,
+		  <0xac08 &gic_its 0x1ab2 0x2>,
+		  <0xad00 &gic_its 0x1ab4 0x2>,
+		  <0xad08 &gic_its 0x1ab6 0x2>,
+		  <0xae00 &gic_its 0x1ab8 0x2>,
+		  <0xae08 &gic_its 0x1aba 0x2>,
+		  <0xaf00 &gic_its 0x1abc 0x2>,
+		  <0xaf08 &gic_its 0x1abe 0x2>,
+		  <0xb000 &gic_its 0x1ac0 0x2>,
+		  <0xb008 &gic_its 0x1ac2 0x2>,
+		  <0xb100 &gic_its 0x1ac4 0x2>,
+		  <0xb108 &gic_its 0x1ac6 0x2>,
+		  <0xb200 &gic_its 0x1ac8 0x2>,
+		  <0xb208 &gic_its 0x1aca 0x2>,
+		  <0xb300 &gic_its 0x1acc 0x2>,
+		  <0xb308 &gic_its 0x1ace 0x2>,
+		  <0xb400 &gic_its 0x1ad0 0x2>,
+		  <0xb408 &gic_its 0x1ad2 0x2>,
+		  <0xb500 &gic_its 0x1ad4 0x2>,
+		  <0xb508 &gic_its 0x1ad6 0x2>,
+		  <0xb600 &gic_its 0x1ad8 0x2>,
+		  <0xb608 &gic_its 0x1ada 0x2>,
+		  <0xb700 &gic_its 0x1adc 0x2>,
+		  <0xb708 &gic_its 0x1ade 0x2>,
+		  <0xb800 &gic_its 0x1ae0 0x2>,
+		  <0xb808 &gic_its 0x1ae2 0x2>,
+		  <0xb900 &gic_its 0x1ae4 0x2>,
+		  <0xb908 &gic_its 0x1ae6 0x2>,
+		  <0xba00 &gic_its 0x1ae8 0x2>,
+		  <0xba08 &gic_its 0x1aea 0x2>,
+		  <0xbb00 &gic_its 0x1aec 0x2>,
+		  <0xbb08 &gic_its 0x1aee 0x2>,
+		  <0xbc00 &gic_its 0x1af0 0x2>,
+		  <0xbc08 &gic_its 0x1af2 0x2>,
+		  <0xbd00 &gic_its 0x1af4 0x2>,
+		  <0xbd08 &gic_its 0x1af6 0x2>,
+		  <0xbe00 &gic_its 0x1af8 0x2>,
+		  <0xbe08 &gic_its 0x1afa 0x2>,
+		  <0xbf00 &gic_its 0x1afc 0x2>,
+		  <0xbf08 &gic_its 0x1afe 0x2>,
+		  <0xc000 &gic_its 0x1b00 0x2>,
+		  <0xc008 &gic_its 0x1b02 0x2>,
+		  <0xc100 &gic_its 0x1b04 0x2>,
+		  <0xc108 &gic_its 0x1b06 0x2>,
+		  <0xc200 &gic_its 0x1b08 0x2>,
+		  <0xc208 &gic_its 0x1b0a 0x2>,
+		  <0xc300 &gic_its 0x1b0c 0x2>,
+		  <0xc308 &gic_its 0x1b0e 0x2>,
+		  <0xc400 &gic_its 0x1b10 0x2>,
+		  <0xc408 &gic_its 0x1b12 0x2>,
+		  <0xc500 &gic_its 0x1b14 0x2>,
+		  <0xc508 &gic_its 0x1b16 0x2>,
+		  <0xc600 &gic_its 0x1b18 0x2>,
+		  <0xc608 &gic_its 0x1b1a 0x2>,
+		  <0xc700 &gic_its 0x1b1c 0x2>,
+		  <0xc708 &gic_its 0x1b1e 0x2>,
+		  <0xc800 &gic_its 0x1b20 0x2>,
+		  <0xc808 &gic_its 0x1b22 0x2>,
+		  <0xc900 &gic_its 0x1b24 0x2>,
+		  <0xc908 &gic_its 0x1b26 0x2>,
+		  <0xca00 &gic_its 0x1b28 0x2>,
+		  <0xca08 &gic_its 0x1b2a 0x2>,
+		  <0xcb00 &gic_its 0x1b2c 0x2>,
+		  <0xcb08 &gic_its 0x1b2e 0x2>,
+		  <0xcc00 &gic_its 0x1b30 0x2>,
+		  <0xcc08 &gic_its 0x1b32 0x2>,
+		  <0xcd00 &gic_its 0x1b34 0x2>,
+		  <0xcd08 &gic_its 0x1b36 0x2>,
+		  <0xce00 &gic_its 0x1b38 0x2>,
+		  <0xce08 &gic_its 0x1b3a 0x2>,
+		  <0xcf00 &gic_its 0x1b3c 0x2>,
+		  <0xcf08 &gic_its 0x1b3e 0x2>,
+		  <0xd000 &gic_its 0x1b40 0x2>,
+		  <0xd008 &gic_its 0x1b42 0x2>,
+		  <0xd100 &gic_its 0x1b44 0x2>,
+		  <0xd108 &gic_its 0x1b46 0x2>,
+		  <0xd200 &gic_its 0x1b48 0x2>,
+		  <0xd208 &gic_its 0x1b4a 0x2>,
+		  <0xd300 &gic_its 0x1b4c 0x2>,
+		  <0xd308 &gic_its 0x1b4e 0x2>,
+		  <0xd400 &gic_its 0x1b50 0x2>,
+		  <0xd408 &gic_its 0x1b52 0x2>,
+		  <0xd500 &gic_its 0x1b54 0x2>,
+		  <0xd508 &gic_its 0x1b56 0x2>,
+		  <0xd600 &gic_its 0x1b58 0x2>,
+		  <0xd608 &gic_its 0x1b5a 0x2>,
+		  <0xd700 &gic_its 0x1b5c 0x2>,
+		  <0xd708 &gic_its 0x1b5e 0x2>,
+		  <0xd800 &gic_its 0x1b60 0x2>,
+		  <0xd808 &gic_its 0x1b62 0x2>,
+		  <0xd900 &gic_its 0x1b64 0x2>,
+		  <0xd908 &gic_its 0x1b66 0x2>,
+		  <0xda00 &gic_its 0x1b68 0x2>,
+		  <0xda08 &gic_its 0x1b6a 0x2>,
+		  <0xdb00 &gic_its 0x1b6c 0x2>,
+		  <0xdb08 &gic_its 0x1b6e 0x2>,
+		  <0xdc00 &gic_its 0x1b70 0x2>,
+		  <0xdc08 &gic_its 0x1b72 0x2>,
+		  <0xdd00 &gic_its 0x1b74 0x2>,
+		  <0xdd08 &gic_its 0x1b76 0x2>,
+		  <0xde00 &gic_its 0x1b78 0x2>,
+		  <0xde08 &gic_its 0x1b7a 0x2>,
+		  <0xdf00 &gic_its 0x1b7c 0x2>,
+		  <0xdf08 &gic_its 0x1b7e 0x2>,
+		  <0xe000 &gic_its 0x1b80 0x2>,
+		  <0xe008 &gic_its 0x1b82 0x2>,
+		  <0xe100 &gic_its 0x1b84 0x2>,
+		  <0xe108 &gic_its 0x1b86 0x2>,
+		  <0xe200 &gic_its 0x1b88 0x2>,
+		  <0xe208 &gic_its 0x1b8a 0x2>,
+		  <0xe300 &gic_its 0x1b8c 0x2>,
+		  <0xe308 &gic_its 0x1b8e 0x2>,
+		  <0xe400 &gic_its 0x1b90 0x2>,
+		  <0xe408 &gic_its 0x1b92 0x2>,
+		  <0xe500 &gic_its 0x1b94 0x2>,
+		  <0xe508 &gic_its 0x1b96 0x2>,
+		  <0xe600 &gic_its 0x1b98 0x2>,
+		  <0xe608 &gic_its 0x1b9a 0x2>,
+		  <0xe700 &gic_its 0x1b9c 0x2>,
+		  <0xe708 &gic_its 0x1b9e 0x2>,
+		  <0xe800 &gic_its 0x1ba0 0x2>,
+		  <0xe808 &gic_its 0x1ba2 0x2>,
+		  <0xe900 &gic_its 0x1ba4 0x2>,
+		  <0xe908 &gic_its 0x1ba6 0x2>,
+		  <0xea00 &gic_its 0x1ba8 0x2>,
+		  <0xea08 &gic_its 0x1baa 0x2>,
+		  <0xeb00 &gic_its 0x1bac 0x2>,
+		  <0xeb08 &gic_its 0x1bae 0x2>,
+		  <0xec00 &gic_its 0x1bb0 0x2>,
+		  <0xec08 &gic_its 0x1bb2 0x2>,
+		  <0xed00 &gic_its 0x1bb4 0x2>,
+		  <0xed08 &gic_its 0x1bb6 0x2>,
+		  <0xee00 &gic_its 0x1bb8 0x2>,
+		  <0xee08 &gic_its 0x1bba 0x2>,
+		  <0xef00 &gic_its 0x1bbc 0x2>,
+		  <0xef08 &gic_its 0x1bbe 0x2>,
+		  <0xf000 &gic_its 0x1bc0 0x2>,
+		  <0xf008 &gic_its 0x1bc2 0x2>,
+		  <0xf100 &gic_its 0x1bc4 0x2>,
+		  <0xf108 &gic_its 0x1bc6 0x2>,
+		  <0xf200 &gic_its 0x1bc8 0x2>,
+		  <0xf208 &gic_its 0x1bca 0x2>,
+		  <0xf300 &gic_its 0x1bcc 0x2>,
+		  <0xf308 &gic_its 0x1bce 0x2>,
+		  <0xf400 &gic_its 0x1bd0 0x2>,
+		  <0xf408 &gic_its 0x1bd2 0x2>,
+		  <0xf500 &gic_its 0x1bd4 0x2>,
+		  <0xf508 &gic_its 0x1bd6 0x2>,
+		  <0xf600 &gic_its 0x1bd8 0x2>,
+		  <0xf608 &gic_its 0x1bda 0x2>,
+		  <0xf700 &gic_its 0x1bdc 0x2>,
+		  <0xf708 &gic_its 0x1bde 0x2>,
+		  <0xf800 &gic_its 0x1be0 0x2>,
+		  <0xf808 &gic_its 0x1be2 0x2>,
+		  <0xf900 &gic_its 0x1be4 0x2>,
+		  <0xf908 &gic_its 0x1be6 0x2>,
+		  <0xfa00 &gic_its 0x1be8 0x2>,
+		  <0xfa08 &gic_its 0x1bea 0x2>,
+		  <0xfb00 &gic_its 0x1bec 0x2>,
+		  <0xfb08 &gic_its 0x1bee 0x2>,
+		  <0xfc00 &gic_its 0x1bf0 0x2>,
+		  <0xfc08 &gic_its 0x1bf2 0x2>,
+		  <0xfd00 &gic_its 0x1bf4 0x2>,
+		  <0xfd08 &gic_its 0x1bf6 0x2>,
+		  <0xfe00 &gic_its 0x1bf8 0x2>,
+		  <0xfe08 &gic_its 0x1bfa 0x2>,
+		  <0xff00 &gic_its 0x1bfc 0x2>,
+		  <0xff08 &gic_its 0x1bfe 0x2>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x1800 0x2>,
+		    <0x0008 &smmu 0x1802 0x2>,
+		    <0x0100 &smmu 0x1804 0x2>,
+		    <0x0108 &smmu 0x1806 0x2>,
+		    <0x0200 &smmu 0x1808 0x2>,
+		    <0x0208 &smmu 0x180a 0x2>,
+		    <0x0300 &smmu 0x180c 0x2>,
+		    <0x0308 &smmu 0x180e 0x2>,
+		    <0x0400 &smmu 0x1810 0x2>,
+		    <0x0408 &smmu 0x1812 0x2>,
+		    <0x0500 &smmu 0x1814 0x2>,
+		    <0x0508 &smmu 0x1816 0x2>,
+		    <0x0600 &smmu 0x1818 0x2>,
+		    <0x0608 &smmu 0x181a 0x2>,
+		    <0x0700 &smmu 0x181c 0x2>,
+		    <0x0708 &smmu 0x181e 0x2>,
+		    <0x0800 &smmu 0x1820 0x2>,
+		    <0x0808 &smmu 0x1822 0x2>,
+		    <0x0900 &smmu 0x1824 0x2>,
+		    <0x0908 &smmu 0x1826 0x2>,
+		    <0x0a00 &smmu 0x1828 0x2>,
+		    <0x0a08 &smmu 0x182a 0x2>,
+		    <0x0b00 &smmu 0x182c 0x2>,
+		    <0x0b08 &smmu 0x182e 0x2>,
+		    <0x0c00 &smmu 0x1830 0x2>,
+		    <0x0c08 &smmu 0x1832 0x2>,
+		    <0x0d00 &smmu 0x1834 0x2>,
+		    <0x0d08 &smmu 0x1836 0x2>,
+		    <0x0e00 &smmu 0x1838 0x2>,
+		    <0x0e08 &smmu 0x183a 0x2>,
+		    <0x0f00 &smmu 0x183c 0x2>,
+		    <0x0f08 &smmu 0x183e 0x2>,
+		    <0x1000 &smmu 0x1840 0x2>,
+		    <0x1008 &smmu 0x1842 0x2>,
+		    <0x1100 &smmu 0x1844 0x2>,
+		    <0x1108 &smmu 0x1846 0x2>,
+		    <0x1200 &smmu 0x1848 0x2>,
+		    <0x1208 &smmu 0x184a 0x2>,
+		    <0x1300 &smmu 0x184c 0x2>,
+		    <0x1308 &smmu 0x184e 0x2>,
+		    <0x1400 &smmu 0x1850 0x2>,
+		    <0x1408 &smmu 0x1852 0x2>,
+		    <0x1500 &smmu 0x1854 0x2>,
+		    <0x1508 &smmu 0x1856 0x2>,
+		    <0x1600 &smmu 0x1858 0x2>,
+		    <0x1608 &smmu 0x185a 0x2>,
+		    <0x1700 &smmu 0x185c 0x2>,
+		    <0x1708 &smmu 0x185e 0x2>,
+		    <0x1800 &smmu 0x1860 0x2>,
+		    <0x1808 &smmu 0x1862 0x2>,
+		    <0x1900 &smmu 0x1864 0x2>,
+		    <0x1908 &smmu 0x1866 0x2>,
+		    <0x1a00 &smmu 0x1868 0x2>,
+		    <0x1a08 &smmu 0x186a 0x2>,
+		    <0x1b00 &smmu 0x186c 0x2>,
+		    <0x1b08 &smmu 0x186e 0x2>,
+		    <0x1c00 &smmu 0x1870 0x2>,
+		    <0x1c08 &smmu 0x1872 0x2>,
+		    <0x1d00 &smmu 0x1874 0x2>,
+		    <0x1d08 &smmu 0x1876 0x2>,
+		    <0x1e00 &smmu 0x1878 0x2>,
+		    <0x1e08 &smmu 0x187a 0x2>,
+		    <0x1f00 &smmu 0x187c 0x2>,
+		    <0x1f08 &smmu 0x187e 0x2>,
+		    <0x2000 &smmu 0x1880 0x2>,
+		    <0x2008 &smmu 0x1882 0x2>,
+		    <0x2100 &smmu 0x1884 0x2>,
+		    <0x2108 &smmu 0x1886 0x2>,
+		    <0x2200 &smmu 0x1888 0x2>,
+		    <0x2208 &smmu 0x188a 0x2>,
+		    <0x2300 &smmu 0x188c 0x2>,
+		    <0x2308 &smmu 0x188e 0x2>,
+		    <0x2400 &smmu 0x1890 0x2>,
+		    <0x2408 &smmu 0x1892 0x2>,
+		    <0x2500 &smmu 0x1894 0x2>,
+		    <0x2508 &smmu 0x1896 0x2>,
+		    <0x2600 &smmu 0x1898 0x2>,
+		    <0x2608 &smmu 0x189a 0x2>,
+		    <0x2700 &smmu 0x189c 0x2>,
+		    <0x2708 &smmu 0x189e 0x2>,
+		    <0x2800 &smmu 0x18a0 0x2>,
+		    <0x2808 &smmu 0x18a2 0x2>,
+		    <0x2900 &smmu 0x18a4 0x2>,
+		    <0x2908 &smmu 0x18a6 0x2>,
+		    <0x2a00 &smmu 0x18a8 0x2>,
+		    <0x2a08 &smmu 0x18aa 0x2>,
+		    <0x2b00 &smmu 0x18ac 0x2>,
+		    <0x2b08 &smmu 0x18ae 0x2>,
+		    <0x2c00 &smmu 0x18b0 0x2>,
+		    <0x2c08 &smmu 0x18b2 0x2>,
+		    <0x2d00 &smmu 0x18b4 0x2>,
+		    <0x2d08 &smmu 0x18b6 0x2>,
+		    <0x2e00 &smmu 0x18b8 0x2>,
+		    <0x2e08 &smmu 0x18ba 0x2>,
+		    <0x2f00 &smmu 0x18bc 0x2>,
+		    <0x2f08 &smmu 0x18be 0x2>,
+		    <0x3000 &smmu 0x18c0 0x2>,
+		    <0x3008 &smmu 0x18c2 0x2>,
+		    <0x3100 &smmu 0x18c4 0x2>,
+		    <0x3108 &smmu 0x18c6 0x2>,
+		    <0x3200 &smmu 0x18c8 0x2>,
+		    <0x3208 &smmu 0x18ca 0x2>,
+		    <0x3300 &smmu 0x18cc 0x2>,
+		    <0x3308 &smmu 0x18ce 0x2>,
+		    <0x3400 &smmu 0x18d0 0x2>,
+		    <0x3408 &smmu 0x18d2 0x2>,
+		    <0x3500 &smmu 0x18d4 0x2>,
+		    <0x3508 &smmu 0x18d6 0x2>,
+		    <0x3600 &smmu 0x18d8 0x2>,
+		    <0x3608 &smmu 0x18da 0x2>,
+		    <0x3700 &smmu 0x18dc 0x2>,
+		    <0x3708 &smmu 0x18de 0x2>,
+		    <0x3800 &smmu 0x18e0 0x2>,
+		    <0x3808 &smmu 0x18e2 0x2>,
+		    <0x3900 &smmu 0x18e4 0x2>,
+		    <0x3908 &smmu 0x18e6 0x2>,
+		    <0x3a00 &smmu 0x18e8 0x2>,
+		    <0x3a08 &smmu 0x18ea 0x2>,
+		    <0x3b00 &smmu 0x18ec 0x2>,
+		    <0x3b08 &smmu 0x18ee 0x2>,
+		    <0x3c00 &smmu 0x18f0 0x2>,
+		    <0x3c08 &smmu 0x18f2 0x2>,
+		    <0x3d00 &smmu 0x18f4 0x2>,
+		    <0x3d08 &smmu 0x18f6 0x2>,
+		    <0x3e00 &smmu 0x18f8 0x2>,
+		    <0x3e08 &smmu 0x18fa 0x2>,
+		    <0x3f00 &smmu 0x18fc 0x2>,
+		    <0x3f08 &smmu 0x18fe 0x2>,
+		    <0x4000 &smmu 0x1900 0x2>,
+		    <0x4008 &smmu 0x1902 0x2>,
+		    <0x4100 &smmu 0x1904 0x2>,
+		    <0x4108 &smmu 0x1906 0x2>,
+		    <0x4200 &smmu 0x1908 0x2>,
+		    <0x4208 &smmu 0x190a 0x2>,
+		    <0x4300 &smmu 0x190c 0x2>,
+		    <0x4308 &smmu 0x190e 0x2>,
+		    <0x4400 &smmu 0x1910 0x2>,
+		    <0x4408 &smmu 0x1912 0x2>,
+		    <0x4500 &smmu 0x1914 0x2>,
+		    <0x4508 &smmu 0x1916 0x2>,
+		    <0x4600 &smmu 0x1918 0x2>,
+		    <0x4608 &smmu 0x191a 0x2>,
+		    <0x4700 &smmu 0x191c 0x2>,
+		    <0x4708 &smmu 0x191e 0x2>,
+		    <0x4800 &smmu 0x1920 0x2>,
+		    <0x4808 &smmu 0x1922 0x2>,
+		    <0x4900 &smmu 0x1924 0x2>,
+		    <0x4908 &smmu 0x1926 0x2>,
+		    <0x4a00 &smmu 0x1928 0x2>,
+		    <0x4a08 &smmu 0x192a 0x2>,
+		    <0x4b00 &smmu 0x192c 0x2>,
+		    <0x4b08 &smmu 0x192e 0x2>,
+		    <0x4c00 &smmu 0x1930 0x2>,
+		    <0x4c08 &smmu 0x1932 0x2>,
+		    <0x4d00 &smmu 0x1934 0x2>,
+		    <0x4d08 &smmu 0x1936 0x2>,
+		    <0x4e00 &smmu 0x1938 0x2>,
+		    <0x4e08 &smmu 0x193a 0x2>,
+		    <0x4f00 &smmu 0x193c 0x2>,
+		    <0x4f08 &smmu 0x193e 0x2>,
+		    <0x5000 &smmu 0x1940 0x2>,
+		    <0x5008 &smmu 0x1942 0x2>,
+		    <0x5100 &smmu 0x1944 0x2>,
+		    <0x5108 &smmu 0x1946 0x2>,
+		    <0x5200 &smmu 0x1948 0x2>,
+		    <0x5208 &smmu 0x194a 0x2>,
+		    <0x5300 &smmu 0x194c 0x2>,
+		    <0x5308 &smmu 0x194e 0x2>,
+		    <0x5400 &smmu 0x1950 0x2>,
+		    <0x5408 &smmu 0x1952 0x2>,
+		    <0x5500 &smmu 0x1954 0x2>,
+		    <0x5508 &smmu 0x1956 0x2>,
+		    <0x5600 &smmu 0x1958 0x2>,
+		    <0x5608 &smmu 0x195a 0x2>,
+		    <0x5700 &smmu 0x195c 0x2>,
+		    <0x5708 &smmu 0x195e 0x2>,
+		    <0x5800 &smmu 0x1960 0x2>,
+		    <0x5808 &smmu 0x1962 0x2>,
+		    <0x5900 &smmu 0x1964 0x2>,
+		    <0x5908 &smmu 0x1966 0x2>,
+		    <0x5a00 &smmu 0x1968 0x2>,
+		    <0x5a08 &smmu 0x196a 0x2>,
+		    <0x5b00 &smmu 0x196c 0x2>,
+		    <0x5b08 &smmu 0x196e 0x2>,
+		    <0x5c00 &smmu 0x1970 0x2>,
+		    <0x5c08 &smmu 0x1972 0x2>,
+		    <0x5d00 &smmu 0x1974 0x2>,
+		    <0x5d08 &smmu 0x1976 0x2>,
+		    <0x5e00 &smmu 0x1978 0x2>,
+		    <0x5e08 &smmu 0x197a 0x2>,
+		    <0x5f00 &smmu 0x197c 0x2>,
+		    <0x5f08 &smmu 0x197e 0x2>,
+		    <0x6000 &smmu 0x1980 0x2>,
+		    <0x6008 &smmu 0x1982 0x2>,
+		    <0x6100 &smmu 0x1984 0x2>,
+		    <0x6108 &smmu 0x1986 0x2>,
+		    <0x6200 &smmu 0x1988 0x2>,
+		    <0x6208 &smmu 0x198a 0x2>,
+		    <0x6300 &smmu 0x198c 0x2>,
+		    <0x6308 &smmu 0x198e 0x2>,
+		    <0x6400 &smmu 0x1990 0x2>,
+		    <0x6408 &smmu 0x1992 0x2>,
+		    <0x6500 &smmu 0x1994 0x2>,
+		    <0x6508 &smmu 0x1996 0x2>,
+		    <0x6600 &smmu 0x1998 0x2>,
+		    <0x6608 &smmu 0x199a 0x2>,
+		    <0x6700 &smmu 0x199c 0x2>,
+		    <0x6708 &smmu 0x199e 0x2>,
+		    <0x6800 &smmu 0x19a0 0x2>,
+		    <0x6808 &smmu 0x19a2 0x2>,
+		    <0x6900 &smmu 0x19a4 0x2>,
+		    <0x6908 &smmu 0x19a6 0x2>,
+		    <0x6a00 &smmu 0x19a8 0x2>,
+		    <0x6a08 &smmu 0x19aa 0x2>,
+		    <0x6b00 &smmu 0x19ac 0x2>,
+		    <0x6b08 &smmu 0x19ae 0x2>,
+		    <0x6c00 &smmu 0x19b0 0x2>,
+		    <0x6c08 &smmu 0x19b2 0x2>,
+		    <0x6d00 &smmu 0x19b4 0x2>,
+		    <0x6d08 &smmu 0x19b6 0x2>,
+		    <0x6e00 &smmu 0x19b8 0x2>,
+		    <0x6e08 &smmu 0x19ba 0x2>,
+		    <0x6f00 &smmu 0x19bc 0x2>,
+		    <0x6f08 &smmu 0x19be 0x2>,
+		    <0x7000 &smmu 0x19c0 0x2>,
+		    <0x7008 &smmu 0x19c2 0x2>,
+		    <0x7100 &smmu 0x19c4 0x2>,
+		    <0x7108 &smmu 0x19c6 0x2>,
+		    <0x7200 &smmu 0x19c8 0x2>,
+		    <0x7208 &smmu 0x19ca 0x2>,
+		    <0x7300 &smmu 0x19cc 0x2>,
+		    <0x7308 &smmu 0x19ce 0x2>,
+		    <0x7400 &smmu 0x19d0 0x2>,
+		    <0x7408 &smmu 0x19d2 0x2>,
+		    <0x7500 &smmu 0x19d4 0x2>,
+		    <0x7508 &smmu 0x19d6 0x2>,
+		    <0x7600 &smmu 0x19d8 0x2>,
+		    <0x7608 &smmu 0x19da 0x2>,
+		    <0x7700 &smmu 0x19dc 0x2>,
+		    <0x7708 &smmu 0x19de 0x2>,
+		    <0x7800 &smmu 0x19e0 0x2>,
+		    <0x7808 &smmu 0x19e2 0x2>,
+		    <0x7900 &smmu 0x19e4 0x2>,
+		    <0x7908 &smmu 0x19e6 0x2>,
+		    <0x7a00 &smmu 0x19e8 0x2>,
+		    <0x7a08 &smmu 0x19ea 0x2>,
+		    <0x7b00 &smmu 0x19ec 0x2>,
+		    <0x7b08 &smmu 0x19ee 0x2>,
+		    <0x7c00 &smmu 0x19f0 0x2>,
+		    <0x7c08 &smmu 0x19f2 0x2>,
+		    <0x7d00 &smmu 0x19f4 0x2>,
+		    <0x7d08 &smmu 0x19f6 0x2>,
+		    <0x7e00 &smmu 0x19f8 0x2>,
+		    <0x7e08 &smmu 0x19fa 0x2>,
+		    <0x7f00 &smmu 0x19fc 0x2>,
+		    <0x7f08 &smmu 0x19fe 0x2>,
+		    <0x8000 &smmu 0x1a00 0x2>,
+		    <0x8008 &smmu 0x1a02 0x2>,
+		    <0x8100 &smmu 0x1a04 0x2>,
+		    <0x8108 &smmu 0x1a06 0x2>,
+		    <0x8200 &smmu 0x1a08 0x2>,
+		    <0x8208 &smmu 0x1a0a 0x2>,
+		    <0x8300 &smmu 0x1a0c 0x2>,
+		    <0x8308 &smmu 0x1a0e 0x2>,
+		    <0x8400 &smmu 0x1a10 0x2>,
+		    <0x8408 &smmu 0x1a12 0x2>,
+		    <0x8500 &smmu 0x1a14 0x2>,
+		    <0x8508 &smmu 0x1a16 0x2>,
+		    <0x8600 &smmu 0x1a18 0x2>,
+		    <0x8608 &smmu 0x1a1a 0x2>,
+		    <0x8700 &smmu 0x1a1c 0x2>,
+		    <0x8708 &smmu 0x1a1e 0x2>,
+		    <0x8800 &smmu 0x1a20 0x2>,
+		    <0x8808 &smmu 0x1a22 0x2>,
+		    <0x8900 &smmu 0x1a24 0x2>,
+		    <0x8908 &smmu 0x1a26 0x2>,
+		    <0x8a00 &smmu 0x1a28 0x2>,
+		    <0x8a08 &smmu 0x1a2a 0x2>,
+		    <0x8b00 &smmu 0x1a2c 0x2>,
+		    <0x8b08 &smmu 0x1a2e 0x2>,
+		    <0x8c00 &smmu 0x1a30 0x2>,
+		    <0x8c08 &smmu 0x1a32 0x2>,
+		    <0x8d00 &smmu 0x1a34 0x2>,
+		    <0x8d08 &smmu 0x1a36 0x2>,
+		    <0x8e00 &smmu 0x1a38 0x2>,
+		    <0x8e08 &smmu 0x1a3a 0x2>,
+		    <0x8f00 &smmu 0x1a3c 0x2>,
+		    <0x8f08 &smmu 0x1a3e 0x2>,
+		    <0x9000 &smmu 0x1a40 0x2>,
+		    <0x9008 &smmu 0x1a42 0x2>,
+		    <0x9100 &smmu 0x1a44 0x2>,
+		    <0x9108 &smmu 0x1a46 0x2>,
+		    <0x9200 &smmu 0x1a48 0x2>,
+		    <0x9208 &smmu 0x1a4a 0x2>,
+		    <0x9300 &smmu 0x1a4c 0x2>,
+		    <0x9308 &smmu 0x1a4e 0x2>,
+		    <0x9400 &smmu 0x1a50 0x2>,
+		    <0x9408 &smmu 0x1a52 0x2>,
+		    <0x9500 &smmu 0x1a54 0x2>,
+		    <0x9508 &smmu 0x1a56 0x2>,
+		    <0x9600 &smmu 0x1a58 0x2>,
+		    <0x9608 &smmu 0x1a5a 0x2>,
+		    <0x9700 &smmu 0x1a5c 0x2>,
+		    <0x9708 &smmu 0x1a5e 0x2>,
+		    <0x9800 &smmu 0x1a60 0x2>,
+		    <0x9808 &smmu 0x1a62 0x2>,
+		    <0x9900 &smmu 0x1a64 0x2>,
+		    <0x9908 &smmu 0x1a66 0x2>,
+		    <0x9a00 &smmu 0x1a68 0x2>,
+		    <0x9a08 &smmu 0x1a6a 0x2>,
+		    <0x9b00 &smmu 0x1a6c 0x2>,
+		    <0x9b08 &smmu 0x1a6e 0x2>,
+		    <0x9c00 &smmu 0x1a70 0x2>,
+		    <0x9c08 &smmu 0x1a72 0x2>,
+		    <0x9d00 &smmu 0x1a74 0x2>,
+		    <0x9d08 &smmu 0x1a76 0x2>,
+		    <0x9e00 &smmu 0x1a78 0x2>,
+		    <0x9e08 &smmu 0x1a7a 0x2>,
+		    <0x9f00 &smmu 0x1a7c 0x2>,
+		    <0x9f08 &smmu 0x1a7e 0x2>,
+		    <0xa000 &smmu 0x1a80 0x2>,
+		    <0xa008 &smmu 0x1a82 0x2>,
+		    <0xa100 &smmu 0x1a84 0x2>,
+		    <0xa108 &smmu 0x1a86 0x2>,
+		    <0xa200 &smmu 0x1a88 0x2>,
+		    <0xa208 &smmu 0x1a8a 0x2>,
+		    <0xa300 &smmu 0x1a8c 0x2>,
+		    <0xa308 &smmu 0x1a8e 0x2>,
+		    <0xa400 &smmu 0x1a90 0x2>,
+		    <0xa408 &smmu 0x1a92 0x2>,
+		    <0xa500 &smmu 0x1a94 0x2>,
+		    <0xa508 &smmu 0x1a96 0x2>,
+		    <0xa600 &smmu 0x1a98 0x2>,
+		    <0xa608 &smmu 0x1a9a 0x2>,
+		    <0xa700 &smmu 0x1a9c 0x2>,
+		    <0xa708 &smmu 0x1a9e 0x2>,
+		    <0xa800 &smmu 0x1aa0 0x2>,
+		    <0xa808 &smmu 0x1aa2 0x2>,
+		    <0xa900 &smmu 0x1aa4 0x2>,
+		    <0xa908 &smmu 0x1aa6 0x2>,
+		    <0xaa00 &smmu 0x1aa8 0x2>,
+		    <0xaa08 &smmu 0x1aaa 0x2>,
+		    <0xab00 &smmu 0x1aac 0x2>,
+		    <0xab08 &smmu 0x1aae 0x2>,
+		    <0xac00 &smmu 0x1ab0 0x2>,
+		    <0xac08 &smmu 0x1ab2 0x2>,
+		    <0xad00 &smmu 0x1ab4 0x2>,
+		    <0xad08 &smmu 0x1ab6 0x2>,
+		    <0xae00 &smmu 0x1ab8 0x2>,
+		    <0xae08 &smmu 0x1aba 0x2>,
+		    <0xaf00 &smmu 0x1abc 0x2>,
+		    <0xaf08 &smmu 0x1abe 0x2>,
+		    <0xb000 &smmu 0x1ac0 0x2>,
+		    <0xb008 &smmu 0x1ac2 0x2>,
+		    <0xb100 &smmu 0x1ac4 0x2>,
+		    <0xb108 &smmu 0x1ac6 0x2>,
+		    <0xb200 &smmu 0x1ac8 0x2>,
+		    <0xb208 &smmu 0x1aca 0x2>,
+		    <0xb300 &smmu 0x1acc 0x2>,
+		    <0xb308 &smmu 0x1ace 0x2>,
+		    <0xb400 &smmu 0x1ad0 0x2>,
+		    <0xb408 &smmu 0x1ad2 0x2>,
+		    <0xb500 &smmu 0x1ad4 0x2>,
+		    <0xb508 &smmu 0x1ad6 0x2>,
+		    <0xb600 &smmu 0x1ad8 0x2>,
+		    <0xb608 &smmu 0x1ada 0x2>,
+		    <0xb700 &smmu 0x1adc 0x2>,
+		    <0xb708 &smmu 0x1ade 0x2>,
+		    <0xb800 &smmu 0x1ae0 0x2>,
+		    <0xb808 &smmu 0x1ae2 0x2>,
+		    <0xb900 &smmu 0x1ae4 0x2>,
+		    <0xb908 &smmu 0x1ae6 0x2>,
+		    <0xba00 &smmu 0x1ae8 0x2>,
+		    <0xba08 &smmu 0x1aea 0x2>,
+		    <0xbb00 &smmu 0x1aec 0x2>,
+		    <0xbb08 &smmu 0x1aee 0x2>,
+		    <0xbc00 &smmu 0x1af0 0x2>,
+		    <0xbc08 &smmu 0x1af2 0x2>,
+		    <0xbd00 &smmu 0x1af4 0x2>,
+		    <0xbd08 &smmu 0x1af6 0x2>,
+		    <0xbe00 &smmu 0x1af8 0x2>,
+		    <0xbe08 &smmu 0x1afa 0x2>,
+		    <0xbf00 &smmu 0x1afc 0x2>,
+		    <0xbf08 &smmu 0x1afe 0x2>,
+		    <0xc000 &smmu 0x1b00 0x2>,
+		    <0xc008 &smmu 0x1b02 0x2>,
+		    <0xc100 &smmu 0x1b04 0x2>,
+		    <0xc108 &smmu 0x1b06 0x2>,
+		    <0xc200 &smmu 0x1b08 0x2>,
+		    <0xc208 &smmu 0x1b0a 0x2>,
+		    <0xc300 &smmu 0x1b0c 0x2>,
+		    <0xc308 &smmu 0x1b0e 0x2>,
+		    <0xc400 &smmu 0x1b10 0x2>,
+		    <0xc408 &smmu 0x1b12 0x2>,
+		    <0xc500 &smmu 0x1b14 0x2>,
+		    <0xc508 &smmu 0x1b16 0x2>,
+		    <0xc600 &smmu 0x1b18 0x2>,
+		    <0xc608 &smmu 0x1b1a 0x2>,
+		    <0xc700 &smmu 0x1b1c 0x2>,
+		    <0xc708 &smmu 0x1b1e 0x2>,
+		    <0xc800 &smmu 0x1b20 0x2>,
+		    <0xc808 &smmu 0x1b22 0x2>,
+		    <0xc900 &smmu 0x1b24 0x2>,
+		    <0xc908 &smmu 0x1b26 0x2>,
+		    <0xca00 &smmu 0x1b28 0x2>,
+		    <0xca08 &smmu 0x1b2a 0x2>,
+		    <0xcb00 &smmu 0x1b2c 0x2>,
+		    <0xcb08 &smmu 0x1b2e 0x2>,
+		    <0xcc00 &smmu 0x1b30 0x2>,
+		    <0xcc08 &smmu 0x1b32 0x2>,
+		    <0xcd00 &smmu 0x1b34 0x2>,
+		    <0xcd08 &smmu 0x1b36 0x2>,
+		    <0xce00 &smmu 0x1b38 0x2>,
+		    <0xce08 &smmu 0x1b3a 0x2>,
+		    <0xcf00 &smmu 0x1b3c 0x2>,
+		    <0xcf08 &smmu 0x1b3e 0x2>,
+		    <0xd000 &smmu 0x1b40 0x2>,
+		    <0xd008 &smmu 0x1b42 0x2>,
+		    <0xd100 &smmu 0x1b44 0x2>,
+		    <0xd108 &smmu 0x1b46 0x2>,
+		    <0xd200 &smmu 0x1b48 0x2>,
+		    <0xd208 &smmu 0x1b4a 0x2>,
+		    <0xd300 &smmu 0x1b4c 0x2>,
+		    <0xd308 &smmu 0x1b4e 0x2>,
+		    <0xd400 &smmu 0x1b50 0x2>,
+		    <0xd408 &smmu 0x1b52 0x2>,
+		    <0xd500 &smmu 0x1b54 0x2>,
+		    <0xd508 &smmu 0x1b56 0x2>,
+		    <0xd600 &smmu 0x1b58 0x2>,
+		    <0xd608 &smmu 0x1b5a 0x2>,
+		    <0xd700 &smmu 0x1b5c 0x2>,
+		    <0xd708 &smmu 0x1b5e 0x2>,
+		    <0xd800 &smmu 0x1b60 0x2>,
+		    <0xd808 &smmu 0x1b62 0x2>,
+		    <0xd900 &smmu 0x1b64 0x2>,
+		    <0xd908 &smmu 0x1b66 0x2>,
+		    <0xda00 &smmu 0x1b68 0x2>,
+		    <0xda08 &smmu 0x1b6a 0x2>,
+		    <0xdb00 &smmu 0x1b6c 0x2>,
+		    <0xdb08 &smmu 0x1b6e 0x2>,
+		    <0xdc00 &smmu 0x1b70 0x2>,
+		    <0xdc08 &smmu 0x1b72 0x2>,
+		    <0xdd00 &smmu 0x1b74 0x2>,
+		    <0xdd08 &smmu 0x1b76 0x2>,
+		    <0xde00 &smmu 0x1b78 0x2>,
+		    <0xde08 &smmu 0x1b7a 0x2>,
+		    <0xdf00 &smmu 0x1b7c 0x2>,
+		    <0xdf08 &smmu 0x1b7e 0x2>,
+		    <0xe000 &smmu 0x1b80 0x2>,
+		    <0xe008 &smmu 0x1b82 0x2>,
+		    <0xe100 &smmu 0x1b84 0x2>,
+		    <0xe108 &smmu 0x1b86 0x2>,
+		    <0xe200 &smmu 0x1b88 0x2>,
+		    <0xe208 &smmu 0x1b8a 0x2>,
+		    <0xe300 &smmu 0x1b8c 0x2>,
+		    <0xe308 &smmu 0x1b8e 0x2>,
+		    <0xe400 &smmu 0x1b90 0x2>,
+		    <0xe408 &smmu 0x1b92 0x2>,
+		    <0xe500 &smmu 0x1b94 0x2>,
+		    <0xe508 &smmu 0x1b96 0x2>,
+		    <0xe600 &smmu 0x1b98 0x2>,
+		    <0xe608 &smmu 0x1b9a 0x2>,
+		    <0xe700 &smmu 0x1b9c 0x2>,
+		    <0xe708 &smmu 0x1b9e 0x2>,
+		    <0xe800 &smmu 0x1ba0 0x2>,
+		    <0xe808 &smmu 0x1ba2 0x2>,
+		    <0xe900 &smmu 0x1ba4 0x2>,
+		    <0xe908 &smmu 0x1ba6 0x2>,
+		    <0xea00 &smmu 0x1ba8 0x2>,
+		    <0xea08 &smmu 0x1baa 0x2>,
+		    <0xeb00 &smmu 0x1bac 0x2>,
+		    <0xeb08 &smmu 0x1bae 0x2>,
+		    <0xec00 &smmu 0x1bb0 0x2>,
+		    <0xec08 &smmu 0x1bb2 0x2>,
+		    <0xed00 &smmu 0x1bb4 0x2>,
+		    <0xed08 &smmu 0x1bb6 0x2>,
+		    <0xee00 &smmu 0x1bb8 0x2>,
+		    <0xee08 &smmu 0x1bba 0x2>,
+		    <0xef00 &smmu 0x1bbc 0x2>,
+		    <0xef08 &smmu 0x1bbe 0x2>,
+		    <0xf000 &smmu 0x1bc0 0x2>,
+		    <0xf008 &smmu 0x1bc2 0x2>,
+		    <0xf100 &smmu 0x1bc4 0x2>,
+		    <0xf108 &smmu 0x1bc6 0x2>,
+		    <0xf200 &smmu 0x1bc8 0x2>,
+		    <0xf208 &smmu 0x1bca 0x2>,
+		    <0xf300 &smmu 0x1bcc 0x2>,
+		    <0xf308 &smmu 0x1bce 0x2>,
+		    <0xf400 &smmu 0x1bd0 0x2>,
+		    <0xf408 &smmu 0x1bd2 0x2>,
+		    <0xf500 &smmu 0x1bd4 0x2>,
+		    <0xf508 &smmu 0x1bd6 0x2>,
+		    <0xf600 &smmu 0x1bd8 0x2>,
+		    <0xf608 &smmu 0x1bda 0x2>,
+		    <0xf700 &smmu 0x1bdc 0x2>,
+		    <0xf708 &smmu 0x1bde 0x2>,
+		    <0xf800 &smmu 0x1be0 0x2>,
+		    <0xf808 &smmu 0x1be2 0x2>,
+		    <0xf900 &smmu 0x1be4 0x2>,
+		    <0xf908 &smmu 0x1be6 0x2>,
+		    <0xfa00 &smmu 0x1be8 0x2>,
+		    <0xfa08 &smmu 0x1bea 0x2>,
+		    <0xfb00 &smmu 0x1bec 0x2>,
+		    <0xfb08 &smmu 0x1bee 0x2>,
+		    <0xfc00 &smmu 0x1bf0 0x2>,
+		    <0xfc08 &smmu 0x1bf2 0x2>,
+		    <0xfd00 &smmu 0x1bf4 0x2>,
+		    <0xfd08 &smmu 0x1bf6 0x2>,
+		    <0xfe00 &smmu 0x1bf8 0x2>,
+		    <0xfe08 &smmu 0x1bfa 0x2>,
+		    <0xff00 &smmu 0x1bfc 0x2>,
+		    <0xff08 &smmu 0x1bfe 0x2>;
+#endif
+};
+
+&pcie7 {
+	msi-map = <0x0000 &gic_its 0x1c00 0x2>,
+		  <0x0008 &gic_its 0x1c02 0x2>,
+		  <0x0100 &gic_its 0x1c04 0x2>,
+		  <0x0108 &gic_its 0x1c06 0x2>,
+		  <0x0200 &gic_its 0x1c08 0x2>,
+		  <0x0208 &gic_its 0x1c0a 0x2>,
+		  <0x0300 &gic_its 0x1c0c 0x2>,
+		  <0x0308 &gic_its 0x1c0e 0x2>,
+		  <0x0400 &gic_its 0x1c10 0x2>,
+		  <0x0408 &gic_its 0x1c12 0x2>,
+		  <0x0500 &gic_its 0x1c14 0x2>,
+		  <0x0508 &gic_its 0x1c16 0x2>,
+		  <0x0600 &gic_its 0x1c18 0x2>,
+		  <0x0608 &gic_its 0x1c1a 0x2>,
+		  <0x0700 &gic_its 0x1c1c 0x2>,
+		  <0x0708 &gic_its 0x1c1e 0x2>,
+		  <0x0800 &gic_its 0x1c20 0x2>,
+		  <0x0808 &gic_its 0x1c22 0x2>,
+		  <0x0900 &gic_its 0x1c24 0x2>,
+		  <0x0908 &gic_its 0x1c26 0x2>,
+		  <0x0a00 &gic_its 0x1c28 0x2>,
+		  <0x0a08 &gic_its 0x1c2a 0x2>,
+		  <0x0b00 &gic_its 0x1c2c 0x2>,
+		  <0x0b08 &gic_its 0x1c2e 0x2>,
+		  <0x0c00 &gic_its 0x1c30 0x2>,
+		  <0x0c08 &gic_its 0x1c32 0x2>,
+		  <0x0d00 &gic_its 0x1c34 0x2>,
+		  <0x0d08 &gic_its 0x1c36 0x2>,
+		  <0x0e00 &gic_its 0x1c38 0x2>,
+		  <0x0e08 &gic_its 0x1c3a 0x2>,
+		  <0x0f00 &gic_its 0x1c3c 0x2>,
+		  <0x0f08 &gic_its 0x1c3e 0x2>,
+		  <0x1000 &gic_its 0x1c40 0x2>,
+		  <0x1008 &gic_its 0x1c42 0x2>,
+		  <0x1100 &gic_its 0x1c44 0x2>,
+		  <0x1108 &gic_its 0x1c46 0x2>,
+		  <0x1200 &gic_its 0x1c48 0x2>,
+		  <0x1208 &gic_its 0x1c4a 0x2>,
+		  <0x1300 &gic_its 0x1c4c 0x2>,
+		  <0x1308 &gic_its 0x1c4e 0x2>,
+		  <0x1400 &gic_its 0x1c50 0x2>,
+		  <0x1408 &gic_its 0x1c52 0x2>,
+		  <0x1500 &gic_its 0x1c54 0x2>,
+		  <0x1508 &gic_its 0x1c56 0x2>,
+		  <0x1600 &gic_its 0x1c58 0x2>,
+		  <0x1608 &gic_its 0x1c5a 0x2>,
+		  <0x1700 &gic_its 0x1c5c 0x2>,
+		  <0x1708 &gic_its 0x1c5e 0x2>,
+		  <0x1800 &gic_its 0x1c60 0x2>,
+		  <0x1808 &gic_its 0x1c62 0x2>,
+		  <0x1900 &gic_its 0x1c64 0x2>,
+		  <0x1908 &gic_its 0x1c66 0x2>,
+		  <0x1a00 &gic_its 0x1c68 0x2>,
+		  <0x1a08 &gic_its 0x1c6a 0x2>,
+		  <0x1b00 &gic_its 0x1c6c 0x2>,
+		  <0x1b08 &gic_its 0x1c6e 0x2>,
+		  <0x1c00 &gic_its 0x1c70 0x2>,
+		  <0x1c08 &gic_its 0x1c72 0x2>,
+		  <0x1d00 &gic_its 0x1c74 0x2>,
+		  <0x1d08 &gic_its 0x1c76 0x2>,
+		  <0x1e00 &gic_its 0x1c78 0x2>,
+		  <0x1e08 &gic_its 0x1c7a 0x2>,
+		  <0x1f00 &gic_its 0x1c7c 0x2>,
+		  <0x1f08 &gic_its 0x1c7e 0x2>,
+		  <0x2000 &gic_its 0x1c80 0x2>,
+		  <0x2008 &gic_its 0x1c82 0x2>,
+		  <0x2100 &gic_its 0x1c84 0x2>,
+		  <0x2108 &gic_its 0x1c86 0x2>,
+		  <0x2200 &gic_its 0x1c88 0x2>,
+		  <0x2208 &gic_its 0x1c8a 0x2>,
+		  <0x2300 &gic_its 0x1c8c 0x2>,
+		  <0x2308 &gic_its 0x1c8e 0x2>,
+		  <0x2400 &gic_its 0x1c90 0x2>,
+		  <0x2408 &gic_its 0x1c92 0x2>,
+		  <0x2500 &gic_its 0x1c94 0x2>,
+		  <0x2508 &gic_its 0x1c96 0x2>,
+		  <0x2600 &gic_its 0x1c98 0x2>,
+		  <0x2608 &gic_its 0x1c9a 0x2>,
+		  <0x2700 &gic_its 0x1c9c 0x2>,
+		  <0x2708 &gic_its 0x1c9e 0x2>,
+		  <0x2800 &gic_its 0x1ca0 0x2>,
+		  <0x2808 &gic_its 0x1ca2 0x2>,
+		  <0x2900 &gic_its 0x1ca4 0x2>,
+		  <0x2908 &gic_its 0x1ca6 0x2>,
+		  <0x2a00 &gic_its 0x1ca8 0x2>,
+		  <0x2a08 &gic_its 0x1caa 0x2>,
+		  <0x2b00 &gic_its 0x1cac 0x2>,
+		  <0x2b08 &gic_its 0x1cae 0x2>,
+		  <0x2c00 &gic_its 0x1cb0 0x2>,
+		  <0x2c08 &gic_its 0x1cb2 0x2>,
+		  <0x2d00 &gic_its 0x1cb4 0x2>,
+		  <0x2d08 &gic_its 0x1cb6 0x2>,
+		  <0x2e00 &gic_its 0x1cb8 0x2>,
+		  <0x2e08 &gic_its 0x1cba 0x2>,
+		  <0x2f00 &gic_its 0x1cbc 0x2>,
+		  <0x2f08 &gic_its 0x1cbe 0x2>,
+		  <0x3000 &gic_its 0x1cc0 0x2>,
+		  <0x3008 &gic_its 0x1cc2 0x2>,
+		  <0x3100 &gic_its 0x1cc4 0x2>,
+		  <0x3108 &gic_its 0x1cc6 0x2>,
+		  <0x3200 &gic_its 0x1cc8 0x2>,
+		  <0x3208 &gic_its 0x1cca 0x2>,
+		  <0x3300 &gic_its 0x1ccc 0x2>,
+		  <0x3308 &gic_its 0x1cce 0x2>,
+		  <0x3400 &gic_its 0x1cd0 0x2>,
+		  <0x3408 &gic_its 0x1cd2 0x2>,
+		  <0x3500 &gic_its 0x1cd4 0x2>,
+		  <0x3508 &gic_its 0x1cd6 0x2>,
+		  <0x3600 &gic_its 0x1cd8 0x2>,
+		  <0x3608 &gic_its 0x1cda 0x2>,
+		  <0x3700 &gic_its 0x1cdc 0x2>,
+		  <0x3708 &gic_its 0x1cde 0x2>,
+		  <0x3800 &gic_its 0x1ce0 0x2>,
+		  <0x3808 &gic_its 0x1ce2 0x2>,
+		  <0x3900 &gic_its 0x1ce4 0x2>,
+		  <0x3908 &gic_its 0x1ce6 0x2>,
+		  <0x3a00 &gic_its 0x1ce8 0x2>,
+		  <0x3a08 &gic_its 0x1cea 0x2>,
+		  <0x3b00 &gic_its 0x1cec 0x2>,
+		  <0x3b08 &gic_its 0x1cee 0x2>,
+		  <0x3c00 &gic_its 0x1cf0 0x2>,
+		  <0x3c08 &gic_its 0x1cf2 0x2>,
+		  <0x3d00 &gic_its 0x1cf4 0x2>,
+		  <0x3d08 &gic_its 0x1cf6 0x2>,
+		  <0x3e00 &gic_its 0x1cf8 0x2>,
+		  <0x3e08 &gic_its 0x1cfa 0x2>,
+		  <0x3f00 &gic_its 0x1cfc 0x2>,
+		  <0x3f08 &gic_its 0x1cfe 0x2>,
+		  <0x4000 &gic_its 0x1d00 0x2>,
+		  <0x4008 &gic_its 0x1d02 0x2>,
+		  <0x4100 &gic_its 0x1d04 0x2>,
+		  <0x4108 &gic_its 0x1d06 0x2>,
+		  <0x4200 &gic_its 0x1d08 0x2>,
+		  <0x4208 &gic_its 0x1d0a 0x2>,
+		  <0x4300 &gic_its 0x1d0c 0x2>,
+		  <0x4308 &gic_its 0x1d0e 0x2>,
+		  <0x4400 &gic_its 0x1d10 0x2>,
+		  <0x4408 &gic_its 0x1d12 0x2>,
+		  <0x4500 &gic_its 0x1d14 0x2>,
+		  <0x4508 &gic_its 0x1d16 0x2>,
+		  <0x4600 &gic_its 0x1d18 0x2>,
+		  <0x4608 &gic_its 0x1d1a 0x2>,
+		  <0x4700 &gic_its 0x1d1c 0x2>,
+		  <0x4708 &gic_its 0x1d1e 0x2>,
+		  <0x4800 &gic_its 0x1d20 0x2>,
+		  <0x4808 &gic_its 0x1d22 0x2>,
+		  <0x4900 &gic_its 0x1d24 0x2>,
+		  <0x4908 &gic_its 0x1d26 0x2>,
+		  <0x4a00 &gic_its 0x1d28 0x2>,
+		  <0x4a08 &gic_its 0x1d2a 0x2>,
+		  <0x4b00 &gic_its 0x1d2c 0x2>,
+		  <0x4b08 &gic_its 0x1d2e 0x2>,
+		  <0x4c00 &gic_its 0x1d30 0x2>,
+		  <0x4c08 &gic_its 0x1d32 0x2>,
+		  <0x4d00 &gic_its 0x1d34 0x2>,
+		  <0x4d08 &gic_its 0x1d36 0x2>,
+		  <0x4e00 &gic_its 0x1d38 0x2>,
+		  <0x4e08 &gic_its 0x1d3a 0x2>,
+		  <0x4f00 &gic_its 0x1d3c 0x2>,
+		  <0x4f08 &gic_its 0x1d3e 0x2>,
+		  <0x5000 &gic_its 0x1d40 0x2>,
+		  <0x5008 &gic_its 0x1d42 0x2>,
+		  <0x5100 &gic_its 0x1d44 0x2>,
+		  <0x5108 &gic_its 0x1d46 0x2>,
+		  <0x5200 &gic_its 0x1d48 0x2>,
+		  <0x5208 &gic_its 0x1d4a 0x2>,
+		  <0x5300 &gic_its 0x1d4c 0x2>,
+		  <0x5308 &gic_its 0x1d4e 0x2>,
+		  <0x5400 &gic_its 0x1d50 0x2>,
+		  <0x5408 &gic_its 0x1d52 0x2>,
+		  <0x5500 &gic_its 0x1d54 0x2>,
+		  <0x5508 &gic_its 0x1d56 0x2>,
+		  <0x5600 &gic_its 0x1d58 0x2>,
+		  <0x5608 &gic_its 0x1d5a 0x2>,
+		  <0x5700 &gic_its 0x1d5c 0x2>,
+		  <0x5708 &gic_its 0x1d5e 0x2>,
+		  <0x5800 &gic_its 0x1d60 0x2>,
+		  <0x5808 &gic_its 0x1d62 0x2>,
+		  <0x5900 &gic_its 0x1d64 0x2>,
+		  <0x5908 &gic_its 0x1d66 0x2>,
+		  <0x5a00 &gic_its 0x1d68 0x2>,
+		  <0x5a08 &gic_its 0x1d6a 0x2>,
+		  <0x5b00 &gic_its 0x1d6c 0x2>,
+		  <0x5b08 &gic_its 0x1d6e 0x2>,
+		  <0x5c00 &gic_its 0x1d70 0x2>,
+		  <0x5c08 &gic_its 0x1d72 0x2>,
+		  <0x5d00 &gic_its 0x1d74 0x2>,
+		  <0x5d08 &gic_its 0x1d76 0x2>,
+		  <0x5e00 &gic_its 0x1d78 0x2>,
+		  <0x5e08 &gic_its 0x1d7a 0x2>,
+		  <0x5f00 &gic_its 0x1d7c 0x2>,
+		  <0x5f08 &gic_its 0x1d7e 0x2>,
+		  <0x6000 &gic_its 0x1d80 0x2>,
+		  <0x6008 &gic_its 0x1d82 0x2>,
+		  <0x6100 &gic_its 0x1d84 0x2>,
+		  <0x6108 &gic_its 0x1d86 0x2>,
+		  <0x6200 &gic_its 0x1d88 0x2>,
+		  <0x6208 &gic_its 0x1d8a 0x2>,
+		  <0x6300 &gic_its 0x1d8c 0x2>,
+		  <0x6308 &gic_its 0x1d8e 0x2>,
+		  <0x6400 &gic_its 0x1d90 0x2>,
+		  <0x6408 &gic_its 0x1d92 0x2>,
+		  <0x6500 &gic_its 0x1d94 0x2>,
+		  <0x6508 &gic_its 0x1d96 0x2>,
+		  <0x6600 &gic_its 0x1d98 0x2>,
+		  <0x6608 &gic_its 0x1d9a 0x2>,
+		  <0x6700 &gic_its 0x1d9c 0x2>,
+		  <0x6708 &gic_its 0x1d9e 0x2>,
+		  <0x6800 &gic_its 0x1da0 0x2>,
+		  <0x6808 &gic_its 0x1da2 0x2>,
+		  <0x6900 &gic_its 0x1da4 0x2>,
+		  <0x6908 &gic_its 0x1da6 0x2>,
+		  <0x6a00 &gic_its 0x1da8 0x2>,
+		  <0x6a08 &gic_its 0x1daa 0x2>,
+		  <0x6b00 &gic_its 0x1dac 0x2>,
+		  <0x6b08 &gic_its 0x1dae 0x2>,
+		  <0x6c00 &gic_its 0x1db0 0x2>,
+		  <0x6c08 &gic_its 0x1db2 0x2>,
+		  <0x6d00 &gic_its 0x1db4 0x2>,
+		  <0x6d08 &gic_its 0x1db6 0x2>,
+		  <0x6e00 &gic_its 0x1db8 0x2>,
+		  <0x6e08 &gic_its 0x1dba 0x2>,
+		  <0x6f00 &gic_its 0x1dbc 0x2>,
+		  <0x6f08 &gic_its 0x1dbe 0x2>,
+		  <0x7000 &gic_its 0x1dc0 0x2>,
+		  <0x7008 &gic_its 0x1dc2 0x2>,
+		  <0x7100 &gic_its 0x1dc4 0x2>,
+		  <0x7108 &gic_its 0x1dc6 0x2>,
+		  <0x7200 &gic_its 0x1dc8 0x2>,
+		  <0x7208 &gic_its 0x1dca 0x2>,
+		  <0x7300 &gic_its 0x1dcc 0x2>,
+		  <0x7308 &gic_its 0x1dce 0x2>,
+		  <0x7400 &gic_its 0x1dd0 0x2>,
+		  <0x7408 &gic_its 0x1dd2 0x2>,
+		  <0x7500 &gic_its 0x1dd4 0x2>,
+		  <0x7508 &gic_its 0x1dd6 0x2>,
+		  <0x7600 &gic_its 0x1dd8 0x2>,
+		  <0x7608 &gic_its 0x1dda 0x2>,
+		  <0x7700 &gic_its 0x1ddc 0x2>,
+		  <0x7708 &gic_its 0x1dde 0x2>,
+		  <0x7800 &gic_its 0x1de0 0x2>,
+		  <0x7808 &gic_its 0x1de2 0x2>,
+		  <0x7900 &gic_its 0x1de4 0x2>,
+		  <0x7908 &gic_its 0x1de6 0x2>,
+		  <0x7a00 &gic_its 0x1de8 0x2>,
+		  <0x7a08 &gic_its 0x1dea 0x2>,
+		  <0x7b00 &gic_its 0x1dec 0x2>,
+		  <0x7b08 &gic_its 0x1dee 0x2>,
+		  <0x7c00 &gic_its 0x1df0 0x2>,
+		  <0x7c08 &gic_its 0x1df2 0x2>,
+		  <0x7d00 &gic_its 0x1df4 0x2>,
+		  <0x7d08 &gic_its 0x1df6 0x2>,
+		  <0x7e00 &gic_its 0x1df8 0x2>,
+		  <0x7e08 &gic_its 0x1dfa 0x2>,
+		  <0x7f00 &gic_its 0x1dfc 0x2>,
+		  <0x7f08 &gic_its 0x1dfe 0x2>,
+		  <0x8000 &gic_its 0x1e00 0x2>,
+		  <0x8008 &gic_its 0x1e02 0x2>,
+		  <0x8100 &gic_its 0x1e04 0x2>,
+		  <0x8108 &gic_its 0x1e06 0x2>,
+		  <0x8200 &gic_its 0x1e08 0x2>,
+		  <0x8208 &gic_its 0x1e0a 0x2>,
+		  <0x8300 &gic_its 0x1e0c 0x2>,
+		  <0x8308 &gic_its 0x1e0e 0x2>,
+		  <0x8400 &gic_its 0x1e10 0x2>,
+		  <0x8408 &gic_its 0x1e12 0x2>,
+		  <0x8500 &gic_its 0x1e14 0x2>,
+		  <0x8508 &gic_its 0x1e16 0x2>,
+		  <0x8600 &gic_its 0x1e18 0x2>,
+		  <0x8608 &gic_its 0x1e1a 0x2>,
+		  <0x8700 &gic_its 0x1e1c 0x2>,
+		  <0x8708 &gic_its 0x1e1e 0x2>,
+		  <0x8800 &gic_its 0x1e20 0x2>,
+		  <0x8808 &gic_its 0x1e22 0x2>,
+		  <0x8900 &gic_its 0x1e24 0x2>,
+		  <0x8908 &gic_its 0x1e26 0x2>,
+		  <0x8a00 &gic_its 0x1e28 0x2>,
+		  <0x8a08 &gic_its 0x1e2a 0x2>,
+		  <0x8b00 &gic_its 0x1e2c 0x2>,
+		  <0x8b08 &gic_its 0x1e2e 0x2>,
+		  <0x8c00 &gic_its 0x1e30 0x2>,
+		  <0x8c08 &gic_its 0x1e32 0x2>,
+		  <0x8d00 &gic_its 0x1e34 0x2>,
+		  <0x8d08 &gic_its 0x1e36 0x2>,
+		  <0x8e00 &gic_its 0x1e38 0x2>,
+		  <0x8e08 &gic_its 0x1e3a 0x2>,
+		  <0x8f00 &gic_its 0x1e3c 0x2>,
+		  <0x8f08 &gic_its 0x1e3e 0x2>,
+		  <0x9000 &gic_its 0x1e40 0x2>,
+		  <0x9008 &gic_its 0x1e42 0x2>,
+		  <0x9100 &gic_its 0x1e44 0x2>,
+		  <0x9108 &gic_its 0x1e46 0x2>,
+		  <0x9200 &gic_its 0x1e48 0x2>,
+		  <0x9208 &gic_its 0x1e4a 0x2>,
+		  <0x9300 &gic_its 0x1e4c 0x2>,
+		  <0x9308 &gic_its 0x1e4e 0x2>,
+		  <0x9400 &gic_its 0x1e50 0x2>,
+		  <0x9408 &gic_its 0x1e52 0x2>,
+		  <0x9500 &gic_its 0x1e54 0x2>,
+		  <0x9508 &gic_its 0x1e56 0x2>,
+		  <0x9600 &gic_its 0x1e58 0x2>,
+		  <0x9608 &gic_its 0x1e5a 0x2>,
+		  <0x9700 &gic_its 0x1e5c 0x2>,
+		  <0x9708 &gic_its 0x1e5e 0x2>,
+		  <0x9800 &gic_its 0x1e60 0x2>,
+		  <0x9808 &gic_its 0x1e62 0x2>,
+		  <0x9900 &gic_its 0x1e64 0x2>,
+		  <0x9908 &gic_its 0x1e66 0x2>,
+		  <0x9a00 &gic_its 0x1e68 0x2>,
+		  <0x9a08 &gic_its 0x1e6a 0x2>,
+		  <0x9b00 &gic_its 0x1e6c 0x2>,
+		  <0x9b08 &gic_its 0x1e6e 0x2>,
+		  <0x9c00 &gic_its 0x1e70 0x2>,
+		  <0x9c08 &gic_its 0x1e72 0x2>,
+		  <0x9d00 &gic_its 0x1e74 0x2>,
+		  <0x9d08 &gic_its 0x1e76 0x2>,
+		  <0x9e00 &gic_its 0x1e78 0x2>,
+		  <0x9e08 &gic_its 0x1e7a 0x2>,
+		  <0x9f00 &gic_its 0x1e7c 0x2>,
+		  <0x9f08 &gic_its 0x1e7e 0x2>,
+		  <0xa000 &gic_its 0x1e80 0x2>,
+		  <0xa008 &gic_its 0x1e82 0x2>,
+		  <0xa100 &gic_its 0x1e84 0x2>,
+		  <0xa108 &gic_its 0x1e86 0x2>,
+		  <0xa200 &gic_its 0x1e88 0x2>,
+		  <0xa208 &gic_its 0x1e8a 0x2>,
+		  <0xa300 &gic_its 0x1e8c 0x2>,
+		  <0xa308 &gic_its 0x1e8e 0x2>,
+		  <0xa400 &gic_its 0x1e90 0x2>,
+		  <0xa408 &gic_its 0x1e92 0x2>,
+		  <0xa500 &gic_its 0x1e94 0x2>,
+		  <0xa508 &gic_its 0x1e96 0x2>,
+		  <0xa600 &gic_its 0x1e98 0x2>,
+		  <0xa608 &gic_its 0x1e9a 0x2>,
+		  <0xa700 &gic_its 0x1e9c 0x2>,
+		  <0xa708 &gic_its 0x1e9e 0x2>,
+		  <0xa800 &gic_its 0x1ea0 0x2>,
+		  <0xa808 &gic_its 0x1ea2 0x2>,
+		  <0xa900 &gic_its 0x1ea4 0x2>,
+		  <0xa908 &gic_its 0x1ea6 0x2>,
+		  <0xaa00 &gic_its 0x1ea8 0x2>,
+		  <0xaa08 &gic_its 0x1eaa 0x2>,
+		  <0xab00 &gic_its 0x1eac 0x2>,
+		  <0xab08 &gic_its 0x1eae 0x2>,
+		  <0xac00 &gic_its 0x1eb0 0x2>,
+		  <0xac08 &gic_its 0x1eb2 0x2>,
+		  <0xad00 &gic_its 0x1eb4 0x2>,
+		  <0xad08 &gic_its 0x1eb6 0x2>,
+		  <0xae00 &gic_its 0x1eb8 0x2>,
+		  <0xae08 &gic_its 0x1eba 0x2>,
+		  <0xaf00 &gic_its 0x1ebc 0x2>,
+		  <0xaf08 &gic_its 0x1ebe 0x2>,
+		  <0xb000 &gic_its 0x1ec0 0x2>,
+		  <0xb008 &gic_its 0x1ec2 0x2>,
+		  <0xb100 &gic_its 0x1ec4 0x2>,
+		  <0xb108 &gic_its 0x1ec6 0x2>,
+		  <0xb200 &gic_its 0x1ec8 0x2>,
+		  <0xb208 &gic_its 0x1eca 0x2>,
+		  <0xb300 &gic_its 0x1ecc 0x2>,
+		  <0xb308 &gic_its 0x1ece 0x2>,
+		  <0xb400 &gic_its 0x1ed0 0x2>,
+		  <0xb408 &gic_its 0x1ed2 0x2>,
+		  <0xb500 &gic_its 0x1ed4 0x2>,
+		  <0xb508 &gic_its 0x1ed6 0x2>,
+		  <0xb600 &gic_its 0x1ed8 0x2>,
+		  <0xb608 &gic_its 0x1eda 0x2>,
+		  <0xb700 &gic_its 0x1edc 0x2>,
+		  <0xb708 &gic_its 0x1ede 0x2>,
+		  <0xb800 &gic_its 0x1ee0 0x2>,
+		  <0xb808 &gic_its 0x1ee2 0x2>,
+		  <0xb900 &gic_its 0x1ee4 0x2>,
+		  <0xb908 &gic_its 0x1ee6 0x2>,
+		  <0xba00 &gic_its 0x1ee8 0x2>,
+		  <0xba08 &gic_its 0x1eea 0x2>,
+		  <0xbb00 &gic_its 0x1eec 0x2>,
+		  <0xbb08 &gic_its 0x1eee 0x2>,
+		  <0xbc00 &gic_its 0x1ef0 0x2>,
+		  <0xbc08 &gic_its 0x1ef2 0x2>,
+		  <0xbd00 &gic_its 0x1ef4 0x2>,
+		  <0xbd08 &gic_its 0x1ef6 0x2>,
+		  <0xbe00 &gic_its 0x1ef8 0x2>,
+		  <0xbe08 &gic_its 0x1efa 0x2>,
+		  <0xbf00 &gic_its 0x1efc 0x2>,
+		  <0xbf08 &gic_its 0x1efe 0x2>,
+		  <0xc000 &gic_its 0x1f00 0x2>,
+		  <0xc008 &gic_its 0x1f02 0x2>,
+		  <0xc100 &gic_its 0x1f04 0x2>,
+		  <0xc108 &gic_its 0x1f06 0x2>,
+		  <0xc200 &gic_its 0x1f08 0x2>,
+		  <0xc208 &gic_its 0x1f0a 0x2>,
+		  <0xc300 &gic_its 0x1f0c 0x2>,
+		  <0xc308 &gic_its 0x1f0e 0x2>,
+		  <0xc400 &gic_its 0x1f10 0x2>,
+		  <0xc408 &gic_its 0x1f12 0x2>,
+		  <0xc500 &gic_its 0x1f14 0x2>,
+		  <0xc508 &gic_its 0x1f16 0x2>,
+		  <0xc600 &gic_its 0x1f18 0x2>,
+		  <0xc608 &gic_its 0x1f1a 0x2>,
+		  <0xc700 &gic_its 0x1f1c 0x2>,
+		  <0xc708 &gic_its 0x1f1e 0x2>,
+		  <0xc800 &gic_its 0x1f20 0x2>,
+		  <0xc808 &gic_its 0x1f22 0x2>,
+		  <0xc900 &gic_its 0x1f24 0x2>,
+		  <0xc908 &gic_its 0x1f26 0x2>,
+		  <0xca00 &gic_its 0x1f28 0x2>,
+		  <0xca08 &gic_its 0x1f2a 0x2>,
+		  <0xcb00 &gic_its 0x1f2c 0x2>,
+		  <0xcb08 &gic_its 0x1f2e 0x2>,
+		  <0xcc00 &gic_its 0x1f30 0x2>,
+		  <0xcc08 &gic_its 0x1f32 0x2>,
+		  <0xcd00 &gic_its 0x1f34 0x2>,
+		  <0xcd08 &gic_its 0x1f36 0x2>,
+		  <0xce00 &gic_its 0x1f38 0x2>,
+		  <0xce08 &gic_its 0x1f3a 0x2>,
+		  <0xcf00 &gic_its 0x1f3c 0x2>,
+		  <0xcf08 &gic_its 0x1f3e 0x2>,
+		  <0xd000 &gic_its 0x1f40 0x2>,
+		  <0xd008 &gic_its 0x1f42 0x2>,
+		  <0xd100 &gic_its 0x1f44 0x2>,
+		  <0xd108 &gic_its 0x1f46 0x2>,
+		  <0xd200 &gic_its 0x1f48 0x2>,
+		  <0xd208 &gic_its 0x1f4a 0x2>,
+		  <0xd300 &gic_its 0x1f4c 0x2>,
+		  <0xd308 &gic_its 0x1f4e 0x2>,
+		  <0xd400 &gic_its 0x1f50 0x2>,
+		  <0xd408 &gic_its 0x1f52 0x2>,
+		  <0xd500 &gic_its 0x1f54 0x2>,
+		  <0xd508 &gic_its 0x1f56 0x2>,
+		  <0xd600 &gic_its 0x1f58 0x2>,
+		  <0xd608 &gic_its 0x1f5a 0x2>,
+		  <0xd700 &gic_its 0x1f5c 0x2>,
+		  <0xd708 &gic_its 0x1f5e 0x2>,
+		  <0xd800 &gic_its 0x1f60 0x2>,
+		  <0xd808 &gic_its 0x1f62 0x2>,
+		  <0xd900 &gic_its 0x1f64 0x2>,
+		  <0xd908 &gic_its 0x1f66 0x2>,
+		  <0xda00 &gic_its 0x1f68 0x2>,
+		  <0xda08 &gic_its 0x1f6a 0x2>,
+		  <0xdb00 &gic_its 0x1f6c 0x2>,
+		  <0xdb08 &gic_its 0x1f6e 0x2>,
+		  <0xdc00 &gic_its 0x1f70 0x2>,
+		  <0xdc08 &gic_its 0x1f72 0x2>,
+		  <0xdd00 &gic_its 0x1f74 0x2>,
+		  <0xdd08 &gic_its 0x1f76 0x2>,
+		  <0xde00 &gic_its 0x1f78 0x2>,
+		  <0xde08 &gic_its 0x1f7a 0x2>,
+		  <0xdf00 &gic_its 0x1f7c 0x2>,
+		  <0xdf08 &gic_its 0x1f7e 0x2>,
+		  <0xe000 &gic_its 0x1f80 0x2>,
+		  <0xe008 &gic_its 0x1f82 0x2>,
+		  <0xe100 &gic_its 0x1f84 0x2>,
+		  <0xe108 &gic_its 0x1f86 0x2>,
+		  <0xe200 &gic_its 0x1f88 0x2>,
+		  <0xe208 &gic_its 0x1f8a 0x2>,
+		  <0xe300 &gic_its 0x1f8c 0x2>,
+		  <0xe308 &gic_its 0x1f8e 0x2>,
+		  <0xe400 &gic_its 0x1f90 0x2>,
+		  <0xe408 &gic_its 0x1f92 0x2>,
+		  <0xe500 &gic_its 0x1f94 0x2>,
+		  <0xe508 &gic_its 0x1f96 0x2>,
+		  <0xe600 &gic_its 0x1f98 0x2>,
+		  <0xe608 &gic_its 0x1f9a 0x2>,
+		  <0xe700 &gic_its 0x1f9c 0x2>,
+		  <0xe708 &gic_its 0x1f9e 0x2>,
+		  <0xe800 &gic_its 0x1fa0 0x2>,
+		  <0xe808 &gic_its 0x1fa2 0x2>,
+		  <0xe900 &gic_its 0x1fa4 0x2>,
+		  <0xe908 &gic_its 0x1fa6 0x2>,
+		  <0xea00 &gic_its 0x1fa8 0x2>,
+		  <0xea08 &gic_its 0x1faa 0x2>,
+		  <0xeb00 &gic_its 0x1fac 0x2>,
+		  <0xeb08 &gic_its 0x1fae 0x2>,
+		  <0xec00 &gic_its 0x1fb0 0x2>,
+		  <0xec08 &gic_its 0x1fb2 0x2>,
+		  <0xed00 &gic_its 0x1fb4 0x2>,
+		  <0xed08 &gic_its 0x1fb6 0x2>,
+		  <0xee00 &gic_its 0x1fb8 0x2>,
+		  <0xee08 &gic_its 0x1fba 0x2>,
+		  <0xef00 &gic_its 0x1fbc 0x2>,
+		  <0xef08 &gic_its 0x1fbe 0x2>,
+		  <0xf000 &gic_its 0x1fc0 0x2>,
+		  <0xf008 &gic_its 0x1fc2 0x2>,
+		  <0xf100 &gic_its 0x1fc4 0x2>,
+		  <0xf108 &gic_its 0x1fc6 0x2>,
+		  <0xf200 &gic_its 0x1fc8 0x2>,
+		  <0xf208 &gic_its 0x1fca 0x2>,
+		  <0xf300 &gic_its 0x1fcc 0x2>,
+		  <0xf308 &gic_its 0x1fce 0x2>,
+		  <0xf400 &gic_its 0x1fd0 0x2>,
+		  <0xf408 &gic_its 0x1fd2 0x2>,
+		  <0xf500 &gic_its 0x1fd4 0x2>,
+		  <0xf508 &gic_its 0x1fd6 0x2>,
+		  <0xf600 &gic_its 0x1fd8 0x2>,
+		  <0xf608 &gic_its 0x1fda 0x2>,
+		  <0xf700 &gic_its 0x1fdc 0x2>,
+		  <0xf708 &gic_its 0x1fde 0x2>,
+		  <0xf800 &gic_its 0x1fe0 0x2>,
+		  <0xf808 &gic_its 0x1fe2 0x2>,
+		  <0xf900 &gic_its 0x1fe4 0x2>,
+		  <0xf908 &gic_its 0x1fe6 0x2>,
+		  <0xfa00 &gic_its 0x1fe8 0x2>,
+		  <0xfa08 &gic_its 0x1fea 0x2>,
+		  <0xfb00 &gic_its 0x1fec 0x2>,
+		  <0xfb08 &gic_its 0x1fee 0x2>,
+		  <0xfc00 &gic_its 0x1ff0 0x2>,
+		  <0xfc08 &gic_its 0x1ff2 0x2>,
+		  <0xfd00 &gic_its 0x1ff4 0x2>,
+		  <0xfd08 &gic_its 0x1ff6 0x2>,
+		  <0xfe00 &gic_its 0x1ff8 0x2>,
+		  <0xfe08 &gic_its 0x1ffa 0x2>,
+		  <0xff00 &gic_its 0x1ffc 0x2>,
+		  <0xff08 &gic_its 0x1ffe 0x2>;
+#if (ENABLE_PAXB_IOMMU == 1)
+	iommu-map = <0x0000 &smmu 0x1c00 0x2>,
+		    <0x0008 &smmu 0x1c02 0x2>,
+		    <0x0100 &smmu 0x1c04 0x2>,
+		    <0x0108 &smmu 0x1c06 0x2>,
+		    <0x0200 &smmu 0x1c08 0x2>,
+		    <0x0208 &smmu 0x1c0a 0x2>,
+		    <0x0300 &smmu 0x1c0c 0x2>,
+		    <0x0308 &smmu 0x1c0e 0x2>,
+		    <0x0400 &smmu 0x1c10 0x2>,
+		    <0x0408 &smmu 0x1c12 0x2>,
+		    <0x0500 &smmu 0x1c14 0x2>,
+		    <0x0508 &smmu 0x1c16 0x2>,
+		    <0x0600 &smmu 0x1c18 0x2>,
+		    <0x0608 &smmu 0x1c1a 0x2>,
+		    <0x0700 &smmu 0x1c1c 0x2>,
+		    <0x0708 &smmu 0x1c1e 0x2>,
+		    <0x0800 &smmu 0x1c20 0x2>,
+		    <0x0808 &smmu 0x1c22 0x2>,
+		    <0x0900 &smmu 0x1c24 0x2>,
+		    <0x0908 &smmu 0x1c26 0x2>,
+		    <0x0a00 &smmu 0x1c28 0x2>,
+		    <0x0a08 &smmu 0x1c2a 0x2>,
+		    <0x0b00 &smmu 0x1c2c 0x2>,
+		    <0x0b08 &smmu 0x1c2e 0x2>,
+		    <0x0c00 &smmu 0x1c30 0x2>,
+		    <0x0c08 &smmu 0x1c32 0x2>,
+		    <0x0d00 &smmu 0x1c34 0x2>,
+		    <0x0d08 &smmu 0x1c36 0x2>,
+		    <0x0e00 &smmu 0x1c38 0x2>,
+		    <0x0e08 &smmu 0x1c3a 0x2>,
+		    <0x0f00 &smmu 0x1c3c 0x2>,
+		    <0x0f08 &smmu 0x1c3e 0x2>,
+		    <0x1000 &smmu 0x1c40 0x2>,
+		    <0x1008 &smmu 0x1c42 0x2>,
+		    <0x1100 &smmu 0x1c44 0x2>,
+		    <0x1108 &smmu 0x1c46 0x2>,
+		    <0x1200 &smmu 0x1c48 0x2>,
+		    <0x1208 &smmu 0x1c4a 0x2>,
+		    <0x1300 &smmu 0x1c4c 0x2>,
+		    <0x1308 &smmu 0x1c4e 0x2>,
+		    <0x1400 &smmu 0x1c50 0x2>,
+		    <0x1408 &smmu 0x1c52 0x2>,
+		    <0x1500 &smmu 0x1c54 0x2>,
+		    <0x1508 &smmu 0x1c56 0x2>,
+		    <0x1600 &smmu 0x1c58 0x2>,
+		    <0x1608 &smmu 0x1c5a 0x2>,
+		    <0x1700 &smmu 0x1c5c 0x2>,
+		    <0x1708 &smmu 0x1c5e 0x2>,
+		    <0x1800 &smmu 0x1c60 0x2>,
+		    <0x1808 &smmu 0x1c62 0x2>,
+		    <0x1900 &smmu 0x1c64 0x2>,
+		    <0x1908 &smmu 0x1c66 0x2>,
+		    <0x1a00 &smmu 0x1c68 0x2>,
+		    <0x1a08 &smmu 0x1c6a 0x2>,
+		    <0x1b00 &smmu 0x1c6c 0x2>,
+		    <0x1b08 &smmu 0x1c6e 0x2>,
+		    <0x1c00 &smmu 0x1c70 0x2>,
+		    <0x1c08 &smmu 0x1c72 0x2>,
+		    <0x1d00 &smmu 0x1c74 0x2>,
+		    <0x1d08 &smmu 0x1c76 0x2>,
+		    <0x1e00 &smmu 0x1c78 0x2>,
+		    <0x1e08 &smmu 0x1c7a 0x2>,
+		    <0x1f00 &smmu 0x1c7c 0x2>,
+		    <0x1f08 &smmu 0x1c7e 0x2>,
+		    <0x2000 &smmu 0x1c80 0x2>,
+		    <0x2008 &smmu 0x1c82 0x2>,
+		    <0x2100 &smmu 0x1c84 0x2>,
+		    <0x2108 &smmu 0x1c86 0x2>,
+		    <0x2200 &smmu 0x1c88 0x2>,
+		    <0x2208 &smmu 0x1c8a 0x2>,
+		    <0x2300 &smmu 0x1c8c 0x2>,
+		    <0x2308 &smmu 0x1c8e 0x2>,
+		    <0x2400 &smmu 0x1c90 0x2>,
+		    <0x2408 &smmu 0x1c92 0x2>,
+		    <0x2500 &smmu 0x1c94 0x2>,
+		    <0x2508 &smmu 0x1c96 0x2>,
+		    <0x2600 &smmu 0x1c98 0x2>,
+		    <0x2608 &smmu 0x1c9a 0x2>,
+		    <0x2700 &smmu 0x1c9c 0x2>,
+		    <0x2708 &smmu 0x1c9e 0x2>,
+		    <0x2800 &smmu 0x1ca0 0x2>,
+		    <0x2808 &smmu 0x1ca2 0x2>,
+		    <0x2900 &smmu 0x1ca4 0x2>,
+		    <0x2908 &smmu 0x1ca6 0x2>,
+		    <0x2a00 &smmu 0x1ca8 0x2>,
+		    <0x2a08 &smmu 0x1caa 0x2>,
+		    <0x2b00 &smmu 0x1cac 0x2>,
+		    <0x2b08 &smmu 0x1cae 0x2>,
+		    <0x2c00 &smmu 0x1cb0 0x2>,
+		    <0x2c08 &smmu 0x1cb2 0x2>,
+		    <0x2d00 &smmu 0x1cb4 0x2>,
+		    <0x2d08 &smmu 0x1cb6 0x2>,
+		    <0x2e00 &smmu 0x1cb8 0x2>,
+		    <0x2e08 &smmu 0x1cba 0x2>,
+		    <0x2f00 &smmu 0x1cbc 0x2>,
+		    <0x2f08 &smmu 0x1cbe 0x2>,
+		    <0x3000 &smmu 0x1cc0 0x2>,
+		    <0x3008 &smmu 0x1cc2 0x2>,
+		    <0x3100 &smmu 0x1cc4 0x2>,
+		    <0x3108 &smmu 0x1cc6 0x2>,
+		    <0x3200 &smmu 0x1cc8 0x2>,
+		    <0x3208 &smmu 0x1cca 0x2>,
+		    <0x3300 &smmu 0x1ccc 0x2>,
+		    <0x3308 &smmu 0x1cce 0x2>,
+		    <0x3400 &smmu 0x1cd0 0x2>,
+		    <0x3408 &smmu 0x1cd2 0x2>,
+		    <0x3500 &smmu 0x1cd4 0x2>,
+		    <0x3508 &smmu 0x1cd6 0x2>,
+		    <0x3600 &smmu 0x1cd8 0x2>,
+		    <0x3608 &smmu 0x1cda 0x2>,
+		    <0x3700 &smmu 0x1cdc 0x2>,
+		    <0x3708 &smmu 0x1cde 0x2>,
+		    <0x3800 &smmu 0x1ce0 0x2>,
+		    <0x3808 &smmu 0x1ce2 0x2>,
+		    <0x3900 &smmu 0x1ce4 0x2>,
+		    <0x3908 &smmu 0x1ce6 0x2>,
+		    <0x3a00 &smmu 0x1ce8 0x2>,
+		    <0x3a08 &smmu 0x1cea 0x2>,
+		    <0x3b00 &smmu 0x1cec 0x2>,
+		    <0x3b08 &smmu 0x1cee 0x2>,
+		    <0x3c00 &smmu 0x1cf0 0x2>,
+		    <0x3c08 &smmu 0x1cf2 0x2>,
+		    <0x3d00 &smmu 0x1cf4 0x2>,
+		    <0x3d08 &smmu 0x1cf6 0x2>,
+		    <0x3e00 &smmu 0x1cf8 0x2>,
+		    <0x3e08 &smmu 0x1cfa 0x2>,
+		    <0x3f00 &smmu 0x1cfc 0x2>,
+		    <0x3f08 &smmu 0x1cfe 0x2>,
+		    <0x4000 &smmu 0x1d00 0x2>,
+		    <0x4008 &smmu 0x1d02 0x2>,
+		    <0x4100 &smmu 0x1d04 0x2>,
+		    <0x4108 &smmu 0x1d06 0x2>,
+		    <0x4200 &smmu 0x1d08 0x2>,
+		    <0x4208 &smmu 0x1d0a 0x2>,
+		    <0x4300 &smmu 0x1d0c 0x2>,
+		    <0x4308 &smmu 0x1d0e 0x2>,
+		    <0x4400 &smmu 0x1d10 0x2>,
+		    <0x4408 &smmu 0x1d12 0x2>,
+		    <0x4500 &smmu 0x1d14 0x2>,
+		    <0x4508 &smmu 0x1d16 0x2>,
+		    <0x4600 &smmu 0x1d18 0x2>,
+		    <0x4608 &smmu 0x1d1a 0x2>,
+		    <0x4700 &smmu 0x1d1c 0x2>,
+		    <0x4708 &smmu 0x1d1e 0x2>,
+		    <0x4800 &smmu 0x1d20 0x2>,
+		    <0x4808 &smmu 0x1d22 0x2>,
+		    <0x4900 &smmu 0x1d24 0x2>,
+		    <0x4908 &smmu 0x1d26 0x2>,
+		    <0x4a00 &smmu 0x1d28 0x2>,
+		    <0x4a08 &smmu 0x1d2a 0x2>,
+		    <0x4b00 &smmu 0x1d2c 0x2>,
+		    <0x4b08 &smmu 0x1d2e 0x2>,
+		    <0x4c00 &smmu 0x1d30 0x2>,
+		    <0x4c08 &smmu 0x1d32 0x2>,
+		    <0x4d00 &smmu 0x1d34 0x2>,
+		    <0x4d08 &smmu 0x1d36 0x2>,
+		    <0x4e00 &smmu 0x1d38 0x2>,
+		    <0x4e08 &smmu 0x1d3a 0x2>,
+		    <0x4f00 &smmu 0x1d3c 0x2>,
+		    <0x4f08 &smmu 0x1d3e 0x2>,
+		    <0x5000 &smmu 0x1d40 0x2>,
+		    <0x5008 &smmu 0x1d42 0x2>,
+		    <0x5100 &smmu 0x1d44 0x2>,
+		    <0x5108 &smmu 0x1d46 0x2>,
+		    <0x5200 &smmu 0x1d48 0x2>,
+		    <0x5208 &smmu 0x1d4a 0x2>,
+		    <0x5300 &smmu 0x1d4c 0x2>,
+		    <0x5308 &smmu 0x1d4e 0x2>,
+		    <0x5400 &smmu 0x1d50 0x2>,
+		    <0x5408 &smmu 0x1d52 0x2>,
+		    <0x5500 &smmu 0x1d54 0x2>,
+		    <0x5508 &smmu 0x1d56 0x2>,
+		    <0x5600 &smmu 0x1d58 0x2>,
+		    <0x5608 &smmu 0x1d5a 0x2>,
+		    <0x5700 &smmu 0x1d5c 0x2>,
+		    <0x5708 &smmu 0x1d5e 0x2>,
+		    <0x5800 &smmu 0x1d60 0x2>,
+		    <0x5808 &smmu 0x1d62 0x2>,
+		    <0x5900 &smmu 0x1d64 0x2>,
+		    <0x5908 &smmu 0x1d66 0x2>,
+		    <0x5a00 &smmu 0x1d68 0x2>,
+		    <0x5a08 &smmu 0x1d6a 0x2>,
+		    <0x5b00 &smmu 0x1d6c 0x2>,
+		    <0x5b08 &smmu 0x1d6e 0x2>,
+		    <0x5c00 &smmu 0x1d70 0x2>,
+		    <0x5c08 &smmu 0x1d72 0x2>,
+		    <0x5d00 &smmu 0x1d74 0x2>,
+		    <0x5d08 &smmu 0x1d76 0x2>,
+		    <0x5e00 &smmu 0x1d78 0x2>,
+		    <0x5e08 &smmu 0x1d7a 0x2>,
+		    <0x5f00 &smmu 0x1d7c 0x2>,
+		    <0x5f08 &smmu 0x1d7e 0x2>,
+		    <0x6000 &smmu 0x1d80 0x2>,
+		    <0x6008 &smmu 0x1d82 0x2>,
+		    <0x6100 &smmu 0x1d84 0x2>,
+		    <0x6108 &smmu 0x1d86 0x2>,
+		    <0x6200 &smmu 0x1d88 0x2>,
+		    <0x6208 &smmu 0x1d8a 0x2>,
+		    <0x6300 &smmu 0x1d8c 0x2>,
+		    <0x6308 &smmu 0x1d8e 0x2>,
+		    <0x6400 &smmu 0x1d90 0x2>,
+		    <0x6408 &smmu 0x1d92 0x2>,
+		    <0x6500 &smmu 0x1d94 0x2>,
+		    <0x6508 &smmu 0x1d96 0x2>,
+		    <0x6600 &smmu 0x1d98 0x2>,
+		    <0x6608 &smmu 0x1d9a 0x2>,
+		    <0x6700 &smmu 0x1d9c 0x2>,
+		    <0x6708 &smmu 0x1d9e 0x2>,
+		    <0x6800 &smmu 0x1da0 0x2>,
+		    <0x6808 &smmu 0x1da2 0x2>,
+		    <0x6900 &smmu 0x1da4 0x2>,
+		    <0x6908 &smmu 0x1da6 0x2>,
+		    <0x6a00 &smmu 0x1da8 0x2>,
+		    <0x6a08 &smmu 0x1daa 0x2>,
+		    <0x6b00 &smmu 0x1dac 0x2>,
+		    <0x6b08 &smmu 0x1dae 0x2>,
+		    <0x6c00 &smmu 0x1db0 0x2>,
+		    <0x6c08 &smmu 0x1db2 0x2>,
+		    <0x6d00 &smmu 0x1db4 0x2>,
+		    <0x6d08 &smmu 0x1db6 0x2>,
+		    <0x6e00 &smmu 0x1db8 0x2>,
+		    <0x6e08 &smmu 0x1dba 0x2>,
+		    <0x6f00 &smmu 0x1dbc 0x2>,
+		    <0x6f08 &smmu 0x1dbe 0x2>,
+		    <0x7000 &smmu 0x1dc0 0x2>,
+		    <0x7008 &smmu 0x1dc2 0x2>,
+		    <0x7100 &smmu 0x1dc4 0x2>,
+		    <0x7108 &smmu 0x1dc6 0x2>,
+		    <0x7200 &smmu 0x1dc8 0x2>,
+		    <0x7208 &smmu 0x1dca 0x2>,
+		    <0x7300 &smmu 0x1dcc 0x2>,
+		    <0x7308 &smmu 0x1dce 0x2>,
+		    <0x7400 &smmu 0x1dd0 0x2>,
+		    <0x7408 &smmu 0x1dd2 0x2>,
+		    <0x7500 &smmu 0x1dd4 0x2>,
+		    <0x7508 &smmu 0x1dd6 0x2>,
+		    <0x7600 &smmu 0x1dd8 0x2>,
+		    <0x7608 &smmu 0x1dda 0x2>,
+		    <0x7700 &smmu 0x1ddc 0x2>,
+		    <0x7708 &smmu 0x1dde 0x2>,
+		    <0x7800 &smmu 0x1de0 0x2>,
+		    <0x7808 &smmu 0x1de2 0x2>,
+		    <0x7900 &smmu 0x1de4 0x2>,
+		    <0x7908 &smmu 0x1de6 0x2>,
+		    <0x7a00 &smmu 0x1de8 0x2>,
+		    <0x7a08 &smmu 0x1dea 0x2>,
+		    <0x7b00 &smmu 0x1dec 0x2>,
+		    <0x7b08 &smmu 0x1dee 0x2>,
+		    <0x7c00 &smmu 0x1df0 0x2>,
+		    <0x7c08 &smmu 0x1df2 0x2>,
+		    <0x7d00 &smmu 0x1df4 0x2>,
+		    <0x7d08 &smmu 0x1df6 0x2>,
+		    <0x7e00 &smmu 0x1df8 0x2>,
+		    <0x7e08 &smmu 0x1dfa 0x2>,
+		    <0x7f00 &smmu 0x1dfc 0x2>,
+		    <0x7f08 &smmu 0x1dfe 0x2>,
+		    <0x8000 &smmu 0x1e00 0x2>,
+		    <0x8008 &smmu 0x1e02 0x2>,
+		    <0x8100 &smmu 0x1e04 0x2>,
+		    <0x8108 &smmu 0x1e06 0x2>,
+		    <0x8200 &smmu 0x1e08 0x2>,
+		    <0x8208 &smmu 0x1e0a 0x2>,
+		    <0x8300 &smmu 0x1e0c 0x2>,
+		    <0x8308 &smmu 0x1e0e 0x2>,
+		    <0x8400 &smmu 0x1e10 0x2>,
+		    <0x8408 &smmu 0x1e12 0x2>,
+		    <0x8500 &smmu 0x1e14 0x2>,
+		    <0x8508 &smmu 0x1e16 0x2>,
+		    <0x8600 &smmu 0x1e18 0x2>,
+		    <0x8608 &smmu 0x1e1a 0x2>,
+		    <0x8700 &smmu 0x1e1c 0x2>,
+		    <0x8708 &smmu 0x1e1e 0x2>,
+		    <0x8800 &smmu 0x1e20 0x2>,
+		    <0x8808 &smmu 0x1e22 0x2>,
+		    <0x8900 &smmu 0x1e24 0x2>,
+		    <0x8908 &smmu 0x1e26 0x2>,
+		    <0x8a00 &smmu 0x1e28 0x2>,
+		    <0x8a08 &smmu 0x1e2a 0x2>,
+		    <0x8b00 &smmu 0x1e2c 0x2>,
+		    <0x8b08 &smmu 0x1e2e 0x2>,
+		    <0x8c00 &smmu 0x1e30 0x2>,
+		    <0x8c08 &smmu 0x1e32 0x2>,
+		    <0x8d00 &smmu 0x1e34 0x2>,
+		    <0x8d08 &smmu 0x1e36 0x2>,
+		    <0x8e00 &smmu 0x1e38 0x2>,
+		    <0x8e08 &smmu 0x1e3a 0x2>,
+		    <0x8f00 &smmu 0x1e3c 0x2>,
+		    <0x8f08 &smmu 0x1e3e 0x2>,
+		    <0x9000 &smmu 0x1e40 0x2>,
+		    <0x9008 &smmu 0x1e42 0x2>,
+		    <0x9100 &smmu 0x1e44 0x2>,
+		    <0x9108 &smmu 0x1e46 0x2>,
+		    <0x9200 &smmu 0x1e48 0x2>,
+		    <0x9208 &smmu 0x1e4a 0x2>,
+		    <0x9300 &smmu 0x1e4c 0x2>,
+		    <0x9308 &smmu 0x1e4e 0x2>,
+		    <0x9400 &smmu 0x1e50 0x2>,
+		    <0x9408 &smmu 0x1e52 0x2>,
+		    <0x9500 &smmu 0x1e54 0x2>,
+		    <0x9508 &smmu 0x1e56 0x2>,
+		    <0x9600 &smmu 0x1e58 0x2>,
+		    <0x9608 &smmu 0x1e5a 0x2>,
+		    <0x9700 &smmu 0x1e5c 0x2>,
+		    <0x9708 &smmu 0x1e5e 0x2>,
+		    <0x9800 &smmu 0x1e60 0x2>,
+		    <0x9808 &smmu 0x1e62 0x2>,
+		    <0x9900 &smmu 0x1e64 0x2>,
+		    <0x9908 &smmu 0x1e66 0x2>,
+		    <0x9a00 &smmu 0x1e68 0x2>,
+		    <0x9a08 &smmu 0x1e6a 0x2>,
+		    <0x9b00 &smmu 0x1e6c 0x2>,
+		    <0x9b08 &smmu 0x1e6e 0x2>,
+		    <0x9c00 &smmu 0x1e70 0x2>,
+		    <0x9c08 &smmu 0x1e72 0x2>,
+		    <0x9d00 &smmu 0x1e74 0x2>,
+		    <0x9d08 &smmu 0x1e76 0x2>,
+		    <0x9e00 &smmu 0x1e78 0x2>,
+		    <0x9e08 &smmu 0x1e7a 0x2>,
+		    <0x9f00 &smmu 0x1e7c 0x2>,
+		    <0x9f08 &smmu 0x1e7e 0x2>,
+		    <0xa000 &smmu 0x1e80 0x2>,
+		    <0xa008 &smmu 0x1e82 0x2>,
+		    <0xa100 &smmu 0x1e84 0x2>,
+		    <0xa108 &smmu 0x1e86 0x2>,
+		    <0xa200 &smmu 0x1e88 0x2>,
+		    <0xa208 &smmu 0x1e8a 0x2>,
+		    <0xa300 &smmu 0x1e8c 0x2>,
+		    <0xa308 &smmu 0x1e8e 0x2>,
+		    <0xa400 &smmu 0x1e90 0x2>,
+		    <0xa408 &smmu 0x1e92 0x2>,
+		    <0xa500 &smmu 0x1e94 0x2>,
+		    <0xa508 &smmu 0x1e96 0x2>,
+		    <0xa600 &smmu 0x1e98 0x2>,
+		    <0xa608 &smmu 0x1e9a 0x2>,
+		    <0xa700 &smmu 0x1e9c 0x2>,
+		    <0xa708 &smmu 0x1e9e 0x2>,
+		    <0xa800 &smmu 0x1ea0 0x2>,
+		    <0xa808 &smmu 0x1ea2 0x2>,
+		    <0xa900 &smmu 0x1ea4 0x2>,
+		    <0xa908 &smmu 0x1ea6 0x2>,
+		    <0xaa00 &smmu 0x1ea8 0x2>,
+		    <0xaa08 &smmu 0x1eaa 0x2>,
+		    <0xab00 &smmu 0x1eac 0x2>,
+		    <0xab08 &smmu 0x1eae 0x2>,
+		    <0xac00 &smmu 0x1eb0 0x2>,
+		    <0xac08 &smmu 0x1eb2 0x2>,
+		    <0xad00 &smmu 0x1eb4 0x2>,
+		    <0xad08 &smmu 0x1eb6 0x2>,
+		    <0xae00 &smmu 0x1eb8 0x2>,
+		    <0xae08 &smmu 0x1eba 0x2>,
+		    <0xaf00 &smmu 0x1ebc 0x2>,
+		    <0xaf08 &smmu 0x1ebe 0x2>,
+		    <0xb000 &smmu 0x1ec0 0x2>,
+		    <0xb008 &smmu 0x1ec2 0x2>,
+		    <0xb100 &smmu 0x1ec4 0x2>,
+		    <0xb108 &smmu 0x1ec6 0x2>,
+		    <0xb200 &smmu 0x1ec8 0x2>,
+		    <0xb208 &smmu 0x1eca 0x2>,
+		    <0xb300 &smmu 0x1ecc 0x2>,
+		    <0xb308 &smmu 0x1ece 0x2>,
+		    <0xb400 &smmu 0x1ed0 0x2>,
+		    <0xb408 &smmu 0x1ed2 0x2>,
+		    <0xb500 &smmu 0x1ed4 0x2>,
+		    <0xb508 &smmu 0x1ed6 0x2>,
+		    <0xb600 &smmu 0x1ed8 0x2>,
+		    <0xb608 &smmu 0x1eda 0x2>,
+		    <0xb700 &smmu 0x1edc 0x2>,
+		    <0xb708 &smmu 0x1ede 0x2>,
+		    <0xb800 &smmu 0x1ee0 0x2>,
+		    <0xb808 &smmu 0x1ee2 0x2>,
+		    <0xb900 &smmu 0x1ee4 0x2>,
+		    <0xb908 &smmu 0x1ee6 0x2>,
+		    <0xba00 &smmu 0x1ee8 0x2>,
+		    <0xba08 &smmu 0x1eea 0x2>,
+		    <0xbb00 &smmu 0x1eec 0x2>,
+		    <0xbb08 &smmu 0x1eee 0x2>,
+		    <0xbc00 &smmu 0x1ef0 0x2>,
+		    <0xbc08 &smmu 0x1ef2 0x2>,
+		    <0xbd00 &smmu 0x1ef4 0x2>,
+		    <0xbd08 &smmu 0x1ef6 0x2>,
+		    <0xbe00 &smmu 0x1ef8 0x2>,
+		    <0xbe08 &smmu 0x1efa 0x2>,
+		    <0xbf00 &smmu 0x1efc 0x2>,
+		    <0xbf08 &smmu 0x1efe 0x2>,
+		    <0xc000 &smmu 0x1f00 0x2>,
+		    <0xc008 &smmu 0x1f02 0x2>,
+		    <0xc100 &smmu 0x1f04 0x2>,
+		    <0xc108 &smmu 0x1f06 0x2>,
+		    <0xc200 &smmu 0x1f08 0x2>,
+		    <0xc208 &smmu 0x1f0a 0x2>,
+		    <0xc300 &smmu 0x1f0c 0x2>,
+		    <0xc308 &smmu 0x1f0e 0x2>,
+		    <0xc400 &smmu 0x1f10 0x2>,
+		    <0xc408 &smmu 0x1f12 0x2>,
+		    <0xc500 &smmu 0x1f14 0x2>,
+		    <0xc508 &smmu 0x1f16 0x2>,
+		    <0xc600 &smmu 0x1f18 0x2>,
+		    <0xc608 &smmu 0x1f1a 0x2>,
+		    <0xc700 &smmu 0x1f1c 0x2>,
+		    <0xc708 &smmu 0x1f1e 0x2>,
+		    <0xc800 &smmu 0x1f20 0x2>,
+		    <0xc808 &smmu 0x1f22 0x2>,
+		    <0xc900 &smmu 0x1f24 0x2>,
+		    <0xc908 &smmu 0x1f26 0x2>,
+		    <0xca00 &smmu 0x1f28 0x2>,
+		    <0xca08 &smmu 0x1f2a 0x2>,
+		    <0xcb00 &smmu 0x1f2c 0x2>,
+		    <0xcb08 &smmu 0x1f2e 0x2>,
+		    <0xcc00 &smmu 0x1f30 0x2>,
+		    <0xcc08 &smmu 0x1f32 0x2>,
+		    <0xcd00 &smmu 0x1f34 0x2>,
+		    <0xcd08 &smmu 0x1f36 0x2>,
+		    <0xce00 &smmu 0x1f38 0x2>,
+		    <0xce08 &smmu 0x1f3a 0x2>,
+		    <0xcf00 &smmu 0x1f3c 0x2>,
+		    <0xcf08 &smmu 0x1f3e 0x2>,
+		    <0xd000 &smmu 0x1f40 0x2>,
+		    <0xd008 &smmu 0x1f42 0x2>,
+		    <0xd100 &smmu 0x1f44 0x2>,
+		    <0xd108 &smmu 0x1f46 0x2>,
+		    <0xd200 &smmu 0x1f48 0x2>,
+		    <0xd208 &smmu 0x1f4a 0x2>,
+		    <0xd300 &smmu 0x1f4c 0x2>,
+		    <0xd308 &smmu 0x1f4e 0x2>,
+		    <0xd400 &smmu 0x1f50 0x2>,
+		    <0xd408 &smmu 0x1f52 0x2>,
+		    <0xd500 &smmu 0x1f54 0x2>,
+		    <0xd508 &smmu 0x1f56 0x2>,
+		    <0xd600 &smmu 0x1f58 0x2>,
+		    <0xd608 &smmu 0x1f5a 0x2>,
+		    <0xd700 &smmu 0x1f5c 0x2>,
+		    <0xd708 &smmu 0x1f5e 0x2>,
+		    <0xd800 &smmu 0x1f60 0x2>,
+		    <0xd808 &smmu 0x1f62 0x2>,
+		    <0xd900 &smmu 0x1f64 0x2>,
+		    <0xd908 &smmu 0x1f66 0x2>,
+		    <0xda00 &smmu 0x1f68 0x2>,
+		    <0xda08 &smmu 0x1f6a 0x2>,
+		    <0xdb00 &smmu 0x1f6c 0x2>,
+		    <0xdb08 &smmu 0x1f6e 0x2>,
+		    <0xdc00 &smmu 0x1f70 0x2>,
+		    <0xdc08 &smmu 0x1f72 0x2>,
+		    <0xdd00 &smmu 0x1f74 0x2>,
+		    <0xdd08 &smmu 0x1f76 0x2>,
+		    <0xde00 &smmu 0x1f78 0x2>,
+		    <0xde08 &smmu 0x1f7a 0x2>,
+		    <0xdf00 &smmu 0x1f7c 0x2>,
+		    <0xdf08 &smmu 0x1f7e 0x2>,
+		    <0xe000 &smmu 0x1f80 0x2>,
+		    <0xe008 &smmu 0x1f82 0x2>,
+		    <0xe100 &smmu 0x1f84 0x2>,
+		    <0xe108 &smmu 0x1f86 0x2>,
+		    <0xe200 &smmu 0x1f88 0x2>,
+		    <0xe208 &smmu 0x1f8a 0x2>,
+		    <0xe300 &smmu 0x1f8c 0x2>,
+		    <0xe308 &smmu 0x1f8e 0x2>,
+		    <0xe400 &smmu 0x1f90 0x2>,
+		    <0xe408 &smmu 0x1f92 0x2>,
+		    <0xe500 &smmu 0x1f94 0x2>,
+		    <0xe508 &smmu 0x1f96 0x2>,
+		    <0xe600 &smmu 0x1f98 0x2>,
+		    <0xe608 &smmu 0x1f9a 0x2>,
+		    <0xe700 &smmu 0x1f9c 0x2>,
+		    <0xe708 &smmu 0x1f9e 0x2>,
+		    <0xe800 &smmu 0x1fa0 0x2>,
+		    <0xe808 &smmu 0x1fa2 0x2>,
+		    <0xe900 &smmu 0x1fa4 0x2>,
+		    <0xe908 &smmu 0x1fa6 0x2>,
+		    <0xea00 &smmu 0x1fa8 0x2>,
+		    <0xea08 &smmu 0x1faa 0x2>,
+		    <0xeb00 &smmu 0x1fac 0x2>,
+		    <0xeb08 &smmu 0x1fae 0x2>,
+		    <0xec00 &smmu 0x1fb0 0x2>,
+		    <0xec08 &smmu 0x1fb2 0x2>,
+		    <0xed00 &smmu 0x1fb4 0x2>,
+		    <0xed08 &smmu 0x1fb6 0x2>,
+		    <0xee00 &smmu 0x1fb8 0x2>,
+		    <0xee08 &smmu 0x1fba 0x2>,
+		    <0xef00 &smmu 0x1fbc 0x2>,
+		    <0xef08 &smmu 0x1fbe 0x2>,
+		    <0xf000 &smmu 0x1fc0 0x2>,
+		    <0xf008 &smmu 0x1fc2 0x2>,
+		    <0xf100 &smmu 0x1fc4 0x2>,
+		    <0xf108 &smmu 0x1fc6 0x2>,
+		    <0xf200 &smmu 0x1fc8 0x2>,
+		    <0xf208 &smmu 0x1fca 0x2>,
+		    <0xf300 &smmu 0x1fcc 0x2>,
+		    <0xf308 &smmu 0x1fce 0x2>,
+		    <0xf400 &smmu 0x1fd0 0x2>,
+		    <0xf408 &smmu 0x1fd2 0x2>,
+		    <0xf500 &smmu 0x1fd4 0x2>,
+		    <0xf508 &smmu 0x1fd6 0x2>,
+		    <0xf600 &smmu 0x1fd8 0x2>,
+		    <0xf608 &smmu 0x1fda 0x2>,
+		    <0xf700 &smmu 0x1fdc 0x2>,
+		    <0xf708 &smmu 0x1fde 0x2>,
+		    <0xf800 &smmu 0x1fe0 0x2>,
+		    <0xf808 &smmu 0x1fe2 0x2>,
+		    <0xf900 &smmu 0x1fe4 0x2>,
+		    <0xf908 &smmu 0x1fe6 0x2>,
+		    <0xfa00 &smmu 0x1fe8 0x2>,
+		    <0xfa08 &smmu 0x1fea 0x2>,
+		    <0xfb00 &smmu 0x1fec 0x2>,
+		    <0xfb08 &smmu 0x1fee 0x2>,
+		    <0xfc00 &smmu 0x1ff0 0x2>,
+		    <0xfc08 &smmu 0x1ff2 0x2>,
+		    <0xfd00 &smmu 0x1ff4 0x2>,
+		    <0xfd08 &smmu 0x1ff6 0x2>,
+		    <0xfe00 &smmu 0x1ff8 0x2>,
+		    <0xfe08 &smmu 0x1ffa 0x2>,
+		    <0xff00 &smmu 0x1ffc 0x2>,
+		    <0xff08 &smmu 0x1ffe 0x2>;
+#endif
+};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/stingray-pcie.dtsi
@@ -0,0 +1,521 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if (NUM_PAXB == 8)
+#define ENABLE_PCIE0	1
+#define ENABLE_PCIE1	1
+#define ENABLE_PCIE2	1
+#define ENABLE_PCIE3	1
+#define ENABLE_PCIE4	1
+#define ENABLE_PCIE5	1
+#define ENABLE_PCIE6	1
+#define ENABLE_PCIE7	1
+#endif
+
+#if (NUM_PAXB == 1)
+#define ENABLE_PCIE0	1
+#endif
+
+	pcie0: pcie@48000000 {
+		compatible = "brcm,iproc-pcie-paxb-v2";
+		reg = <0 0x48000000 0 0x4000>;
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 0 1 &pcie0 1>,
+				<0 0 0 0 2 &pcie0 2>,
+				<0 0 0 0 3 &pcie0 3>,
+				<0 0 0 0 4 &pcie0 4>;
+		interrupts = <GIC_SPI 420 IRQ_TYPE_LEVEL_HIGH>;
+
+		linux,pci-domain = <0>;
+
+		bus-range = <0x0 0xff>;
+
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+#if (ENABLE_32BIT_OUTBOUND == 1)
+		ranges = <0x83000000 0x0 0x42000000 0x0 0x42000000 0 0x2000000>,
+			 <0x43000000 0x4 0x00000000 0x4 0x00000000 0 0x80000000>;
+#else
+		ranges = <0x43000000 0x4 0x00000000 0x4 0x00000000 0 0x40000000>,
+			 <0x43000000 0x4 0x40000000 0x4 0x40000000 0 0x20000000>,
+			 <0x43000000 0x4 0x60000000 0x4 0x60000000 0 0x10000000>,
+			 <0x83000000 0x0 0x40000000 0x4 0x70000000 0 0x10000000>;
+#endif
+		brcm,pcie-ob;
+		brcm,pcie-ob-axi-offset = <0x00000000>;
+
+		dma-coherent;
+
+		msi-map = <0x000 &gic_its 0x000 0x400>;
+
+#if (ENABLE_PAXB_IOMMU == 1)
+		iommu-map = <0x000 &smmu 0x000 0x400>;
+#endif
+
+		phys = <&pcie_phy 0>;
+		phy-names = "pcie-phy";
+
+#if (ENABLE_PCIE0 == 1)
+		status = "okay";
+#else
+		status = "disabled";
+#endif
+	};
+
+	pcie1: pcie@48004000 {
+		compatible = "brcm,iproc-pcie-paxb-v2";
+		reg = <0 0x48004000 0 0x4000>;
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 0 1 &pcie1 1>,
+				<0 0 0 0 2 &pcie1 2>,
+				<0 0 0 0 3 &pcie1 3>,
+				<0 0 0 0 4 &pcie1 4>;
+		interrupts = <GIC_SPI 426 IRQ_TYPE_LEVEL_HIGH>;
+
+		linux,pci-domain = <1>;
+
+		bus-range = <0x0 0xff>;
+
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+#if (ENABLE_32BIT_OUTBOUND == 1)
+		ranges = <0x83000000 0x0 0x44000000 0x0 0x44000000 0 0x2000000>,
+			 <0x43000000 0x4 0x80000000 0x4 0x80000000 0 0x80000000>;
+#else
+		ranges = <0x43000000 0x4 0x80000000 0x4 0x80000000 0 0x40000000>,
+			 <0x43000000 0x4 0xc0000000 0x4 0xc0000000 0 0x20000000>,
+			 <0x43000000 0x4 0xe0000000 0x4 0xe0000000 0 0x10000000>,
+			 <0x83000000 0x0 0x40000000 0x4 0xf0000000 0 0x10000000>;
+#endif
+		brcm,pcie-ob;
+		brcm,pcie-ob-axi-offset = <0x00000000>;
+
+		dma-coherent;
+
+		msi-map = <0x000 &gic_its 0x400 0x400>;
+
+#if (ENABLE_PAXB_IOMMU == 1)
+		iommu-map = <0x000 &smmu 0x400 0x400>;
+#endif
+
+		phys = <&pcie_phy 1>;
+		phy-names = "pcie-phy";
+
+#if (ENABLE_PCIE1 == 1)
+		status = "okay";
+#else
+		status = "disabled";
+#endif
+	};
+
+	pcie2: pcie@48008000 {
+		compatible = "brcm,iproc-pcie-paxb-v2";
+		reg = <0 0x48008000 0 0x4000>;
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 0 1 &pcie2 1>,
+				<0 0 0 0 2 &pcie2 2>,
+				<0 0 0 0 3 &pcie2 3>,
+				<0 0 0 0 4 &pcie2 4>;
+		interrupts = <GIC_SPI 432 IRQ_TYPE_LEVEL_HIGH>;
+
+		linux,pci-domain = <2>;
+
+		bus-range = <0x0 0xff>;
+
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+#if (ENABLE_32BIT_OUTBOUND == 1)
+		ranges = <0x83000000 0x0 0x4a000000 0x0 0x4a000000 0 0x2000000>,
+			 <0x43000000 0x5 0x00000000 0x5 0x00000000 0 0x80000000>;
+#else
+		ranges = <0x43000000 0x5 0x00000000 0x5 0x00000000 0 0x40000000>,
+			 <0x43000000 0x5 0x40000000 0x5 0x40000000 0 0x20000000>,
+			 <0x43000000 0x5 0x60000000 0x5 0x60000000 0 0x10000000>,
+			 <0x83000000 0x0 0x40000000 0x5 0x70000000 0 0x10000000>;
+#endif
+		brcm,pcie-ob;
+		brcm,pcie-ob-axi-offset = <0x00000000>;
+
+		dma-coherent;
+
+		msi-map = <0x000 &gic_its 0x800 0x400>;
+
+#if (ENABLE_PAXB_IOMMU == 1)
+		iommu-map = <0x000 &smmu 0x800 0x400>;
+#endif
+
+		phys = <&pcie_phy 2>;
+		phy-names = "pcie-phy";
+
+#if (ENABLE_PCIE2 == 1)
+		status = "okay";
+#else
+		status = "disabled";
+#endif
+	};
+
+	pcie3: pcie@4800c000 {
+		compatible = "brcm,iproc-pcie-paxb-v2";
+		reg = <0 0x4800c000 0 0x4000>;
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 0 1 &pcie3 1>,
+				<0 0 0 0 2 &pcie3 2>,
+				<0 0 0 0 3 &pcie3 3>,
+				<0 0 0 0 4 &pcie3 4>;
+		interrupts = <GIC_SPI 438 IRQ_TYPE_LEVEL_HIGH>;
+
+		linux,pci-domain = <3>;
+
+		bus-range = <0x0 0xff>;
+
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+#if (ENABLE_32BIT_OUTBOUND == 1)
+		ranges = <0x83000000 0x0 0x4c000000 0x0 0x4c000000 0 0x2000000>,
+			 <0x43000000 0x5 0x80000000 0x5 0x80000000 0 0x80000000>;
+#else
+		ranges = <0x43000000 0x5 0x80000000 0x5 0x80000000 0 0x40000000>,
+			 <0x43000000 0x5 0xc0000000 0x5 0xc0000000 0 0x20000000>,
+			 <0x43000000 0x5 0xe0000000 0x5 0xe0000000 0 0x10000000>,
+			 <0x83000000 0x0 0x40000000 0x5 0xf0000000 0 0x10000000>;
+#endif
+		brcm,pcie-ob;
+		brcm,pcie-ob-axi-offset = <0x00000000>;
+
+		dma-coherent;
+
+		msi-map = <0x000 &gic_its 0xc00 0x400>;
+
+#if (ENABLE_PAXB_IOMMU == 1)
+		iommu-map = <0x000 &smmu 0xc00 0x400>;
+#endif
+
+		phys = <&pcie_phy 3>;
+		phy-names = "pcie-phy";
+
+#if (ENABLE_PCIE3 == 1)
+		status = "okay";
+#else
+		status = "disabled";
+#endif
+	};
+
+	pcie4: pcie@48010000 {
+		compatible = "brcm,iproc-pcie-paxb-v2";
+		reg = <0 0x48010000 0 0x4000>;
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 0 1 &pcie4 1>,
+				<0 0 0 0 2 &pcie4 2>,
+				<0 0 0 0 3 &pcie4 3>,
+				<0 0 0 0 4 &pcie4 4>;
+		interrupts = <GIC_SPI 444 IRQ_TYPE_LEVEL_HIGH>;
+
+		linux,pci-domain = <4>;
+
+		bus-range = <0x0 0xff>;
+
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+#if (ENABLE_32BIT_OUTBOUND == 1)
+		ranges = <0x83000000 0x0 0x52000000 0x0 0x52000000 0 0x2000000>,
+			 <0x43000000 0x6 0x00000000 0x6 0x00000000 0 0x80000000>;
+#else
+		ranges = <0x43000000 0x6 0x00000000 0x6 0x00000000 0 0x40000000>,
+			 <0x43000000 0x6 0x40000000 0x6 0x40000000 0 0x20000000>,
+			 <0x43000000 0x6 0x60000000 0x6 0x60000000 0 0x10000000>,
+			 <0x83000000 0x0 0x40000000 0x6 0x70000000 0 0x10000000>;
+#endif
+		brcm,pcie-ob;
+		brcm,pcie-ob-axi-offset = <0x00000000>;
+
+		dma-coherent;
+
+		msi-map = <0x000 &gic_its 0x1000 0x400>;
+
+#if (ENABLE_PAXB_IOMMU == 1)
+		iommu-map = <0x000 &smmu 0x1000 0x400>;
+#endif
+
+		phys = <&pcie_phy 4>;
+		phy-names = "pcie-phy";
+
+#if (ENABLE_PCIE4 == 1)
+		status = "okay";
+#else
+		status = "disabled";
+#endif
+	};
+
+	pcie5: pcie@48014000 {
+		compatible = "brcm,iproc-pcie-paxb-v2";
+		reg = <0 0x48014000 0 0x4000>;
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 0 1 &pcie5 1>,
+				<0 0 0 0 2 &pcie5 2>,
+				<0 0 0 0 3 &pcie5 3>,
+				<0 0 0 0 4 &pcie5 4>;
+		interrupts = <GIC_SPI 450 IRQ_TYPE_LEVEL_HIGH>;
+
+		linux,pci-domain = <5>;
+
+		bus-range = <0x0 0xff>;
+
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+#if (ENABLE_32BIT_OUTBOUND == 1)
+		ranges = <0x83000000 0x0 0x54000000 0x0 0x54000000 0 0x2000000>,
+			 <0x43000000 0x6 0x80000000 0x6 0x80000000 0 0x80000000>;
+#else
+		ranges = <0x43000000 0x6 0x80000000 0x6 0x80000000 0 0x40000000>,
+			 <0x43000000 0x6 0xc0000000 0x6 0xc0000000 0 0x20000000>,
+			 <0x43000000 0x6 0xe0000000 0x6 0xe0000000 0 0x10000000>,
+			 <0x83000000 0x0 0x40000000 0x6 0xf0000000 0 0x10000000>;
+#endif
+		brcm,pcie-ob;
+		brcm,pcie-ob-axi-offset = <0x00000000>;
+
+		dma-coherent;
+
+		msi-map = <0x000 &gic_its 0x1400 0x400>;
+
+#if (ENABLE_PAXB_IOMMU == 1)
+		iommu-map = <0x000 &smmu 0x1400 0x400>;
+#endif
+
+		phys = <&pcie_phy 5>;
+		phy-names = "pcie-phy";
+
+#if (ENABLE_PCIE5 == 1)
+		status = "okay";
+#else
+		status = "disabled";
+#endif
+	};
+
+	pcie6: pcie@48018000 {
+		compatible = "brcm,iproc-pcie-paxb-v2";
+		reg = <0 0x48018000 0 0x4000>;
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 0 1 &pcie6 1>,
+				<0 0 0 0 2 &pcie6 2>,
+				<0 0 0 0 3 &pcie6 3>,
+				<0 0 0 0 4 &pcie6 4>;
+		interrupts = <GIC_SPI 456 IRQ_TYPE_LEVEL_HIGH>;
+
+		linux,pci-domain = <6>;
+
+		bus-range = <0x0 0xff>;
+
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+#if (ENABLE_32BIT_OUTBOUND == 1)
+		ranges = <0x83000000 0x0 0x5a000000 0x0 0x5a000000 0 0x2000000>,
+			 <0x43000000 0x7 0x00000000 0x7 0x00000000 0 0x80000000>;
+#else
+		ranges = <0x43000000 0x7 0x00000000 0x7 0x00000000 0 0x40000000>,
+			 <0x43000000 0x7 0x40000000 0x7 0x40000000 0 0x20000000>,
+			 <0x43000000 0x7 0x60000000 0x7 0x60000000 0 0x10000000>,
+			 <0x83000000 0x0 0x40000000 0x7 0x70000000 0 0x10000000>;
+#endif
+		brcm,pcie-ob;
+		brcm,pcie-ob-axi-offset = <0x00000000>;
+
+		dma-coherent;
+
+		msi-map = <0x000 &gic_its 0x1800 0x400>;
+
+#if (ENABLE_PAXB_IOMMU == 1)
+		iommu-map = <0x000 &smmu 0x1800 0x400>;
+#endif
+
+		phys = <&pcie_phy 6>;
+		phy-names = "pcie-phy";
+
+#if (ENABLE_PCIE6 == 1)
+		status = "okay";
+#else
+		status = "disabled";
+#endif
+	};
+
+	pcie7: pcie@4801c000 {
+		compatible = "brcm,iproc-pcie-paxb-v2";
+		reg = <0 0x4801c000 0 0x4000>;
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 0 1 &pcie7 1>,
+				<0 0 0 0 2 &pcie7 2>,
+				<0 0 0 0 3 &pcie7 3>,
+				<0 0 0 0 4 &pcie7 4>;
+		interrupts = <GIC_SPI 462 IRQ_TYPE_LEVEL_HIGH>;
+
+		linux,pci-domain = <7>;
+
+		bus-range = <0x0 0xff>;
+
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+#if (ENABLE_32BIT_OUTBOUND == 1)
+		ranges = <0x83000000 0x0 0x5c000000 0x0 0x5c000000 0 0x2000000>,
+			 <0x43000000 0x7 0x80000000 0x7 0x80000000 0 0x80000000>;
+#else
+		ranges = <0x43000000 0x7 0x80000000 0x7 0x80000000 0 0x40000000>,
+			 <0x43000000 0x7 0xc0000000 0x7 0xc0000000 0 0x20000000>,
+			 <0x43000000 0x7 0xd0000000 0x7 0xe0000000 0 0x10000000>,
+			 <0x83000000 0x0 0x40000000 0x7 0xf0000000 0 0x10000000>;
+#endif
+		brcm,pcie-ob;
+		brcm,pcie-ob-axi-offset = <0x00000000>;
+
+		dma-coherent;
+
+		msi-map = <0x000 &gic_its 0x1c00 0x400>;
+
+#if (ENABLE_PAXB_IOMMU == 1)
+		iommu-map = <0x000 &smmu 0x1c00 0x400>;
+#endif
+
+		phys = <&pcie_phy 7>;
+		phy-names = "pcie-phy";
+
+#if (ENABLE_PCIE7 == 1)
+		status = "okay";
+#else
+		status = "disabled";
+#endif
+	};
+
+	pcie8: pcie@60400000 {
+		compatible = "brcm,iproc-pcie-paxc-v2";
+		reg = <0 0x60400000 0 0x1000>;
+		linux,pci-domain = <8>;
+
+		bus-range = <0x0 0x1>;
+
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+		ranges = <0x83000000 0 0x10000000 0 0x10000000 0 0x20000000>;
+
+		dma-coherent;
+
+		msi-map = <0x100 &gic_its 0x2000 0x1>, /* PF0 */
+			  <0x108 &gic_its 0x2040 0x8>, /* PF0-VF0-7 */
+			  <0x101 &gic_its 0x2080 0x1>, /* PF1 */
+			  <0x110 &gic_its 0x20c8 0x8>, /* PF1-VF8-15 */
+			  <0x102 &gic_its 0x2100 0x1>, /* PF2 */
+			  <0x118 &gic_its 0x2150 0x8>, /* PF2-VF16-23 */
+			  <0x103 &gic_its 0x2180 0x1>, /* PF3 */
+			  <0x120 &gic_its 0x21d8 0x8>, /* PF3-VF24-31 */
+			  <0x104 &gic_its 0x2200 0x1>, /* PF4 */
+			  <0x128 &gic_its 0x2260 0x8>, /* PF4-VF32-39 */
+			  <0x105 &gic_its 0x2280 0x1>, /* PF5 */
+			  <0x130 &gic_its 0x22e8 0x8>, /* PF5-VF40-47 */
+			  <0x106 &gic_its 0x2300 0x1>, /* PF6 */
+			  <0x138 &gic_its 0x2370 0x8>, /* PF6-VF48-55 */
+			  <0x107 &gic_its 0x2380 0x1>, /* PF7 */
+			  <0x140 &gic_its 0x23f8 0x8>; /* PF7-VF56-63 */
+
+#if (ENABLE_PAXC_IOMMU == 1)
+		iommu-map = <0x100 &smmu 0x2000 0x1>, /* PF0 */
+			    <0x108 &smmu 0x2040 0x8>, /* PF0-VF0-7 */
+			    <0x101 &smmu 0x2080 0x1>, /* PF1 */
+			    <0x110 &smmu 0x20c8 0x8>, /* PF1-VF8-15 */
+			    <0x102 &smmu 0x2100 0x1>, /* PF2 */
+			    <0x118 &smmu 0x2150 0x8>, /* PF2-VF16-23 */
+			    <0x103 &smmu 0x2180 0x1>, /* PF3 */
+			    <0x120 &smmu 0x21d8 0x8>, /* PF3-VF24-31 */
+			    <0x104 &smmu 0x2200 0x1>, /* PF4 */
+			    <0x128 &smmu 0x2260 0x8>, /* PF4-VF32-39 */
+			    <0x105 &smmu 0x2280 0x1>, /* PF5 */
+			    <0x130 &smmu 0x22e8 0x8>, /* PF5-VF40-47 */
+			    <0x106 &smmu 0x2300 0x1>, /* PF6 */
+			    <0x138 &smmu 0x2370 0x8>, /* PF6-VF48-55 */
+			    <0x107 &smmu 0x2380 0x1>, /* PF7 */
+			    <0x140 &smmu 0x23f8 0x8>; /* PF7-VF56-63 */
+#endif
+
+		phys = <&pcie_phy 8>;
+		phy-names = "pcie-phy";
+
+#if (ENABLE_PAXC == 1)
+		status = "okay";
+#else
+		status = "disabled";
+#endif
+	};
+
+	pcie-ss {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x40000000 0x800>;
+
+		pcie_phy: phy {
+			compatible = "brcm,sr-pcie-phy";
+			reg = <0x0 0x200>;
+			brcm,sr-cdru = <&cdru>;
+			brcm,sr-mhb = <&mhb>;
+			#phy-cells = <1>;
+		};
+	};
--- a/arch/arm64/boot/dts/broadcom/stingray/stingray-pinctrl.dtsi
+++ b/arch/arm64/boot/dts/broadcom/stingray/stingray-pinctrl.dtsi
@@ -32,7 +32,7 @@
 
 #include <dt-bindings/pinctrl/brcm,pinctrl-stingray.h>
 
-		pinconf: pinconf@00140000 {
+		pinconf: pinconf@140000 {
 			compatible = "pinconf-single";
 			reg = <0x00140000 0x250>;
 			pinctrl-single,register-width = <32>;
@@ -40,7 +40,7 @@
 			/* pinconf functions */
 		};
 
-		pinmux: pinmux@0014029c {
+		pinmux: pinmux@14029c {
 			compatible = "pinctrl-single";
 			reg = <0x0014029c 0x250>;
 			#address-cells = <1>;
--- a/arch/arm64/boot/dts/broadcom/stingray/stingray-sata.dtsi
+++ b/arch/arm64/boot/dts/broadcom/stingray/stingray-sata.dtsi
@@ -32,18 +32,23 @@
 
 	sata {
 		compatible = "simple-bus";
+		dma-ranges;
 		#address-cells = <1>;
 		#size-cells = <1>;
 		ranges = <0x0 0x0 0x67d00000 0x00800000>;
 
-		sata0: ahci@00210000 {
+		sata0: ahci@0 {
 			compatible = "brcm,iproc-ahci", "generic-ahci";
-			reg = <0x00210000 0x1000>;
+			reg = <0x00000000 0x1000>;
 			reg-names = "ahci";
-			interrupts = <GIC_SPI 339 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 321 IRQ_TYPE_LEVEL_HIGH>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 0)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata0_port0: sata-port@0 {
 				reg = <0>;
@@ -52,13 +57,17 @@
 			};
 		};
 
-		sata_phy0: sata_phy@00212100 {
+		sata_phy0: sata_phy@2100 {
 			compatible = "brcm,iproc-sr-sata-phy";
-			reg = <0x00212100 0x1000>;
+			reg = <0x00002100 0x1000>;
 			reg-names = "phy";
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 0)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata0_phy0: sata-phy@0 {
 				reg = <0>;
@@ -66,14 +75,18 @@
 			};
 		};
 
-		sata1: ahci@00310000 {
+		sata1: ahci@10000 {
 			compatible = "brcm,iproc-ahci", "generic-ahci";
-			reg = <0x00310000 0x1000>;
+			reg = <0x00010000 0x1000>;
 			reg-names = "ahci";
-			interrupts = <GIC_SPI 347 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 323 IRQ_TYPE_LEVEL_HIGH>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 1)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata1_port0: sata-port@0 {
 				reg = <0>;
@@ -82,13 +95,17 @@
 			};
 		};
 
-		sata_phy1: sata_phy@00312100 {
+		sata_phy1: sata_phy@12100 {
 			compatible = "brcm,iproc-sr-sata-phy";
-			reg = <0x00312100 0x1000>;
+			reg = <0x00012100 0x1000>;
 			reg-names = "phy";
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 1)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata1_phy0: sata-phy@0 {
 				reg = <0>;
@@ -96,14 +113,18 @@
 			};
 		};
 
-		sata2: ahci@00120000 {
+		sata2: ahci@20000 {
 			compatible = "brcm,iproc-ahci", "generic-ahci";
-			reg = <0x00120000 0x1000>;
+			reg = <0x00020000 0x1000>;
 			reg-names = "ahci";
-			interrupts = <GIC_SPI 333 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 325 IRQ_TYPE_LEVEL_HIGH>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 2)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata2_port0: sata-port@0 {
 				reg = <0>;
@@ -112,13 +133,17 @@
 			};
 		};
 
-		sata_phy2: sata_phy@00122100 {
+		sata_phy2: sata_phy@22100 {
 			compatible = "brcm,iproc-sr-sata-phy";
-			reg = <0x00122100 0x1000>;
+			reg = <0x00022100 0x1000>;
 			reg-names = "phy";
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 2)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata2_phy0: sata-phy@0 {
 				reg = <0>;
@@ -126,14 +151,18 @@
 			};
 		};
 
-		sata3: ahci@00130000 {
+		sata3: ahci@30000 {
 			compatible = "brcm,iproc-ahci", "generic-ahci";
-			reg = <0x00130000 0x1000>;
+			reg = <0x00030000 0x1000>;
 			reg-names = "ahci";
-			interrupts = <GIC_SPI 335 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 327 IRQ_TYPE_LEVEL_HIGH>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 3)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata3_port0: sata-port@0 {
 				reg = <0>;
@@ -142,13 +171,17 @@
 			};
 		};
 
-		sata_phy3: sata_phy@00132100 {
+		sata_phy3: sata_phy@32100 {
 			compatible = "brcm,iproc-sr-sata-phy";
-			reg = <0x00132100 0x1000>;
+			reg = <0x00032100 0x1000>;
 			reg-names = "phy";
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 3)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata3_phy0: sata-phy@0 {
 				reg = <0>;
@@ -156,14 +189,18 @@
 			};
 		};
 
-		sata4: ahci@00330000 {
+		sata4: ahci@100000 {
 			compatible = "brcm,iproc-ahci", "generic-ahci";
-			reg = <0x00330000 0x1000>;
+			reg = <0x00100000 0x1000>;
 			reg-names = "ahci";
-			interrupts = <GIC_SPI 351 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 329 IRQ_TYPE_LEVEL_HIGH>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 4)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata4_port0: sata-port@0 {
 				reg = <0>;
@@ -172,13 +209,17 @@
 			};
 		};
 
-		sata_phy4: sata_phy@00332100 {
+		sata_phy4: sata_phy@102100 {
 			compatible = "brcm,iproc-sr-sata-phy";
-			reg = <0x00332100 0x1000>;
+			reg = <0x00102100 0x1000>;
 			reg-names = "phy";
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 4)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata4_phy0: sata-phy@0 {
 				reg = <0>;
@@ -186,14 +227,18 @@
 			};
 		};
 
-		sata5: ahci@00400000 {
+		sata5: ahci@110000 {
 			compatible = "brcm,iproc-ahci", "generic-ahci";
-			reg = <0x00400000 0x1000>;
+			reg = <0x00110000 0x1000>;
 			reg-names = "ahci";
-			interrupts = <GIC_SPI 353 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 331 IRQ_TYPE_LEVEL_HIGH>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 5)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata5_port0: sata-port@0 {
 				reg = <0>;
@@ -202,13 +247,17 @@
 			};
 		};
 
-		sata_phy5: sata_phy@00402100 {
+		sata_phy5: sata_phy@112100 {
 			compatible = "brcm,iproc-sr-sata-phy";
-			reg = <0x00402100 0x1000>;
+			reg = <0x00112100 0x1000>;
 			reg-names = "phy";
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 5)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata5_phy0: sata-phy@0 {
 				reg = <0>;
@@ -216,14 +265,18 @@
 			};
 		};
 
-		sata6: ahci@00410000 {
+		sata6: ahci@120000 {
 			compatible = "brcm,iproc-ahci", "generic-ahci";
-			reg = <0x00410000 0x1000>;
+			reg = <0x00120000 0x1000>;
 			reg-names = "ahci";
-			interrupts = <GIC_SPI 355 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 333 IRQ_TYPE_LEVEL_HIGH>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 6)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata6_port0: sata-port@0 {
 				reg = <0>;
@@ -232,13 +285,17 @@
 			};
 		};
 
-		sata_phy6: sata_phy@00412100 {
+		sata_phy6: sata_phy@122100 {
 			compatible = "brcm,iproc-sr-sata-phy";
-			reg = <0x00412100 0x1000>;
+			reg = <0x00122100 0x1000>;
 			reg-names = "phy";
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 6)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata6_phy0: sata-phy@0 {
 				reg = <0>;
@@ -246,14 +303,18 @@
 			};
 		};
 
-		sata7: ahci@00420000 {
+		sata7: ahci@130000 {
 			compatible = "brcm,iproc-ahci", "generic-ahci";
-			reg = <0x00420000 0x1000>;
+			reg = <0x00130000 0x1000>;
 			reg-names = "ahci";
-			interrupts = <GIC_SPI 357 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 335 IRQ_TYPE_LEVEL_HIGH>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 7)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata7_port0: sata-port@0 {
 				reg = <0>;
@@ -262,17 +323,25 @@
 			};
 		};
 
-		sata_phy7: sata_phy@00422100 {
+		sata_phy7: sata_phy@132100 {
 			compatible = "brcm,iproc-sr-sata-phy";
-			reg = <0x00422100 0x1000>;
+			reg = <0x00132100 0x1000>;
 			reg-names = "phy";
 			#address-cells = <1>;
 			#size-cells = <0>;
+#if (NUM_SATA > 7)
+			status = "okay";
+#else
 			status = "disabled";
+#endif
 
 			sata7_phy0: sata-phy@0 {
 				reg = <0>;
 				#phy-cells = <0>;
 			};
 		};
+
+#if (NUM_SATA > 8)
+#error "NUM_SATA > 8"
+#endif
 	};
--- /dev/null
+++ b/arch/arm64/boot/dts/broadcom/stingray/stingray-usb.dtsi
@@ -0,0 +1,171 @@
+/*
+ *  BSD LICENSE
+ *
+ *  Copyright(c) 2016-2017 Broadcom.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in
+ *      the documentation and/or other materials provided with the
+ *      distribution.
+ *    * Neither the name of Broadcom nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+	usb {
+		compatible = "simple-bus";
+		dma-ranges;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x68500000 0x00400000>;
+
+		usbphy0: usb-phy@00000000 {
+			compatible = "brcm,sr-usb-phy";
+			reg = <0x00000000 0x100>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			usb0_phy0: phy@0 {
+				reg = <0>;
+				#phy-cells = <0>;
+#if (ENABLE_USB0 == 1)
+				status = "okay";
+#else
+				status = "disabled";
+#endif
+			};
+			usb0_phy1: phy@1 {
+				reg = <1>;
+				#phy-cells = <0>;
+#if (ENABLE_USB0 == 1)
+				status = "okay";
+#else
+				status = "disabled";
+#endif
+			};
+
+		};
+
+		xhci0: usb@00001000 {
+			compatible = "generic-xhci";
+			reg = <0x00001000 0x1000>;
+			interrupts = <GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>;
+			phys = <&usb0_phy1>, <&usb0_phy0>;
+			phy-names = "phy0", "phy1";
+#if (USB_DMA_COHERENT == 1)
+			dma-coherent;
+#endif
+#if (ENABLE_USB0 == 1)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
+		};
+
+		bdc0: usb@00002000 {
+			compatible = "brcm,bdc-usb3";
+			reg = <0x00002000 0x1000>;
+			interrupts = <GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH>;
+			phys = <&usb0_phy1>, <&usb0_phy0>;
+			phy-names = "phy0", "phy1";
+#if (USB_DMA_COHERENT == 1)
+			dma-coherent;
+#endif
+#if (ENABLE_USB0 == 1)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
+		};
+
+		xhci1: usb@00011000 {
+			compatible = "generic-xhci";
+			reg = <0x00011000 0x1000>;
+			interrupts = <GIC_SPI 263 IRQ_TYPE_LEVEL_HIGH>;
+			phys = <&usb1_phy1>, <&usbphy2>, <&usb1_phy0>;
+			phy-names = "phy0", "phy1", "phy2";
+#if (USB_DMA_COHERENT == 1)
+			dma-coherent;
+#endif
+#if (ENABLE_USB1 == 1)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
+		};
+
+		usbphy1: usb-phy@00010000 {
+			compatible = "brcm,sr-usb-phy";
+			reg = <0x00010000 0x100>,
+			      <0x00020000 0x100>;
+			reg-names = "usb3h","drdu2";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			usb1_phy0: phy@0 {
+				reg = <0>;
+				#phy-cells = <0>;
+#if (ENABLE_USB1 == 1)
+				status = "okay";
+#else
+				status = "disabled";
+#endif
+			};
+			usb1_phy1: phy@1 {
+				reg = <1>;
+				#phy-cells = <0>;
+#if (ENABLE_USB1 == 1)
+				status = "okay";
+#else
+				status = "disabled";
+#endif
+			};
+		};
+
+		usbphy2: usb-phy@00020000 {
+			compatible = "brcm,sr-usb-phy-v2";
+			reg = <0x00020000 0x100>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#phy-cells = <0>;
+#if (ENABLE_USB1 == 1)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
+		};
+
+		bdc1: usb@00021000 {
+			compatible = "brcm,bdc-usb3";
+			reg = <0x00021000 0x1000>;
+			interrupts = <GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>;
+			phys = <&usbphy2>;
+			phy-names = "phy0";
+#if (USB_DMA_COHERENT == 1)
+			dma-coherent;
+#endif
+#if (ENABLE_USB1 == 1)
+			status = "okay";
+#else
+			status = "disabled";
+#endif
+		};
+	};
--- a/arch/arm64/boot/dts/broadcom/stingray/stingray.dtsi
+++ b/arch/arm64/boot/dts/broadcom/stingray/stingray.dtsi
@@ -32,37 +32,68 @@
 
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 
+#ifndef ENABLE_PAXB_IOMMU
+#define ENABLE_PAXB_IOMMU	0
+#endif
+
+#ifndef ENABLE_IHOST12_CPUS
+#define ENABLE_IHOST12_CPUS	1
+#endif
+
+#ifndef ENABLE_FS4_IOMMU
+#define ENABLE_FS4_IOMMU	1
+#endif
+
 / {
 	compatible = "brcm,stingray";
 	interrupt-parent = <&gic>;
 	#address-cells = <2>;
 	#size-cells = <2>;
+	dma-ranges = <0x0 0x0 0x0 0x0 0x100 0x0>;
 
 	cpus {
 		#address-cells = <2>;
 		#size-cells = <0>;
 
-		cpu@000 {
+		cpu@0 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a72", "arm,armv8";
 			reg = <0x0 0x0>;
 			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
 			next-level-cache = <&CLUSTER0_L2>;
 		};
 
-		cpu@001 {
+		cpu@1 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a72", "arm,armv8";
 			reg = <0x0 0x1>;
 			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
 			next-level-cache = <&CLUSTER0_L2>;
 		};
-
+#if (ENABLE_IHOST12_CPUS == 1)
 		cpu@100 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a72", "arm,armv8";
 			reg = <0x0 0x100>;
 			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
 			next-level-cache = <&CLUSTER1_L2>;
 		};
 
@@ -71,6 +102,12 @@
 			compatible = "arm,cortex-a72", "arm,armv8";
 			reg = <0x0 0x101>;
 			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
 			next-level-cache = <&CLUSTER1_L2>;
 		};
 
@@ -79,6 +116,12 @@
 			compatible = "arm,cortex-a72", "arm,armv8";
 			reg = <0x0 0x200>;
 			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
 			next-level-cache = <&CLUSTER2_L2>;
 		};
 
@@ -87,14 +130,26 @@
 			compatible = "arm,cortex-a72", "arm,armv8";
 			reg = <0x0 0x201>;
 			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
 			next-level-cache = <&CLUSTER2_L2>;
 		};
-
+#endif
 		cpu@300 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a72", "arm,armv8";
 			reg = <0x0 0x300>;
 			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
 			next-level-cache = <&CLUSTER3_L2>;
 		};
 
@@ -103,23 +158,41 @@
 			compatible = "arm,cortex-a72", "arm,armv8";
 			reg = <0x0 0x301>;
 			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
 			next-level-cache = <&CLUSTER3_L2>;
 		};
 
-		CLUSTER0_L2: l2-cache@000 {
+		CLUSTER0_L2: l2-cache@0 {
 			compatible = "cache";
+			cache-size = <0x200000>;
+			cache-line-size = <64>;
+			cache-sets = <2048>;
 		};
-
+#if (ENABLE_IHOST12_CPUS == 1)
 		CLUSTER1_L2: l2-cache@100 {
 			compatible = "cache";
+			cache-size = <0x200000>;
+			cache-line-size = <64>;
+			cache-sets = <2048>;
 		};
 
 		CLUSTER2_L2: l2-cache@200 {
 			compatible = "cache";
+			cache-size = <0x200000>;
+			cache-line-size = <64>;
+			cache-sets = <2048>;
 		};
-
+#endif
 		CLUSTER3_L2: l2-cache@300 {
 			compatible = "cache";
+			cache-size = <0x200000>;
+			cache-line-size = <64>;
+			cache-sets = <2048>;
 		};
 	};
 
@@ -146,19 +219,26 @@
 			     <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW>;
 	};
 
+	#include "stingray-pcie.dtsi"
+
+	mhb: syscon@60401000 {
+		compatible = "brcm,sr-mhb", "syscon";
+		reg = <0 0x60401000 0 0x38c>;
+	};
+
 	scr {
 		compatible = "simple-bus";
 		#address-cells = <1>;
 		#size-cells = <1>;
 		ranges = <0x0 0x0 0x61000000 0x05000000>;
 
-		ccn: ccn@00000000 {
+		ccn: ccn@0 {
 			compatible = "arm,ccn-502";
 			reg = <0x00000000 0x900000>;
 			interrupts = <GIC_SPI 799 IRQ_TYPE_LEVEL_HIGH>;
 		};
 
-		gic: interrupt-controller@02c00000 {
+		gic: interrupt-controller@2c00000 {
 			compatible = "arm,gic-v3";
 			#interrupt-cells = <3>;
 			#address-cells = <1>;
@@ -177,10 +257,18 @@
 			};
 		};
 
-		smmu: mmu@03000000 {
+		smmu: mmu@3000000 {
 			compatible = "arm,mmu-500";
 			reg = <0x03000000 0x80000>;
 			#global-interrupts = <1>;
+			/* reserve gic-its (@63c20000 + its translater) */
+			#region-address-cells = <1>;
+			#region-size-cells = <1>;
+			reserved-msi-region = <0x0 0x1a 0x63c30000 0x8000>;
+#if (ENABLE_PAXC_IOMMU == 0)
+			reserved-context-banks = <1>;
+			reserved-mapping-groups = <8>;
+#endif
 			interrupts = <GIC_SPI 704 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 711 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 712 IRQ_TYPE_LEVEL_HIGH>,
@@ -243,9 +331,11 @@
 				     <GIC_SPI 769 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 770 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 771 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 772 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 773 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 774 IRQ_TYPE_LEVEL_HIGH>;
+				     <GIC_SPI 772 IRQ_TYPE_LEVEL_HIGH>
+#if (ENABLE_PAXC_IOMMU == 1)
+				     ,<GIC_SPI 773 IRQ_TYPE_LEVEL_HIGH>
+#endif
+					;
 			#iommu-cells = <2>;
 		};
 	};
@@ -258,7 +348,25 @@
 
 		#include "stingray-clock.dtsi"
 
-		gpio_crmu: gpio@00024800 {
+		otp: otp@1c400 {
+			compatible = "brcm,ocotp-v2";
+			reg = <0x0001c400 0x68>;
+			brcm,ocotp-size = <2048>;
+			status = "okay";
+		};
+
+		cdru: syscon@1d000 {
+			compatible = "brcm,sr-cdru", "syscon";
+			reg = <0x0001d000 0x400>;
+		};
+
+		mailbox: mailbox@24024 {
+			compatible = "brcm,iproc-mailbox";
+			reg = <0x00024024 0x8>;
+			#mbox-cells = <1>;
+		};
+
+		gpio_crmu: gpio@24800 {
 			compatible = "brcm,iproc-gpio";
 			reg = <0x00024800 0x4c>;
 			ngpios = <6>;
@@ -269,47 +377,41 @@
 
 	#include "stingray-fs4.dtsi"
 	#include "stingray-sata.dtsi"
+	#include "stingray-usb.dtsi"
+	#include "stingray-optee.dtsi"
 
 	hsls {
 		compatible = "simple-bus";
+		dma-ranges;
 		#address-cells = <1>;
 		#size-cells = <1>;
 		ranges = <0x0 0x0 0x68900000 0x17700000>;
 
 		#include "stingray-pinctrl.dtsi"
 
-		mdio_mux_iproc: mdio-mux@0002023c {
+		mdio_mux_iproc: mdio-mux@20000 {
 			compatible = "brcm,mdio-mux-iproc";
-			reg = <0x0002023c 0x14>;
+			reg = <0x00020000 0x250>;
 			#address-cells = <1>;
 			#size-cells = <0>;
-
-			mdio@0 { /* PCIe serdes */
-				reg = <0x0>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-			};
+			status = "disabled";
 
 			mdio@2 { /* SATA */
 				reg = <0x2>;
 				#address-cells = <1>;
 				#size-cells = <0>;
+				status = "disabled";
 			};
 
-			mdio@3 { /* USB */
-				reg = <0x3>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-			};
-
-			mdio@10 { /* RGMII */
+			mdio@10 { /* SGMII */
 				reg = <0x10>;
 				#address-cells = <1>;
 				#size-cells = <0>;
+				status = "disabled";
 			};
 		};
 
-		pwm: pwm@00010000 {
+		pwm: pwm@10000 {
 			compatible = "brcm,iproc-pwm";
 			reg = <0x00010000 0x1000>;
 			clocks = <&crmu_ref25m>;
@@ -317,7 +419,8 @@
 			status = "disabled";
 		};
 
-		timer0: timer@00030000 {
+		/* Don't use this timer it is being used by ATF */
+		timer0: timer@30000 {
 			compatible = "arm,sp804", "arm,primecell";
 			reg = <0x00030000 0x1000>;
 			interrupts = <GIC_SPI 179 IRQ_TYPE_LEVEL_HIGH>;
@@ -328,7 +431,7 @@
 			status = "disabled";
 		};
 
-		timer1: timer@00040000 {
+		timer1: timer@40000 {
 			compatible = "arm,sp804", "arm,primecell";
 			reg = <0x00040000 0x1000>;
 			interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>;
@@ -338,7 +441,7 @@
 			clock-names = "timer1", "timer2", "apb_pclk";
 		};
 
-		timer2: timer@00050000 {
+		timer2: timer@50000 {
 			compatible = "arm,sp804", "arm,primecell";
 			reg = <0x00050000 0x1000>;
 			interrupts = <GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>;
@@ -349,7 +452,7 @@
 			status = "disabled";
 		};
 
-		timer3: timer@00060000 {
+		timer3: timer@60000 {
 			compatible = "arm,sp804", "arm,primecell";
 			reg = <0x00060000 0x1000>;
 			interrupts = <GIC_SPI 182 IRQ_TYPE_LEVEL_HIGH>;
@@ -360,7 +463,7 @@
 			status = "disabled";
 		};
 
-		timer4: timer@00070000 {
+		timer4: timer@70000 {
 			compatible = "arm,sp804", "arm,primecell";
 			reg = <0x00070000 0x1000>;
 			interrupts = <GIC_SPI 207 IRQ_TYPE_LEVEL_HIGH>;
@@ -371,7 +474,7 @@
 			status = "disabled";
 		};
 
-		timer5: timer@00080000 {
+		timer5: timer@80000 {
 			compatible = "arm,sp804", "arm,primecell";
 			reg = <0x00080000 0x1000>;
 			interrupts = <GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>;
@@ -382,7 +485,7 @@
 			status = "disabled";
 		};
 
-		timer6: timer@00090000 {
+		timer6: timer@90000 {
 			compatible = "arm,sp804", "arm,primecell";
 			reg = <0x00090000 0x1000>;
 			interrupts = <GIC_SPI 209 IRQ_TYPE_LEVEL_HIGH>;
@@ -393,7 +496,7 @@
 			status = "disabled";
 		};
 
-		timer7: timer@000a0000 {
+		timer7: timer@a0000 {
 			compatible = "arm,sp804", "arm,primecell";
 			reg = <0x000a0000 0x1000>;
 			interrupts = <GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>;
@@ -404,7 +507,7 @@
 			status = "disabled";
 		};
 
-		i2c0: i2c@000b0000 {
+		i2c0: i2c@b0000 {
 			compatible = "brcm,iproc-i2c";
 			reg = <0x000b0000 0x100>;
 			#address-cells = <1>;
@@ -414,21 +517,23 @@
 			status = "disabled";
 		};
 
-		wdt0: watchdog@000c0000 {
+		wdt0: watchdog@c0000 {
 			compatible = "arm,sp805", "arm,primecell";
 			reg = <0x000c0000 0x1000>;
 			interrupts = <GIC_SPI 189 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&hsls_25m_div2_clk>, <&hsls_div4_clk>;
 			clock-names = "wdogclk", "apb_pclk";
+			timeout-sec = <60>;
 		};
 
-		gpio_hsls: gpio@000d0000 {
+		gpio_hsls: gpio@d0000 {
 			compatible = "brcm,iproc-gpio";
 			reg = <0x000d0000 0x864>;
 			ngpios = <151>;
 			#gpio-cells = <2>;
 			gpio-controller;
 			interrupt-controller;
+			#interrupt-cells = <2>;
 			interrupts = <GIC_SPI 183 IRQ_TYPE_LEVEL_HIGH>;
 			gpio-ranges = <&pinmux 0 0 16>,
 					<&pinmux 16 71 2>,
@@ -448,7 +553,7 @@
 					<&pinmux 151 91 4>;
 		};
 
-		i2c1: i2c@000e0000 {
+		i2c1: i2c@e0000 {
 			compatible = "brcm,iproc-i2c";
 			reg = <0x000e0000 0x100>;
 			#address-cells = <1>;
@@ -458,7 +563,7 @@
 			status = "disabled";
 		};
 
-		uart0: uart@00100000 {
+		uart0: uart@100000 {
 			device_type = "serial";
 			compatible = "snps,dw-apb-uart";
 			reg = <0x00100000 0x1000>;
@@ -469,7 +574,7 @@
 			status = "disabled";
 		};
 
-		uart1: uart@00110000 {
+		uart1: uart@110000 {
 			device_type = "serial";
 			compatible = "snps,dw-apb-uart";
 			reg = <0x00110000 0x1000>;
@@ -480,7 +585,7 @@
 			status = "disabled";
 		};
 
-		uart2: uart@00120000 {
+		uart2: uart@120000 {
 			device_type = "serial";
 			compatible = "snps,dw-apb-uart";
 			reg = <0x00120000 0x1000>;
@@ -491,7 +596,7 @@
 			status = "disabled";
 		};
 
-		uart3: uart@00130000 {
+		uart3: uart@130000 {
 			device_type = "serial";
 			compatible = "snps,dw-apb-uart";
 			reg = <0x00130000 0x1000>;
@@ -502,7 +607,7 @@
 			status = "disabled";
 		};
 
-		ssp0: ssp@00180000 {
+		ssp0: spi@180000 {
 			compatible = "arm,pl022", "arm,primecell";
 			reg = <0x00180000 0x1000>;
 			interrupts = <GIC_SPI 187 IRQ_TYPE_LEVEL_HIGH>;
@@ -514,7 +619,7 @@
 			status = "disabled";
 		};
 
-		ssp1: ssp@00190000 {
+		ssp1: spi@190000 {
 			compatible = "arm,pl022", "arm,primecell";
 			reg = <0x00190000 0x1000>;
 			interrupts = <GIC_SPI 188 IRQ_TYPE_LEVEL_HIGH>;
@@ -526,12 +631,12 @@
 			status = "disabled";
 		};
 
-		hwrng: hwrng@00220000 {
+		hwrng: hwrng@220000 {
 			compatible = "brcm,iproc-rng200";
 			reg = <0x00220000 0x28>;
 		};
 
-		dma0: dma@00310000 {
+		dma0: dma@310000 {
 			compatible = "arm,pl330", "arm,primecell";
 			reg = <0x00310000 0x1000>;
 			interrupts = <GIC_SPI 193 IRQ_TYPE_LEVEL_HIGH>,
@@ -551,7 +656,7 @@
 			iommus = <&smmu 0x6000 0x0000>;
 		};
 
-		enet: ethernet@00340000{
+		enet: ethernet@340000{
 			compatible = "brcm,amac";
 			reg = <0x00340000 0x1000>;
 			reg-names = "amac_base";
@@ -560,7 +665,7 @@
 			status= "disabled";
 		};
 
-		nand: nand@00360000 {
+		nand: nand@360000 {
 			compatible = "brcm,nand-iproc", "brcm,brcmnand-v6.1";
 			reg = <0x00360000 0x600>,
 			      <0x0050a408 0x600>,
@@ -573,7 +678,27 @@
 			status = "disabled";
 		};
 
-		sdio0: sdhci@003f1000 {
+		qspi: spi@370200 {
+			compatible = "brcm,spi-iproc-qspi-v1",
+				     "brcm,spi-bcm-qspi";
+			reg = <0x00370200 0x184>,
+				<0x00370000 0x124>,
+				<0x0050c408 0x004>,
+				<0x003703a0 0x01c>;
+			reg-names = "mspi", "bspi", "intr_regs",
+				"intr_status_reg";
+			interrupts = <GIC_SPI 202 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "spi_l1_intr";
+			clocks = <&hsls_div4_clk>;
+			clock-names = "qspi_clk";
+			clock-frequency = <175000000>;
+			num-cs = <2>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		sdio0: sdhci@3f1000 {
 			compatible = "brcm,sdhci-iproc";
 			reg = <0x003f1000 0x100>;
 			interrupts = <GIC_SPI 204 IRQ_TYPE_LEVEL_HIGH>;
@@ -583,7 +708,7 @@
 			status = "disabled";
 		};
 
-		sdio1: sdhci@003f2000 {
+		sdio1: sdhci@3f2000 {
 			compatible = "brcm,sdhci-iproc";
 			reg = <0x003f2000 0x100>;
 			interrupts = <GIC_SPI 205 IRQ_TYPE_LEVEL_HIGH>;
@@ -593,4 +718,122 @@
 			status = "disabled";
 		};
 	};
+
+	rtc: rtc {
+		compatible = "brcm,iproc-rtc";
+		interrupts = <GIC_SPI 219 IRQ_TYPE_EDGE_RISING>;
+		status = "disabled";
+	};
+
+	tmons {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x8f100000 0x100>;
+
+		tmon: tmon@0 {
+			compatible = "brcm,sr-thermal";
+			reg = <0x0 0x40>;
+			brcm,tmon-mask = <0x3f>;
+			#thermal-sensor-cells = <1>;
+		};
+	};
+
+	thermal-zones {
+		ihost0_thermal: ihost0-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 0>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+
+		ihost1_thermal: ihost1-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 1>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+
+		ihost2_thermal: ihost2-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 2>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+
+		ihost3_thermal: ihost3-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 3>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+
+		crmu_thermal: crmu-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 4>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+
+		nitro_thermal: nitro-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <1000>;
+			thermal-sensors = <&tmon 5>;
+			trips {
+				cpu-crit {
+					temperature = <105000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+		};
+	};
+
+	nic-hsls {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0  0x0 0xffffffff>;
+
+		nic_i2c0: i2c@60826100 {
+			compatible = "brcm,iproc-nic-i2c";
+			reg = <0x60826100 0x100>,
+			      <0x60e00408 0x1000>;
+			brcm,ape-hsls-addr-mask = <0x03400000>;
+			clock-frequency = <100000>;
+			status = "disabled";
+		};
+	};
 };
+
+#include "stingray-pcie-msi-map.dtsi"
--- /dev/null
+++ b/arch/arm64/configs/iproc_defconfig
@@ -0,0 +1,351 @@
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_BPF_SYSCALL=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_BLK_CMDLINE_PARSER=y
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_ARCH_BCM_IPROC=y
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER_INJECT=m
+CONFIG_PCI_DEBUG=y
+CONFIG_PCI_IOV=y
+CONFIG_HOTPLUG_PCI=y
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_NR_CPUS=8
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_KSM=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_CMA=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_ARM64_LSE_ATOMICS=y
+CONFIG_COMPAT=y
+CONFIG_PM_DEBUG=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IPV6=m
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NET_SCH_DEFAULT=y
+CONFIG_NET_CLS_BASIC=y
+CONFIG_NET_CLS_TCINDEX=y
+CONFIG_NET_CLS_ROUTE4=y
+CONFIG_NET_CLS_FW=y
+CONFIG_NET_CLS_U32=y
+CONFIG_CLS_U32_PERF=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=y
+CONFIG_NET_CLS_RSVP6=y
+CONFIG_NET_CLS_FLOW=y
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_CLS_BPF=y
+CONFIG_NET_CLS_FLOWER=y
+CONFIG_NET_CLS_MATCHALL=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_CMP=y
+CONFIG_NET_EMATCH_NBYTE=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_EMATCH_META=y
+CONFIG_NET_EMATCH_TEXT=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_NET_ACT_SAMPLE=y
+CONFIG_NET_ACT_IPT=m
+CONFIG_NET_ACT_NAT=y
+CONFIG_NET_ACT_PEDIT=y
+CONFIG_NET_ACT_SIMP=y
+CONFIG_NET_ACT_SKBEDIT=y
+CONFIG_NET_ACT_CSUM=y
+CONFIG_NET_ACT_VLAN=y
+CONFIG_NET_ACT_BPF=y
+CONFIG_NET_ACT_SKBMOD=y
+CONFIG_NET_ACT_TUNNEL_KEY=y
+CONFIG_NET_CLS_IND=y
+CONFIG_DCB=y
+CONFIG_OPENVSWITCH=m
+CONFIG_NET_SWITCHDEV=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+CONFIG_NET_DEVLINK=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_DMA_CMA=y
+CONFIG_ARM_CCN=y
+CONFIG_MTD=y
+CONFIG_MTD_TESTS=m
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_M25P80=m
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_BRCMNAND=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_NULL_BLK=m
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_NBD=m
+CONFIG_VIRTIO_BLK=m
+CONFIG_BLK_DEV_NVME=y
+CONFIG_NVME_RDMA=m
+CONFIG_NVME_LPM_BACKUP=m
+CONFIG_NVME_TARGET=m
+CONFIG_NVME_TARGET_LOOP=m
+CONFIG_NVME_TARGET_RDMA=m
+CONFIG_EEPROM_AT25=m
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_ISCSI_TCP=y
+CONFIG_SCSI_MPT3SAS=y
+CONFIG_ATA=y
+CONFIG_SATA_AHCI=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_PATA_PLATFORM=y
+CONFIG_PATA_OF_PLATFORM=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+CONFIG_MD_RAID10=y
+CONFIG_MD_RAID456=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_NETDEVICES=y
+CONFIG_BONDING=m
+CONFIG_VXLAN=y
+CONFIG_TUN=y
+CONFIG_VIRTIO_NET=m
+CONFIG_E1000E=y
+CONFIG_BROADCOM_PHY=y
+CONFIG_USB_RTL8152=y
+CONFIG_USB_USBNET=y
+# CONFIG_WLAN is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_8250_EARLYLOG=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_STUB=m
+CONFIG_I2C_SLAVE_EEPROM=y
+CONFIG_I2C_SLAVE_BMC=m
+CONFIG_SPI=y
+CONFIG_SPI_PL022=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCF857X=y
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_SENSORS_LM90=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_WATCHDOG=y
+CONFIG_ARM_SP805_WATCHDOG=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PLATFORM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_ACM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_CONSOLE=y
+CONFIG_USB_SERIAL_FTDI_SIO=y
+CONFIG_USB_SERIAL_PL2303=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_BDC_UDC=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_RTC_CLASS=y
+CONFIG_DMADEVICES=y
+CONFIG_PL330_DMA=y
+CONFIG_ASYNC_TX_DMA=y
+CONFIG_DMATEST=m
+CONFIG_UIO=y
+CONFIG_UIO_PDRV_GENIRQ=y
+CONFIG_UIO_DMEM_GENIRQ=y
+CONFIG_VFIO=y
+CONFIG_VFIO_NOIOMMU=y
+CONFIG_VFIO_PCI=y
+CONFIG_VFIO_PLATFORM=y
+CONFIG_VFIO_AMBA=y
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
+CONFIG_VIRTIO_MMIO=y
+CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES=y
+# CONFIG_COMMON_CLK_XGENE is not set
+CONFIG_ARM_TIMER_SP804=y
+CONFIG_MAILBOX=y
+CONFIG_BCM_PDC_MBOX=y
+CONFIG_ARM_SMMU=y
+CONFIG_ARM_SMMU_V3=y
+CONFIG_PWM=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+# CONFIG_DMIID is not set
+CONFIG_EFI_VARS=y
+CONFIG_EFI_BOOTLOADER_CONTROL=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_OVERLAY_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_HUGETLBFS=y
+CONFIG_EFIVAR_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V4=y
+CONFIG_9P_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_FS=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_FTRACE is not set
+CONFIG_ASYNC_TX_TEST=y
+CONFIG_MEMTEST=y
+CONFIG_SECURITY=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_XCBC=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_SHA3=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_USER_API_AEAD=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
--- a/arch/arm64/include/asm/pci.h
+++ b/arch/arm64/include/asm/pci.h
@@ -23,6 +23,7 @@
  */
 #define PCI_DMA_BUS_IS_PHYS	(0)
 
+#define HAVE_PCI_MMAP
 #define ARCH_GENERIC_PCI_MMAP_RESOURCE	1
 
 extern int isa_dma_bridge_buggy;
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@ -839,8 +839,13 @@ static void ipi_cpu_stop(unsigned int cpu)
 
 	local_irq_disable();
 
+#ifdef CONFIG_HOTPLUG_CPU
+	if (cpu_ops[cpu]->cpu_die)
+		cpu_ops[cpu]->cpu_die(cpu);
+#else
 	while (1)
 		cpu_relax();
+#endif
 }
 
 #ifdef CONFIG_KEXEC_CORE
--- /dev/null
+++ b/brcm-genconfigs/README
@@ -0,0 +1,66 @@
+===========================================================
+Modifying the defconfig file:
+===========================================================
+
+If you need to modify the defconfig to add a new driver or option for an existing driver,
+please follow the below process:
+
+The following example uses arm64 based platform as an example, but the same tool also works for arm 32-bit platforms
+
+------------------------------
+Step 1: Add/Find the new CONFIG's
+------------------------------
+1.	From the Kernel directory run the below to create the '.config' file
+$ make ARCH=arm64 ns2_defconfig
+
+2.	Now run menuconfig to select the new driver/options
+$ make ARCH=arm64 menuconfig
+
+3.	Add the new options using the 'menuconfig', then save and exit the 'menuconfig'
+
+------------------------------
+Step 2: Save the new CONFIG changes
+--------------------------------
+4.	Create the minimal 'defconfig' with the new options (selected using 'menuconfig').
+$ make ARCH=arm64 savedefconfig
+
+The above will create a 'defconfig' file in the kernel directory with the minimal options selected.
+
+5.	Now merge the new CONFIG's in the 'defconfig' file (in Kernel directory) to the 'brcm-genconfigs/base-arm64.cfg'
+
+------------------------------
+Step 3: Create the new 'defconfig' files
+---------------------------------
+6.	From the kernel directory run the 'update_defconfig.sh' to create the 'defconfig' files.
+$ ./brcm-genconfigs/update_defconfig.sh
+
+This will create the default and the "ns2_defconfig" defconfig files in the 'arch/arm64/configs'
+folder updated with the new options from 'brcm-genconfigs/base-arm64.cfg'.
+
+Step 4: Submit the Changes
+7.	Add (git), commit (git) and submit (gerrit) the modified files in 'arch/arm64/configs' and 'brcm-genconfigs'.
+
+
+===========================================================
+Adding new snippet configurations
+===========================================================
+
+1. To add new snippet configurations add a .cfg file with the configurations.
+
+2. Modify the main() function in the update_defconfig.sh to add the new snippet combinations
+For example
+	do_update ns2_debug $ns2_debug_defconfig
+In the above:
+do_update - Command to combine the snipped .cfg files
+ns2_debug - This is the name of the new defconfig file to be created in arch/arm64/configs
+ns2_debug_defconfig - A variable defined in fragments.sh script that contains all the config
+  files (fragments) it requires. The variable should be the same name as the defconfig file.
+  Eg: ns2_debug_defconfig="base-arm64 debug"
+  See fragments.sh for more information.
+
+So the command combines 'base-arm64.cfg' and 'debug.cfg' to create 'ns2_debug_defconfig'
+file and stores in 'arch/arm64/configs'.
+
+If there is a new .cfg (eg: demo.cfg) then append it to the variable for the
+defconfig:
+ ns2_debug_defconfig="base-arm64 debug demo"
--- /dev/null
+++ b/brcm-genconfigs/ata.cfg
@@ -0,0 +1,7 @@
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_ATA=y
+CONFIG_SATA_AHCI=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_PATA_PLATFORM=y
+CONFIG_PATA_OF_PLATFORM=y
--- /dev/null
+++ b/brcm-genconfigs/base-arm32.cfg
@@ -0,0 +1,57 @@
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_NAMESPACES=y
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_CMDLINE_PARTITION=y
+CONFIG_ARCH_BCM=y
+CONFIG_AEABI=y
+# CONFIG_ATAGS is not set
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+CONFIG_KEXEC=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=5
+CONFIG_SERIAL_8250_RUNTIME_UARTS=5
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+# CONFIG_HWMON is not set
+CONFIG_PRINTK_TIME=y
+CONFIG_HIGHMEM=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_IPROC=y
+CONFIG_PREEMPT=y
+CONFIG_CMA=y
+CONFIG_DMA_CMA=y
--- /dev/null
+++ b/brcm-genconfigs/base-arm64.cfg
@@ -0,0 +1,78 @@
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_FHANDLE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_ARCH_BCM_IPROC=y
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_NR_CPUS=8
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_KSM=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_CMA=y
+CONFIG_ARM64_LSE_ATOMICS=y
+CONFIG_COMPAT=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_DMA_CMA=y
+# CONFIG_BCM_IPROC_DTE is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_PINCTRL_NS2_MUX is not set
+CONFIG_POWER_RESET_SYSCON=y
+# CONFIG_HWMON is not set
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_COMMON_CLK_XGENE is not set
+# CONFIG_CLK_BCM_NS2 is not set
+CONFIG_ARM_SMMU=y
+CONFIG_ARM_SMMU_V3=y
+# CONFIG_PHY_BRCM_SATA is not set
+# CONFIG_PHY_STINGRAY_PCIE is not set
+# CONFIG_PHY_STINGRAY_PCIE_PRBS is not set
+# CONFIG_PHY_STINGRAY_SATA_PRBS is not set
+# CONFIG_PHY_NS2_USB3 is not set
+# CONFIG_PHY_NS2_USB_DRD is not set
+# CONFIG_PHY_STINGRAY_USB is not set
+# CONFIG_PHY_NSP_USB3 is not set
+# CONFIG_DMIID is not set
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_PRINTK_TIME=y
--- /dev/null
+++ b/brcm-genconfigs/blk.cfg
@@ -0,0 +1,8 @@
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_CMDLINE_PARSER=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_BLK_DEV_NULL_BLK=m
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_SD=y
--- /dev/null
+++ b/brcm-genconfigs/bpf.cfg
@@ -0,0 +1,2 @@
+CONFIG_BPF_SYSCALL=y
+CONFIG_KPROBES=y
--- /dev/null
+++ b/brcm-genconfigs/bt.cfg
@@ -0,0 +1,2 @@
+CONFIG_BCM_RFKILL=y
+CONFIG_RFKILL=y
--- /dev/null
+++ b/brcm-genconfigs/camera.cfg
@@ -0,0 +1,4 @@
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_PLATFORM=y
+CONFIG_SOC_CAMERA_OV5640=y
--- /dev/null
+++ b/brcm-genconfigs/clocksource.cfg
@@ -0,0 +1,4 @@
+CONFIG_CLKSRC_OF=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+CONFIG_ARM_TIMER_SP804=y
--- /dev/null
+++ b/brcm-genconfigs/crashdump.cfg
@@ -0,0 +1,2 @@
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
--- /dev/null
+++ b/brcm-genconfigs/crypto.cfg
@@ -0,0 +1,25 @@
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_XCBC=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_SHA3=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_USER_API_AEAD=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
--- /dev/null
+++ b/brcm-genconfigs/cygnus.cfg
@@ -0,0 +1,2 @@
+CONFIG_ARCH_BCM_CYGNUS=y
+# CONFIG_SMP is not set
--- /dev/null
+++ b/brcm-genconfigs/dbg.cfg
@@ -0,0 +1,14 @@
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_FS=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_FTRACE is not set
+CONFIG_MEMTEST=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_ASYNC_TX_TEST=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_PM_DEBUG=y
+CONFIG_SERIAL_8250_EARLYLOG=y
--- /dev/null
+++ b/brcm-genconfigs/dma.cfg
@@ -0,0 +1,6 @@
+CONFIG_DMADEVICES=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+CONFIG_ASYNC_TX_DMA=y
+CONFIG_DMATEST=m
+CONFIG_PL330_DMA=y
--- /dev/null
+++ b/brcm-genconfigs/drm.cfg
@@ -0,0 +1,6 @@
+CONFIG_DRM=y
+CONFIG_DRM_PL111=y
+CONFIG_DRM_PANEL_WINTEK_WD_F6448X_EFLWC=y
+CONFIG_DRM_FBDEV_EMULATION=y
+CONFIG_DRM_FBDEV_OVERALLOC=200
+CONFIG_DRM_VC4=y
--- /dev/null
+++ b/brcm-genconfigs/dte.cfg
@@ -0,0 +1 @@
+CONFIG_BCM_IPROC_DTE=y
--- /dev/null
+++ b/brcm-genconfigs/efi.cfg
@@ -0,0 +1,3 @@
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_VARS=y
+CONFIG_EFI_BOOTLOADER_CONTROL=y
--- /dev/null
+++ b/brcm-genconfigs/fragments.sh
@@ -0,0 +1,58 @@
+#!/bin/sh
+
+# All supported defconfigs. Add new defconfigs to list for the proper
+# architecture.
+arm_defconfigs="bcm_cygnus_defconfig"
+arm64_defconfigs="iproc_defconfig bcm_omega_defconfig"
+
+# Defines the fragments that apply to each defconfig. Variable name must be the
+# same as the defconfig file.
+bcm_cygnus_defconfig="base-arm32 cygnus  \
+    blk bt camera                        \
+    dbg dma drm dte                      \
+    fs i2c                               \
+    iio                                  \
+    input                                \
+    lcd mailbox media misc mmc mtd       \
+    net                                  \
+    optee                                \
+    pci pwm                              \
+    regulator rng                        \
+    sound spi stmpe trace                \
+    usb usbd                             \
+    watchdog wifi                        \
+    "
+
+bcm_omega_defconfig="base-arm64          \
+    blk bt                               \
+    clocksource                          \
+    dbg dma dte                          \
+    fs i2c                               \
+    iio                                  \
+    input iomux                          \
+    lcd mailbox media misc mmc mtd       \
+    net                                  \
+    optee                                \
+    pwm                                  \
+    regulator rng                        \
+    sound spi stmpe trace                \
+    usb usbd                             \
+    watchdog wifi"
+
+iproc_defconfig="base-arm64 ns2 stingray \
+    ata blk bpf                          \
+    clocksource crypto crashdump         \
+    dbg dma                              \
+    efi fs hba hwmon                     \
+    i2c i2c-slave infiniband iomux       \
+    iscsi                                \
+    mailbox md misc mmc mtd mtd-spi      \
+    net nvme                             \
+    optee                                \
+    pci perf profiling pwm               \
+    regulator rng rtc                    \
+    spi                                  \
+    tc                                   \
+    tmon                                 \
+    uio usb usbd                         \
+    vfio watchdog virtio"
--- /dev/null
+++ b/brcm-genconfigs/fs.cfg
@@ -0,0 +1,25 @@
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_OVERLAY_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_HUGETLBFS=y
+CONFIG_EFIVAR_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+CONFIG_9P_FS=y
+CONFIG_SECURITY=y
--- /dev/null
+++ b/brcm-genconfigs/hba.cfg
@@ -0,0 +1,2 @@
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_SCSI_MPT3SAS=y
--- /dev/null
+++ b/brcm-genconfigs/hwmon.cfg
@@ -0,0 +1,2 @@
+CONFIG_HWMON=y
+CONFIG_SENSORS_LM90=y
--- /dev/null
+++ b/brcm-genconfigs/i2c-slave.cfg
@@ -0,0 +1,3 @@
+CONFIG_I2C_SLAVE=y
+CONFIG_I2C_SLAVE_EEPROM=y
+CONFIG_I2C_SLAVE_BMC=m
--- /dev/null
+++ b/brcm-genconfigs/i2c.cfg
@@ -0,0 +1,3 @@
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_STUB=m
--- /dev/null
+++ b/brcm-genconfigs/iio.cfg
@@ -0,0 +1 @@
+CONFIG_IIO=y
--- /dev/null
+++ b/brcm-genconfigs/infiniband.cfg
@@ -0,0 +1,4 @@
+CONFIG_DCB=y
+CONFIG_INFINIBAND=y
+CONFIG_INFINIBAND_USER_MAD=y
+CONFIG_INFINIBAND_USER_ACCESS=y
--- /dev/null
+++ b/brcm-genconfigs/input.cfg
@@ -0,0 +1,6 @@
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_INPUT_MOUSE=y
+CONFIG_INPUT_TOUCHSCREEN=y
--- /dev/null
+++ b/brcm-genconfigs/iomux.cfg
@@ -0,0 +1 @@
+CONFIG_PINCTRL_SINGLE=y
--- /dev/null
+++ b/brcm-genconfigs/iscsi.cfg
@@ -0,0 +1,3 @@
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_ISCSI_TCP=y
+CONFIG_SCSI_ISCSI_ATTRS=y
--- /dev/null
+++ b/brcm-genconfigs/lcd.cfg
@@ -0,0 +1,10 @@
+CONFIG_FB=y
+CONFIG_FB_ARMCLCD=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_LOGO=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_BACKLIGHT_PWM=y
--- /dev/null
+++ b/brcm-genconfigs/mailbox.cfg
@@ -0,0 +1 @@
+CONFIG_MAILBOX=y
--- /dev/null
+++ b/brcm-genconfigs/md.cfg
@@ -0,0 +1,8 @@
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+CONFIG_MD_RAID10=y
+CONFIG_MD_RAID456=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
--- /dev/null
+++ b/brcm-genconfigs/media.cfg
@@ -0,0 +1,2 @@
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
--- /dev/null
+++ b/brcm-genconfigs/misc.cfg
@@ -0,0 +1,4 @@
+CONFIG_EEPROM_AT25=m
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCF857X=y
+CONFIG_MFD_SYSCON=y
--- /dev/null
+++ b/brcm-genconfigs/mmc.cfg
@@ -0,0 +1,5 @@
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_IPROC=y
--- /dev/null
+++ b/brcm-genconfigs/mtd-spi.cfg
@@ -0,0 +1,2 @@
+CONFIG_MTD_M25P80=m
+CONFIG_MTD_SPI_NOR=y
--- /dev/null
+++ b/brcm-genconfigs/mtd.cfg
@@ -0,0 +1,11 @@
+CONFIG_MTD=y
+CONFIG_MTD_TESTS=m
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_OF_PARTS=y
+CONFIG_MTD_NAND_ECC=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_BRCMNAND=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_LIMIT=20
--- /dev/null
+++ b/brcm-genconfigs/net.cfg
@@ -0,0 +1,58 @@
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=m
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
+CONFIG_BPF_JIT=y
+CONFIG_NETDEVICES=y
+CONFIG_OPENVSWITCH=m
+CONFIG_BONDING=m
+CONFIG_VXLAN=y
+CONFIG_TUN=y
+CONFIG_E1000E=y
+# CONFIG_WLAN is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V4=y
+CONFIG_NET_9P=y
+CONFIG_BROADCOM_PHY=y
--- /dev/null
+++ b/brcm-genconfigs/ns2.cfg
@@ -0,0 +1,6 @@
+CONFIG_PINCTRL_NS2_MUX=y
+CONFIG_CLK_BCM_NS2=y
+CONFIG_PHY_BRCM_SATA=y
+CONFIG_PHY_NS2_USB3=y
+CONFIG_PHY_NS2_USB_DRD=y
+CONFIG_BCM_PDC_MBOX=y
--- /dev/null
+++ b/brcm-genconfigs/nvme.cfg
@@ -0,0 +1,7 @@
+CONFIG_CONFIGFS_FS=y
+CONFIG_BLK_DEV_NVME=y
+CONFIG_NVME_RDMA=m
+CONFIG_NVME_LPM_BACKUP=m
+CONFIG_NVME_TARGET=m
+CONFIG_NVME_TARGET_LOOP=m
+CONFIG_NVME_TARGET_RDMA=m
--- /dev/null
+++ b/brcm-genconfigs/optee.cfg
@@ -0,0 +1,2 @@
+CONFIG_TEE=y
+CONFIG_OPTEE=y
--- /dev/null
+++ b/brcm-genconfigs/pci.cfg
@@ -0,0 +1,7 @@
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCI_DEBUG=y
+CONFIG_PCI_IOV=y
+CONFIG_HOTPLUG_PCI=y
+CONFIG_PCIEAER_INJECT=m
--- /dev/null
+++ b/brcm-genconfigs/perf.cfg
@@ -0,0 +1 @@
+CONFIG_ARM_CCN=y
--- /dev/null
+++ b/brcm-genconfigs/profiling.cfg
@@ -0,0 +1 @@
+CONFIG_PROFILING=y
--- /dev/null
+++ b/brcm-genconfigs/pwm.cfg
@@ -0,0 +1 @@
+CONFIG_PWM=y
--- /dev/null
+++ b/brcm-genconfigs/regulator.cfg
@@ -0,0 +1,3 @@
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_GPIO=y
--- /dev/null
+++ b/brcm-genconfigs/rng.cfg
@@ -0,0 +1,2 @@
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_IPROC_RNG200=y
--- /dev/null
+++ b/brcm-genconfigs/rtc.cfg
@@ -0,0 +1 @@
+CONFIG_RTC_CLASS=y
--- /dev/null
+++ b/brcm-genconfigs/sound.cfg
@@ -0,0 +1,11 @@
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_ALOOP=m
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_CYGNUS=y
+CONFIG_SND_SOC_CYGNUS_AUD_BASE_MACHINE=y
+CONFIG_SND_SOC_CYGNUS_VOIPPHONE_MACHINE=y
+CONFIG_SND_SOC_CYGNUS_SVK_MACHINE=y
+CONFIG_SND_SOC_CYGNUS_AK4458_MACHINE=y
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=y
--- /dev/null
+++ b/brcm-genconfigs/spi.cfg
@@ -0,0 +1,3 @@
+CONFIG_SPI=y
+CONFIG_SPI_PL022=y
+CONFIG_SPI_SPIDEV=y
--- /dev/null
+++ b/brcm-genconfigs/stingray.cfg
@@ -0,0 +1,7 @@
+CONFIG_PINCTRL_IPROC_GPIO=y
+CONFIG_PHY_BRCM_SATA=y
+CONFIG_PHY_STINGRAY_PCIE=y
+CONFIG_PHY_STINGRAY_PCIE_PRBS=y
+CONFIG_PHY_STINGRAY_SATA_PRBS=y
+CONFIG_PHY_STINGRAY_USB=y
+# CONFIG_NET_BCM_AMAC is not set
--- /dev/null
+++ b/brcm-genconfigs/stmpe.cfg
@@ -0,0 +1,8 @@
+CONFIG_MFD_STMPE=y
+CONFIG_STMPE_SPI=y
+CONFIG_TOUCHSCREEN_STMPE=y
+CONFIG_GPIO_STMPE=y
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_STAGING=y
+CONFIG_FB_TFT=y
+CONFIG_FB_TFT_ILI9341=y
--- /dev/null
+++ b/brcm-genconfigs/tc.cfg
@@ -0,0 +1,44 @@
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NET_SCH_DEFAULT=y
+CONFIG_NET_CLS_BASIC=y
+CONFIG_NET_CLS_TCINDEX=y
+CONFIG_NET_CLS_ROUTE4=y
+CONFIG_NET_CLS_FW=y
+CONFIG_NET_CLS_U32=y
+CONFIG_CLS_U32_PERF=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=y
+CONFIG_NET_CLS_RSVP6=y
+CONFIG_NET_CLS_FLOW=y
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_CLS_BPF=y
+CONFIG_NET_CLS_FLOWER=y
+CONFIG_NET_CLS_MATCHALL=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_CMP=y
+CONFIG_NET_EMATCH_NBYTE=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_EMATCH_META=y
+CONFIG_NET_EMATCH_TEXT=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_NET_ACT_SAMPLE=y
+CONFIG_NET_ACT_IPT=m
+CONFIG_NET_ACT_NAT=y
+CONFIG_NET_ACT_PEDIT=y
+CONFIG_NET_ACT_SIMP=y
+CONFIG_NET_ACT_SKBEDIT=y
+CONFIG_NET_ACT_CSUM=y
+CONFIG_NET_ACT_VLAN=y
+CONFIG_NET_ACT_BPF=y
+CONFIG_NET_ACT_SKBMOD=y
+CONFIG_NET_ACT_TUNNEL_KEY=y
+CONFIG_NET_CLS_IND=y
+CONFIG_NET_SWITCHDEV=y
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_DEVLINK=y
--- /dev/null
+++ b/brcm-genconfigs/tmon.cfg
@@ -0,0 +1,2 @@
+CONFIG_THERMAL=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
--- /dev/null
+++ b/brcm-genconfigs/trace.cfg
@@ -0,0 +1,10 @@
+CONFIG_FTRACE=y
+CONFIG_KPROBES=y
+CONFIG_IRQSOFF_TRACER=y
+CONFIG_SCHED_TRACER=y
+CONFIG_HWLAT_TRACER=y
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_FUNCTION_PROFILER=y
+CONFIG_TRACE_ENUM_MAP_FILE=y
--- /dev/null
+++ b/brcm-genconfigs/uio.cfg
@@ -0,0 +1,3 @@
+CONFIG_UIO=y
+CONFIG_UIO_PDRV_GENIRQ=y
+CONFIG_UIO_DMEM_GENIRQ=y
--- /dev/null
+++ b/brcm-genconfigs/update_defconfig.sh
@@ -0,0 +1,164 @@
+#!/bin/bash
+#*****************************************************************************
+#  Copyright 2014-2015 Broadcom Corporation.  All rights reserved.
+#
+#  Unless you and Broadcom execute a separate written software license
+#  agreement governing use of this software, this software is licensed to you
+#  under the terms of the GNU General Public License version 2, available at
+#  http://www.gnu.org/licenses/old-license/gpl-2.0.html (the "GPL").
+#
+#  Notwithstanding the above, under no circumstances may you combine this
+#  software in any way with any other Broadcom software provided under a
+#  license other than the GPL, without Broadcom's express prior written
+#  consent.
+#
+#*****************************************************************************
+
+#*****************************************************************************
+##
+#  @file    update_defconfig.sh
+#
+#  @brief   Script to update the defconfig files based on the config bits
+#           located in this directory.
+#
+#  @note    Usage: ./brcm-genconfigs/update_defconfig.sh
+#
+#*****************************************************************************
+
+# ---- Private Variables -----------------------------------------------------
+
+#*****************************************************************************
+###
+#  @brief   Verbose flag
+#
+#  @note    Call with V=1 to debug this script.
+#
+#*****************************************************************************
+V=${V-0}
+
+#*****************************************************************************
+###
+#  @brief   Linux Architecture name
+#
+#  default to arm64
+#
+#*****************************************************************************
+ARCH64=arm64
+ARCH32=arm
+
+#*****************************************************************************
+###
+#  @brief   SEARCH_PATH
+#
+#  @note    Where to search for config files (in order of precedence)
+#
+#*****************************************************************************
+declare -a SEARCH_PATH=(
+	brcm-genconfigs
+)
+
+# ==== Private Functions ============================================
+
+#*****************************************************************************
+###
+#  @brief   Entry point for the script.
+#
+#  @return  None
+#
+#  @note    The entry point is called at the end of the file, because we want
+#           Bash to parse the entire file before executing anything.
+#
+#*****************************************************************************
+main() {
+	local iproc_base
+	local iproc_extra
+
+	local script_dir="${BASH_SOURCE[0]%/*}"
+	. $script_dir/fragments.sh
+
+	# Show all commands (for debugging).
+	if [ $V -ne 0 ]; then
+		set -x
+	fi
+
+	# 64 bit platforms
+	# iproc_defconfig, for both NS2 and Stingray
+	# for uses when NS2/Stingray run standalone without NB host
+	do_update ${ARCH64} iproc $iproc_defconfig
+
+	#Cleanup 64 bit
+	make ARCH=${ARCH64} mrproper > /dev/null
+	if [ -e defconfig ]; then
+		rm defconfig
+	fi
+	echo "Done 64 bit."
+}
+
+#*****************************************************************************
+###
+#  @brief   Search config bits, call merge-config and save the defconfig.
+#
+#  @param   $1     Defconfig file name (without path or _defconfig)
+#  @param   $[2-*] Config bits file names (without path or .cfg)
+#
+#  @return  0 on success, 1 on error.
+#
+#*****************************************************************************
+do_update() {
+	local defcfg	# Destination file
+	local arg	# Argument iterator
+	local path	# Search path iterator
+	local tst	# Test path
+	local found	# File found flag
+	local -a bits	# Array of configuration files found.
+	local arch	# 32 or 64 bit architecture
+
+	if [ $# -lt 1 ]; then
+		echo "Error in $FUNCNAME: missing arguments!" >&2
+		return 1
+	fi
+
+	arch=${1}
+
+	defcfg=arch/$arch/configs/${2}_defconfig
+	shift
+
+	# shift again to take out the arch parameter
+	shift
+
+	for arg in $*; do
+		found=0
+		for path in ${SEARCH_PATH[@]}; do
+			tst=${path}/${arg}.cfg
+			if [ -r $tst ]; then
+				bits[${#bits[*]}]=$tst # Append to bits array
+				found=1
+				break
+			fi
+		done
+		if [ $found -ne 1 ]; then
+			echo "Error: cannot find config bits for $arg in \"$*\"" >&2
+			return 1
+		fi
+	done
+
+	if ARCH=$arch scripts/kconfig/merge_config.sh -m ${bits[@]}; then
+		if [ -e defconfig ]; then
+			rm defconfig
+		fi
+		echo "Creating minimal defconfig from .config"
+		echo "arch is $arch"
+		make ARCH=$arch savedefconfig
+		cp -v defconfig $defcfg # Save defconfig
+	else
+		return 1
+	fi
+	return 0
+}
+
+#*****************************************************************************
+##
+#  @brief   Entry (and exit) point for the script.
+#
+#*****************************************************************************
+main
--- /dev/null
+++ b/brcm-genconfigs/usb.cfg
@@ -0,0 +1,18 @@
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PLATFORM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_ACM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_CONSOLE=y
+CONFIG_USB_SERIAL_FTDI_SIO=y
+CONFIG_USB_SERIAL_PL2303=y
+CONFIG_USB_RTL8152=y
+CONFIG_USB_USBNET=y
--- /dev/null
+++ b/brcm-genconfigs/usbd.cfg
@@ -0,0 +1,6 @@
+CONFIG_USB_GADGET=y
+CONFIG_USB_BDC_UDC=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_ACM=y
--- /dev/null
+++ b/brcm-genconfigs/vfio.cfg
@@ -0,0 +1,6 @@
+CONFIG_VFIO=y
+CONFIG_VFIO_NOIOMMU=y
+CONFIG_VFIO_PLATFORM=y
+CONFIG_VFIO_PLATFORM_BCMFLEXRM_RESET=y
+CONFIG_VFIO_AMBA=y
+CONFIG_VFIO_PCI=y
--- /dev/null
+++ b/brcm-genconfigs/virtio.cfg
@@ -0,0 +1,12 @@
+CONFIG_NET_9P_VIRTIO=y
+CONFIG_VIRTIO_BLK=m
+CONFIG_VIRTIO_NET=m
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
+CONFIG_VIRTIO_MMIO=y
+CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
--- /dev/null
+++ b/brcm-genconfigs/watchdog.cfg
@@ -0,0 +1,3 @@
+CONFIG_WATCHDOG=y
+CONFIG_ARM_SP805_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
--- /dev/null
+++ b/brcm-genconfigs/wifi.cfg
@@ -0,0 +1,14 @@
+CONFIG_WLAN=y
+CONFIG_NETDEVICES=y
+CONFIG_WLAN_VENDOR_BROADCOM=y
+CONFIG_CFG80211=y
+# CONFIG_CFG80211_DEFAULT_PS is not set
+CONFIG_CFG80211_DEBUGFS=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=y
+CONFIG_MAC80211_RC_MINSTREL_VHT=y
+CONFIG_BRCMFMAC=m
+CONFIG_BRCMFMAC_PCIE=y
+CONFIG_BRCMDBG=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC_ITU_T=y
--- a/crypto/async_tx/Makefile
+++ b/crypto/async_tx/Makefile
@@ -5,3 +5,5 @@ obj-$(CONFIG_ASYNC_XOR) += async_xor.o
 obj-$(CONFIG_ASYNC_PQ) += async_pq.o
 obj-$(CONFIG_ASYNC_RAID6_RECOV) += async_raid6_recov.o
 obj-$(CONFIG_ASYNC_RAID6_TEST) += raid6test.o
+obj-$(CONFIG_ASYNC_TX_TEST) += async_tx_test.o
+
--- /dev/null
+++ b/crypto/async_tx/async_tx_test.c
@@ -0,0 +1,1184 @@
+/*
+ * Copyright (C) 2017 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/async_tx.h>
+#include <linux/completion.h>
+#include <linux/gfp.h>
+#include <linux/kthread.h>
+#include <linux/math64.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/raid/pq.h>
+#include <linux/sched/task.h>
+#include <linux/slab.h>
+
+#undef pr
+#define pr(fmt, args...) pr_info("async_tx_test: " fmt, ##args)
+
+#undef pr_err
+#define pr_err(fmt, args...) pr_info("async_tx_test: error: " fmt, ##args)
+
+#define MIN_BLOCK_SIZE	8
+#define MAX_BLOCK_SIZE	PAGE_SIZE
+#define MIN_DISKS	2
+#define MAX_DISKS	253
+
+static unsigned int thread_count = 1;
+module_param(thread_count, uint, 0644);
+MODULE_PARM_DESC(thread_count,
+"Number of threads, Should be atleast 1");
+
+static unsigned int disk_block_size = PAGE_SIZE;
+module_param(disk_block_size, uint, 0644);
+MODULE_PARM_DESC(disk_block_size,
+"Size of disk block, Should be between 8 to PAGE_SIZE and multiple of 8");
+
+static unsigned int disk_count = 4;
+module_param(disk_count, uint, 0644);
+MODULE_PARM_DESC(disk_count,
+"Number of test disks, Should be between 2 to 256");
+
+static unsigned int request_count = 1;
+module_param(request_count, uint, 0644);
+MODULE_PARM_DESC(request_count,
+"Number of request submitted in one iteration, Should be atleast 1");
+
+static unsigned int iteration_count = 1;
+module_param(iteration_count, uint, 0644);
+MODULE_PARM_DESC(iteration_count,
+"Number of iterations, Should be atleast 1");
+
+static int async_tx_test_type_set(const char *val,
+				 const struct kernel_param *kp);
+static int async_tx_test_type_get(char *val,
+				 const struct kernel_param *kp);
+static const struct kernel_param_ops type_ops = {
+	.set = async_tx_test_type_set,
+	.get = async_tx_test_type_get,
+};
+static char test_type[20] = "pq";
+module_param_cb(type, &type_ops, test_type, 0644);
+MODULE_PARM_DESC(type, "Type of test (default: pq)");
+
+static bool verbose;
+module_param(verbose, bool, 0644);
+MODULE_PARM_DESC(verbose, "Print more info (default: off)");
+
+static int async_tx_test_run_set(const char *val,
+				 const struct kernel_param *kp);
+static int async_tx_test_run_get(char *val,
+				 const struct kernel_param *kp);
+static const struct kernel_param_ops run_ops = {
+	.set = async_tx_test_run_set,
+	.get = async_tx_test_run_get,
+};
+static bool test_run;
+module_param_cb(run, &run_ops, &test_run, 0644);
+MODULE_PARM_DESC(run, "Run the test (default: false)");
+
+static DEFINE_MUTEX(test_lock);
+
+struct async_tx_test;
+
+struct async_tx_test_request {
+	unsigned int num;
+	struct async_tx_test *test;
+	struct page *disk[MAX_DISKS+2];
+	struct page *p;
+	struct page *q;
+	addr_conv_t addr_conv[MAX_DISKS+2];
+};
+
+struct async_tx_test_ops {
+	char name[20];
+	unsigned int min_disk_count;
+	unsigned int max_disk_count;
+	unsigned int (*io_size)(struct async_tx_test *test);
+	int (*prep_input)(struct async_tx_test_request *req);
+	int (*prep_output)(struct async_tx_test_request *req);
+	int (*submit)(struct async_tx_test_request *req);
+	int (*verify_output)(struct async_tx_test_request *req);
+	void (*cleanup)(struct async_tx_test_request *req);
+};
+
+struct async_tx_test {
+	/* Test parameters */
+	bool verbose;
+	unsigned int thread_count;
+	unsigned int block_size;
+	unsigned int disk_count;
+	unsigned int request_count;
+	unsigned int iteration_count;
+	struct async_tx_test_ops *ops;
+	/* Test iteration data */
+	struct completion *done;
+	struct async_tx_test_request *reqs;
+	ktime_t iter_start_ktime;
+	s64 iter_runtime_usecs;
+	atomic_t iter_done_count;
+	struct completion iter_done;
+	/* Test thread data */
+	unsigned int num;
+	struct task_struct *task;
+	unsigned long long min_KBs;
+	unsigned long long max_KBs;
+	unsigned long long avg_KBs;
+	unsigned long long min_IOPs;
+	unsigned long long max_IOPs;
+	unsigned long long avg_IOPs;
+	atomic_t *done_count;
+};
+
+static unsigned long long async_tx_test_persec(s64 runtime, unsigned int val)
+{
+	unsigned long long per_sec = 1000000;
+
+	if (runtime <= 0)
+		return 0;
+
+	/* drop precision until runtime is 32-bits */
+	while (runtime > UINT_MAX) {
+		runtime >>= 1;
+		per_sec <<= 1;
+	}
+
+	per_sec *= val;
+	do_div(per_sec, runtime);
+	return per_sec;
+}
+
+static void async_tx_test_callback(void *param)
+{
+	struct async_tx_test_request *req = param;
+	struct async_tx_test *test;
+
+	if (!req || !req->test)
+		return;
+	test = req->test;
+
+	if (atomic_dec_return(&test->iter_done_count))
+		return;
+
+	if (!test->iter_runtime_usecs)
+		test->iter_runtime_usecs =
+			ktime_us_delta(ktime_get(), test->iter_start_ktime);
+
+	complete(&test->iter_done);
+}
+
+#define ASYNC_TX_TEST_REF0	0xa5a5a5a5a5a5a5a5ULL
+#define ASYNC_TX_TEST_REF1	0x5a5a5a5a5a5a5a5aULL
+#define ASYNC_TX_TEST_REF2	0x1020304050607080ULL
+#define ASYNC_TX_TEST_REF3	0x1122334455667788ULL
+
+static u64 async_tx_test_ref64(unsigned int disk_num)
+{
+	switch (disk_num & 0x3) {
+	case 0:
+		return ASYNC_TX_TEST_REF0;
+	case 1:
+		return ASYNC_TX_TEST_REF1;
+	case 2:
+		return ASYNC_TX_TEST_REF2;
+	case 3:
+		return ASYNC_TX_TEST_REF3;
+	}
+
+	return 0;
+}
+
+u64 async_tx_test_gfmul64(int pos, u64 val)
+{
+	u64 ret = 0x0;
+	u8 coef = raid6_gfexp[pos];
+	u8 *valp = (u8 *)&val;
+	u8 *retp = (u8 *)&ret;
+	const u8 *mul_table = raid6_gfmul[coef];
+
+	retp[0] = mul_table[valp[0]];
+	retp[1] = mul_table[valp[1]];
+	retp[2] = mul_table[valp[2]];
+	retp[3] = mul_table[valp[3]];
+	retp[4] = mul_table[valp[4]];
+	retp[5] = mul_table[valp[5]];
+	retp[6] = mul_table[valp[6]];
+	retp[7] = mul_table[valp[7]];
+
+	return ret;
+}
+
+static void async_tx_test_dummy_cleanup(struct async_tx_test_request *req)
+{
+	/* Nothing to do here. */
+}
+
+static unsigned int memcpy_test_io_size(struct async_tx_test *test)
+{
+	return test->block_size;
+}
+
+static int memcpy_test_prep_input(struct async_tx_test_request *req)
+{
+	u64 *data;
+	unsigned int i;
+	struct async_tx_test *test = req->test;
+	u64 ref = async_tx_test_ref64(req->num);
+
+	data = (u64 *)page_address(req->disk[0]);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		data[i] = ref;
+
+	return 0;
+}
+
+static int memcpy_test_prep_output(struct async_tx_test_request *req)
+{
+	struct async_tx_test *test = req->test;
+
+	memset(page_address(req->p), 0, test->block_size);
+
+	return 0;
+}
+
+static int memcpy_test_submit(struct async_tx_test_request *req)
+{
+	struct async_submit_ctl submit;
+	struct dma_async_tx_descriptor *tx;
+	struct async_tx_test *test = req->test;
+
+	init_async_submit(&submit, ASYNC_TX_ACK, NULL,
+			  async_tx_test_callback, req, req->addr_conv);
+	tx = async_memcpy(req->p, req->disk[0], 0, 0,
+			  test->block_size, &submit);
+	async_tx_issue_pending(tx);
+
+	return 0;
+}
+
+static int memcpy_test_verify_output(struct async_tx_test_request *req)
+{
+	u64 *data;
+	unsigned int i;
+	struct async_tx_test *test = req->test;
+	u64 out_ref = async_tx_test_ref64(req->num);
+
+	data = (u64 *)page_address(req->p);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		if (data[i] != out_ref)
+			return 0;
+
+	return 1;
+}
+
+static unsigned int xor_test_io_size(struct async_tx_test *test)
+{
+	return test->block_size * test->disk_count;
+}
+
+static int xor_test_prep_input(struct async_tx_test_request *req)
+{
+	u64 *data;
+	unsigned int i, j;
+	struct async_tx_test *test = req->test;
+
+	for (i = 0; i < test->disk_count; i++) {
+		data = (u64 *)page_address(req->disk[i]);
+		for (j = 0; j < test->block_size / sizeof(u64); j++)
+			data[j] = async_tx_test_ref64(i);
+	}
+
+	return 0;
+}
+
+static int xor_test_prep_output(struct async_tx_test_request *req)
+{
+	struct async_tx_test *test = req->test;
+
+	memset(page_address(req->p), 0, test->block_size);
+
+	return 0;
+}
+
+static int xor_test_submit(struct async_tx_test_request *req)
+{
+	struct async_submit_ctl submit;
+	struct dma_async_tx_descriptor *tx;
+	struct async_tx_test *test = req->test;
+
+	init_async_submit(&submit, ASYNC_TX_ACK, NULL,
+			  async_tx_test_callback, req, req->addr_conv);
+	tx = async_xor(req->p, req->disk, 0, test->disk_count,
+		       test->block_size, &submit);
+	async_tx_issue_pending(tx);
+
+	return 0;
+}
+
+static int xor_test_verify_output(struct async_tx_test_request *req)
+{
+	u64 *data;
+	u64 out_ref;
+	unsigned int i;
+	struct async_tx_test *test = req->test;
+
+	out_ref = 0x0;
+	for (i = 0; i < test->disk_count; i++)
+		out_ref = out_ref ^ async_tx_test_ref64(i);
+
+	data = (u64 *)page_address(req->p);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		if (data[i] != out_ref)
+			return 0;
+
+	return 1;
+}
+
+static unsigned int pq_test_io_size(struct async_tx_test *test)
+{
+	return test->block_size * test->disk_count;
+}
+
+static int pq_test_prep_input(struct async_tx_test_request *req)
+{
+	u64 *data;
+	unsigned int i, j;
+	struct async_tx_test *test = req->test;
+
+	for (i = 0; i < test->disk_count; i++) {
+		data = (u64 *)page_address(req->disk[i]);
+		for (j = 0; j < test->block_size / sizeof(u64); j++)
+			data[j] = async_tx_test_ref64(i);
+	}
+
+	return 0;
+}
+
+static int pq_test_prep_output(struct async_tx_test_request *req)
+{
+	struct async_tx_test *test = req->test;
+
+	memset(page_address(req->p), 0, test->block_size);
+	memset(page_address(req->q), 0, test->block_size);
+
+	return 0;
+}
+
+static int pq_test_submit(struct async_tx_test_request *req)
+{
+	struct async_submit_ctl submit;
+	struct dma_async_tx_descriptor *tx;
+	struct async_tx_test *test = req->test;
+
+	init_async_submit(&submit, ASYNC_TX_ACK, NULL,
+			  async_tx_test_callback, req, req->addr_conv);
+	tx = async_gen_syndrome(req->disk, 0, test->disk_count + 2,
+				test->block_size, &submit);
+	async_tx_issue_pending(tx);
+
+	return 0;
+}
+
+static int pq_test_verify_output(struct async_tx_test_request *req)
+{
+	u64 *data;
+	unsigned int i;
+	u64 ref, out_ref, out_gf_ref;
+	struct async_tx_test *test = req->test;
+
+	out_ref = out_gf_ref = 0x0;
+	for (i = 0; i < test->disk_count; i++) {
+		ref = async_tx_test_ref64(i);
+		out_ref = out_ref ^ ref;
+		out_gf_ref = out_gf_ref ^ async_tx_test_gfmul64(i, ref);
+	}
+
+	data = (u64 *)page_address(req->p);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		if (data[i] != out_ref)
+			return 0;
+
+	data = (u64 *)page_address(req->q);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		if (data[i] != out_gf_ref)
+			return 0;
+
+	return 1;
+}
+
+#define UPDATE_PQ_DISKS		16
+#define UPDATE_PQ_OLD_DATA	0
+#define UPDATE_PQ_NEW_DATA	1
+#define UPDATE_PQ_P		2
+#define UPDATE_PQ_Q		3
+
+static unsigned int update_pq_test_io_size(struct async_tx_test *test)
+{
+	return test->block_size * 4;
+}
+
+static int update_pq_test_prep_input(struct async_tx_test_request *req)
+{
+	u64 *data;
+	unsigned int i;
+	struct async_tx_test *test = req->test;
+
+	data = (u64 *)page_address(req->disk[UPDATE_PQ_OLD_DATA]);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		data[i] = async_tx_test_ref64(UPDATE_PQ_OLD_DATA);
+
+	data = (u64 *)page_address(req->disk[UPDATE_PQ_NEW_DATA]);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		data[i] = async_tx_test_ref64(UPDATE_PQ_NEW_DATA);
+
+	return 0;
+}
+
+static int update_pq_test_prep_output(struct async_tx_test_request *req)
+{
+	u64 *data;
+	unsigned int i;
+	struct async_tx_test *test = req->test;
+
+	data = (u64 *)page_address(req->p);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		data[i] = async_tx_test_ref64(UPDATE_PQ_P);
+
+	data = (u64 *)page_address(req->q);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		data[i] = async_tx_test_ref64(UPDATE_PQ_Q);
+
+	return 0;
+}
+
+static int update_pq_test_submit(struct async_tx_test_request *req)
+{
+	int i, pos = req->num % UPDATE_PQ_DISKS;
+	struct async_submit_ctl submit;
+	struct dma_async_tx_descriptor *tx;
+	struct async_tx_test *test = req->test;
+	struct page *srcs[UPDATE_PQ_DISKS + 2];
+
+	for (i = 0; i < UPDATE_PQ_DISKS; i++)
+		srcs[i] = NULL;
+
+	srcs[pos] = req->disk[UPDATE_PQ_OLD_DATA];
+	srcs[UPDATE_PQ_DISKS] = req->p;
+	srcs[UPDATE_PQ_DISKS + 1] = req->q;
+
+	init_async_submit(&submit, ASYNC_TX_PQ_XOR_DST, NULL,
+			  NULL, NULL, req->addr_conv);
+	tx = async_gen_syndrome(srcs, 0, UPDATE_PQ_DISKS + 2,
+				test->block_size, &submit);
+
+	srcs[pos] = req->disk[UPDATE_PQ_NEW_DATA];
+
+	init_async_submit(&submit, ASYNC_TX_PQ_XOR_DST|ASYNC_TX_ACK, tx,
+			  async_tx_test_callback, req, req->addr_conv);
+	tx = async_gen_syndrome(srcs, 0, UPDATE_PQ_DISKS + 2,
+				test->block_size, &submit);
+
+	async_tx_issue_pending(tx);
+
+	return 0;
+}
+
+static int update_pq_test_verify_output(struct async_tx_test_request *req)
+{
+	u64 *data;
+	u64 ref, out_ref, out_gf_ref;
+	int i, pos = req->num % UPDATE_PQ_DISKS;
+	struct async_tx_test *test = req->test;
+
+	out_ref = async_tx_test_ref64(UPDATE_PQ_P);
+	out_gf_ref = async_tx_test_ref64(UPDATE_PQ_Q);
+
+	ref = async_tx_test_ref64(UPDATE_PQ_OLD_DATA);
+	out_ref = out_ref ^ ref;
+	out_gf_ref = out_gf_ref ^ async_tx_test_gfmul64(pos, ref);
+
+	ref = async_tx_test_ref64(UPDATE_PQ_NEW_DATA);
+	out_ref = out_ref ^ ref;
+	out_gf_ref = out_gf_ref ^ async_tx_test_gfmul64(pos, ref);
+
+	data = (u64 *)page_address(req->p);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		if (data[i] != out_ref)
+			return 0;
+
+	data = (u64 *)page_address(req->q);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		if (data[i] != out_gf_ref)
+			return 0;
+
+	return 1;
+}
+
+static unsigned int recov_datap_test_io_size(struct async_tx_test *test)
+{
+	return test->block_size * test->disk_count;
+}
+
+static int recov_datap_test_prep_input(struct async_tx_test_request *req)
+{
+	u64 *data;
+	unsigned int i, j;
+	u64 ref, out_ref, out_gf_ref;
+	struct async_tx_test *test = req->test;
+
+	out_ref = out_gf_ref = 0x0;
+	for (i = 0; i < test->disk_count; i++) {
+		ref = async_tx_test_ref64(i);
+		out_ref = out_ref ^ ref;
+		out_gf_ref = out_gf_ref ^ async_tx_test_gfmul64(i, ref);
+		data = (u64 *)page_address(req->disk[i]);
+		for (j = 0; j < test->block_size / sizeof(u64); j++)
+			data[j] = ref;
+	}
+
+	data = (u64 *)page_address(req->p);
+	for (j = 0; j < test->block_size / sizeof(u64); j++)
+		data[j] = out_ref;
+
+	data = (u64 *)page_address(req->q);
+	for (j = 0; j < test->block_size / sizeof(u64); j++)
+		data[j] = out_gf_ref;
+
+	return 0;
+}
+
+static int recov_datap_test_prep_output(struct async_tx_test_request *req)
+{
+	struct async_tx_test *test = req->test;
+	unsigned int faila = req->num % test->disk_count;
+
+	memset(page_address(req->p), 0, test->block_size);
+	memset(page_address(req->disk[faila]), 0, test->block_size);
+
+	return 0;
+}
+
+static int recov_datap_test_submit(struct async_tx_test_request *req)
+{
+	struct async_submit_ctl submit;
+	struct dma_async_tx_descriptor *tx;
+	struct async_tx_test *test = req->test;
+	unsigned int faila = req->num % test->disk_count;
+
+	init_async_submit(&submit, ASYNC_TX_ACK, NULL,
+			  async_tx_test_callback, req, req->addr_conv);
+	tx = async_raid6_datap_recov(test->disk_count + 2, test->block_size,
+				     faila, req->disk, &submit);
+	async_tx_issue_pending(tx);
+
+	return 0;
+}
+
+static int recov_datap_test_verify_output(struct async_tx_test_request *req)
+{
+	u64 *data;
+	unsigned int i;
+	u64 ref, out_ref, out_data_ref;
+	struct async_tx_test *test = req->test;
+	unsigned int faila = req->num % test->disk_count;
+
+	out_ref = 0x0;
+	for (i = 0; i < test->disk_count; i++) {
+		ref = async_tx_test_ref64(i);
+		out_ref = out_ref ^ ref;
+	}
+	out_data_ref = async_tx_test_ref64(faila);
+
+	data = (u64 *)page_address(req->p);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		if (data[i] != out_ref)
+			return 0;
+
+	data = (u64 *)page_address(req->disk[faila]);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		if (data[i] != out_data_ref)
+			return 0;
+
+	return 1;
+}
+
+static unsigned int recov_2data_test_io_size(struct async_tx_test *test)
+{
+	return test->block_size * test->disk_count;
+}
+
+static int recov_2data_test_prep_input(struct async_tx_test_request *req)
+{
+	u64 *data;
+	unsigned int i, j;
+	u64 ref, out_ref, out_gf_ref;
+	struct async_tx_test *test = req->test;
+
+	out_ref = out_gf_ref = 0x0;
+	for (i = 0; i < test->disk_count; i++) {
+		ref = async_tx_test_ref64(i);
+		out_ref = out_ref ^ ref;
+		out_gf_ref = out_gf_ref ^ async_tx_test_gfmul64(i, ref);
+		data = (u64 *)page_address(req->disk[i]);
+		for (j = 0; j < test->block_size / sizeof(u64); j++)
+			data[j] = ref;
+	}
+
+	data = (u64 *)page_address(req->p);
+	for (j = 0; j < test->block_size / sizeof(u64); j++)
+		data[j] = out_ref;
+
+	data = (u64 *)page_address(req->q);
+	for (j = 0; j < test->block_size / sizeof(u64); j++)
+		data[j] = out_gf_ref;
+
+	return 0;
+}
+
+static int recov_2data_test_prep_output(struct async_tx_test_request *req)
+{
+	struct async_tx_test *test = req->test;
+	unsigned int faila = req->num % test->disk_count;
+	unsigned int failb = (req->num + 1) % test->disk_count;
+
+	memset(page_address(req->disk[faila]), 0, test->block_size);
+	memset(page_address(req->disk[failb]), 0, test->block_size);
+
+	return 0;
+}
+
+static int recov_2data_test_submit(struct async_tx_test_request *req)
+{
+	struct async_submit_ctl submit;
+	struct dma_async_tx_descriptor *tx;
+	struct async_tx_test *test = req->test;
+	unsigned int faila = req->num % test->disk_count;
+	unsigned int failb = (req->num + 1) % test->disk_count;
+
+	init_async_submit(&submit, ASYNC_TX_ACK, NULL,
+			  async_tx_test_callback, req, req->addr_conv);
+	tx = async_raid6_2data_recov(test->disk_count + 2, test->block_size,
+				     faila, failb, req->disk, &submit);
+	async_tx_issue_pending(tx);
+
+	return 0;
+}
+
+static int recov_2data_test_verify_output(struct async_tx_test_request *req)
+{
+	u64 *data;
+	unsigned int i;
+	u64 out_data_ref, out_data1_ref;
+	struct async_tx_test *test = req->test;
+	unsigned int faila = req->num % test->disk_count;
+	unsigned int failb = (req->num + 1) % test->disk_count;
+
+	out_data_ref = async_tx_test_ref64(faila);
+	out_data1_ref = async_tx_test_ref64(failb);
+
+	data = (u64 *)page_address(req->disk[faila]);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		if (data[i] != out_data_ref)
+			return 0;
+
+	data = (u64 *)page_address(req->disk[failb]);
+	for (i = 0; i < test->block_size / sizeof(u64); i++)
+		if (data[i] != out_data1_ref)
+			return 0;
+
+	return 1;
+}
+
+static struct async_tx_test_ops ops_table[] = {
+	{
+		.name = "memcpy",
+		.min_disk_count = 1,
+		.max_disk_count = 1,
+		.io_size = memcpy_test_io_size,
+		.prep_input = memcpy_test_prep_input,
+		.prep_output = memcpy_test_prep_output,
+		.submit = memcpy_test_submit,
+		.verify_output = memcpy_test_verify_output,
+		.cleanup = async_tx_test_dummy_cleanup,
+	},
+	{
+		.name = "xor",
+		.min_disk_count = 1,
+		.max_disk_count = MAX_DISKS,
+		.io_size = xor_test_io_size,
+		.prep_input = xor_test_prep_input,
+		.prep_output = xor_test_prep_output,
+		.submit = xor_test_submit,
+		.verify_output = xor_test_verify_output,
+		.cleanup = async_tx_test_dummy_cleanup,
+	},
+	{
+		.name = "pq",
+		.min_disk_count = 1,
+		.max_disk_count = MAX_DISKS,
+		.io_size = pq_test_io_size,
+		.prep_input = pq_test_prep_input,
+		.prep_output = pq_test_prep_output,
+		.submit = pq_test_submit,
+		.verify_output = pq_test_verify_output,
+		.cleanup = async_tx_test_dummy_cleanup,
+	},
+	{
+		.name = "update_pq",
+		.min_disk_count = 2,
+		.max_disk_count = 2,
+		.io_size = update_pq_test_io_size,
+		.prep_input = update_pq_test_prep_input,
+		.prep_output = update_pq_test_prep_output,
+		.submit = update_pq_test_submit,
+		.verify_output = update_pq_test_verify_output,
+		.cleanup = async_tx_test_dummy_cleanup,
+	},
+	{
+		.name = "recov_datap",
+		.min_disk_count = 2,
+		.max_disk_count = MAX_DISKS,
+		.io_size = recov_datap_test_io_size,
+		.prep_input = recov_datap_test_prep_input,
+		.prep_output = recov_datap_test_prep_output,
+		.submit = recov_datap_test_submit,
+		.verify_output = recov_datap_test_verify_output,
+		.cleanup = async_tx_test_dummy_cleanup,
+	},
+	{
+		.name = "recov_2data",
+		.min_disk_count = 2,
+		.max_disk_count = MAX_DISKS,
+		.io_size = recov_2data_test_io_size,
+		.prep_input = recov_2data_test_prep_input,
+		.prep_output = recov_2data_test_prep_output,
+		.submit = recov_2data_test_submit,
+		.verify_output = recov_2data_test_verify_output,
+		.cleanup = async_tx_test_dummy_cleanup,
+	},
+};
+
+static struct async_tx_test_ops *async_tx_test_find(const char *name)
+{
+	int i;
+	struct async_tx_test_ops *ops;
+
+	for (i = 0; i < ARRAY_SIZE(ops_table); i++) {
+		ops = &ops_table[i];
+		if (!strncmp(ops->name, name, sizeof(ops->name)))
+			return ops;
+	}
+
+	return NULL;
+}
+
+static int async_tx_test_thread_main(void *data)
+{
+	int ret = 0;
+	unsigned int i, r, io_size;
+	struct async_tx_test_request *req;
+	unsigned long long input_bytes_count;
+	s64 iter_usecs, min_usecs = 0, max_usecs = 0, avg_usecs = 0;
+	unsigned long long iter_KBs, min_KBs = 0, max_KBs = 0, avg_KBs = 0;
+	struct async_tx_test *test = data;
+
+	/* Print thread start bannner */
+	pr("thread=%u started\n", test->num);
+
+	/* Allocate request array */
+	test->reqs = kcalloc(test->request_count,
+			     sizeof(*test->reqs), GFP_KERNEL);
+	if (!test->reqs) {
+		ret = -ENOMEM;
+		pr_err("failed to alloc requests for thread=%u\n",
+			test->num);
+		goto fail;
+	}
+
+	/* Allocate all request disk data */
+	for (r = 0; r < test->request_count; r++) {
+		req = &test->reqs[r];
+
+		req->num = r;
+		req->test = test;
+		for (i = 0; i < (test->disk_count + 2); i++) {
+			req->disk[i] = alloc_page(GFP_KERNEL);
+			if (req->disk[i])
+				continue;
+
+			ret = -ENOMEM;
+			pr_err("alloc page failed thread=%u req=%u disk=%u\n",
+				test->num, r, i);
+			goto free_reqs_data;
+		}
+		req->p = req->disk[test->disk_count];
+		req->q = req->disk[test->disk_count + 1];
+	}
+
+	/* Calculate IO size and total input bytes */
+	io_size = test->ops->io_size(test);
+	input_bytes_count = io_size;
+	input_bytes_count *= test->request_count;
+
+	/* Prepare input data */
+	for (r = 0; r < test->request_count; r++) {
+		ret = test->ops->prep_input(&test->reqs[r]);
+		if (!ret)
+			continue;
+
+		pr_err("prepare input failed for thread=%u req=%u\n",
+			test->num, r);
+		goto cleanup_reqs;
+	}
+
+	/* Execute each iteration */
+	for (i = 0; i < test->iteration_count; i++) {
+		/* Prepare output data for iteration */
+		for (r = 0; r < test->request_count; r++) {
+			ret = test->ops->prep_output(&test->reqs[r]);
+			if (!ret)
+				continue;
+
+			pr_err("prepare output fail thread=%u iter=%u req=%u\n",
+			   test->num, i, r);
+			goto cleanup_reqs;
+		}
+
+		/* Start of iteration */
+		test->iter_start_ktime = ktime_get();
+		test->iter_runtime_usecs = 0;
+		atomic_set(&test->iter_done_count, test->request_count);
+		init_completion(&test->iter_done);
+
+		/* Submit all request */
+		for (r = 0; r < test->request_count; r++) {
+			ret = test->ops->submit(&test->reqs[r]);
+			if (!ret)
+				continue;
+
+			pr_err("submit failed for thread=%u iter=%u req=%u\n",
+				test->num, i, r);
+			goto cleanup_reqs;
+		}
+
+		/* Wait for all request to complete */
+		wait_for_completion(&test->iter_done);
+
+		/* Verify output data for iteration */
+		for (r = 0; r < test->request_count; r++) {
+			if (test->ops->verify_output(&test->reqs[r]))
+				continue;
+
+			ret = -EIO;
+			pr_err("verify failed thread=%u iter=%u req=%u\n",
+				test->num, i, r);
+			goto cleanup_reqs;
+		}
+
+		/* Update stats */
+		iter_usecs = test->iter_runtime_usecs;
+		iter_KBs = async_tx_test_persec(test->iter_runtime_usecs,
+						input_bytes_count >> 10);
+		min_usecs = (i == 0) ?
+			    iter_usecs : min(min_usecs, iter_usecs);
+		max_usecs = (i == 0) ?
+			    iter_usecs : max(max_usecs, iter_usecs);
+		avg_usecs += iter_usecs;
+		min_KBs = (i == 0) ?
+			  iter_KBs : min(min_KBs, iter_KBs);
+		max_KBs = (i == 0) ?
+			  iter_KBs : max(max_KBs, iter_KBs);
+		avg_KBs += iter_KBs;
+
+		/* Print iteration summary */
+		if (test->verbose)
+			pr("thread=%u cpu=%d iter=%u usecs=%ld KBs=%llu\n",
+			   test->num, smp_processor_id(),
+			   i, (long)iter_usecs, iter_KBs);
+	}
+
+	/* Compute average usecs and average KBs */
+	if (i) {
+		avg_usecs = div_s64(avg_usecs, i);
+		avg_KBs = div_u64(avg_KBs, i);
+	}
+
+	/* Save stats */
+	test->min_KBs = min_KBs;
+	test->max_KBs = max_KBs;
+	test->avg_KBs = avg_KBs;
+	test->min_IOPs = div_u64(min_KBs * 1024, io_size);
+	test->max_IOPs = div_u64(max_KBs * 1024, io_size);
+	test->avg_IOPs = div_u64(avg_KBs * 1024, io_size);
+
+cleanup_reqs:
+	/* Cleanup all requests */
+	for (r = 0; r < test->request_count; r++)
+		test->ops->cleanup(&test->reqs[r]);
+
+	/* Free all requests disk data  */
+free_reqs_data:
+	for (r = 0; r < test->request_count; r++) {
+		req = &test->reqs[r];
+
+		for (i = 0; i < (test->disk_count + 2); i++) {
+			if (req->disk[i]) {
+				__free_page(req->disk[i]);
+				req->disk[i] = NULL;
+			}
+		}
+	}
+
+	/* Free all requests */
+	kfree(test->reqs);
+
+fail:
+	/* Signal completion to parent thread */
+	if (!atomic_dec_return(test->done_count))
+		complete(test->done);
+
+	return ret;
+}
+
+static int async_tx_test_run(void)
+{
+	int ret = 0;
+	unsigned int i, j, cpu;
+	atomic_t done_count;
+	struct completion done;
+	struct async_tx_test_ops *ops;
+	struct async_tx_test *thread;
+	unsigned long long min_KBs, max_KBs, avg_KBs;
+	unsigned long long min_IOPs, max_IOPs, avg_IOPs;
+
+	ops = async_tx_test_find(strim(test_type));
+	if (!ops) {
+		pr_err("invalid type %s\n", test_type);
+		return -EINVAL;
+	}
+
+	if (!thread_count) {
+		pr_err("invalid thread_count %u\n", thread_count);
+		return -EINVAL;
+	}
+
+	if ((disk_block_size < MIN_BLOCK_SIZE) ||
+	    (disk_block_size > MAX_BLOCK_SIZE)) {
+		pr_err("invalid disk_block_size %u\n", disk_block_size);
+		return -EINVAL;
+	}
+	if (disk_block_size & (MIN_BLOCK_SIZE - 1)) {
+		pr_err("disk_block_size %u not multiple of %u\n",
+			disk_block_size, MIN_BLOCK_SIZE);
+		return -EINVAL;
+	}
+
+	if ((disk_count < ops->min_disk_count) ||
+	    (disk_count > ops->max_disk_count)) {
+		pr_err("invalid disk_count %u\n", disk_count);
+		return -EINVAL;
+	}
+
+	if (!request_count) {
+		pr_err("invalid request_count %u\n", request_count);
+		return -EINVAL;
+	}
+
+	if (!iteration_count) {
+		pr_err("invalid iteration_count %u\n", iteration_count);
+		return -EINVAL;
+	}
+
+	thread = kcalloc(thread_count, sizeof(*thread), GFP_KERNEL);
+	if (!thread)
+		return -ENOMEM;
+
+	/* Print test configuration */
+	pr("type=%s block_size=%u disk_count=%u\n",
+	   ops->name, disk_block_size, disk_count);
+	pr("request_count=%u iteration_count=%u\n",
+	   request_count, iteration_count);
+	pr("threads=%u\n", thread_count);
+
+	atomic_set(&done_count, thread_count);
+	init_completion(&done);
+
+	for (i = 0; i < thread_count; i++) {
+		thread[i].ops = ops;
+		thread[i].verbose = verbose;
+		thread[i].thread_count = thread_count;
+		thread[i].block_size = disk_block_size;
+		thread[i].disk_count = disk_count;
+		thread[i].request_count = request_count;
+		thread[i].iteration_count = iteration_count;
+		thread[i].num = i;
+		thread[i].task = NULL;
+		thread[i].min_KBs = 0;
+		thread[i].max_KBs = 0;
+		thread[i].avg_KBs = 0;
+		thread[i].min_IOPs = 0;
+		thread[i].max_IOPs = 0;
+		thread[i].avg_IOPs = 0;
+		thread[i].done_count = &done_count;
+		thread[i].done = &done;
+		thread[i].task = kthread_create(async_tx_test_thread_main,
+						&thread[i],
+						"async-tx-test%u", i);
+		if (IS_ERR(thread[i].task)) {
+			pr_err("failed to create thread=%u\n", i);
+			if (!atomic_dec_return(&done_count))
+				complete(&done);
+			continue;
+		}
+
+		get_task_struct(thread[i].task);
+
+		j = i;
+		do {
+			for_each_online_cpu(cpu) {
+				if (!j) {
+					kthread_bind(thread[i].task, cpu);
+					break;
+				}
+				j--;
+			}
+		} while (j);
+
+		wake_up_process(thread[i].task);
+	}
+
+	/* Wait for threads to finish */
+	wait_for_completion(&done);
+
+	/* Print stats of each thread */
+	min_KBs = max_KBs = avg_KBs = 0;
+	min_IOPs = max_IOPs = avg_IOPs = 0;
+	for (i = 0; i < thread_count; i++) {
+		if (IS_ERR(thread[i].task))
+			continue;
+
+		ret = kthread_stop(thread[i].task);
+		if (ret)
+			pr_err("thread=%u failed with error=%d\n", i, ret);
+		put_task_struct(thread[i].task);
+		thread[i].task = NULL;
+
+		pr("thread=%u min_KBs=%llu max_KBs=%llu avg_KBs=%llu\n",
+		   i, thread[i].min_KBs, thread[i].max_KBs, thread[i].avg_KBs);
+		pr("thread=%u min_IOPS=%llu max_IOPS=%llu avg_IOPS=%llu\n",
+		   i, thread[i].min_IOPs, thread[i].max_IOPs,
+		   thread[i].avg_IOPs);
+
+		min_KBs += thread[i].min_KBs;
+		max_KBs += thread[i].max_KBs;
+		avg_KBs += thread[i].avg_KBs;
+		min_IOPs += thread[i].min_IOPs;
+		max_IOPs += thread[i].max_IOPs;
+		avg_IOPs += thread[i].avg_IOPs;
+	}
+
+	/* Print overall stats */
+	pr("overall min_KBs=%llu max_KBs=%llu avg_KBs=%llu\n",
+	   min_KBs, max_KBs, avg_KBs);
+	pr("overall min_IOPS=%llu max_IOPS=%llu avg_IOPS=%llu\n",
+	   min_IOPs, max_IOPs, avg_IOPs);
+
+	return ret;
+}
+
+static int async_tx_test_type_set(const char *val,
+				  const struct kernel_param *kp)
+{
+	char str[20];
+	struct async_tx_test_ops *ops;
+
+	mutex_lock(&test_lock);
+
+	strncpy(str, val, sizeof(str));
+	str[sizeof(str) - 1] = '\0';
+	strim(str);
+
+	ops = async_tx_test_find(str);
+	if (!ops) {
+		pr("invalid test type %s\n", str);
+		mutex_unlock(&test_lock);
+		return -EINVAL;
+	}
+
+	strncpy(test_type, ops->name, sizeof(ops->name));
+
+	mutex_unlock(&test_lock);
+
+	return 0;
+}
+
+static int async_tx_test_type_get(char *val,
+				  const struct kernel_param *kp)
+{
+	int i, r = 0;
+	struct async_tx_test_ops *ops;
+
+	mutex_lock(&test_lock);
+
+	for (i = 0; i < ARRAY_SIZE(ops_table); i++) {
+		ops = &ops_table[i];
+		if (!strncmp(ops->name, test_type, sizeof(ops->name))) {
+			if (!i)
+				r += sprintf(val + r, "[%s]", ops->name);
+			else
+				r += sprintf(val + r, " [%s]", ops->name);
+		} else {
+			if (!i)
+				r += sprintf(val + r, "%s", ops->name);
+			else
+				r += sprintf(val + r, " %s", ops->name);
+		}
+	}
+
+	mutex_unlock(&test_lock);
+
+	return r;
+}
+
+static int async_tx_test_run_set(const char *val,
+				 const struct kernel_param *kp)
+{
+	int ret;
+
+	mutex_lock(&test_lock);
+
+	test_run = true;
+
+	ret = param_set_bool(val, kp);
+	if (ret) {
+		test_run = false;
+		mutex_unlock(&test_lock);
+		return ret;
+	}
+
+	ret = async_tx_test_run();
+	if (ret)
+		pr("failed (error %d)\n", ret);
+	else
+		pr("passed\n");
+
+	test_run = false;
+
+	mutex_unlock(&test_lock);
+
+	return ret;
+}
+
+static int async_tx_test_run_get(char *val,
+				 const struct kernel_param *kp)
+{
+	return param_get_bool(val, kp);
+}
+
+MODULE_AUTHOR("Anup Patel <anup.patel@broadcom.com>");
+MODULE_DESCRIPTION("Async Tx Test Module");
+MODULE_LICENSE("GPL");
--- a/drivers/acpi/pci_mcfg.c
+++ b/drivers/acpi/pci_mcfg.c
@@ -141,6 +141,11 @@ struct mcfg_fixup {
 	XGENE_V2_ECAM_MCFG(4, 0),
 	XGENE_V2_ECAM_MCFG(4, 1),
 	XGENE_V2_ECAM_MCFG(4, 2),
+
+#define BCM_ECAM_MCFG(rev, seg) \
+	{"BRCM  ", "BRCM-SRX", rev, seg, MCFG_BUS_ANY, \
+		&iproc_pcie_paxcv2_ecam_ops }
+	BCM_ECAM_MCFG(1, 8),
 };
 
 static char mcfg_oem_id[ACPI_OEM_ID_SIZE];
--- a/drivers/clk/bcm/clk-iproc-asiu.c
+++ b/drivers/clk/bcm/clk-iproc-asiu.c
@@ -88,6 +88,10 @@ static unsigned long iproc_asiu_clk_recalc_rate(struct clk_hw *hw,
 		return 0;
 	}
 
+	/* some clocks at the ASIU level do not have divisior */
+	if (clk->div.offset == IPROC_CLK_INVALID_OFFSET)
+		return 0;
+
 	/* if clock divisor is not enabled, simply return parent rate */
 	val = readl(asiu->div_base + clk->div.offset);
 	if ((val & (1 << clk->div.en_shift)) == 0) {
@@ -119,7 +123,7 @@ static long iproc_asiu_clk_round_rate(struct clk_hw *hw, unsigned long rate,
 	if (rate == *parent_rate)
 		return *parent_rate;
 
-	div = DIV_ROUND_UP(*parent_rate, rate);
+	div = DIV_ROUND_CLOSEST(*parent_rate, rate);
 	if (div < 2)
 		return *parent_rate;
 
@@ -137,6 +141,10 @@ static int iproc_asiu_clk_set_rate(struct clk_hw *hw, unsigned long rate,
 	if (rate == 0 || parent_rate == 0)
 		return -EINVAL;
 
+	/* some clocks at the ASIU level do not have divisior */
+	if (clk->div.offset == IPROC_CLK_INVALID_OFFSET)
+		return 0;
+
 	/* simply disable the divisor if one wants the same rate as parent */
 	if (rate == parent_rate) {
 		val = readl(asiu->div_base + clk->div.offset);
@@ -145,7 +153,7 @@ static int iproc_asiu_clk_set_rate(struct clk_hw *hw, unsigned long rate,
 		return 0;
 	}
 
-	div = DIV_ROUND_UP(parent_rate, rate);
+	div = DIV_ROUND_CLOSEST(parent_rate, rate);
 	if (div < 2)
 		return -EINVAL;
 
--- a/drivers/clk/bcm/clk-iproc-pll.c
+++ b/drivers/clk/bcm/clk-iproc-pll.c
@@ -69,16 +69,6 @@ enum vco_freq_range {
 	VCO_MAX       = 4000000000U,
 };
 
-struct iproc_pll;
-
-struct iproc_clk {
-	struct clk_hw hw;
-	const char *name;
-	struct iproc_pll *pll;
-	unsigned long rate;
-	const struct iproc_clk_ctrl *ctrl;
-};
-
 struct iproc_pll {
 	void __iomem *status_base;
 	void __iomem *control_base;
@@ -88,13 +78,49 @@ struct iproc_pll {
 	const struct iproc_pll_ctrl *ctrl;
 	const struct iproc_pll_vco_param *vco_param;
 	unsigned int num_vco_entries;
+};
 
-	struct clk_hw_onecell_data *clk_data;
-	struct iproc_clk *clks;
+struct iproc_clk {
+	struct clk_hw hw;
+	struct iproc_pll *pll;
+	const struct iproc_clk_ctrl *ctrl;
 };
 
 #define to_iproc_clk(hw) container_of(hw, struct iproc_clk, hw)
 
+static int pll_calc_param(unsigned long target_rate,
+			unsigned long parent_rate,
+			struct iproc_pll_vco_param *vco_out)
+{
+	u64 ndiv_int, ndiv_frac, residual;
+
+	ndiv_int = target_rate / parent_rate;
+
+	if (!ndiv_int || (ndiv_int > 255))
+		return -EINVAL;
+
+	residual = target_rate - (ndiv_int * parent_rate);
+	residual <<= 20;
+
+	/*
+	 * Add half of the divisor so the result will be rounded to closest
+	 * instead of rounded down.
+	 */
+	residual += (parent_rate / 2);
+	ndiv_frac = div64_u64((u64)residual, (u64)parent_rate);
+
+	vco_out->ndiv_int = ndiv_int;
+	vco_out->ndiv_frac = ndiv_frac;
+	vco_out->pdiv = 1;
+
+	vco_out->rate = vco_out->ndiv_int * parent_rate;
+	residual = (u64)vco_out->ndiv_frac * (u64)parent_rate;
+	residual >>= 20;
+	vco_out->rate += residual;
+
+	return 0;
+}
+
 /*
  * Based on the target frequency, find a match from the VCO frequency parameter
  * table and return its index
@@ -252,17 +278,51 @@ static void __pll_bring_out_reset(struct iproc_pll *pll, unsigned int kp,
 	iproc_pll_write(pll, pll->control_base, reset->offset, val);
 }
 
-static int pll_set_rate(struct iproc_clk *clk, unsigned int rate_index,
+/*
+ * Determines if the change to be applied to the PLL is minor (just an update
+ * or the fractional divider). If so, then we can avoid going through a
+ * disruptive reset and lock sequence.
+ */
+static bool pll_fractional_change_only(struct iproc_pll *pll,
+				       struct iproc_pll_vco_param *vco)
+{
+	const struct iproc_pll_ctrl *ctrl = pll->ctrl;
+	u32 val;
+	u32 ndiv_int;
+	unsigned int pdiv;
+
+	/* PLL needs to be locked */
+	val = readl(pll->status_base + ctrl->status.offset);
+	if ((val & (1 << ctrl->status.shift)) == 0)
+		return false;
+
+	val = readl(pll->control_base + ctrl->ndiv_int.offset);
+	ndiv_int = (val >> ctrl->ndiv_int.shift) &
+		bit_mask(ctrl->ndiv_int.width);
+
+	if (ndiv_int != vco->ndiv_int)
+		return false;
+
+	val = readl(pll->control_base + ctrl->pdiv.offset);
+	pdiv = (val >> ctrl->pdiv.shift) & bit_mask(ctrl->pdiv.width);
+
+	if (pdiv != vco->pdiv)
+		return false;
+
+	return true;
+}
+
+static int pll_set_rate(struct iproc_clk *clk, struct iproc_pll_vco_param *vco,
 			unsigned long parent_rate)
 {
 	struct iproc_pll *pll = clk->pll;
-	const struct iproc_pll_vco_param *vco = &pll->vco_param[rate_index];
 	const struct iproc_pll_ctrl *ctrl = pll->ctrl;
 	int ka = 0, ki, kp, ret;
 	unsigned long rate = vco->rate;
 	u32 val;
 	enum kp_band kp_index;
 	unsigned long ref_freq;
+	const char *clk_name = clk_hw_get_name(&clk->hw);
 
 	/*
 	 * reference frequency = parent frequency / PDIV
@@ -285,22 +345,35 @@ static int pll_set_rate(struct iproc_clk *clk, unsigned int rate_index,
 		kp_index = KP_BAND_HIGH_HIGH;
 	} else {
 		pr_err("%s: pll: %s has invalid rate: %lu\n", __func__,
-				clk->name, rate);
+				clk_name, rate);
 		return -EINVAL;
 	}
 
 	kp = get_kp(ref_freq, kp_index);
 	if (kp < 0) {
-		pr_err("%s: pll: %s has invalid kp\n", __func__, clk->name);
+		pr_err("%s: pll: %s has invalid kp\n", __func__, clk_name);
 		return kp;
 	}
 
 	ret = __pll_enable(pll);
 	if (ret) {
-		pr_err("%s: pll: %s fails to enable\n", __func__, clk->name);
+		pr_err("%s: pll: %s fails to enable\n", __func__, clk_name);
 		return ret;
 	}
 
+	if (pll_fractional_change_only(clk->pll, vco)) {
+		/* program fractional part of NDIV */
+		if (ctrl->flags & IPROC_CLK_PLL_HAS_NDIV_FRAC) {
+			val = readl(pll->control_base + ctrl->ndiv_frac.offset);
+			val &= ~(bit_mask(ctrl->ndiv_frac.width) <<
+				 ctrl->ndiv_frac.shift);
+			val |= vco->ndiv_frac << ctrl->ndiv_frac.shift;
+			iproc_pll_write(pll, pll->control_base,
+					ctrl->ndiv_frac.offset, val);
+			return 0;
+		}
+	}
+
 	/* put PLL in reset */
 	__pll_put_in_reset(pll);
 
@@ -354,7 +427,7 @@ static int pll_set_rate(struct iproc_clk *clk, unsigned int rate_index,
 
 	ret = pll_wait_for_lock(pll);
 	if (ret < 0) {
-		pr_err("%s: pll: %s failed to lock\n", __func__, clk->name);
+		pr_err("%s: pll: %s failed to lock\n", __func__, clk_name);
 		return ret;
 	}
 
@@ -390,16 +463,15 @@ static unsigned long iproc_pll_recalc_rate(struct clk_hw *hw,
 	u32 val;
 	u64 ndiv, ndiv_int, ndiv_frac;
 	unsigned int pdiv;
+	unsigned long rate;
 
 	if (parent_rate == 0)
 		return 0;
 
 	/* PLL needs to be locked */
 	val = readl(pll->status_base + ctrl->status.offset);
-	if ((val & (1 << ctrl->status.shift)) == 0) {
-		clk->rate = 0;
+	if ((val & (1 << ctrl->status.shift)) == 0)
 		return 0;
-	}
 
 	/*
 	 * PLL output frequency =
@@ -421,35 +493,60 @@ static unsigned long iproc_pll_recalc_rate(struct clk_hw *hw,
 	val = readl(pll->control_base + ctrl->pdiv.offset);
 	pdiv = (val >> ctrl->pdiv.shift) & bit_mask(ctrl->pdiv.width);
 
-	clk->rate = (ndiv * parent_rate) >> 20;
+	rate = (ndiv * parent_rate) >> 20;
 
 	if (pdiv == 0)
-		clk->rate *= 2;
+		rate *= 2;
 	else
-		clk->rate /= pdiv;
+		rate /= pdiv;
 
-	return clk->rate;
+	return rate;
 }
 
-static long iproc_pll_round_rate(struct clk_hw *hw, unsigned long rate,
-				 unsigned long *parent_rate)
+static int iproc_pll_determine_rate(struct clk_hw *hw,
+		struct clk_rate_request *req)
 {
-	unsigned i;
+	unsigned int  i;
 	struct iproc_clk *clk = to_iproc_clk(hw);
 	struct iproc_pll *pll = clk->pll;
+	const struct iproc_pll_ctrl *ctrl = pll->ctrl;
+	unsigned long  diff, best_diff;
+	unsigned int  best_idx = 0;
+	int ret;
+
+	if (req->rate == 0 || req->best_parent_rate == 0)
+		return -EINVAL;
+
+	if (ctrl->flags & IPROC_CLK_PLL_CALC_PARAM) {
+		struct iproc_pll_vco_param vco_param;
 
-	if (rate == 0 || *parent_rate == 0 || !pll->vco_param)
+		ret = pll_calc_param(req->rate, req->best_parent_rate,
+					&vco_param);
+		if (ret)
+			return ret;
+
+		req->rate = vco_param.rate;
+		return 0;
+	}
+
+	if (!pll->vco_param)
 		return -EINVAL;
 
+	best_diff = ULONG_MAX;
 	for (i = 0; i < pll->num_vco_entries; i++) {
-		if (rate <= pll->vco_param[i].rate)
+		diff = abs(req->rate - pll->vco_param[i].rate);
+		if (diff <= best_diff) {
+			best_diff = diff;
+			best_idx = i;
+		}
+		/* break now if perfect match */
+		if (diff == 0)
 			break;
 	}
 
-	if (i == pll->num_vco_entries)
-		i--;
+	req->rate = pll->vco_param[best_idx].rate;
 
-	return pll->vco_param[i].rate;
+	return 0;
 }
 
 static int iproc_pll_set_rate(struct clk_hw *hw, unsigned long rate,
@@ -457,13 +554,23 @@ static int iproc_pll_set_rate(struct clk_hw *hw, unsigned long rate,
 {
 	struct iproc_clk *clk = to_iproc_clk(hw);
 	struct iproc_pll *pll = clk->pll;
+	const struct iproc_pll_ctrl *ctrl = pll->ctrl;
+	struct iproc_pll_vco_param vco_param;
 	int rate_index, ret;
 
-	rate_index = pll_get_rate_index(pll, rate);
-	if (rate_index < 0)
-		return rate_index;
+	if (ctrl->flags & IPROC_CLK_PLL_CALC_PARAM) {
+		ret = pll_calc_param(rate, parent_rate, &vco_param);
+		if (ret)
+			return ret;
+	} else {
+		rate_index = pll_get_rate_index(pll, rate);
+		if (rate_index < 0)
+			return rate_index;
 
-	ret = pll_set_rate(clk, rate_index, parent_rate);
+		vco_param = pll->vco_param[rate_index];
+	}
+
+	ret = pll_set_rate(clk, &vco_param, parent_rate);
 	return ret;
 }
 
@@ -471,7 +578,7 @@ static int iproc_pll_set_rate(struct clk_hw *hw, unsigned long rate,
 	.enable = iproc_pll_enable,
 	.disable = iproc_pll_disable,
 	.recalc_rate = iproc_pll_recalc_rate,
-	.round_rate = iproc_pll_round_rate,
+	.determine_rate = iproc_pll_determine_rate,
 	.set_rate = iproc_pll_set_rate,
 };
 
@@ -518,6 +625,7 @@ static unsigned long iproc_clk_recalc_rate(struct clk_hw *hw,
 	struct iproc_pll *pll = clk->pll;
 	u32 val;
 	unsigned int mdiv;
+	unsigned long rate;
 
 	if (parent_rate == 0)
 		return 0;
@@ -528,32 +636,33 @@ static unsigned long iproc_clk_recalc_rate(struct clk_hw *hw,
 		mdiv = 256;
 
 	if (ctrl->flags & IPROC_CLK_MCLK_DIV_BY_2)
-		clk->rate = parent_rate / (mdiv * 2);
+		rate = parent_rate / (mdiv * 2);
 	else
-		clk->rate = parent_rate / mdiv;
+		rate = parent_rate / mdiv;
 
-	return clk->rate;
+	return rate;
 }
 
-static long iproc_clk_round_rate(struct clk_hw *hw, unsigned long rate,
-		unsigned long *parent_rate)
+static int iproc_clk_determine_rate(struct clk_hw *hw,
+		struct clk_rate_request *req)
 {
-	unsigned int div;
+	unsigned int bestdiv;
 
-	if (rate == 0 || *parent_rate == 0)
+	if (req->rate == 0)
 		return -EINVAL;
+	if (req->rate == req->best_parent_rate)
+		return 0;
 
-	if (rate == *parent_rate)
-		return *parent_rate;
+	bestdiv = DIV_ROUND_CLOSEST(req->best_parent_rate, req->rate);
+	if (bestdiv < 2)
+		req->rate = req->best_parent_rate;
 
-	div = DIV_ROUND_UP(*parent_rate, rate);
-	if (div < 2)
-		return *parent_rate;
+	if (bestdiv > 256)
+		bestdiv = 256;
 
-	if (div > 256)
-		div = 256;
+	req->rate = req->best_parent_rate / bestdiv;
 
-	return *parent_rate / div;
+	return 0;
 }
 
 static int iproc_clk_set_rate(struct clk_hw *hw, unsigned long rate,
@@ -568,10 +677,10 @@ static int iproc_clk_set_rate(struct clk_hw *hw, unsigned long rate,
 	if (rate == 0 || parent_rate == 0)
 		return -EINVAL;
 
+	div = DIV_ROUND_CLOSEST(parent_rate, rate);
 	if (ctrl->flags & IPROC_CLK_MCLK_DIV_BY_2)
-		div = DIV_ROUND_UP(parent_rate, rate * 2);
-	else
-		div = DIV_ROUND_UP(parent_rate, rate);
+		div /=  2;
+
 	if (div > 256)
 		return -EINVAL;
 
@@ -583,10 +692,6 @@ static int iproc_clk_set_rate(struct clk_hw *hw, unsigned long rate,
 		val |= div << ctrl->mdiv.shift;
 	}
 	iproc_pll_write(pll, pll->control_base, ctrl->mdiv.offset, val);
-	if (ctrl->flags & IPROC_CLK_MCLK_DIV_BY_2)
-		clk->rate = parent_rate / (div * 2);
-	else
-		clk->rate = parent_rate / div;
 
 	return 0;
 }
@@ -595,7 +700,7 @@ static int iproc_clk_set_rate(struct clk_hw *hw, unsigned long rate,
 	.enable = iproc_clk_enable,
 	.disable = iproc_clk_disable,
 	.recalc_rate = iproc_clk_recalc_rate,
-	.round_rate = iproc_clk_round_rate,
+	.determine_rate = iproc_clk_determine_rate,
 	.set_rate = iproc_clk_set_rate,
 };
 
@@ -629,6 +734,8 @@ void iproc_pll_clk_setup(struct device_node *node,
 	struct iproc_clk *iclk;
 	struct clk_init_data init;
 	const char *parent_name;
+	struct iproc_clk *iclk_array;
+	struct clk_hw_onecell_data *clk_data;
 
 	if (WARN_ON(!pll_ctrl) || WARN_ON(!clk_ctrl))
 		return;
@@ -637,14 +744,14 @@ void iproc_pll_clk_setup(struct device_node *node,
 	if (WARN_ON(!pll))
 		return;
 
-	pll->clk_data = kzalloc(sizeof(*pll->clk_data->hws) * num_clks +
-				sizeof(*pll->clk_data), GFP_KERNEL);
-	if (WARN_ON(!pll->clk_data))
+	clk_data = kzalloc(sizeof(*clk_data->hws) * num_clks +
+				sizeof(*clk_data), GFP_KERNEL);
+	if (WARN_ON(!clk_data))
 		goto err_clk_data;
-	pll->clk_data->num = num_clks;
+	clk_data->num = num_clks;
 
-	pll->clks = kcalloc(num_clks, sizeof(*pll->clks), GFP_KERNEL);
-	if (WARN_ON(!pll->clks))
+	iclk_array = kcalloc(num_clks, sizeof(struct iproc_clk), GFP_KERNEL);
+	if (WARN_ON(!iclk_array))
 		goto err_clks;
 
 	pll->control_base = of_iomap(node, 0);
@@ -674,9 +781,8 @@ void iproc_pll_clk_setup(struct device_node *node,
 	/* initialize and register the PLL itself */
 	pll->ctrl = pll_ctrl;
 
-	iclk = &pll->clks[0];
+	iclk = &iclk_array[0];
 	iclk->pll = pll;
-	iclk->name = node->name;
 
 	init.name = node->name;
 	init.ops = &iproc_pll_ops;
@@ -697,7 +803,7 @@ void iproc_pll_clk_setup(struct device_node *node,
 	if (WARN_ON(ret))
 		goto err_pll_register;
 
-	pll->clk_data->hws[0] = &iclk->hw;
+	clk_data->hws[0] = &iclk->hw;
 
 	/* now initialize and register all leaf clocks */
 	for (i = 1; i < num_clks; i++) {
@@ -711,8 +817,7 @@ void iproc_pll_clk_setup(struct device_node *node,
 		if (WARN_ON(ret))
 			goto err_clk_register;
 
-		iclk = &pll->clks[i];
-		iclk->name = clk_name;
+		iclk = &iclk_array[i];
 		iclk->pll = pll;
 		iclk->ctrl = &clk_ctrl[i];
 
@@ -727,11 +832,10 @@ void iproc_pll_clk_setup(struct device_node *node,
 		if (WARN_ON(ret))
 			goto err_clk_register;
 
-		pll->clk_data->hws[i] = &iclk->hw;
+		clk_data->hws[i] = &iclk->hw;
 	}
 
-	ret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get,
-				     pll->clk_data);
+	ret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);
 	if (WARN_ON(ret))
 		goto err_clk_register;
 
@@ -739,7 +843,7 @@ void iproc_pll_clk_setup(struct device_node *node,
 
 err_clk_register:
 	while (--i >= 0)
-		clk_hw_unregister(pll->clk_data->hws[i]);
+		clk_hw_unregister(clk_data->hws[i]);
 
 err_pll_register:
 	if (pll->status_base != pll->control_base)
@@ -756,10 +860,10 @@ void iproc_pll_clk_setup(struct device_node *node,
 	iounmap(pll->control_base);
 
 err_pll_iomap:
-	kfree(pll->clks);
+	kfree(iclk_array);
 
 err_clks:
-	kfree(pll->clk_data);
+	kfree(clk_data);
 
 err_clk_data:
 	kfree(pll);
--- a/drivers/clk/bcm/clk-iproc.h
+++ b/drivers/clk/bcm/clk-iproc.h
@@ -81,6 +81,11 @@
 #define IPROC_CLK_PLL_RESET_ACTIVE_LOW BIT(9)
 
 /*
+ * Calculate the PLL parameters are runtime, instead of using table
+ */
+#define IPROC_CLK_PLL_CALC_PARAM BIT(10)
+
+/*
  * Parameters for VCO frequency configuration
  *
  * VCO frequency =
@@ -216,4 +221,6 @@ void iproc_asiu_setup(struct device_node *node,
 		      const struct iproc_asiu_gate *gate,
 		      unsigned int num_clks);
 
+int iproc_audiomux_setup(struct device_node *node);
+
 #endif /* _CLK_IPROC_H */
--- a/drivers/clk/bcm/clk-sr.c
+++ b/drivers/clk/bcm/clk-sr.c
@@ -56,8 +56,8 @@
 };
 
 static const struct iproc_clk_ctrl sr_genpll0_clk[] = {
-	[BCM_SR_GENPLL0_SATA_CLK] = {
-		.channel = BCM_SR_GENPLL0_SATA_CLK,
+	[BCM_SR_GENPLL0_125M_CLK] = {
+		.channel = BCM_SR_GENPLL0_125M_CLK,
 		.flags = IPROC_CLK_AON,
 		.enable = ENABLE_VAL(0x4, 6, 0, 12),
 		.mdiv = REG_VAL(0x18, 0, 9),
@@ -102,6 +102,65 @@ static int sr_genpll0_clk_init(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct iproc_pll_ctrl sr_genpll2 = {
+	.flags = IPROC_CLK_AON | IPROC_CLK_PLL_HAS_NDIV_FRAC |
+		IPROC_CLK_PLL_NEEDS_SW_CFG,
+	.aon = AON_VAL(0x0, 1, 13, 12),
+	.reset = RESET_VAL(0x0, 12, 11),
+	.dig_filter = DF_VAL(0x0, 4, 3, 0, 4, 7, 3),
+	.sw_ctrl = SW_CTRL_VAL(0x10, 31),
+	.ndiv_int = REG_VAL(0x10, 20, 10),
+	.ndiv_frac = REG_VAL(0x10, 0, 20),
+	.pdiv = REG_VAL(0x14, 0, 4),
+	.status = REG_VAL(0x30, 12, 1),
+};
+
+static const struct iproc_clk_ctrl sr_genpll2_clk[] = {
+	[BCM_SR_GENPLL2_NIC_CLK] = {
+		.channel = BCM_SR_GENPLL2_NIC_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x4, 6, 0, 12),
+		.mdiv = REG_VAL(0x18, 0, 9),
+	},
+	[BCM_SR_GENPLL2_TS_500_CLK] = {
+		.channel = BCM_SR_GENPLL2_TS_500_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x4, 7, 1, 13),
+		.mdiv = REG_VAL(0x18, 10, 9),
+	},
+	[BCM_SR_GENPLL2_125_NITRO_CLK] = {
+		.channel = BCM_SR_GENPLL2_125_NITRO_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x4, 8, 2, 14),
+		.mdiv = REG_VAL(0x18, 20, 9),
+	},
+	[BCM_SR_GENPLL2_CHIMP_CLK] = {
+		.channel = BCM_SR_GENPLL2_CHIMP_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x4, 9, 3, 15),
+		.mdiv = REG_VAL(0x1c, 0, 9),
+	},
+	[BCM_SR_GENPLL2_NIC_FLASH_CLK] = {
+		.channel = BCM_SR_GENPLL2_NIC_FLASH_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x4, 10, 4, 16),
+		.mdiv = REG_VAL(0x1c, 10, 9),
+	},
+	[BCM_SR_GENPLL2_FS4_CLK] = {
+		.channel = BCM_SR_GENPLL2_FS4_CLK,
+		.enable = ENABLE_VAL(0x4, 11, 5, 17),
+		.mdiv = REG_VAL(0x1c, 20, 9),
+	},
+};
+
+static int sr_genpll2_clk_init(struct platform_device *pdev)
+{
+	iproc_pll_clk_setup(pdev->dev.of_node,
+			    &sr_genpll2, NULL, 0, sr_genpll2_clk,
+			    ARRAY_SIZE(sr_genpll2_clk));
+	return 0;
+}
+
 static const struct iproc_pll_ctrl sr_genpll3 = {
 	.flags = IPROC_CLK_AON | IPROC_CLK_PLL_HAS_NDIV_FRAC |
 		IPROC_CLK_PLL_NEEDS_SW_CFG,
@@ -157,6 +216,30 @@ static void sr_genpll3_clk_init(struct device_node *node)
 		.enable = ENABLE_VAL(0x4, 6, 0, 12),
 		.mdiv = REG_VAL(0x18, 0, 9),
 	},
+	[BCM_SR_GENPLL4_TPIU_PLL_CLK] = {
+		.channel = BCM_SR_GENPLL4_TPIU_PLL_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x4, 7, 1, 13),
+		.mdiv = REG_VAL(0x18, 10, 9),
+	},
+	[BCM_SR_GENPLL4_NOC_CLK] = {
+		.channel = BCM_SR_GENPLL4_NOC_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x4, 8, 2, 14),
+		.mdiv = REG_VAL(0x18, 20, 9),
+	},
+	[BCM_SR_GENPLL4_CHCLK_FS4_CLK] = {
+		.channel = BCM_SR_GENPLL4_CHCLK_FS4_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x4, 9, 3, 15),
+		.mdiv = REG_VAL(0x1c, 0, 9),
+	},
+	[BCM_SR_GENPLL4_BRIDGE_FSCPU_CLK] = {
+		.channel = BCM_SR_GENPLL4_BRIDGE_FSCPU_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x4, 10, 4, 16),
+		.mdiv = REG_VAL(0x1c, 10, 9),
+	},
 };
 
 static int sr_genpll4_clk_init(struct platform_device *pdev)
@@ -181,18 +264,21 @@ static int sr_genpll4_clk_init(struct platform_device *pdev)
 };
 
 static const struct iproc_clk_ctrl sr_genpll5_clk[] = {
-	[BCM_SR_GENPLL5_FS_CLK] = {
-		.channel = BCM_SR_GENPLL5_FS_CLK,
-		.flags = IPROC_CLK_AON,
+	[BCM_SR_GENPLL5_FS4_HF_CLK] = {
+		.channel = BCM_SR_GENPLL5_FS4_HF_CLK,
 		.enable = ENABLE_VAL(0x4, 6, 0, 12),
 		.mdiv = REG_VAL(0x18, 0, 9),
 	},
-	[BCM_SR_GENPLL5_SPU_CLK] = {
-		.channel = BCM_SR_GENPLL5_SPU_CLK,
-		.flags = IPROC_CLK_AON,
-		.enable = ENABLE_VAL(0x4, 6, 0, 12),
+	[BCM_SR_GENPLL5_CRYPTO_AE_CLK] = {
+		.channel = BCM_SR_GENPLL5_CRYPTO_AE_CLK,
+		.enable = ENABLE_VAL(0x4, 7, 1, 12),
 		.mdiv = REG_VAL(0x18, 10, 9),
 	},
+	[BCM_SR_GENPLL5_RAID_AE_CLK] = {
+		.channel = BCM_SR_GENPLL5_RAID_AE_CLK,
+		.enable = ENABLE_VAL(0x4, 8, 2, 14),
+		.mdiv = REG_VAL(0x18, 20, 9),
+	},
 };
 
 static int sr_genpll5_clk_init(struct platform_device *pdev)
@@ -214,24 +300,30 @@ static int sr_genpll5_clk_init(struct platform_device *pdev)
 };
 
 static const struct iproc_clk_ctrl sr_lcpll0_clk[] = {
-	[BCM_SR_LCPLL0_SATA_REF_CLK] = {
-		.channel = BCM_SR_LCPLL0_SATA_REF_CLK,
+	[BCM_SR_LCPLL0_SATA_REFP_CLK] = {
+		.channel = BCM_SR_LCPLL0_SATA_REFP_CLK,
 		.flags = IPROC_CLK_AON,
 		.enable = ENABLE_VAL(0x0, 7, 1, 13),
 		.mdiv = REG_VAL(0x14, 0, 9),
 	},
-	[BCM_SR_LCPLL0_USB_REF_CLK] = {
-		.channel = BCM_SR_LCPLL0_USB_REF_CLK,
+	[BCM_SR_LCPLL0_SATA_REFN_CLK] = {
+		.channel = BCM_SR_LCPLL0_SATA_REFN_CLK,
 		.flags = IPROC_CLK_AON,
 		.enable = ENABLE_VAL(0x0, 8, 2, 14),
 		.mdiv = REG_VAL(0x14, 10, 9),
 	},
-	[BCM_SR_LCPLL0_SATA_REFPN_CLK] = {
-		.channel = BCM_SR_LCPLL0_SATA_REFPN_CLK,
+	[BCM_SR_LCPLL0_SATA_350_CLK] = {
+		.channel = BCM_SR_LCPLL0_SATA_350_CLK,
 		.flags = IPROC_CLK_AON,
 		.enable = ENABLE_VAL(0x0, 9, 3, 15),
 		.mdiv = REG_VAL(0x14, 20, 9),
 	},
+	[BCM_SR_LCPLL0_SATA_500_CLK] = {
+		.channel = BCM_SR_LCPLL0_SATA_500_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x0, 10, 4, 16),
+		.mdiv = REG_VAL(0x18, 0, 9),
+	},
 };
 
 static int sr_lcpll0_clk_init(struct platform_device *pdev)
@@ -259,6 +351,18 @@ static int sr_lcpll0_clk_init(struct platform_device *pdev)
 		.enable = ENABLE_VAL(0x0, 7, 1, 13),
 		.mdiv = REG_VAL(0x14, 0, 9),
 	},
+	[BCM_SR_LCPLL1_USB_REF_CLK] = {
+		.channel = BCM_SR_LCPLL1_USB_REF_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x0, 8, 2, 14),
+		.mdiv = REG_VAL(0x14, 10, 9),
+	},
+	[BCM_SR_LCPLL1_CRMU_TS_CLK] = {
+		.channel = BCM_SR_LCPLL1_CRMU_TS_CLK,
+		.flags = IPROC_CLK_AON,
+		.enable = ENABLE_VAL(0x0, 9, 3, 15),
+		.mdiv = REG_VAL(0x14, 20, 9),
+	},
 };
 
 static int sr_lcpll1_clk_init(struct platform_device *pdev)
@@ -298,6 +402,7 @@ static int sr_lcpll_pcie_clk_init(struct platform_device *pdev)
 
 static const struct of_device_id sr_clk_dt_ids[] = {
 	{ .compatible = "brcm,sr-genpll0", .data = sr_genpll0_clk_init },
+	{ .compatible = "brcm,sr-genpll2", .data = sr_genpll2_clk_init },
 	{ .compatible = "brcm,sr-genpll4", .data = sr_genpll4_clk_init },
 	{ .compatible = "brcm,sr-genpll5", .data = sr_genpll5_clk_init },
 	{ .compatible = "brcm,sr-lcpll0", .data = sr_lcpll0_clk_init },
old mode 100644
new mode 100755
--- a/drivers/crypto/bcm/cipher.c
+++ b/drivers/crypto/bcm/cipher.c
@@ -2615,7 +2615,7 @@ static int aead_need_fallback(struct aead_request *req)
 	 */
 	if (((ctx->cipher.mode == CIPHER_MODE_GCM) ||
 	     (ctx->cipher.mode == CIPHER_MODE_CCM)) &&
-	    (req->assoclen == 0)) {
+	     ((req->assoclen == 0) || (req->cryptlen == 0))) {
 		if ((rctx->is_encrypt && (req->cryptlen == 0)) ||
 		    (!rctx->is_encrypt && (req->cryptlen == ctx->digestsize))) {
 			flow_log("AES GCM/CCM needs fallback for 0 len req\n");
@@ -4490,8 +4490,7 @@ static void spu_functions_register(struct device *dev,
 }
 
 /**
- * spu_mb_init() - Initialize mailbox client. Request ownership of a mailbox
- * channel for the SPU being probed.
+ * spu_mb_init() - Initialize mailbox client.
  * @dev:  SPU driver device structure
  *
  * Return: 0 if successful
@@ -4637,12 +4636,16 @@ static int spu_register_ahash(struct iproc_alg_s *driver_alg)
 	hash->halg.statesize = sizeof(struct spu_hash_export_s);
 
 	if (driver_alg->auth_info.mode != HASH_MODE_HMAC) {
-		hash->setkey = ahash_setkey;
 		hash->init = ahash_init;
 		hash->update = ahash_update;
 		hash->final = ahash_final;
 		hash->finup = ahash_finup;
 		hash->digest = ahash_digest;
+		if ((driver_alg->auth_info.alg == HASH_ALG_AES) &&
+		    ((driver_alg->auth_info.mode == HASH_MODE_XCBC) ||
+		    (driver_alg->auth_info.mode == HASH_MODE_CMAC))) {
+			hash->setkey = ahash_setkey;
+		}
 	} else {
 		hash->setkey = ahash_hmac_setkey;
 		hash->init = ahash_hmac_init;
--- a/drivers/crypto/bcm/spu.c
+++ b/drivers/crypto/bcm/spu.c
@@ -1155,8 +1155,6 @@ int spum_status_process(u8 *statp)
 	status = __be32_to_cpu(*(__be32 *)statp);
 	flow_log("SPU response STATUS %#08x\n", status);
 	if (status & SPU_STATUS_ERROR_FLAG) {
-		pr_err("%s() Warning: Error result from SPU: %#08x\n",
-		       __func__, status);
 		if (status & SPU_STATUS_INVALID_ICV)
 			return SPU_INVALID_ICV;
 		return -EBADMSG;
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -115,7 +115,7 @@ config BCM_SBA_RAID
 	select DMA_ENGINE_RAID
 	select ASYNC_TX_DISABLE_XOR_VAL_DMA
 	select ASYNC_TX_DISABLE_PQ_VAL_DMA
-	default ARCH_BCM_IPROC
+	default m if ARCH_BCM_IPROC
 	help
 	  Enable support for Broadcom SBA RAID Engine. The SBA RAID
 	  engine is available on most of the Broadcom iProc SoCs. It
--- a/drivers/dma/bcm-sba-raid.c
+++ b/drivers/dma/bcm-sba-raid.c
@@ -1,9 +1,14 @@
 /*
  * Copyright (C) 2017 Broadcom
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  */
 
 /*
@@ -25,11 +30,8 @@
  *
  * The Broadcom SBA RAID driver does not require any register programming
  * except submitting request to SBA hardware device via mailbox channels.
- * This driver implements a DMA device with one DMA channel using a set
- * of mailbox channels provided by Broadcom SoC specific ring manager
- * driver. To exploit parallelism (as described above), all DMA request
- * coming to SBA RAID DMA channel are broken down to smaller requests
- * and submitted to multiple mailbox channels in round-robin fashion.
+ * This driver implements a DMA device with one DMA channel using a single
+ * mailbox channel provided by Broadcom SoC specific ring manager driver.
  * For having more SBA DMA channels, we can create more SBA device nodes
  * in Broadcom SoC specific DTS based on number of hardware rings supported
  * by Broadcom SoC ring manager.
@@ -85,6 +87,7 @@
 #define SBA_CMD_GALOIS					0xe
 
 #define SBA_MAX_REQ_PER_MBOX_CHANNEL			8192
+#define SBA_MAX_MSG_SEND_PER_MBOX_CHANNEL		8
 
 /* Driver helper macros */
 #define to_sba_request(tx)		\
@@ -142,9 +145,7 @@ struct sba_device {
 	u32 max_cmds_pool_size;
 	/* Maibox client and Mailbox channels */
 	struct mbox_client client;
-	int mchans_count;
-	atomic_t mchans_current;
-	struct mbox_chan **mchans;
+	struct mbox_chan *mchan;
 	struct device *mbox_dev;
 	/* DMA device and DMA channel */
 	struct dma_device dma_dev;
@@ -200,14 +201,6 @@ static inline u32 __pure sba_cmd_pq_c_mdata(u32 d, u32 b1, u32 b0)
 
 /* ====== General helper routines ===== */
 
-static void sba_peek_mchans(struct sba_device *sba)
-{
-	int mchan_idx;
-
-	for (mchan_idx = 0; mchan_idx < sba->mchans_count; mchan_idx++)
-		mbox_client_peek_data(sba->mchans[mchan_idx]);
-}
-
 static struct sba_request *sba_alloc_request(struct sba_device *sba)
 {
 	bool found = false;
@@ -231,7 +224,7 @@ static struct sba_request *sba_alloc_request(struct sba_device *sba)
 		 * would have completed which will create more
 		 * room for new requests.
 		 */
-		sba_peek_mchans(sba);
+		mbox_client_peek_data(sba->mchan);
 		return NULL;
 	}
 
@@ -369,15 +362,11 @@ static void sba_cleanup_pending_requests(struct sba_device *sba)
 static int sba_send_mbox_request(struct sba_device *sba,
 				 struct sba_request *req)
 {
-	int mchans_idx, ret = 0;
-
-	/* Select mailbox channel in round-robin fashion */
-	mchans_idx = atomic_inc_return(&sba->mchans_current);
-	mchans_idx = mchans_idx % sba->mchans_count;
+	int ret = 0;
 
 	/* Send message for the request */
 	req->msg.error = 0;
-	ret = mbox_send_message(sba->mchans[mchans_idx], &req->msg);
+	ret = mbox_send_message(sba->mchan, &req->msg);
 	if (ret < 0) {
 		dev_err(sba->dev, "send message failed with error %d", ret);
 		return ret;
@@ -390,7 +379,7 @@ static int sba_send_mbox_request(struct sba_device *sba,
 	}
 
 	/* Signal txdone for mailbox channel */
-	mbox_client_txdone(sba->mchans[mchans_idx], ret);
+	mbox_client_txdone(sba->mchan, ret);
 
 	return ret;
 }
@@ -402,13 +391,8 @@ static void _sba_process_pending_requests(struct sba_device *sba)
 	u32 count;
 	struct sba_request *req;
 
-	/*
-	 * Process few pending requests
-	 *
-	 * For now, we process (<number_of_mailbox_channels> * 8)
-	 * number of requests at a time.
-	 */
-	count = sba->mchans_count * 8;
+	/* Process few pending requests */
+	count = SBA_MAX_MSG_SEND_PER_MBOX_CHANNEL;
 	while (!list_empty(&sba->reqs_pending_list) && count) {
 		/* Get the first pending request */
 		req = list_first_entry(&sba->reqs_pending_list,
@@ -442,7 +426,9 @@ static void sba_process_received_request(struct sba_device *sba,
 
 		WARN_ON(tx->cookie < 0);
 		if (tx->cookie > 0) {
+			spin_lock_irqsave(&sba->reqs_lock, flags);
 			dma_cookie_complete(tx);
+			spin_unlock_irqrestore(&sba->reqs_lock, flags);
 			dmaengine_desc_get_callback_invoke(tx, NULL);
 			dma_descriptor_unmap(tx);
 			tx->callback = NULL;
@@ -454,8 +440,11 @@ static void sba_process_received_request(struct sba_device *sba,
 		spin_lock_irqsave(&sba->reqs_lock, flags);
 
 		/* Free all requests chained to first request */
-		list_for_each_entry(nreq, &first->next, next)
+		list_for_each_entry(nreq, &first->next, next) {
+			async_tx_ack(&nreq->tx);
 			_sba_free_request(sba, nreq);
+		}
+
 		INIT_LIST_HEAD(&first->next);
 
 		/* Free the first request */
@@ -465,6 +454,12 @@ static void sba_process_received_request(struct sba_device *sba,
 		_sba_process_pending_requests(sba);
 
 		spin_unlock_irqrestore(&sba->reqs_lock, flags);
+	} else {
+		spin_lock_irqsave(&sba->reqs_lock, flags);
+		sba->reqs_fence = false;
+		/* Process pending requests */
+		_sba_process_pending_requests(sba);
+		spin_unlock_irqrestore(&sba->reqs_lock, flags);
 	}
 }
 
@@ -570,7 +565,7 @@ static enum dma_status sba_tx_status(struct dma_chan *dchan,
 	if (ret == DMA_COMPLETE)
 		return ret;
 
-	sba_peek_mchans(sba);
+	mbox_client_peek_data(sba->mchan);
 
 	return dma_cookie_status(dchan, cookie, txstate);
 }
@@ -1637,7 +1632,7 @@ static int sba_async_register(struct sba_device *sba)
 
 static int sba_probe(struct platform_device *pdev)
 {
-	int i, ret = 0, mchans_count;
+	int ret = 0;
 	struct sba_device *sba;
 	struct platform_device *mbox_pdev;
 	struct of_phandle_args args;
@@ -1650,12 +1645,11 @@ static int sba_probe(struct platform_device *pdev)
 	sba->dev = &pdev->dev;
 	platform_set_drvdata(pdev, sba);
 
-	/* Number of channels equals number of mailbox channels */
+	/* Number of mailbox channels should be atleast 1 */
 	ret = of_count_phandle_with_args(pdev->dev.of_node,
 					 "mboxes", "#mbox-cells");
 	if (ret <= 0)
 		return -ENODEV;
-	mchans_count = ret;
 
 	/* Determine SBA version from DT compatible string */
 	if (of_device_is_compatible(sba->dev->of_node, "brcm,iproc-sba"))
@@ -1688,7 +1682,7 @@ static int sba_probe(struct platform_device *pdev)
 	default:
 		return -EINVAL;
 	}
-	sba->max_req = SBA_MAX_REQ_PER_MBOX_CHANNEL * mchans_count;
+	sba->max_req = SBA_MAX_REQ_PER_MBOX_CHANNEL;
 	sba->max_cmd_per_req = sba->max_pq_srcs + 3;
 	sba->max_xor_srcs = sba->max_cmd_per_req - 1;
 	sba->max_resp_pool_size = sba->max_req * sba->hw_resp_size;
@@ -1702,55 +1696,30 @@ static int sba_probe(struct platform_device *pdev)
 	sba->client.knows_txdone	= true;
 	sba->client.tx_tout		= 0;
 
-	/* Allocate mailbox channel array */
-	sba->mchans = devm_kcalloc(&pdev->dev, mchans_count,
-				   sizeof(*sba->mchans), GFP_KERNEL);
-	if (!sba->mchans)
-		return -ENOMEM;
-
-	/* Request mailbox channels */
-	sba->mchans_count = 0;
-	for (i = 0; i < mchans_count; i++) {
-		sba->mchans[i] = mbox_request_channel(&sba->client, i);
-		if (IS_ERR(sba->mchans[i])) {
-			ret = PTR_ERR(sba->mchans[i]);
-			goto fail_free_mchans;
-		}
-		sba->mchans_count++;
+	/* Request mailbox channel */
+	sba->mchan = mbox_request_channel(&sba->client, 0);
+	if (IS_ERR(sba->mchan)) {
+		ret = PTR_ERR(sba->mchan);
+		goto fail_exit;
 	}
-	atomic_set(&sba->mchans_current, 0);
 
 	/* Find-out underlying mailbox device */
 	ret = of_parse_phandle_with_args(pdev->dev.of_node,
 					 "mboxes", "#mbox-cells", 0, &args);
 	if (ret)
-		goto fail_free_mchans;
+		goto fail_free_mchan;
 	mbox_pdev = of_find_device_by_node(args.np);
 	of_node_put(args.np);
 	if (!mbox_pdev) {
 		ret = -ENODEV;
-		goto fail_free_mchans;
+		goto fail_free_mchan;
 	}
 	sba->mbox_dev = &mbox_pdev->dev;
 
-	/* All mailbox channels should be of same ring manager device */
-	for (i = 1; i < mchans_count; i++) {
-		ret = of_parse_phandle_with_args(pdev->dev.of_node,
-					 "mboxes", "#mbox-cells", i, &args);
-		if (ret)
-			goto fail_free_mchans;
-		mbox_pdev = of_find_device_by_node(args.np);
-		of_node_put(args.np);
-		if (sba->mbox_dev != &mbox_pdev->dev) {
-			ret = -EINVAL;
-			goto fail_free_mchans;
-		}
-	}
-
 	/* Prealloc channel resource */
 	ret = sba_prealloc_channel_resources(sba);
 	if (ret)
-		goto fail_free_mchans;
+		goto fail_free_mchan;
 
 	/* Check availability of debugfs */
 	if (!debugfs_initialized())
@@ -1777,24 +1746,23 @@ static int sba_probe(struct platform_device *pdev)
 		goto fail_free_resources;
 
 	/* Print device info */
-	dev_info(sba->dev, "%s using SBAv%d and %d mailbox channels",
+	dev_info(sba->dev, "%s using SBAv%d mailbox channel from %s",
 		 dma_chan_name(&sba->dma_chan), sba->ver+1,
-		 sba->mchans_count);
+		 dev_name(sba->mbox_dev));
 
 	return 0;
 
 fail_free_resources:
 	debugfs_remove_recursive(sba->root);
 	sba_freeup_channel_resources(sba);
-fail_free_mchans:
-	for (i = 0; i < sba->mchans_count; i++)
-		mbox_free_channel(sba->mchans[i]);
+fail_free_mchan:
+	mbox_free_channel(sba->mchan);
+fail_exit:
 	return ret;
 }
 
 static int sba_remove(struct platform_device *pdev)
 {
-	int i;
 	struct sba_device *sba = platform_get_drvdata(pdev);
 
 	dma_async_device_unregister(&sba->dma_dev);
@@ -1803,8 +1771,7 @@ static int sba_remove(struct platform_device *pdev)
 
 	sba_freeup_channel_resources(sba);
 
-	for (i = 0; i < sba->mchans_count; i++)
-		mbox_free_channel(sba->mchans[i]);
+	mbox_free_channel(sba->mchan);
 
 	return 0;
 }
--- a/drivers/extcon/extcon-usb-gpio.c
+++ b/drivers/extcon/extcon-usb-gpio.c
@@ -41,6 +41,7 @@ struct usb_extcon_info {
 
 	unsigned long debounce_jiffies;
 	struct delayed_work wq_detcable;
+	unsigned int gpio_debounce_timeout_ms;
 };
 
 static const unsigned int usb_extcon_cable[] = {
@@ -133,6 +134,11 @@ static int usb_extcon_probe(struct platform_device *pdev)
 	if (IS_ERR(info->vbus_gpiod))
 		return PTR_ERR(info->vbus_gpiod);
 
+	ret = of_property_read_u32(np, "debounce-timeout-ms",
+			     &info->gpio_debounce_timeout_ms);
+	if (ret)
+		info->gpio_debounce_timeout_ms = USB_GPIO_DEBOUNCE_MS;
+
 	info->edev = devm_extcon_dev_allocate(dev, usb_extcon_cable);
 	if (IS_ERR(info->edev)) {
 		dev_err(dev, "failed to allocate extcon device\n");
@@ -147,13 +153,14 @@ static int usb_extcon_probe(struct platform_device *pdev)
 
 	if (info->id_gpiod)
 		ret = gpiod_set_debounce(info->id_gpiod,
-					 USB_GPIO_DEBOUNCE_MS * 1000);
+					 info->gpio_debounce_timeout_ms * 1000);
 	if (!ret && info->vbus_gpiod)
 		ret = gpiod_set_debounce(info->vbus_gpiod,
-					 USB_GPIO_DEBOUNCE_MS * 1000);
+					 info->gpio_debounce_timeout_ms * 1000);
 
 	if (ret < 0)
-		info->debounce_jiffies = msecs_to_jiffies(USB_GPIO_DEBOUNCE_MS);
+		info->debounce_jiffies = msecs_to_jiffies(
+						info->gpio_debounce_timeout_ms);
 
 	INIT_DELAYED_WORK(&info->wq_detcable, usb_extcon_detect_cable);
 
--- a/drivers/gpio/gpio-pca953x.c
+++ b/drivers/gpio/gpio-pca953x.c
@@ -45,9 +45,13 @@
 #define PCAL953X_INT_MASK	37
 #define PCAL953X_INT_STAT	38
 
+#define PCAL9505_INT_MASK	36
+
 #define PCA_GPIO_MASK		0x00FF
 #define PCA_INT			0x0100
 #define PCA_PCAL		0x0200
+#define PCA_PCAL_9505_FIX	0x0400
+
 #define PCA953X_TYPE		0x1000
 #define PCA957X_TYPE		0x2000
 #define PCA_TYPE_MASK		0xF000
@@ -55,7 +59,8 @@
 #define PCA_CHIP_TYPE(x)	((x) & PCA_TYPE_MASK)
 
 static const struct i2c_device_id pca953x_id[] = {
-	{ "pca9505", 40 | PCA953X_TYPE | PCA_INT, },
+	{ "pca9505", 40 | PCA953X_TYPE | PCA_INT | PCA_PCAL |
+	  PCA_PCAL_9505_FIX, },
 	{ "pca9534", 8  | PCA953X_TYPE | PCA_INT, },
 	{ "pca9535", 16 | PCA953X_TYPE | PCA_INT, },
 	{ "pca9536", 4  | PCA953X_TYPE, },
@@ -121,6 +126,7 @@ struct pca953x_chip {
 	unsigned gpio_start;
 	u8 reg_output[MAX_BANK];
 	u8 reg_direction[MAX_BANK];
+	u8 prev_stat[MAX_BANK];
 	struct mutex i2c_lock;
 
 #ifdef CONFIG_GPIO_PCA953X_IRQ
@@ -469,14 +475,20 @@ static void pca953x_irq_bus_sync_unlock(struct irq_data *d)
 	u8 invert_irq_mask[MAX_BANK];
 
 	if (chip->driver_data & PCA_PCAL) {
-		/* Enable latch on interrupt-enabled inputs */
-		pca953x_write_regs(chip, PCAL953X_IN_LATCH, chip->irq_mask);
+		if (!(chip->driver_data & PCA_PCAL_9505_FIX)) {
+			/* Enable latch on interrupt-enabled inputs */
+			pca953x_write_regs(chip, PCAL953X_IN_LATCH,
+					   chip->irq_mask);
+		}
 
 		for (i = 0; i < NBANK(chip); i++)
 			invert_irq_mask[i] = ~chip->irq_mask[i];
 
 		/* Unmask enabled interrupts */
-		pca953x_write_regs(chip, PCAL953X_INT_MASK, invert_irq_mask);
+		if (chip->driver_data & PCA_PCAL_9505_FIX)
+			invert_irq_mask[MAX_BANK - 1] = 0x0;
+		pca953x_write_regs(chip, PCAL9505_INT_MASK,
+				   invert_irq_mask);
 	}
 
 	/* Look for any newly setup interrupt */
@@ -540,16 +552,30 @@ static bool pca953x_irq_pending(struct pca953x_chip *chip, u8 *pending)
 	int ret, i;
 
 	if (chip->driver_data & PCA_PCAL) {
-		/* Read the current interrupt status from the device */
-		ret = pca953x_read_regs(chip, PCAL953X_INT_STAT, trigger);
-		if (ret)
-			return false;
+
+		if (!(chip->driver_data & PCA_PCAL_9505_FIX)) {
+			/* Read the current interrupt status from the device */
+			ret = pca953x_read_regs(chip, PCAL953X_INT_STAT,
+						trigger);
+			if (ret)
+				return false;
+		}
 
 		/* Check latched inputs and clear interrupt status */
 		ret = pca953x_read_regs(chip, PCA953X_INPUT, cur_stat);
 		if (ret)
 			return false;
 
+		if (chip->driver_data & PCA_PCAL_9505_FIX) {
+			for (i = 0; i < NBANK(chip); i++) {
+				pending[i] = (cur_stat[i] ^ chip->prev_stat[i]);
+				if (pending[i])
+					pending_seen = true;
+			}
+			memcpy(chip->prev_stat, cur_stat, NBANK(chip));
+			return pending_seen;
+		}
+
 		for (i = 0; i < NBANK(chip); i++) {
 			/* Apply filter for rising/falling edge selection */
 			pending[i] = (~cur_stat[i] & chip->irq_trig_fall[i]) |
@@ -622,7 +648,7 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 			     int irq_base)
 {
 	struct i2c_client *client = chip->client;
-	int ret, i;
+	int ret, i, irqflags;
 
 	if (client->irq && irq_base != -1
 			&& (chip->driver_data & PCA_INT)) {
@@ -631,6 +657,8 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 		if (ret)
 			return ret;
 
+		if (chip->driver_data & PCA_PCAL_9505_FIX)
+			pca953x_read_regs(chip, PCA953X_INPUT, chip->prev_stat);
 		/*
 		 * There is no way to know which GPIO line generated the
 		 * interrupt.  We have to rely on the previous read for
@@ -640,13 +668,19 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 			chip->irq_stat[i] &= chip->reg_direction[i];
 		mutex_init(&chip->irq_lock);
 
+		if (chip->driver_data & PCA_PCAL_9505_FIX)
+			irqflags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT |
+				   IRQF_SHARED;
+		else
+			irqflags = IRQF_TRIGGER_LOW | IRQF_ONESHOT |
+				   IRQF_SHARED;
+
+		/* Stingray PCI present on falling edge. */
 		ret = devm_request_threaded_irq(&client->dev,
-					client->irq,
-					   NULL,
-					   pca953x_irq_handler,
-					   IRQF_TRIGGER_LOW | IRQF_ONESHOT |
-						   IRQF_SHARED,
-					   dev_name(&client->dev), chip);
+						client->irq,
+						NULL,
+						pca953x_irq_handler, irqflags,
+						dev_name(&client->dev), chip);
 		if (ret) {
 			dev_err(&client->dev, "failed to request irq %d\n",
 				client->irq);
--- a/drivers/i2c/Kconfig
+++ b/drivers/i2c/Kconfig
@@ -118,6 +118,16 @@ if I2C_SLAVE
 config I2C_SLAVE_EEPROM
 	tristate "I2C eeprom slave driver"
 
+config I2C_SLAVE_BMC
+	tristate "I2C slave BMC driver"
+	default ARCH_BCM_IPROC
+	help
+	  Say Y here if you want to build support for slave mode
+	  BMC client device driver. This driver can provide thermal
+	  information and other chip status with i2c command.
+	  This support is also available as a module.  If so, the module
+	  will be called i2c-slave-bmc.
+
 endif
 
 config I2C_DEBUG_CORE
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_I2C_MUX)		+= i2c-mux.o
 obj-y				+= algos/ busses/ muxes/
 obj-$(CONFIG_I2C_STUB)		+= i2c-stub.o
 obj-$(CONFIG_I2C_SLAVE_EEPROM)	+= i2c-slave-eeprom.o
+obj-$(CONFIG_I2C_SLAVE_BMC)	+= i2c-slave-bmc.o
 
 ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
 CFLAGS_i2c-core-base.o := -Wno-deprecated-declarations
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -412,6 +412,7 @@ config I2C_BCM_IPROC
 	tristate "Broadcom iProc I2C controller"
 	depends on ARCH_BCM_IPROC || COMPILE_TEST
 	default ARCH_BCM_IPROC
+	select I2C_SLAVE
 	help
 	  If you say yes to this option, support will be included for the
 	  Broadcom iProc I2C controller.
--- a/drivers/i2c/busses/i2c-bcm-iproc.c
+++ b/drivers/i2c/busses/i2c-bcm-iproc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Broadcom Corporation
+ * Copyright (C) 2014-2017 Broadcom
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -17,80 +17,185 @@
 #include <linux/io.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 
-#define CFG_OFFSET                   0x00
-#define CFG_RESET_SHIFT              31
-#define CFG_EN_SHIFT                 30
-#define CFG_M_RETRY_CNT_SHIFT        16
-#define CFG_M_RETRY_CNT_MASK         0x0f
-
-#define TIM_CFG_OFFSET               0x04
-#define TIM_CFG_MODE_400_SHIFT       31
-
-#define M_FIFO_CTRL_OFFSET           0x0c
-#define M_FIFO_RX_FLUSH_SHIFT        31
-#define M_FIFO_TX_FLUSH_SHIFT        30
-#define M_FIFO_RX_CNT_SHIFT          16
-#define M_FIFO_RX_CNT_MASK           0x7f
-#define M_FIFO_RX_THLD_SHIFT         8
-#define M_FIFO_RX_THLD_MASK          0x3f
-
-#define M_CMD_OFFSET                 0x30
-#define M_CMD_START_BUSY_SHIFT       31
-#define M_CMD_STATUS_SHIFT           25
-#define M_CMD_STATUS_MASK            0x07
-#define M_CMD_STATUS_SUCCESS         0x0
-#define M_CMD_STATUS_LOST_ARB        0x1
-#define M_CMD_STATUS_NACK_ADDR       0x2
-#define M_CMD_STATUS_NACK_DATA       0x3
-#define M_CMD_STATUS_TIMEOUT         0x4
-#define M_CMD_PROTOCOL_SHIFT         9
-#define M_CMD_PROTOCOL_MASK          0xf
-#define M_CMD_PROTOCOL_BLK_WR        0x7
-#define M_CMD_PROTOCOL_BLK_RD        0x8
-#define M_CMD_PEC_SHIFT              8
-#define M_CMD_RD_CNT_SHIFT           0
-#define M_CMD_RD_CNT_MASK            0xff
-
-#define IE_OFFSET                    0x38
-#define IE_M_RX_FIFO_FULL_SHIFT      31
-#define IE_M_RX_THLD_SHIFT           30
-#define IE_M_START_BUSY_SHIFT        28
-#define IE_M_TX_UNDERRUN_SHIFT       27
-
-#define IS_OFFSET                    0x3c
-#define IS_M_RX_FIFO_FULL_SHIFT      31
-#define IS_M_RX_THLD_SHIFT           30
-#define IS_M_START_BUSY_SHIFT        28
-#define IS_M_TX_UNDERRUN_SHIFT       27
-
-#define M_TX_OFFSET                  0x40
-#define M_TX_WR_STATUS_SHIFT         31
-#define M_TX_DATA_SHIFT              0
-#define M_TX_DATA_MASK               0xff
-
-#define M_RX_OFFSET                  0x44
-#define M_RX_STATUS_SHIFT            30
-#define M_RX_STATUS_MASK             0x03
-#define M_RX_PEC_ERR_SHIFT           29
-#define M_RX_DATA_SHIFT              0
-#define M_RX_DATA_MASK               0xff
-
-#define I2C_TIMEOUT_MSEC             50000
-#define M_TX_RX_FIFO_SIZE            64
+#define IDM_CTRL_DIRECT_OFFSET            0x00
+
+#define CFG_OFFSET                        0x00
+#define CFG_RESET_SHIFT                   31
+#define CFG_EN_SHIFT                      30
+#define CFG_SLAVE_ADDR_0_SHIFT            28
+#define CFG_M_RETRY_CNT_SHIFT             16
+#define CFG_M_RETRY_CNT_MASK              0x0f
+
+#define TIM_CFG_OFFSET                    0x04
+#define TIM_CFG_MODE_400_SHIFT            31
+#define TIM_RAND_SLAVE_STRETCH_SHIFT      24
+#define TIM_RAND_SLAVE_STRETCH_MASK       0x7f
+#define TIM_PERIODIC_SLAVE_STRETCH_SHIFT  16
+#define TIM_PERIODIC_SLAVE_STRETCH_MASK   0x7f
+
+#define S_CFG_SMBUS_ADDR_OFFSET           0x08
+#define S_CFG_EN_NIC_SMB_ADDR3_SHIFT      31
+#define S_CFG_NIC_SMB_ADDR3_SHIFT         24
+#define S_CFG_NIC_SMB_ADDR3_MASK          0x7f
+#define S_CFG_EN_NIC_SMB_ADDR2_SHIFT      23
+#define S_CFG_NIC_SMB_ADDR2_SHIFT         16
+#define S_CFG_NIC_SMB_ADDR2_MASK          0x7f
+#define S_CFG_EN_NIC_SMB_ADDR1_SHIFT      15
+#define S_CFG_NIC_SMB_ADDR1_SHIFT         8
+#define S_CFG_NIC_SMB_ADDR1_MASK          0x7f
+#define S_CFG_EN_NIC_SMB_ADDR0_SHIFT      7
+#define S_CFG_NIC_SMB_ADDR0_SHIFT         0
+#define S_CFG_NIC_SMB_ADDR0_MASK          0x7f
+
+#define M_FIFO_CTRL_OFFSET                0x0c
+#define M_FIFO_RX_FLUSH_SHIFT             31
+#define M_FIFO_TX_FLUSH_SHIFT             30
+#define M_FIFO_RX_CNT_SHIFT               16
+#define M_FIFO_RX_CNT_MASK                0x7f
+#define M_FIFO_RX_THLD_SHIFT              8
+#define M_FIFO_RX_THLD_MASK               0x3f
+
+#define S_FIFO_CTRL_OFFSET                0x10
+#define S_FIFO_RX_FLUSH_SHIFT             31
+#define S_FIFO_TX_FLUSH_SHIFT             30
+#define S_FIFO_RX_CNT_SHIFT               16
+#define S_FIFO_RX_CNT_MASK                0x7f
+#define S_FIFO_RX_THLD_SHIFT              8
+#define S_FIFO_RX_THLD_MASK               0x3f
+
+#define M_CMD_OFFSET                      0x30
+#define M_CMD_START_BUSY_SHIFT            31
+#define M_CMD_STATUS_SHIFT                25
+#define M_CMD_STATUS_MASK                 0x07
+#define M_CMD_STATUS_SUCCESS              0x0
+#define M_CMD_STATUS_LOST_ARB             0x1
+#define M_CMD_STATUS_NACK_ADDR            0x2
+#define M_CMD_STATUS_NACK_DATA            0x3
+#define M_CMD_STATUS_TIMEOUT              0x4
+#define M_CMD_STATUS_FIFO_UNDERRUN        0x5
+#define M_CMD_STATUS_RX_FIFO_FULL         0x6
+#define M_CMD_PROTOCOL_SHIFT              9
+#define M_CMD_PROTOCOL_MASK               0xf
+#define M_CMD_PROTOCOL_BLK_WR             0x7
+#define M_CMD_PROTOCOL_BLK_RD             0x8
+#define M_CMD_PEC_SHIFT                   8
+#define M_CMD_RD_CNT_SHIFT                0
+#define M_CMD_RD_CNT_MASK                 0xff
+
+#define S_CMD_OFFSET                      0x34
+#define S_CMD_START_BUSY_SHIFT            31
+#define S_CMD_STATUS_SHIFT                23
+#define S_CMD_STATUS_MASK                 0x07
+#define S_CMD_STATUS_SUCCESS              0x0
+#define S_CMD_STATUS_TIMEOUT              0x5
+
+#define IE_OFFSET                         0x38
+#define IE_M_RX_FIFO_FULL_SHIFT           31
+#define IE_M_RX_THLD_SHIFT                30
+#define IE_M_START_BUSY_SHIFT             28
+#define IE_M_TX_UNDERRUN_SHIFT            27
+#define IE_S_RX_FIFO_FULL_SHIFT           26
+#define IE_S_RX_THLD_SHIFT                25
+#define IE_S_RX_EVENT_SHIFT               24
+#define IE_S_START_BUSY_SHIFT             23
+#define IE_S_TX_UNDERRUN_SHIFT            22
+#define IE_S_RD_EVENT_SHIFT               21
+
+#define IS_OFFSET                         0x3c
+#define IS_M_RX_FIFO_FULL_SHIFT           31
+#define IS_M_RX_THLD_SHIFT                30
+#define IS_M_START_BUSY_SHIFT             28
+#define IS_M_TX_UNDERRUN_SHIFT            27
+#define IS_S_RX_FIFO_FULL_SHIFT           26
+#define IS_S_RX_THLD_SHIFT                25
+#define IS_S_RX_EVENT_SHIFT               24
+#define IS_S_START_BUSY_SHIFT             23
+#define IS_S_TX_UNDERRUN_SHIFT            22
+#define IS_S_RD_EVENT_SHIFT               21
+
+#define M_TX_OFFSET                       0x40
+#define M_TX_WR_STATUS_SHIFT              31
+#define M_TX_DATA_SHIFT                   0
+#define M_TX_DATA_MASK                    0xff
+
+#define M_RX_OFFSET                       0x44
+#define M_RX_STATUS_SHIFT                 30
+#define M_RX_STATUS_MASK                  0x03
+#define M_RX_PEC_ERR_SHIFT                29
+#define M_RX_DATA_SHIFT                   0
+#define M_RX_DATA_MASK                    0xff
+
+#define S_TX_OFFSET                       0x48
+#define S_TX_WR_STATUS_SHIFT              31
+#define S_TX_DATA_SHIFT                   0
+#define S_TX_DATA_MASK                    0xff
+
+#define S_RX_OFFSET                       0x4c
+#define S_RX_STATUS_SHIFT                 30
+#define S_RX_STATUS_MASK                  0x03
+#define S_RX_PEC_ERR_SHIFT                29
+#define S_RX_DATA_SHIFT                   0
+#define S_RX_DATA_MASK                    0xff
+
+#define I2C_TIMEOUT_MSEC                  50000
+#define M_TX_RX_FIFO_SIZE                 64
+#define M_RX_FIFO_MAX_THLD_VALUE          63
+
+#define M_RX_MAX_READ_LEN                 255
+#define M_RX_FIFO_THLD_VALUE              50
+
+#define IE_M_ALL_INTERRUPT_SHIFT          27
+#define IE_M_ALL_INTERRUPT_MASK           0x1e
+
+#define SLAVE_READ_WRITE_BIT_MASK         0x1
+#define SLAVE_READ_WRITE_BIT_SHIFT        0x1
+#define SLAVE_MAX_SIZE_TRANSACTION        64
+#define SLAVE_CLOCK_STRETCH_TIME          25
+
+#define IE_S_ALL_INTERRUPT_SHIFT          21
+#define IE_S_ALL_INTERRUPT_MASK           0x3f
+
+enum i2c_slave_read_status {
+	I2C_SLAVE_RX_FIFO_EMPTY = 0,
+	I2C_SLAVE_RX_START,
+	I2C_SLAVE_RX_DATA,
+	I2C_SLAVE_RX_END,
+};
+
+enum i2c_slave_re_init {
+	REINIT_SLAVE = 0,
+	INIT_SLAVE,
+};
 
 enum bus_speed_index {
 	I2C_SPD_100K = 0,
 	I2C_SPD_400K,
 };
 
+enum bcm_iproc_i2c_type {
+	IPROC_I2C,
+	IPROC_I2C_NIC
+};
+
 struct bcm_iproc_i2c_dev {
 	struct device *device;
+	enum bcm_iproc_i2c_type type;
 	int irq;
 
 	void __iomem *base;
+	void __iomem *idm_base;
+
+	u32 ape_addr_mask;
+
+	/* lock for indirect access through IDM */
+	spinlock_t idm_lock;
+
+	/* indicates no slave mode support */
+	bool no_slave;
 
 	struct i2c_adapter adapter;
 	unsigned int bus_speed;
@@ -100,68 +205,325 @@ struct bcm_iproc_i2c_dev {
 
 	struct i2c_msg *msg;
 
+	struct i2c_client *slave;
+
 	/* bytes that have been transferred */
 	unsigned int tx_bytes;
+	/* bytes that have been read */
+	unsigned int rx_bytes;
+	unsigned int thld_bytes;
 };
 
 /*
  * Can be expanded in the future if more interrupt status bits are utilized
  */
-#define ISR_MASK (BIT(IS_M_START_BUSY_SHIFT) | BIT(IS_M_TX_UNDERRUN_SHIFT))
+#define ISR_MASK (BIT(IS_M_START_BUSY_SHIFT) | BIT(IS_M_TX_UNDERRUN_SHIFT)\
+		| BIT(IS_M_RX_THLD_SHIFT))
 
-static irqreturn_t bcm_iproc_i2c_isr(int irq, void *data)
+#define ISR_MASK_SLAVE (BIT(IS_S_START_BUSY_SHIFT)\
+		| BIT(IS_S_RX_EVENT_SHIFT) | BIT(IS_S_RD_EVENT_SHIFT)\
+		| BIT(IS_S_TX_UNDERRUN_SHIFT))
+
+static int bcm_iproc_i2c_reg_slave(struct i2c_client *slave);
+static int bcm_iproc_i2c_unreg_slave(struct i2c_client *slave);
+static void bcm_iproc_i2c_enable_disable(struct bcm_iproc_i2c_dev *iproc_i2c,
+					 bool enable);
+
+static inline u32 iproc_i2c_rd_reg(struct bcm_iproc_i2c_dev *iproc_i2c,
+				   u32 offset)
 {
-	struct bcm_iproc_i2c_dev *iproc_i2c = data;
-	u32 status = readl(iproc_i2c->base + IS_OFFSET);
+	u32 val;
 
-	status &= ISR_MASK;
+	if (iproc_i2c->idm_base) {
+		spin_lock(&iproc_i2c->idm_lock);
+		writel(iproc_i2c->ape_addr_mask,
+		       iproc_i2c->idm_base + IDM_CTRL_DIRECT_OFFSET);
+		val = readl(iproc_i2c->base + offset);
+		spin_unlock(&iproc_i2c->idm_lock);
+	} else {
+		val = readl(iproc_i2c->base + offset);
+	}
 
-	if (!status)
-		return IRQ_NONE;
+	return val;
+}
 
-	/* TX FIFO is empty and we have more data to send */
-	if (status & BIT(IS_M_TX_UNDERRUN_SHIFT)) {
-		struct i2c_msg *msg = iproc_i2c->msg;
-		unsigned int tx_bytes = msg->len - iproc_i2c->tx_bytes;
-		unsigned int i;
-		u32 val;
-
-		/* can only fill up to the FIFO size */
-		tx_bytes = min_t(unsigned int, tx_bytes, M_TX_RX_FIFO_SIZE);
-		for (i = 0; i < tx_bytes; i++) {
-			/* start from where we left over */
-			unsigned int idx = iproc_i2c->tx_bytes + i;
+static inline void iproc_i2c_wr_reg(struct bcm_iproc_i2c_dev *iproc_i2c,
+				    u32 offset, u32 val)
+{
+	if (iproc_i2c->idm_base) {
+		spin_lock(&iproc_i2c->idm_lock);
+		writel(iproc_i2c->ape_addr_mask,
+		       iproc_i2c->idm_base + IDM_CTRL_DIRECT_OFFSET);
+		writel(val, iproc_i2c->base + offset);
+		spin_unlock(&iproc_i2c->idm_lock);
+	} else {
+		writel(val, iproc_i2c->base + offset);
+	}
+}
+
+static void bcm_iproc_i2c_slave_init(
+	struct bcm_iproc_i2c_dev *iproc_i2c, int re_init)
+{
+	u32 val;
 
-			val = msg->buf[idx];
+	if (re_init == REINIT_SLAVE) {
+		/* put controller in reset */
+		val = iproc_i2c_rd_reg(iproc_i2c, CFG_OFFSET);
+		val |= BIT(CFG_RESET_SHIFT);
+		iproc_i2c_wr_reg(iproc_i2c, CFG_OFFSET, val);
 
-			/* mark the last byte */
-			if (idx == msg->len - 1) {
-				u32 tmp;
+		/* wait 100 usec per spec */
+		udelay(100);
 
-				val |= BIT(M_TX_WR_STATUS_SHIFT);
+		/* bring controller out of reset */
+		val &= ~(BIT(CFG_RESET_SHIFT));
+		iproc_i2c_wr_reg(iproc_i2c, CFG_OFFSET, val);
+	}
+
+	/* flush TX/RX FIFOs */
+	val = (BIT(S_FIFO_RX_FLUSH_SHIFT) | BIT(S_FIFO_TX_FLUSH_SHIFT));
+	iproc_i2c_wr_reg(iproc_i2c, S_FIFO_CTRL_OFFSET, val);
+
+	/* RANDOM SLAVE STRETCH time - 20ms*/
+	val = iproc_i2c_rd_reg(iproc_i2c, TIM_CFG_OFFSET);
+	val &= ~(TIM_RAND_SLAVE_STRETCH_MASK << TIM_RAND_SLAVE_STRETCH_SHIFT);
+	val |= (SLAVE_CLOCK_STRETCH_TIME << TIM_RAND_SLAVE_STRETCH_SHIFT);
+	iproc_i2c_wr_reg(iproc_i2c, TIM_CFG_OFFSET, val);
+
+	/* Configure the slave address */
+	val = iproc_i2c_rd_reg(iproc_i2c, S_CFG_SMBUS_ADDR_OFFSET);
+	val |= BIT(S_CFG_EN_NIC_SMB_ADDR3_SHIFT);
+	val &= ~(S_CFG_NIC_SMB_ADDR3_MASK << S_CFG_NIC_SMB_ADDR3_SHIFT);
+	val |= (iproc_i2c->slave->addr << S_CFG_NIC_SMB_ADDR3_SHIFT);
+	iproc_i2c_wr_reg(iproc_i2c, S_CFG_SMBUS_ADDR_OFFSET, val);
+
+	/* clear all pending slave interrupts */
+	iproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, ISR_MASK_SLAVE);
+
+	/* Enable interrupt register to indicate a valid byte in receive fifo */
+	val = BIT(IE_S_RX_EVENT_SHIFT);
+	/* Enable interrupt register for the Slave BUSY command */
+	val |= BIT(IE_S_START_BUSY_SHIFT);
+	iproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val);
+}
+
+static void bcm_iproc_i2c_check_slave_status(
+	struct bcm_iproc_i2c_dev *iproc_i2c)
+{
+	u32 val;
+
+	val = iproc_i2c_rd_reg(iproc_i2c, S_CMD_OFFSET);
+	/* status is valid only when START_BUSY is cleared after it was set */
+	if (val & BIT(S_CMD_START_BUSY_SHIFT))
+		return;
+
+	val = (val >> S_CMD_STATUS_SHIFT) & S_CMD_STATUS_MASK;
+	if (val == S_CMD_STATUS_TIMEOUT) {
+		dev_err(iproc_i2c->device, "slave random stretch time timeout\n");
+
+		/* re-initialize i2c for recovery */
+		bcm_iproc_i2c_enable_disable(iproc_i2c, false);
+		bcm_iproc_i2c_slave_init(iproc_i2c, REINIT_SLAVE);
+		bcm_iproc_i2c_enable_disable(iproc_i2c, true);
+	}
+}
+
+static bool bcm_iproc_i2c_slave_isr(struct bcm_iproc_i2c_dev *iproc_i2c,
+				    u32 status)
+{
+	u32 val;
+	u8 value, rd_status;
+
+	/* Slave RX byte receive */
+	if (status & BIT(IS_S_RX_EVENT_SHIFT)) {
+		val = iproc_i2c_rd_reg(iproc_i2c, S_RX_OFFSET);
+		rd_status = (val >> S_RX_STATUS_SHIFT) & S_RX_STATUS_MASK;
+		dev_dbg(iproc_i2c->device, "rd_status %x\n", rd_status);
+		if (rd_status == I2C_SLAVE_RX_START) {
+			/* Start of SMBUS for Master write */
+			i2c_slave_event(iproc_i2c->slave,
+					I2C_SLAVE_WRITE_REQUESTED, &value);
+			val = iproc_i2c_rd_reg(iproc_i2c, S_RX_OFFSET);
+			value = (u8)((val >> S_RX_DATA_SHIFT) & S_RX_DATA_MASK);
+			i2c_slave_event(iproc_i2c->slave,
+					I2C_SLAVE_WRITE_RECEIVED, &value);
+		} else if (status & BIT(IS_S_RD_EVENT_SHIFT)) {
+			/* Start of SMBUS for Master Read */
+			i2c_slave_event(iproc_i2c->slave,
+					I2C_SLAVE_READ_REQUESTED, &value);
+			iproc_i2c_wr_reg(iproc_i2c, S_TX_OFFSET, value);
+			val = BIT(S_CMD_START_BUSY_SHIFT);
+			iproc_i2c_wr_reg(iproc_i2c, S_CMD_OFFSET, val);
+			val = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);
+			/*
+			 * Enable interrupt for TX FIFO becomes empty and
+			 * less than PKT_LENGTH bytes were output on the SMBUS
+			 */
+			val |= BIT(IE_S_TX_UNDERRUN_SHIFT);
+			iproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val);
+		} else {
+			/* Master write other than start */
+			value = (u8)((val >> S_RX_DATA_SHIFT) & S_RX_DATA_MASK);
+			i2c_slave_event(iproc_i2c->slave,
+					I2C_SLAVE_WRITE_RECEIVED, &value);
+		}
+	} else if (status & BIT(IS_S_TX_UNDERRUN_SHIFT)) {
+		/* Master read other than start */
+		i2c_slave_event(iproc_i2c->slave,
+				I2C_SLAVE_READ_PROCESSED, &value);
+
+		iproc_i2c_wr_reg(iproc_i2c, S_TX_OFFSET, value);
+		val = BIT(S_CMD_START_BUSY_SHIFT);
+		iproc_i2c_wr_reg(iproc_i2c, S_CMD_OFFSET, val);
+	}
+
+	/* Stop */
+	if (status & BIT(IS_S_START_BUSY_SHIFT)) {
+		i2c_slave_event(iproc_i2c->slave, I2C_SLAVE_STOP, &value);
+		val = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);
+		/* Disable TX UNDERRUN interrupt */
+		val &= ~BIT(IE_S_TX_UNDERRUN_SHIFT);
+		iproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val);
+	}
+
+	/* clear interrupt status */
+	iproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, status);
+	bcm_iproc_i2c_check_slave_status(iproc_i2c);
+
+	return true;
+}
+
+static void bcm_iproc_i2c_read_valid_bytes(struct bcm_iproc_i2c_dev *iproc_i2c)
+{
+	struct i2c_msg *msg = iproc_i2c->msg;
+
+	/* Read valid data from RX FIFO */
+	while (iproc_i2c->rx_bytes < msg->len) {
+		if (!((iproc_i2c_rd_reg(iproc_i2c,
+					M_FIFO_CTRL_OFFSET) >>
+		       M_FIFO_RX_CNT_SHIFT) & M_FIFO_RX_CNT_MASK))
+			break;
+
+		msg->buf[iproc_i2c->rx_bytes] =
+			(iproc_i2c_rd_reg(iproc_i2c, M_RX_OFFSET) >>
+			M_RX_DATA_SHIFT) & M_RX_DATA_MASK;
+		iproc_i2c->rx_bytes++;
+	}
+}
+
+static void bcm_iproc_i2c_send(struct bcm_iproc_i2c_dev *iproc_i2c)
+{
+	struct i2c_msg *msg = iproc_i2c->msg;
+	unsigned int tx_bytes = msg->len - iproc_i2c->tx_bytes;
+	unsigned int i;
+	u32 val;
+
+	/* can only fill up to the FIFO size */
+	tx_bytes = min_t(unsigned int, tx_bytes, M_TX_RX_FIFO_SIZE);
+	for (i = 0; i < tx_bytes; i++) {
+		/* start from where we left over */
+		unsigned int idx = iproc_i2c->tx_bytes + i;
+
+		val = msg->buf[idx];
+
+		/* mark the last byte */
+		if (idx == msg->len - 1) {
+			val |= BIT(M_TX_WR_STATUS_SHIFT);
+
+			if (iproc_i2c->irq) {
+				u32 tmp;
 
 				/*
-				 * Since this is the last byte, we should
-				 * now disable TX FIFO underrun interrupt
+				 * Since this is the last byte, we should now
+				 * disable TX FIFO underrun interrupt
 				 */
-				tmp = readl(iproc_i2c->base + IE_OFFSET);
+				tmp = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);
 				tmp &= ~BIT(IE_M_TX_UNDERRUN_SHIFT);
-				writel(tmp, iproc_i2c->base + IE_OFFSET);
+				iproc_i2c_wr_reg(iproc_i2c, IE_OFFSET,
+						 tmp);
 			}
+		}
 
-			/* load data into TX FIFO */
-			writel(val, iproc_i2c->base + M_TX_OFFSET);
+		/* load data into TX FIFO */
+		iproc_i2c_wr_reg(iproc_i2c, M_TX_OFFSET, val);
+	}
+
+	/* update number of transferred bytes */
+	iproc_i2c->tx_bytes += tx_bytes;
+}
+
+static void bcm_iproc_i2c_read(struct bcm_iproc_i2c_dev *iproc_i2c)
+{
+	struct i2c_msg *msg = iproc_i2c->msg;
+	u32 bytes_left, val;
+
+	bcm_iproc_i2c_read_valid_bytes(iproc_i2c);
+	bytes_left = msg->len - iproc_i2c->rx_bytes;
+	if (bytes_left == 0) {
+		if (iproc_i2c->irq) {
+			/* finished reading all data, disable rx thld event */
+			val = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);
+			val &= ~BIT(IS_M_RX_THLD_SHIFT);
+			iproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val);
 		}
-		/* update number of transferred bytes */
-		iproc_i2c->tx_bytes += tx_bytes;
+	} else if (bytes_left < iproc_i2c->thld_bytes) {
+		/* set bytes left as threshold */
+		val = iproc_i2c_rd_reg(iproc_i2c, M_FIFO_CTRL_OFFSET);
+		val &= ~(M_FIFO_RX_THLD_MASK << M_FIFO_RX_THLD_SHIFT);
+		val |= (bytes_left << M_FIFO_RX_THLD_SHIFT);
+		iproc_i2c_wr_reg(iproc_i2c, M_FIFO_CTRL_OFFSET, val);
+		iproc_i2c->thld_bytes = bytes_left;
+	} else {
+		/*
+		 * bytes_left >= iproc_i2c->thld_bytes,
+		 * hence no need to change the THRESHOLD SET.
+		 * It will remain as iproc_i2c->thld_bytes itself
+		 */
 	}
+}
+
+static void bcm_iproc_i2c_process_m_event(struct bcm_iproc_i2c_dev *iproc_i2c,
+					  u32 status)
+{
+	/* TX FIFO is empty and we have more data to send */
+	if (status & BIT(IS_M_TX_UNDERRUN_SHIFT))
+		bcm_iproc_i2c_send(iproc_i2c);
+
+	/* RX FIFO threshold is reached and data needs to be read out */
+	if (status & BIT(IS_M_RX_THLD_SHIFT))
+		bcm_iproc_i2c_read(iproc_i2c);
 
+	/* transfer is done */
 	if (status & BIT(IS_M_START_BUSY_SHIFT)) {
 		iproc_i2c->xfer_is_done = 1;
-		complete(&iproc_i2c->done);
+		if (iproc_i2c->irq)
+			complete(&iproc_i2c->done);
 	}
+}
 
-	writel(status, iproc_i2c->base + IS_OFFSET);
+static irqreturn_t bcm_iproc_i2c_isr(int irq, void *data)
+{
+	struct bcm_iproc_i2c_dev *iproc_i2c = data;
+	u32 status = iproc_i2c_rd_reg(iproc_i2c, IS_OFFSET);
+	bool ret;
+	u32 sl_status = status & ISR_MASK_SLAVE;
+
+	dev_dbg(iproc_i2c->device, "IS %x\n", status);
+	if (sl_status) {
+		ret = bcm_iproc_i2c_slave_isr(iproc_i2c, sl_status);
+		if (ret)
+			return IRQ_HANDLED;
+		else
+			return IRQ_NONE;
+	}
+
+	status &= ISR_MASK;
+	if (!status)
+		return IRQ_NONE;
+
+	/* process all master based events */
+	bcm_iproc_i2c_process_m_event(iproc_i2c, status);
+	iproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, status);
 
 	return IRQ_HANDLED;
 }
@@ -171,26 +533,28 @@ static int bcm_iproc_i2c_init(struct bcm_iproc_i2c_dev *iproc_i2c)
 	u32 val;
 
 	/* put controller in reset */
-	val = readl(iproc_i2c->base + CFG_OFFSET);
-	val |= 1 << CFG_RESET_SHIFT;
-	val &= ~(1 << CFG_EN_SHIFT);
-	writel(val, iproc_i2c->base + CFG_OFFSET);
+	val = iproc_i2c_rd_reg(iproc_i2c, CFG_OFFSET);
+	val |= BIT(CFG_RESET_SHIFT);
+	iproc_i2c_wr_reg(iproc_i2c, CFG_OFFSET, val);
 
 	/* wait 100 usec per spec */
 	udelay(100);
 
 	/* bring controller out of reset */
-	val &= ~(1 << CFG_RESET_SHIFT);
-	writel(val, iproc_i2c->base + CFG_OFFSET);
+	val &= ~(BIT(CFG_RESET_SHIFT));
+	iproc_i2c_wr_reg(iproc_i2c, CFG_OFFSET, val);
 
 	/* flush TX/RX FIFOs and set RX FIFO threshold to zero */
-	val = (1 << M_FIFO_RX_FLUSH_SHIFT) | (1 << M_FIFO_TX_FLUSH_SHIFT);
-	writel(val, iproc_i2c->base + M_FIFO_CTRL_OFFSET);
+	val = (BIT(M_FIFO_RX_FLUSH_SHIFT) | BIT(M_FIFO_TX_FLUSH_SHIFT));
+	iproc_i2c_wr_reg(iproc_i2c, M_FIFO_CTRL_OFFSET, val);
 	/* disable all interrupts */
-	writel(0, iproc_i2c->base + IE_OFFSET);
+	val = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);
+	val &= ~(IE_M_ALL_INTERRUPT_MASK <<
+			IE_M_ALL_INTERRUPT_SHIFT);
+	iproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val);
 
 	/* clear all pending interrupts */
-	writel(0xffffffff, iproc_i2c->base + IS_OFFSET);
+	iproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, 0xffffffff);
 
 	return 0;
 }
@@ -200,12 +564,12 @@ static void bcm_iproc_i2c_enable_disable(struct bcm_iproc_i2c_dev *iproc_i2c,
 {
 	u32 val;
 
-	val = readl(iproc_i2c->base + CFG_OFFSET);
+	val = iproc_i2c_rd_reg(iproc_i2c, CFG_OFFSET);
 	if (enable)
 		val |= BIT(CFG_EN_SHIFT);
 	else
 		val &= ~BIT(CFG_EN_SHIFT);
-	writel(val, iproc_i2c->base + CFG_OFFSET);
+	iproc_i2c_wr_reg(iproc_i2c, CFG_OFFSET, val);
 }
 
 static int bcm_iproc_i2c_check_status(struct bcm_iproc_i2c_dev *iproc_i2c,
@@ -213,7 +577,7 @@ static int bcm_iproc_i2c_check_status(struct bcm_iproc_i2c_dev *iproc_i2c,
 {
 	u32 val;
 
-	val = readl(iproc_i2c->base + M_CMD_OFFSET);
+	val = iproc_i2c_rd_reg(iproc_i2c, M_CMD_OFFSET);
 	val = (val >> M_CMD_STATUS_SHIFT) & M_CMD_STATUS_MASK;
 
 	switch (val) {
@@ -236,6 +600,14 @@ static int bcm_iproc_i2c_check_status(struct bcm_iproc_i2c_dev *iproc_i2c,
 		dev_dbg(iproc_i2c->device, "bus timeout\n");
 		return -ETIMEDOUT;
 
+	case M_CMD_STATUS_FIFO_UNDERRUN:
+		dev_dbg(iproc_i2c->device, "FIFO under-run\n");
+		return -ENXIO;
+
+	case M_CMD_STATUS_RX_FIFO_FULL:
+		dev_dbg(iproc_i2c->device, "Master Rx FIFO full > 10ms\n");
+		return -ETIMEDOUT;
+
 	default:
 		dev_dbg(iproc_i2c->device, "unknown error code=%d\n", val);
 
@@ -248,18 +620,76 @@ static int bcm_iproc_i2c_check_status(struct bcm_iproc_i2c_dev *iproc_i2c,
 	}
 }
 
+static int bcm_iproc_i2c_xfer_wait(struct bcm_iproc_i2c_dev *iproc_i2c,
+				   struct i2c_msg *msg,
+				   u32 cmd)
+{
+	unsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT_MSEC);
+	u32 val, status;
+	int ret;
+
+	iproc_i2c_wr_reg(iproc_i2c, M_CMD_OFFSET, cmd);
+
+	if (iproc_i2c->irq) {
+		time_left = wait_for_completion_timeout(&iproc_i2c->done,
+							time_left);
+		/* disable all interrupts */
+		iproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, 0);
+		/* read it back to flush the write */
+		iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);
+		/* make sure the interrupt handler isn't running */
+		synchronize_irq(iproc_i2c->irq);
+
+	} else { /* polling mode */
+		unsigned long timeout = jiffies + time_left;
+
+		do {
+			status = iproc_i2c_rd_reg(iproc_i2c,
+						  IS_OFFSET) & ISR_MASK;
+			bcm_iproc_i2c_process_m_event(iproc_i2c, status);
+			iproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, status);
+
+			if (time_after(jiffies, timeout)) {
+				time_left = 0;
+				break;
+			}
+
+			cpu_relax();
+			cond_resched();
+		} while (!iproc_i2c->xfer_is_done);
+	}
+
+	if (!time_left && !iproc_i2c->xfer_is_done) {
+		dev_err(iproc_i2c->device, "transaction timed out\n");
+
+		/* flush both TX/RX FIFOs */
+		val = BIT(M_FIFO_RX_FLUSH_SHIFT) | BIT(M_FIFO_TX_FLUSH_SHIFT);
+		iproc_i2c_wr_reg(iproc_i2c, M_FIFO_CTRL_OFFSET, val);
+		return -ETIMEDOUT;
+	}
+
+	ret = bcm_iproc_i2c_check_status(iproc_i2c, msg);
+	if (ret) {
+		/* flush both TX/RX FIFOs */
+		val = BIT(M_FIFO_RX_FLUSH_SHIFT) | BIT(M_FIFO_TX_FLUSH_SHIFT);
+		iproc_i2c_wr_reg(iproc_i2c, M_FIFO_CTRL_OFFSET, val);
+		return ret;
+	}
+
+	return 0;
+}
+
 static int bcm_iproc_i2c_xfer_single_msg(struct bcm_iproc_i2c_dev *iproc_i2c,
 					 struct i2c_msg *msg)
 {
-	int ret, i;
+	int i;
 	u8 addr;
-	u32 val;
+	u32 val, tmp, val_intr_en;
 	unsigned int tx_bytes;
-	unsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT_MSEC);
 
 	/* check if bus is busy */
-	if (!!(readl(iproc_i2c->base + M_CMD_OFFSET) &
-	       BIT(M_CMD_START_BUSY_SHIFT))) {
+	if (!!(iproc_i2c_rd_reg(iproc_i2c,
+				M_CMD_OFFSET) & BIT(M_CMD_START_BUSY_SHIFT))) {
 		dev_warn(iproc_i2c->device, "bus is busy\n");
 		return -EBUSY;
 	}
@@ -268,7 +698,7 @@ static int bcm_iproc_i2c_xfer_single_msg(struct bcm_iproc_i2c_dev *iproc_i2c,
 
 	/* format and load slave address into the TX FIFO */
 	addr = i2c_8bit_addr_from_msg(msg);
-	writel(addr, iproc_i2c->base + M_TX_OFFSET);
+	iproc_i2c_wr_reg(iproc_i2c, M_TX_OFFSET, addr);
 
 	/*
 	 * For a write transaction, load data into the TX FIFO. Only allow
@@ -284,13 +714,15 @@ static int bcm_iproc_i2c_xfer_single_msg(struct bcm_iproc_i2c_dev *iproc_i2c,
 			if (i == msg->len - 1)
 				val |= 1 << M_TX_WR_STATUS_SHIFT;
 
-			writel(val, iproc_i2c->base + M_TX_OFFSET);
+			iproc_i2c_wr_reg(iproc_i2c, M_TX_OFFSET, val);
 		}
 		iproc_i2c->tx_bytes = tx_bytes;
 	}
 
 	/* mark as incomplete before starting the transaction */
-	reinit_completion(&iproc_i2c->done);
+	if (iproc_i2c->irq)
+		reinit_completion(&iproc_i2c->done);
+
 	iproc_i2c->xfer_is_done = 0;
 
 	/*
@@ -298,7 +730,7 @@ static int bcm_iproc_i2c_xfer_single_msg(struct bcm_iproc_i2c_dev *iproc_i2c,
 	 * transaction is done, i.e., the internal start_busy bit, transitions
 	 * from 1 to 0.
 	 */
-	val = BIT(IE_M_START_BUSY_SHIFT);
+	val_intr_en = BIT(IE_M_START_BUSY_SHIFT);
 
 	/*
 	 * If TX data size is larger than the TX FIFO, need to enable TX
@@ -307,9 +739,7 @@ static int bcm_iproc_i2c_xfer_single_msg(struct bcm_iproc_i2c_dev *iproc_i2c,
 	 */
 	if (!(msg->flags & I2C_M_RD) &&
 	    msg->len > iproc_i2c->tx_bytes)
-		val |= BIT(IE_M_TX_UNDERRUN_SHIFT);
-
-	writel(val, iproc_i2c->base + IE_OFFSET);
+		val_intr_en |= BIT(IE_M_TX_UNDERRUN_SHIFT);
 
 	/*
 	 * Now we can activate the transfer. For a read operation, specify the
@@ -317,54 +747,31 @@ static int bcm_iproc_i2c_xfer_single_msg(struct bcm_iproc_i2c_dev *iproc_i2c,
 	 */
 	val = BIT(M_CMD_START_BUSY_SHIFT);
 	if (msg->flags & I2C_M_RD) {
+		iproc_i2c->rx_bytes = 0;
+		if (msg->len > M_RX_FIFO_MAX_THLD_VALUE)
+			iproc_i2c->thld_bytes = M_RX_FIFO_THLD_VALUE;
+		else
+			iproc_i2c->thld_bytes = msg->len;
+
+		/* set threshold value */
+		tmp = iproc_i2c_rd_reg(iproc_i2c, M_FIFO_CTRL_OFFSET);
+		tmp &= ~(M_FIFO_RX_THLD_MASK << M_FIFO_RX_THLD_SHIFT);
+		tmp |= iproc_i2c->thld_bytes << M_FIFO_RX_THLD_SHIFT;
+		iproc_i2c_wr_reg(iproc_i2c, M_FIFO_CTRL_OFFSET, tmp);
+
+		/* enable the RX threshold interrupt */
+		val_intr_en |= BIT(IE_M_RX_THLD_SHIFT);
+
 		val |= (M_CMD_PROTOCOL_BLK_RD << M_CMD_PROTOCOL_SHIFT) |
 		       (msg->len << M_CMD_RD_CNT_SHIFT);
 	} else {
 		val |= (M_CMD_PROTOCOL_BLK_WR << M_CMD_PROTOCOL_SHIFT);
 	}
-	writel(val, iproc_i2c->base + M_CMD_OFFSET);
 
-	time_left = wait_for_completion_timeout(&iproc_i2c->done, time_left);
+	if (iproc_i2c->irq)
+		iproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val_intr_en);
 
-	/* disable all interrupts */
-	writel(0, iproc_i2c->base + IE_OFFSET);
-	/* read it back to flush the write */
-	readl(iproc_i2c->base + IE_OFFSET);
-
-	/* make sure the interrupt handler isn't running */
-	synchronize_irq(iproc_i2c->irq);
-
-	if (!time_left && !iproc_i2c->xfer_is_done) {
-		dev_err(iproc_i2c->device, "transaction timed out\n");
-
-		/* flush FIFOs */
-		val = (1 << M_FIFO_RX_FLUSH_SHIFT) |
-		      (1 << M_FIFO_TX_FLUSH_SHIFT);
-		writel(val, iproc_i2c->base + M_FIFO_CTRL_OFFSET);
-		return -ETIMEDOUT;
-	}
-
-	ret = bcm_iproc_i2c_check_status(iproc_i2c, msg);
-	if (ret) {
-		/* flush both TX/RX FIFOs */
-		val = (1 << M_FIFO_RX_FLUSH_SHIFT) |
-		      (1 << M_FIFO_TX_FLUSH_SHIFT);
-		writel(val, iproc_i2c->base + M_FIFO_CTRL_OFFSET);
-		return ret;
-	}
-
-	/*
-	 * For a read operation, we now need to load the data from FIFO
-	 * into the memory buffer
-	 */
-	if (msg->flags & I2C_M_RD) {
-		for (i = 0; i < msg->len; i++) {
-			msg->buf[i] = (readl(iproc_i2c->base + M_RX_OFFSET) >>
-				      M_RX_DATA_SHIFT) & M_RX_DATA_MASK;
-		}
-	}
-
-	return 0;
+	return bcm_iproc_i2c_xfer_wait(iproc_i2c, msg, val);
 }
 
 static int bcm_iproc_i2c_xfer(struct i2c_adapter *adapter,
@@ -387,17 +794,24 @@ static int bcm_iproc_i2c_xfer(struct i2c_adapter *adapter,
 
 static uint32_t bcm_iproc_i2c_functionality(struct i2c_adapter *adap)
 {
-	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+	struct bcm_iproc_i2c_dev *iproc_i2c = i2c_get_adapdata(adap);
+	u32 val = I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+
+	if (!iproc_i2c->no_slave)
+		val |= I2C_FUNC_SLAVE;
+
+	return val;
 }
 
 static const struct i2c_algorithm bcm_iproc_algo = {
 	.master_xfer = bcm_iproc_i2c_xfer,
 	.functionality = bcm_iproc_i2c_functionality,
+	.reg_slave = bcm_iproc_i2c_reg_slave,
+	.unreg_slave = bcm_iproc_i2c_unreg_slave,
 };
 
 static const struct i2c_adapter_quirks bcm_iproc_i2c_quirks = {
-	/* need to reserve one byte in the FIFO for the slave address */
-	.max_read_len = M_TX_RX_FIFO_SIZE - 1,
+	.max_read_len = M_RX_MAX_READ_LEN,
 };
 
 static int bcm_iproc_i2c_cfg_speed(struct bcm_iproc_i2c_dev *iproc_i2c)
@@ -425,10 +839,10 @@ static int bcm_iproc_i2c_cfg_speed(struct bcm_iproc_i2c_dev *iproc_i2c)
 	}
 
 	iproc_i2c->bus_speed = bus_speed;
-	val = readl(iproc_i2c->base + TIM_CFG_OFFSET);
+	val = iproc_i2c_rd_reg(iproc_i2c, TIM_CFG_OFFSET);
 	val &= ~(1 << TIM_CFG_MODE_400_SHIFT);
 	val |= (bus_speed == 400000) << TIM_CFG_MODE_400_SHIFT;
-	writel(val, iproc_i2c->base + TIM_CFG_OFFSET);
+	iproc_i2c_wr_reg(iproc_i2c, TIM_CFG_OFFSET, val);
 
 	dev_info(iproc_i2c->device, "bus set to %u Hz\n", bus_speed);
 
@@ -449,6 +863,8 @@ static int bcm_iproc_i2c_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, iproc_i2c);
 	iproc_i2c->device = &pdev->dev;
+	iproc_i2c->type =
+		(enum bcm_iproc_i2c_type) of_device_get_match_data(&pdev->dev);
 	init_completion(&iproc_i2c->done);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -456,6 +872,26 @@ static int bcm_iproc_i2c_probe(struct platform_device *pdev)
 	if (IS_ERR(iproc_i2c->base))
 		return PTR_ERR(iproc_i2c->base);
 
+	if (iproc_i2c->type == IPROC_I2C_NIC) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		iproc_i2c->idm_base = devm_ioremap_resource(iproc_i2c->device,
+							    res);
+		if (IS_ERR(iproc_i2c->idm_base))
+			return PTR_ERR(iproc_i2c->idm_base);
+
+		ret = of_property_read_u32(iproc_i2c->device->of_node,
+					   "brcm,ape-hsls-addr-mask",
+					   &iproc_i2c->ape_addr_mask);
+		if (ret < 0) {
+			dev_err(iproc_i2c->device,
+				"'brcm,ape-hsls-addr-mask' missing\n");
+			return -EINVAL;
+		}
+
+		spin_lock_init(&iproc_i2c->idm_lock);
+		iproc_i2c->no_slave = true;
+	}
+
 	ret = bcm_iproc_i2c_init(iproc_i2c);
 	if (ret)
 		return ret;
@@ -465,17 +901,20 @@ static int bcm_iproc_i2c_probe(struct platform_device *pdev)
 		return ret;
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq <= 0) {
-		dev_err(iproc_i2c->device, "no irq resource\n");
-		return irq;
-	}
-	iproc_i2c->irq = irq;
+	if (irq > 0) {
+		ret = devm_request_irq(iproc_i2c->device, irq,
+				       bcm_iproc_i2c_isr, 0, pdev->name,
+				       iproc_i2c);
+		if (ret < 0) {
+			dev_err(iproc_i2c->device,
+				"unable to request irq %i\n", irq);
+			return ret;
+		}
 
-	ret = devm_request_irq(iproc_i2c->device, irq, bcm_iproc_i2c_isr, 0,
-			       pdev->name, iproc_i2c);
-	if (ret < 0) {
-		dev_err(iproc_i2c->device, "unable to request irq %i\n", irq);
-		return ret;
+		iproc_i2c->irq = irq;
+	} else {
+		dev_warn(iproc_i2c->device,
+			 "no irq resource, falling back to poll mode\n");
 	}
 
 	bcm_iproc_i2c_enable_disable(iproc_i2c, true);
@@ -488,6 +927,8 @@ static int bcm_iproc_i2c_probe(struct platform_device *pdev)
 	adap->dev.parent = &pdev->dev;
 	adap->dev.of_node = pdev->dev.of_node;
 
+	iproc_i2c->slave = NULL;
+
 	return i2c_add_adapter(adap);
 }
 
@@ -495,10 +936,15 @@ static int bcm_iproc_i2c_remove(struct platform_device *pdev)
 {
 	struct bcm_iproc_i2c_dev *iproc_i2c = platform_get_drvdata(pdev);
 
-	/* make sure there's no pending interrupt when we remove the adapter */
-	writel(0, iproc_i2c->base + IE_OFFSET);
-	readl(iproc_i2c->base + IE_OFFSET);
-	synchronize_irq(iproc_i2c->irq);
+	if (iproc_i2c->irq) {
+		/*
+		 * Make sure there's no pending interrupt when we remove the
+		 * adapter
+		 */
+		iproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, 0);
+		iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);
+		synchronize_irq(iproc_i2c->irq);
+	}
 
 	i2c_del_adapter(&iproc_i2c->adapter);
 	bcm_iproc_i2c_enable_disable(iproc_i2c, false);
@@ -512,10 +958,15 @@ static int bcm_iproc_i2c_suspend(struct device *dev)
 {
 	struct bcm_iproc_i2c_dev *iproc_i2c = dev_get_drvdata(dev);
 
-	/* make sure there's no pending interrupt when we go into suspend */
-	writel(0, iproc_i2c->base + IE_OFFSET);
-	readl(iproc_i2c->base + IE_OFFSET);
-	synchronize_irq(iproc_i2c->irq);
+	if (iproc_i2c->irq) {
+		/*
+		 * Make sure there's no pending interrupt when we go into
+		 * suspend
+		 */
+		iproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, 0);
+		iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);
+		synchronize_irq(iproc_i2c->irq);
+	}
 
 	/* now disable the controller */
 	bcm_iproc_i2c_enable_disable(iproc_i2c, false);
@@ -538,10 +989,10 @@ static int bcm_iproc_i2c_resume(struct device *dev)
 		return ret;
 
 	/* configure to the desired bus speed */
-	val = readl(iproc_i2c->base + TIM_CFG_OFFSET);
+	val = iproc_i2c_rd_reg(iproc_i2c, TIM_CFG_OFFSET);
 	val &= ~(1 << TIM_CFG_MODE_400_SHIFT);
 	val |= (iproc_i2c->bus_speed == 400000) << TIM_CFG_MODE_400_SHIFT;
-	writel(val, iproc_i2c->base + TIM_CFG_OFFSET);
+	iproc_i2c_wr_reg(iproc_i2c, TIM_CFG_OFFSET, val);
 
 	bcm_iproc_i2c_enable_disable(iproc_i2c, true);
 
@@ -558,8 +1009,53 @@ static int bcm_iproc_i2c_resume(struct device *dev)
 #define BCM_IPROC_I2C_PM_OPS NULL
 #endif /* CONFIG_PM_SLEEP */
 
+
+static int bcm_iproc_i2c_reg_slave(struct i2c_client *slave)
+{
+	struct bcm_iproc_i2c_dev *iproc_i2c = i2c_get_adapdata(slave->adapter);
+
+	if (iproc_i2c->slave)
+		return -EBUSY;
+
+	if (slave->flags & I2C_CLIENT_TEN)
+		return -EAFNOSUPPORT;
+
+	iproc_i2c->slave = slave;
+	bcm_iproc_i2c_slave_init(iproc_i2c, INIT_SLAVE);
+	return 0;
+}
+
+static int bcm_iproc_i2c_unreg_slave(struct i2c_client *slave)
+{
+	u32 tmp;
+	struct bcm_iproc_i2c_dev *iproc_i2c = i2c_get_adapdata(slave->adapter);
+
+	WARN_ON(!iproc_i2c->slave);
+
+	iproc_i2c->slave = NULL;
+
+	/* disable all slave interrupts */
+	tmp = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);
+	tmp &= ~(IE_S_ALL_INTERRUPT_MASK <<
+			IE_S_ALL_INTERRUPT_SHIFT);
+	iproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, tmp);
+
+	/* Erase the slave address programmed */
+	tmp = iproc_i2c_rd_reg(iproc_i2c, S_CFG_SMBUS_ADDR_OFFSET);
+	tmp &= ~BIT(S_CFG_EN_NIC_SMB_ADDR3_SHIFT);
+	iproc_i2c_wr_reg(iproc_i2c, S_CFG_SMBUS_ADDR_OFFSET, tmp);
+
+	return 0;
+}
+
 static const struct of_device_id bcm_iproc_i2c_of_match[] = {
-	{ .compatible = "brcm,iproc-i2c" },
+	{
+		.compatible = "brcm,iproc-i2c",
+		.data = (int *)IPROC_I2C,
+	}, {
+		.compatible = "brcm,iproc-nic-i2c",
+		.data = (int *)IPROC_I2C_NIC,
+	},
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, bcm_iproc_i2c_of_match);
--- /dev/null
+++ b/drivers/i2c/i2c-slave-bmc.c
@@ -0,0 +1,213 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Broadcom
+ */
+
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/thermal.h>
+
+/* updating temperature reading in the background once every 2 seconds */
+#define BMC_DELAY (HZ * 2)
+
+/*
+ * Tencent out of band management specification:
+ * Command code 5:  read ASIC temperature.
+ * Command code 24: read ASIC temperature limit.
+ */
+enum i2c_slave_bmc_cmd {
+	CMD_ASIC_TEMP = 5,
+	CMD_ASIC_TEMP_LIMIT = 24,
+};
+
+struct bmc_data {
+	struct thermal_zone_device *thermal;
+	int16_t asic_temp;
+	int16_t asic_temp_limit;
+	bool first_write;
+	uint8_t command;
+	spinlock_t buffer_lock;
+	uint8_t buffer_idx;
+	uint8_t buffer_len;
+	uint8_t buffer[I2C_SMBUS_BLOCK_MAX];
+	struct delayed_work work_handler;
+	struct device *dev;
+};
+
+static int i2c_slave_bmc_setup(struct i2c_client *client)
+{
+	struct bmc_data *bmc = i2c_get_clientdata(client);
+	int16_t temp16;
+
+	memset(bmc->buffer, 0, I2C_SMBUS_BLOCK_MAX);
+	bmc->buffer_idx = 0;
+	switch (bmc->command) {
+	case CMD_ASIC_TEMP:
+		temp16 = bmc->asic_temp;
+		dev_dbg(&client->dev, "Temperature = %d\n", temp16);
+		memcpy(&bmc->buffer[0], &temp16, 2);
+		bmc->buffer_len = 2;
+		break;
+	case CMD_ASIC_TEMP_LIMIT:
+		temp16 = bmc->asic_temp_limit;
+		memcpy(&bmc->buffer[2], &bmc->asic_temp_limit, 2);
+		dev_dbg(&client->dev, "Temperature limit = %d\n", temp16);
+
+		/* Expected temperature is temperature limit divided by 2 */
+		temp16 = bmc->asic_temp_limit >> 1;
+		memcpy(&bmc->buffer[0], &temp16, 2);
+		bmc->buffer_len = 4;
+		break;
+	default:
+		dev_err(&client->dev, "Unsupported command %d\n",
+			bmc->command);
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static int i2c_slave_bmc_cb(struct i2c_client *client,
+			    enum i2c_slave_event event, u8 *val)
+{
+	struct bmc_data *bmc = i2c_get_clientdata(client);
+
+	switch (event) {
+	case I2C_SLAVE_WRITE_RECEIVED:
+		if (bmc->first_write) {
+			bmc->command = *val;
+			bmc->first_write = false;
+			spin_lock(&bmc->buffer_lock);
+			i2c_slave_bmc_setup(client);
+			spin_unlock(&bmc->buffer_lock);
+		} else {
+			dev_err(&client->dev, "Only support 1 byte command\n");
+			return -EINVAL;
+		}
+		break;
+	case I2C_SLAVE_READ_PROCESSED:
+		spin_lock(&bmc->buffer_lock);
+		if (bmc->buffer_idx < bmc->buffer_len) {
+			/* The previous byte made it to the bus, get next one */
+			bmc->buffer_idx++;
+			*val = bmc->buffer[bmc->buffer_idx];
+		}
+		spin_unlock(&bmc->buffer_lock);
+		break;
+	case I2C_SLAVE_READ_REQUESTED:
+		spin_lock(&bmc->buffer_lock);
+		*val = bmc->buffer[bmc->buffer_idx];
+		spin_unlock(&bmc->buffer_lock);
+		break;
+	case I2C_SLAVE_STOP:
+	case I2C_SLAVE_WRITE_REQUESTED:
+		bmc->first_write = true;
+		break;
+	default:
+		dev_err(&client->dev, "Unknown event %d\n", event);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void i2c_slave_bmc_handler(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct bmc_data *bmc =
+			container_of(dwork, struct bmc_data, work_handler);
+	unsigned long flags = 0;
+	int temperature;
+	int ret;
+
+	ret = thermal_zone_get_temp(bmc->thermal, &temperature);
+	if (!ret) {
+		spin_lock_irqsave(&bmc->buffer_lock, flags);
+		/* Temperature in Celsius after dividing by 1000 */
+		bmc->asic_temp = temperature / 1000;
+		spin_unlock_irqrestore(&bmc->buffer_lock, flags);
+	} else {
+		dev_err(bmc->dev, "Failed to read temperature, %d\n", ret);
+	}
+	schedule_delayed_work(&bmc->work_handler, BMC_DELAY);
+}
+
+static int i2c_slave_bmc_probe(struct i2c_client *client,
+			       const struct i2c_device_id *id)
+{
+	struct bmc_data *bmc;
+	int ret;
+	uint32_t temperature;
+	struct device *dev = &client->dev;
+	struct device_node *dn = client->dev.of_node;
+	const char *thermal_zone;
+
+	dev_dbg(dev, "I2C address 0x%x, flags 0x%x\n",
+		client->addr, client->flags);
+	bmc = devm_kzalloc(dev, sizeof(*bmc), GFP_KERNEL);
+	if (!bmc)
+		return -ENOMEM;
+
+	bmc->first_write = true;
+	bmc->dev = dev;
+	spin_lock_init(&bmc->buffer_lock);
+	ret = of_property_read_string(dn, "bmc-thermal-zone", &thermal_zone);
+	if (ret)
+		return ret;
+
+	dev_dbg(dev, "Thermal zone name: %s\n", thermal_zone);
+	bmc->thermal = thermal_zone_get_zone_by_name(thermal_zone);
+	if (IS_ERR(bmc->thermal)) {
+		dev_err(dev, "Failed to get thermal zone: %s\n", thermal_zone);
+		return PTR_ERR(bmc->thermal);
+	}
+	ret = thermal_zone_get_crit_temp(bmc->thermal, &temperature);
+	if (ret)
+		return ret;
+
+	/* Temperature in Celsius after dividing by 1000 */
+	bmc->asic_temp_limit = temperature / 1000;
+	dev_dbg(dev, "Temperature limit: %d\n", bmc->asic_temp_limit);
+
+	i2c_set_clientdata(client, bmc);
+
+	ret = i2c_slave_register(client, i2c_slave_bmc_cb);
+	if (ret)
+		return ret;
+
+	INIT_DELAYED_WORK(&bmc->work_handler, i2c_slave_bmc_handler);
+	schedule_delayed_work(&bmc->work_handler, 0);
+	return 0;
+}
+
+static int i2c_slave_bmc_remove(struct i2c_client *client)
+{
+	struct bmc_data *bmc = i2c_get_clientdata(client);
+
+	cancel_delayed_work_sync(&bmc->work_handler);
+	i2c_slave_unregister(client);
+	return 0;
+}
+
+static const struct i2c_device_id i2c_slave_bmc_id[] = {
+	{"i2c-slave-bmc", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, i2c_slave_bmc_id);
+
+static struct i2c_driver i2c_slave_bmc_driver = {
+	.driver = {
+		.name = "i2c-slave-bmc",
+	},
+	.probe = i2c_slave_bmc_probe,
+	.remove = i2c_slave_bmc_remove,
+	.id_table = i2c_slave_bmc_id,
+};
+module_i2c_driver(i2c_slave_bmc_driver);
+
+MODULE_AUTHOR("Geoffrey Lv <geoffrey.lv@broadcom.com>");
+MODULE_DESCRIPTION("I2C slave mode BMC driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/iommu/arm-smmu.c
+++ b/drivers/iommu/arm-smmu.c
@@ -221,6 +221,9 @@ struct arm_smmu_device {
 
 	u32				num_global_irqs;
 	u32				num_context_irqs;
+	u32				reserved_context_banks;
+	u32				reserved_s2_context_banks;
+	u32				reserved_mapping_groups;
 	unsigned int			*irqs;
 
 	u32				cavium_id_base; /* Specific to Cavium */
@@ -1771,6 +1774,12 @@ static int arm_smmu_device_cfg_probe(struct arm_smmu_device *smmu)
 	if (id & ID0_SMS) {
 		smmu->features |= ARM_SMMU_FEAT_STREAM_MATCH;
 		size = (id >> ID0_NUMSMRG_SHIFT) & ID0_NUMSMRG_MASK;
+		if (size < smmu->reserved_mapping_groups) {
+			dev_err(smmu->dev,
+				"invalid reserved mapping groups!\n");
+			return -ENODEV;
+		}
+		size -= smmu->reserved_mapping_groups;
 		if (size == 0) {
 			dev_err(smmu->dev,
 				"stream-matching supported, but no SMRs present!\n");
@@ -1817,7 +1826,17 @@ static int arm_smmu_device_cfg_probe(struct arm_smmu_device *smmu)
 			size * 2, (smmu->cb_base - gr0_base) * 2);
 
 	smmu->num_s2_context_banks = (id >> ID1_NUMS2CB_SHIFT) & ID1_NUMS2CB_MASK;
+	if (smmu->num_s2_context_banks < smmu->reserved_s2_context_banks) {
+		dev_err(smmu->dev, "invalid reserved S2 context banks!\n");
+		return -ENODEV;
+	}
+	smmu->num_s2_context_banks -= smmu->reserved_s2_context_banks;
 	smmu->num_context_banks = (id >> ID1_NUMCB_SHIFT) & ID1_NUMCB_MASK;
+	if (smmu->num_context_banks < smmu->reserved_context_banks) {
+		dev_err(smmu->dev, "invalid reserved context banks!\n");
+		return -ENODEV;
+	}
+	smmu->num_context_banks -= smmu->reserved_context_banks;
 	if (smmu->num_s2_context_banks > smmu->num_context_banks) {
 		dev_err(smmu->dev, "impossible number of S2 context banks!\n");
 		return -ENODEV;
@@ -2013,6 +2032,18 @@ static int arm_smmu_device_dt_probe(struct platform_device *pdev,
 		return -ENODEV;
 	}
 
+	if (of_property_read_u32(dev->of_node, "reserved-context-banks",
+				 &smmu->reserved_context_banks))
+		smmu->reserved_context_banks = 0;
+
+	if (of_property_read_u32(dev->of_node, "reserved-s2-context-banks",
+				 &smmu->reserved_s2_context_banks))
+		smmu->reserved_s2_context_banks = 0;
+
+	if (of_property_read_u32(dev->of_node, "reserved-mapping-groups",
+				 &smmu->reserved_mapping_groups))
+		smmu->reserved_mapping_groups = 0;
+
 	data = of_device_get_match_data(dev);
 	smmu->version = data->version;
 	smmu->model = data->model;
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@ -195,6 +195,21 @@ void iommu_dma_get_resv_regions(struct device *dev, struct list_head *list)
 
 		list_add_tail(&region->list, list);
 	}
+	/* Get reserved DMA windows from host bridge */
+	resource_list_for_each_entry(window, &bridge->dma_resv) {
+		struct iommu_resv_region *region;
+		phys_addr_t start;
+		size_t length;
+
+		start = window->res->start - window->offset;
+		length = window->res->end - window->res->start + 1;
+		region = iommu_alloc_resv_region(start, length, 0,
+				IOMMU_RESV_RESERVED);
+		if (!region)
+			return;
+
+		list_add_tail(&region->list, list);
+	}
 }
 EXPORT_SYMBOL(iommu_dma_get_resv_regions);
 
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -92,6 +92,18 @@ config I8259
 	bool
 	select IRQ_DOMAIN
 
+config BCM_IPROC_CRMU_INTC
+	bool "Broadcom iproc CRMU Interrupt Controller"
+	depends on BCM_IPROC_MBOX
+	depends on ARCH_BCM_IPROC || COMPILE_TEST
+	select IRQ_DOMAIN
+	default ARCH_BCM_IPROC
+	help
+	  Adds support for the Broadcom Interrupt controller for the Cortex-M0
+	  MCU processor. This is required to process interrupts generated on the
+	  MCU. The driver uses the iproc mailbox controller to communicate with
+	  the M0 processor.
+
 config BCM6345_L1_IRQ
 	bool
 	select GENERIC_IRQ_CHIP
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -56,6 +56,7 @@ obj-$(CONFIG_XTENSA_MX)			+= irq-xtensa-mx.o
 obj-$(CONFIG_XILINX_INTC)		+= irq-xilinx-intc.o
 obj-$(CONFIG_IRQ_CROSSBAR)		+= irq-crossbar.o
 obj-$(CONFIG_SOC_VF610)			+= irq-vf610-mscm-ir.o
+obj-$(CONFIG_BCM_IPROC_CRMU_INTC) 	+= irq-bcm-iproc-crmu.o
 obj-$(CONFIG_BCM6345_L1_IRQ)		+= irq-bcm6345-l1.o
 obj-$(CONFIG_BCM7038_L1_IRQ)		+= irq-bcm7038-l1.o
 obj-$(CONFIG_BCM7120_L2_IRQ)		+= irq-bcm7120-l2.o
--- /dev/null
+++ b/drivers/irqchip/irq-bcm-iproc-crmu.c
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2017 Broadcom.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/mailbox_client.h>
+#include <linux/bcm_iproc_mailbox.h>
+
+#define CRMU_IPROC_MAILBOX0_OFFSET       0x0
+#define CRMU_IPROC_MAILBOX1_OFFSET       0x4
+
+#define IPROC_INTR_STATUS                0x0
+#define IPROC_MAILBOX_INTR_SHIFT         0
+#define IPROC_MAILBOX_INTR_MASK          0x1
+
+#define IPROC_INTR_CLEAR                 0x8
+#define IPROC_MAILBOX_INTR_CLR_SHIFT     0
+
+/* Domains that interrupts get forwarded to. */
+enum mbox_domain {
+	AON_GPIO_DOMAIN = 0,
+};
+
+enum iproc_m0_cmd {
+	/*
+	 * Enable/disable GPIO event forwarding from M0 to A9
+	 * Param - 1 to enable, 0 to disable
+	 * Response - return code
+	 */
+	M0_IPC_M0_CMD_AON_GPIO_FORWARDING_ENABLE = 0xe,
+
+	/*
+	 * AON GPIO interrupt ("forwarded" to IPROC)
+	 * Param - AON GPIO mask
+	 */
+	M0_IPC_HOST_CMD_AON_GPIO_EVENT = 0x102,
+};
+
+struct iproc_crmu_intc_data {
+	struct device      *dev;
+	void __iomem       *mbox_base;
+	void __iomem       *intr_base;
+	struct irq_domain  *domain;
+	int                mbox_irq;
+	struct mbox_client client;
+	struct mbox_chan   *mbox_chan;
+};
+
+static void iproc_crmu_intc_aon_gpio_forwarding_enable(
+	struct iproc_crmu_intc_data *data, bool en)
+{
+	int err;
+	struct iproc_mbox_msg msg;
+
+	msg.cmd = M0_IPC_M0_CMD_AON_GPIO_FORWARDING_ENABLE;
+	msg.param = en ? 1 : 0;
+	msg.wait_ack = true;
+
+	err = mbox_send_message(data->mbox_chan, &msg);
+	if (err < 0)
+		dev_err(data->dev,
+			"mbox_send_message failed: %d\n", err);
+	else if (msg.reply_code)
+		dev_err(data->dev,
+			"M0 command failed: 0x%x\n", msg.reply_code);
+	mbox_client_txdone(data->mbox_chan, 0);
+}
+
+static void iproc_crmu_intc_irq_unmask(struct irq_data *d)
+{
+	struct iproc_crmu_intc_data *data = irq_data_get_irq_chip_data(d);
+
+	iproc_crmu_intc_aon_gpio_forwarding_enable(data, true);
+}
+
+static void iproc_crmu_intc_irq_mask(struct irq_data *d)
+{
+	/* Do nothing - Mask callback is not required, since upon GPIO event,
+	 * M0 disables GPIO forwarding to A9. Hence, GPIO forwarding is already
+	 * disabled when in mbox irq handler, and no other mbox events from M0
+	 * to A9 are expected until GPIO forwarding is enabled following
+	 * iproc_crmu_intc_irq_unmask()
+	 */
+}
+
+static struct irq_chip iproc_crmu_intc_irq_chip = {
+	.name = "bcm-iproc-crmu-intc",
+	.irq_mask = iproc_crmu_intc_irq_mask,
+	.irq_unmask = iproc_crmu_intc_irq_unmask,
+};
+
+static int iproc_crmu_intc_irq_map(struct irq_domain *d, unsigned int irq,
+	irq_hw_number_t hwirq)
+{
+	int ret;
+
+	ret = irq_set_chip_data(irq, d->host_data);
+	if (ret < 0)
+		return ret;
+	irq_set_chip_and_handler(irq, &iproc_crmu_intc_irq_chip,
+		handle_simple_irq);
+
+	return 0;
+}
+
+static void iproc_crmu_intc_irq_unmap(struct irq_domain *d, unsigned int irq)
+{
+	irq_set_chip_and_handler(irq, NULL, NULL);
+	irq_set_chip_data(irq, NULL);
+}
+
+static const struct irq_domain_ops iproc_crmu_intc_irq_ops = {
+	.map = iproc_crmu_intc_irq_map,
+	.unmap = iproc_crmu_intc_irq_unmap,
+	.xlate = irq_domain_xlate_onecell,
+};
+
+static void iproc_crmu_intc_irq_handler(struct irq_desc *desc)
+{
+	struct iproc_crmu_intc_data *data = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	unsigned long status;
+	u32 cmd, param;
+	int virq;
+
+	chained_irq_enter(chip, desc);
+
+	/* Determine type of interrupt. */
+	status = readl(data->intr_base + IPROC_INTR_STATUS);
+	status = (status >> IPROC_MAILBOX_INTR_SHIFT) &
+		IPROC_MAILBOX_INTR_MASK;
+
+	/* Process mailbox interrupts. */
+	if (status) {
+		writel(BIT(IPROC_MAILBOX_INTR_CLR_SHIFT),
+			data->intr_base + IPROC_INTR_CLEAR);
+
+		cmd = readl(data->mbox_base + CRMU_IPROC_MAILBOX0_OFFSET);
+		param = readl(data->mbox_base + CRMU_IPROC_MAILBOX1_OFFSET);
+
+		dev_dbg(data->dev,
+			"Received message from M0: cmd 0x%x param 0x%x\n",
+			cmd, param);
+
+		/* Process AON GPIO interrupt - forward to GPIO handler. */
+		if (cmd == M0_IPC_HOST_CMD_AON_GPIO_EVENT) {
+			virq = irq_find_mapping(data->domain,
+				AON_GPIO_DOMAIN);
+			generic_handle_irq(virq);
+		}
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static int iproc_crmu_intc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *dn = dev->of_node;
+	int virq;
+	struct resource *res;
+	struct iproc_crmu_intc_data *data;
+	int err = 0;
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->dev = dev;
+	platform_set_drvdata(pdev, data);
+
+	/* Request mailbox channel. */
+	data->client.dev          = dev;
+	data->client.tx_block     = false;
+	data->client.tx_tout      = 2;
+	data->client.knows_txdone = true;
+	data->mbox_chan = mbox_request_channel(&data->client, 0);
+	if (IS_ERR(data->mbox_chan)) {
+		dev_err(dev, "unable to get mbox channel\n");
+		return PTR_ERR(data->mbox_chan);
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->mbox_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(data->mbox_base)) {
+		dev_err(dev, "failed to map base register\n");
+		err = -ENOMEM;
+		goto free_mbox_chan;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	data->intr_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(data->intr_base)) {
+		dev_err(&pdev->dev, "unable to map I/O memory\n");
+		err = PTR_ERR(data->intr_base);
+		goto free_mbox_chan;
+	}
+
+	data->mbox_irq = irq_of_parse_and_map(dn, 0);
+	if (!data->mbox_irq) {
+		dev_err(dev, "irq_of_parse_and_map failed\n");
+		err = -ENODEV;
+		goto free_mbox_chan;
+	}
+
+	data->domain = irq_domain_add_linear(dn, 1,
+		&iproc_crmu_intc_irq_ops, data);
+	if (!data->domain) {
+		dev_err(dev, "unable to allocate IRQ domain\n");
+		err = -ENXIO;
+		goto dispose_mapping;
+	}
+
+	/* Map irq for AON GPIO interrupt handling into this domain. */
+	virq = irq_create_mapping(data->domain, AON_GPIO_DOMAIN);
+	if (!virq) {
+		dev_err(dev, "failed mapping irq into domain\n");
+		err = -ENXIO;
+		goto domain_remove;
+	}
+	dev_dbg(dev, "irq for aon gpio domain: %d\n", virq);
+
+	irq_set_chained_handler_and_data(data->mbox_irq,
+		iproc_crmu_intc_irq_handler, data);
+
+	return 0;
+
+domain_remove:
+	irq_domain_remove(data->domain);
+
+dispose_mapping:
+	irq_dispose_mapping(data->mbox_irq);
+
+free_mbox_chan:
+	mbox_free_channel(data->mbox_chan);
+	return err;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int iproc_crmu_intc_suspend(struct device *dev)
+{
+	struct iproc_crmu_intc_data *data = dev_get_drvdata(dev);
+
+	dev_info(dev, "Suspending iproc crmu intc: disabling GPIO forwarding\n");
+	iproc_crmu_intc_aon_gpio_forwarding_enable(data, false);
+	synchronize_irq(data->mbox_irq);
+
+	return 0;
+}
+
+static int iproc_crmu_intc_resume(struct device *dev)
+{
+	struct iproc_crmu_intc_data *data = dev_get_drvdata(dev);
+
+	dev_info(dev, "Resuming iproc crmu intc: enabling AON GPIO forwarding\n");
+	iproc_crmu_intc_aon_gpio_forwarding_enable(data, true);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(iproc_crmu_intc_pm_ops, iproc_crmu_intc_suspend,
+	iproc_crmu_intc_resume);
+
+static const struct of_device_id iproc_crmu_intc_of_match[] = {
+	{ .compatible = "brcm,iproc-crmu-intc", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, iproc_crmu_intc_dt_id);
+
+static struct platform_driver iproc_crmu_intc_driver = {
+	.driver = {
+		.name = "brcm_iproc_crmu_intc",
+		.of_match_table = iproc_crmu_intc_of_match,
+		.pm = &iproc_crmu_intc_pm_ops,
+	},
+	.probe = iproc_crmu_intc_probe,
+};
+
+static int __init iproc_crmu_intc_init(void)
+{
+	return platform_driver_register(&iproc_crmu_intc_driver);
+}
+arch_initcall_sync(iproc_crmu_intc_init);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("Broadcom iProc CRMU Interrupt Controller Driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/mailbox/Kconfig
+++ b/drivers/mailbox/Kconfig
@@ -90,6 +90,22 @@ config BCM2835_MBOX
 	  the services of the Videocore. Say Y here if you want to use the
 	  BCM2835 Mailbox.
 
+config BCM_IPROC_MBOX
+	bool "Broadcom iProc Mailbox"
+	depends on ARCH_BCM_IPROC || COMPILE_TEST
+	default ARCH_BCM_IPROC
+	help
+	  Broadcom iProc architected SoC's have an always on Cortex-M0 MCU processor
+	  that handles support for power, clock, and reset management. The iProc
+	  mailbox controller handles all communication with this processor.
+
+config BCM_FS4_MBOX_TEST
+	tristate "Broadcom FlexSparx4 Mailbox Test Client"
+	depends on (ARM64 && RAID6_PQ) || COMPILE_TEST
+	default ARCH_BCM_IPROC
+	help
+	  Test mailbox client for FlexSparx4 offload engines.
+
 config STI_MBOX
 	tristate "STI Mailbox framework support"
 	depends on ARCH_STI && OF
@@ -163,9 +179,10 @@ config BCM_PDC_MBOX
 config BCM_FLEXRM_MBOX
 	tristate "Broadcom FlexRM Mailbox"
 	depends on ARM64
+	depends on ARCH_BCM_IPROC || COMPILE_TEST
 	depends on HAS_DMA
 	select GENERIC_MSI_IRQ_DOMAIN
-	default ARCH_BCM_IPROC
+	default m if ARCH_BCM_IPROC
 	help
 	  Mailbox implementation of the Broadcom FlexRM ring manager,
 	  which provides access to various offload engines on Broadcom
--- a/drivers/mailbox/Makefile
+++ b/drivers/mailbox/Makefile
@@ -21,6 +21,10 @@ obj-$(CONFIG_ALTERA_MBOX)	+= mailbox-altera.o
 
 obj-$(CONFIG_BCM2835_MBOX)	+= bcm2835-mailbox.o
 
+obj-$(CONFIG_BCM_FS4_MBOX_TEST) += bcm-fs4-test.o
+
+obj-$(CONFIG_BCM_IPROC_MBOX)	+= bcm-iproc-mailbox.o
+
 obj-$(CONFIG_STI_MBOX)		+= mailbox-sti.o
 
 obj-$(CONFIG_TI_MESSAGE_MANAGER) += ti-msgmgr.o
--- a/drivers/mailbox/bcm-flexrm-mailbox.c
+++ b/drivers/mailbox/bcm-flexrm-mailbox.c
@@ -1,10 +1,18 @@
-/* Broadcom FlexRM Mailbox Driver
- *
+/*
  * Copyright (C) 2017 Broadcom
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Broadcom FlexRM Mailbox Driver
  *
  * Each Broadcom FlexSparx4 offload engine is implemented as an
  * extension to Broadcom FlexRM ring manager. The FlexRM ring
@@ -19,6 +27,7 @@
 #include <asm/byteorder.h>
 #include <linux/atomic.h>
 #include <linux/bitmap.h>
+#include <linux/clk.h>
 #include <linux/debugfs.h>
 #include <linux/delay.h>
 #include <linux/device.h>
@@ -283,6 +292,9 @@ struct flexrm_ring {
 struct flexrm_mbox {
 	struct device *dev;
 	void __iomem *regs;
+	struct clk *dme_rm_clk;
+	struct clk *ae_clk;
+	struct clk *fs4_clk;
 	u32 num_rings;
 	struct flexrm_ring *rings;
 	struct dma_pool *bd_pool;
@@ -1116,8 +1128,8 @@ static int flexrm_process_completions(struct flexrm_ring *ring)
 		err = flexrm_cmpl_desc_to_error(desc);
 		if (err < 0) {
 			dev_warn(ring->mbox->dev,
-				 "got completion desc=0x%lx with error %d",
-				 (unsigned long)desc, err);
+			"ring%d got completion desc=0x%lx with error %d\n",
+			ring->num, (unsigned long)desc, err);
 		}
 
 		/* Determine request id from completion descriptor */
@@ -1127,8 +1139,8 @@ static int flexrm_process_completions(struct flexrm_ring *ring)
 		msg = ring->requests[reqid];
 		if (!msg) {
 			dev_warn(ring->mbox->dev,
-				 "null msg pointer for completion desc=0x%lx",
-				 (unsigned long)desc);
+			"ring%d null msg pointer for completion desc=0x%lx\n",
+			ring->num, (unsigned long)desc);
 			continue;
 		}
 
@@ -1181,10 +1193,19 @@ static int flexrm_debugfs_stats_show(struct seq_file *file, void *offset)
 
 static irqreturn_t flexrm_irq_event(int irq, void *dev_id)
 {
-	/* We only have MSI for completions so just wakeup IRQ thread */
-	/* Ring related errors will be informed via completion descriptors */
+	struct flexrm_ring *ring = (struct flexrm_ring *)dev_id;
+	u32 cmpl_write_offset;
 
-	return IRQ_WAKE_THREAD;
+	cmpl_write_offset = readl_relaxed(ring->regs + RING_CMPL_WRITE_PTR);
+	cmpl_write_offset *= RING_DESC_SIZE;
+	/*
+	 * Don't schedule irq thread if there is no data to process.
+	 * It means peek_data() has already processed all data.
+	 */
+	if (cmpl_write_offset == ring->cmpl_read_offset)
+		return IRQ_HANDLED;
+	else
+		return IRQ_WAKE_THREAD;
 }
 
 static irqreturn_t flexrm_irq_thread(int irq, void *dev_id)
@@ -1238,7 +1259,9 @@ static int flexrm_startup(struct mbox_chan *chan)
 	ring->bd_base = dma_pool_alloc(ring->mbox->bd_pool,
 				       GFP_KERNEL, &ring->bd_dma_base);
 	if (!ring->bd_base) {
-		dev_err(ring->mbox->dev, "can't allocate BD memory\n");
+		dev_err(ring->mbox->dev,
+			"can't allocate BD memory for ring%d\n",
+			ring->num);
 		ret = -ENOMEM;
 		goto fail;
 	}
@@ -1261,7 +1284,9 @@ static int flexrm_startup(struct mbox_chan *chan)
 	ring->cmpl_base = dma_pool_alloc(ring->mbox->cmpl_pool,
 					 GFP_KERNEL, &ring->cmpl_dma_base);
 	if (!ring->cmpl_base) {
-		dev_err(ring->mbox->dev, "can't allocate completion memory\n");
+		dev_err(ring->mbox->dev,
+			"can't allocate completion memory for ring%d\n",
+			ring->num);
 		ret = -ENOMEM;
 		goto fail_free_bd_memory;
 	}
@@ -1269,7 +1294,8 @@ static int flexrm_startup(struct mbox_chan *chan)
 
 	/* Request IRQ */
 	if (ring->irq == UINT_MAX) {
-		dev_err(ring->mbox->dev, "ring IRQ not available\n");
+		dev_err(ring->mbox->dev,
+			"ring%d IRQ not available\n", ring->num);
 		ret = -ENODEV;
 		goto fail_free_cmpl_memory;
 	}
@@ -1278,7 +1304,8 @@ static int flexrm_startup(struct mbox_chan *chan)
 				   flexrm_irq_thread,
 				   0, dev_name(ring->mbox->dev), ring);
 	if (ret) {
-		dev_err(ring->mbox->dev, "failed to request ring IRQ\n");
+		dev_err(ring->mbox->dev,
+			"failed to request ring%d IRQ\n", ring->num);
 		goto fail_free_cmpl_memory;
 	}
 	ring->irq_requested = true;
@@ -1291,7 +1318,9 @@ static int flexrm_startup(struct mbox_chan *chan)
 			&ring->irq_aff_hint);
 	ret = irq_set_affinity_hint(ring->irq, &ring->irq_aff_hint);
 	if (ret) {
-		dev_err(ring->mbox->dev, "failed to set IRQ affinity hint\n");
+		dev_err(ring->mbox->dev,
+			"failed to set IRQ affinity hint for ring%d\n",
+			ring->num);
 		goto fail_free_irq;
 	}
 
@@ -1517,6 +1546,43 @@ static int flexrm_mbox_probe(struct platform_device *pdev)
 	}
 	regs_end = mbox->regs + resource_size(iomem);
 
+	mbox->dme_rm_clk = devm_clk_get(&pdev->dev, "dme_rm_clk");
+	if (IS_ERR(mbox->dme_rm_clk)) {
+		ret = PTR_ERR(mbox->dme_rm_clk);
+		dev_err(&pdev->dev, "Failed to get dme_rm_clk ret:%d\n", ret);
+		goto fail;
+	}
+	ret = clk_prepare_enable(mbox->dme_rm_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to ena dme_rm_clk ret:%d\n", ret);
+		goto fail;
+	}
+
+	mbox->ae_clk = devm_clk_get(&pdev->dev, "ae_clk");
+	if (IS_ERR(mbox->ae_clk)) {
+		ret = PTR_ERR(mbox->ae_clk);
+		dev_err(&pdev->dev, "Failed to get ae_clk retcode:%d\n", ret);
+		goto fail;
+	}
+
+	ret = clk_prepare_enable(mbox->ae_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable ae_clk ret:%d\n", ret);
+		goto fail;
+	}
+
+	mbox->fs4_clk = devm_clk_get(&pdev->dev, "fs4_clk");
+	if (IS_ERR(mbox->fs4_clk)) {
+		ret = PTR_ERR(mbox->fs4_clk);
+		dev_err(&pdev->dev, "Failed to get fs4_clk ret:%d\n", ret);
+		goto fail;
+	}
+	ret = clk_prepare_enable(mbox->fs4_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable fs4_clk ret:%d\n", ret);
+		goto fail;
+	}
+
 	/* Scan and count available rings */
 	mbox->num_rings = 0;
 	for (regs = mbox->regs; regs < regs_end; regs += RING_REGS_SIZE) {
@@ -1681,6 +1747,9 @@ static int flexrm_mbox_remove(struct platform_device *pdev)
 	debugfs_remove_recursive(mbox->root);
 
 	platform_msi_domain_free_irqs(dev);
+	clk_disable_unprepare(mbox->fs4_clk);
+	clk_disable_unprepare(mbox->ae_clk);
+	clk_disable_unprepare(mbox->dme_rm_clk);
 
 	dma_pool_destroy(mbox->cmpl_pool);
 	dma_pool_destroy(mbox->bd_pool);
--- /dev/null
+++ b/drivers/mailbox/bcm-fs4-test.c
@@ -0,0 +1,2898 @@
+/* Copyright (C) 2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Broadcom FlexSparx4 Mailbox Test Client
+ *
+ * This driver is a mailbox client which directly injects
+ * "struct brcm_message" instances into mailbox channels
+ * pointing to fixed input/output data patterns. The driver
+ * also provides a sysfs interface to configure and start
+ * the test.
+ *
+ * Following are the possible uses of the driver:
+ * 1. Debug a particular feature of FS4 offload engine or
+ * the SoC specific ring manager hardware
+ * 2. Stress a particular feature of FS4 offload engine
+ * 3. Benchmark raw performance of a FS4 offload engine feature
+ */
+
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/mailbox_client.h>
+#include <linux/mailbox/brcm-message.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/raid/xor.h>
+#include <linux/raid/pq.h>
+
+#define FS4_ENGINE_REG_SIZE		0x1000
+#define FS4_MAX_BATCH_COUNT		512
+#define FS4_MAX_CHANNELS		32
+
+struct fs4_test_msg {
+	void *src[FS4_MAX_BATCH_COUNT];
+	dma_addr_t src_dma[FS4_MAX_BATCH_COUNT];
+	void *dst[FS4_MAX_BATCH_COUNT];
+	dma_addr_t dst_dma[FS4_MAX_BATCH_COUNT];
+	void *dst1[FS4_MAX_BATCH_COUNT];
+	dma_addr_t dst1_dma[FS4_MAX_BATCH_COUNT];
+	void *dst_resp[FS4_MAX_BATCH_COUNT];
+	dma_addr_t dst_resp_dma[FS4_MAX_BATCH_COUNT];
+	struct brcm_sba_command *cmds[FS4_MAX_BATCH_COUNT];
+	struct brcm_message msg[FS4_MAX_CHANNELS * FS4_MAX_BATCH_COUNT];
+	unsigned int msg_count;
+	struct brcm_message bmsg[FS4_MAX_CHANNELS];
+	unsigned int bmsg_count;
+	ktime_t start_ktime;
+	s64 runtime_usecs;
+	atomic_t done_count;
+	struct completion done;
+};
+
+struct fs4_test {
+	struct device *dev;
+	struct device *mbox_dev;
+	int (*exec_func)(struct fs4_test *test);
+	void __iomem *regs;
+	unsigned int engine_count;
+	struct mbox_client client;
+	unsigned int mchans_count;
+	struct mbox_chan *mchans[FS4_MAX_CHANNELS];
+	struct mutex lock;
+	unsigned int chan;
+	unsigned int batch_count;
+	unsigned int min_split_size;
+	unsigned int src_count;
+	unsigned int src_size;
+	unsigned int iterations;
+	unsigned int algo;
+	unsigned int secs;
+	unsigned int timeout;
+	unsigned int update;
+	unsigned int verify;
+	unsigned int verbose;
+	unsigned int poll;
+	unsigned int software;
+	unsigned int start;
+};
+
+#define fs4_debug(__test, __msg...) \
+do { \
+	if ((__test)->verbose) \
+		dev_info((__test)->dev, __msg); \
+} while (0)
+
+#define fs4_info(__test, __msg...) dev_info((__test)->dev, __msg)
+
+static unsigned long long fs4_test_persec(s64 runtime, unsigned int val)
+{
+	unsigned long long per_sec = 1000000;
+
+	if (runtime <= 0)
+		return 0;
+
+	/* drop precision until runtime is 32-bits */
+	while (runtime > UINT_MAX) {
+		runtime >>= 1;
+		per_sec <<= 1;
+	}
+
+	per_sec *= val;
+	do_div(per_sec, runtime);
+	return per_sec;
+}
+
+static unsigned long long fs4_test_KBs(s64 runtime, unsigned long long len)
+{
+	return fs4_test_persec(runtime, len >> 10);
+}
+
+static void fs4_test_receive_message(struct mbox_client *cl, void *m)
+{
+	struct brcm_message *msg = m;
+	struct fs4_test_msg *cmsg = msg->ctx;
+
+	if (atomic_dec_return(&cmsg->done_count))
+		return;
+
+	if (!cmsg->runtime_usecs)
+		cmsg->runtime_usecs =
+			ktime_us_delta(ktime_get(), cmsg->start_ktime);
+
+	complete(&cmsg->done);
+}
+
+static const u8 spu2_ref_input[] = {
+0x11, 0x90, 0x00, 0x04, 0x0e, 0x20, 0x00, 0xb7,
+0x80, 0x00, 0x05, 0x81, 0x00, 0xe0, 0x80, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x40, 0x01, 0x00, 0x00, 0x22, 0x6d, 0xdd, 0xf7,
+0xf6, 0xea, 0xd3, 0xb2, 0x0e, 0xbb, 0x93, 0x6c,
+0xcd, 0x31, 0x8d, 0xe1, 0x87, 0x58, 0xaf, 0x6d,
+0x62, 0x8a, 0x71, 0xa2, 0x24, 0x5a, 0x20, 0xf9,
+0x58, 0x46, 0x66, 0xad, 0x67, 0xda, 0xde, 0x11,
+0x53, 0x0d, 0x98, 0x7c, 0x17, 0xf2, 0xf2, 0x8a,
+0xbb, 0x75, 0x67, 0x50, 0x2b, 0x0c, 0x99, 0xcd,
+0x78, 0x9f, 0xe3, 0xb1, 0xee, 0x8c, 0x89, 0x14,
+0x4a, 0x43, 0x97, 0x9e, 0xda, 0xb2, 0xa0, 0x7f,
+0x60, 0x59, 0x23, 0x43, 0xd7, 0xc3, 0x59, 0x9c,
+0x10, 0xe8, 0x44, 0xb7, 0x93, 0x97, 0xf8, 0xb5,
+0x09, 0x8d, 0x88, 0x93, 0x33, 0xde, 0x89, 0x45,
+0xb4, 0x45, 0x81, 0x46, 0x23, 0x00, 0xcc, 0x17,
+0xde, 0x95, 0xce, 0xd1, 0xfd, 0xae, 0xfb, 0x82,
+0x9f, 0x20, 0x01, 0x75, 0xc1, 0xe7, 0xa9, 0xd2,
+0xd0, 0xc7, 0x25, 0x67, 0x3d, 0xa7, 0xf0, 0x73,
+0x28, 0x64, 0x02, 0x9f, 0xe4, 0xef, 0x4e, 0x20,
+0x00, 0x3e, 0x56, 0xc6, 0x63, 0x62, 0xe5, 0xe5,
+0x7e, 0x76, 0xfa, 0x37, 0x6e, 0x11, 0xe8, 0x76,
+0xa1, 0x8f, 0xef, 0x94, 0x82, 0x16, 0x31, 0x3c,
+0xa1, 0xf9, 0x10, 0x9c, 0xd5, 0xb6, 0xac, 0xeb,
+0x9e, 0x77, 0x43, 0xe3, 0xd7, 0xf1, 0x30, 0x03,
+0x64, 0x2a, 0x62, 0xf4, 0x4b, 0x02, 0x1d, 0x0a,
+0x28, 0x74, 0x9b, 0xc3, 0xe3, 0xe1, 0xf2, 0x6b,
+0x49, 0xf7, 0xc7, 0xcc, 0x19, 0xa8, 0x5a, 0x77,
+0x05, 0x61, 0x11, 0x57, 0x4b, 0x7f, 0xff, 0x2c,
+0xcf, 0x19, 0xa6, 0xb0, 0x9f, 0xfe, 0xc1, 0x91,
+0xf3, 0x30, 0xf9, 0x0b, 0x2b, 0x3c, 0xda, 0x65,
+0x6d, 0xaf, 0xd2, 0x27, 0xb5, 0xfa, 0x62, 0x66,
+0x54, 0x3d, 0x36, 0xd3, 0x22, 0xcd, 0x86, 0x78,
+0x5a, 0x11, 0x46, 0x44, 0xd6, 0x3f, 0x19, 0x23,
+0x6c, 0xde, 0xd2, 0x7d, 0xab, 0x1d, 0x1b, 0x5e,
+0xd7, 0xf4, 0xff, 0xab, 0x38, 0xfd, 0x40, 0x3e,
+0x8c, 0xd4, 0x0d, 0xbd, 0xe2, 0xd7, 0x7c, 0x2a,
+0x32, 0xde, 0xb1, 0x2e, 0x30, 0x5d, 0x1b, 0x2d,
+0xd6, 0x79, 0x79, 0xa7, 0x7e, 0xae, 0xc1, 0x8a,
+0xb9, 0xc7, 0x3f, 0x59, 0xf3, 0x73, 0x08, 0x8d,
+0xb0, 0xfd, 0x14, 0x56, 0x47, 0xbb, 0x8c, 0xc6,
+0xd7, 0x11, 0xd1, 0x74, 0x94, 0x26, 0x99, 0x68,
+0x8e, 0x8a, 0x32, 0x82, 0x97, 0xca, 0x55, 0xb0,
+0x3d, 0xd5, 0xd5, 0xac, 0x9c, 0x1f, 0x88, 0x4c,
+0x05, 0xc8, 0x00, 0x69, 0xc9, 0x95, 0xb6, 0x6b,
+0xab, 0x07, 0x70, 0x8a, 0x7c, 0x34, 0xa6, 0x2e,
+};
+
+static const u8 spu2_ref_output[] = {
+0xbf, 0x95, 0xe7, 0xc9, 0x43, 0xcd, 0x44, 0xe5,
+0xc3, 0xb2, 0xf8, 0x97, 0x67, 0xd1, 0x6f, 0x59,
+0x64, 0xb3, 0x46, 0xba, 0x5d, 0xe4, 0xfe, 0x24,
+0xa2, 0x1e, 0xa6, 0x0d, 0xbc, 0x12, 0x91, 0xaa,
+0xbc, 0x6d, 0xab, 0x4d, 0x47, 0xf9, 0xaa, 0x44,
+0x17, 0xf4, 0x4d, 0xb0, 0xcf, 0x15, 0xf1, 0x8a,
+0x24, 0xc8, 0xa3, 0x58, 0x71, 0x08, 0x51, 0x59,
+0x34, 0x30, 0x7d, 0xb6, 0xff, 0x1f, 0x29, 0xc8,
+0x83, 0x16, 0xa5, 0x7f, 0x61, 0xa6, 0x9c, 0x39,
+0x80, 0xdc, 0x91, 0x50, 0xda, 0x27, 0x6a, 0xa0,
+0x45, 0xec, 0x13, 0xf5, 0x1c, 0xde, 0x4f, 0x28,
+0x5c, 0xdc, 0x58, 0xd4, 0x39, 0x5d, 0xce, 0x76,
+0xa6, 0xe1, 0xf7, 0x4f, 0x54, 0xc4, 0xc6, 0xe5,
+0x50, 0xc5, 0xb1, 0xab, 0xd2, 0x58, 0xa4, 0x38,
+0xfb, 0x28, 0xfc, 0xad, 0xe2, 0x35, 0x63, 0xde,
+0xaf, 0x2a, 0x91, 0x65, 0x73, 0x44, 0x2c, 0x1d,
+0x80, 0x03, 0xe4, 0x52, 0x94, 0x17, 0xc5, 0x98,
+0xda, 0x83, 0x51, 0xd6, 0xc8, 0xc1, 0x6e, 0xb0,
+0x08, 0x13, 0xcc, 0x1f, 0x1a, 0x50, 0x66, 0x6e,
+0xa2, 0x8c, 0xfd, 0x99, 0xdf, 0x61, 0x19, 0x05,
+0x4d, 0xe5, 0x73, 0x0a, 0x86, 0x6c, 0xdb, 0x1a,
+0xf3, 0xec, 0x47, 0xa4, 0xa7, 0xb0, 0xec, 0x39,
+0xf2, 0x3a, 0x99, 0x39, 0x8a, 0x50, 0xf9, 0x59,
+0xa6, 0xc6, 0x55, 0xa0, 0x67, 0x79, 0xd2, 0xb9,
+0x4e, 0xd5, 0x48, 0xc7, 0x6d, 0xdf, 0x57, 0x1c,
+0xe9, 0xd6, 0xc5, 0xbc, 0x2b, 0xfb, 0x3c, 0xae,
+0xbd, 0xc1, 0xb9, 0x35, 0xc5, 0x68, 0xbf, 0x78,
+0xb8, 0xba, 0x77, 0x9d, 0xf1, 0x8d, 0xce, 0xbe,
+0x39, 0x00, 0x24, 0x31, 0x09, 0xab, 0xd2, 0x1f,
+0x60, 0x5f, 0x80, 0x28, 0x51, 0x62, 0x7d, 0xcd,
+0xc3, 0xe1, 0x26, 0x40, 0x5e, 0x4b, 0xf1, 0xb5,
+0x99, 0xd4, 0x33, 0x4a, 0x3b, 0x8b, 0x2d, 0x03,
+0x93, 0xdb, 0xd3, 0x62, 0x52, 0xf5, 0x82, 0x20,
+0xdb, 0x1b, 0x54, 0x11, 0xef, 0x44, 0xa2, 0x01,
+0xb0, 0xc4, 0x14, 0x5d, 0x86, 0x5a, 0xe7, 0x7a,
+0x11, 0x7e, 0x3b, 0xef, 0x3f, 0x39, 0xdc, 0x34,
+0x79, 0x96, 0x66, 0x7e, 0x93, 0x8f, 0x34, 0x46,
+0x77, 0x72, 0xbb, 0xd5, 0x17, 0x85, 0x4b, 0x5d,
+0x10, 0xec, 0x19, 0x29, 0xe0, 0xbc, 0x62, 0x97,
+0x43, 0x94, 0x57, 0xbd, 0xd5, 0x8f, 0x29, 0xd2,
+};
+
+#define SPU2_CIPH_ENCRYPT_EN            0x1 /* 0: decrypt, 1: encrypt */
+#define SPU2_CIPH_TYPE                 0xF0 /* one of spu2_cipher_type */
+#define SPU2_CIPH_TYPE_SHIFT              4
+#define SPU2_CIPH_MODE                0xF00 /* one of spu2_cipher_mode */
+#define SPU2_CIPH_MODE_SHIFT              8
+#define SPU2_PL_LEN              0xFFFFFFFF /* payload length in bytes */
+#define SPU2_CIPH_KEY_LEN         0xFF00000 /* len of cipher key in bytes */
+#define SPU2_CIPH_KEY_LEN_SHIFT          20
+#define SPU2_RET_FMD_ONLY				2
+#define SPU2_RETURN_MD_SHIFT            56
+#define SPU_RX_STATUS_LEN				2
+#define SPU2_HASH_TYPE_SHIFT             28
+#define SPU2_STATUS_LEN			2
+#define AES_ECB_128			1
+#define SHA1_DIGEST_LEN			20
+#define AES_ECB_CIPHER_KEY_LEN		16
+
+/* Fixed SPU2 Metadata format */
+struct SPU2_FMD {
+	u64 ctrl0;
+	u64 ctrl1;
+	u64 ctrl2;
+	u64 ctrl3;
+};
+
+/* Note: Must be called with test->lock held */
+static int __spu2_exec(struct fs4_test *test)
+{
+	int rc = 0, i = 0;
+	unsigned int iter = 0, b, s;
+	unsigned long tout;
+	struct scatterlist *src;
+	struct scatterlist *dst;
+	struct mbox_chan *chan;
+	struct fs4_test_msg *cmsg;
+	unsigned long long input_bytes_count;
+	s64 iter_usecs, min_usecs = 0, max_usecs = 0, avg_usecs = 0;
+	unsigned long long iter_KBs, min_KBs = 0, max_KBs = 0, avg_KBs = 0;
+	struct SPU2_FMD *fmd;
+	unsigned int dst_size;
+	unsigned long start, end;
+
+	if (test->algo == AES_ECB_128)
+		dst_size = test->src_size;
+	else
+		dst_size = SHA1_DIGEST_LEN;
+
+	cmsg = devm_kzalloc(test->dev, sizeof(*cmsg), GFP_KERNEL);
+	if (!cmsg)
+		return -ENOMEM;
+
+	src = devm_kzalloc(test->dev, sizeof(*src) * FS4_MAX_BATCH_COUNT,
+				GFP_KERNEL);
+	if (!src) {
+		rc = -ENOMEM;
+		goto free_cmsg;
+	}
+
+	dst = devm_kzalloc(test->dev, sizeof(*dst) * FS4_MAX_BATCH_COUNT,
+				GFP_KERNEL);
+	if (!dst) {
+		rc = -ENOMEM;
+		goto free_src_scatlist;
+	}
+
+	for (b = 0; b < test->batch_count; b++) {
+		if (test->algo == AES_ECB_128) {
+			/* AES ECB-128bit Key Cipher Algorithm */
+			cmsg->src[b] = devm_kzalloc(test->dev, test->src_size +
+						sizeof(struct SPU2_FMD) +
+						AES_ECB_CIPHER_KEY_LEN,
+						GFP_KERNEL);
+			if (!cmsg->src[b])
+				goto free_src;
+
+			cmsg->dst[b] = devm_kzalloc(test->dev, dst_size +
+						sizeof(struct SPU2_FMD) + 2,
+						GFP_KERNEL);
+			if (!cmsg->dst[b])
+				goto free_dst;
+
+			fmd = (struct SPU2_FMD *)cmsg->src[b];
+			/* SPU2_CIPHER_TYPE_AES128, SPU2_CIPHER_MODE_ECB */
+			fmd->ctrl0 = SPU2_CIPH_ENCRYPT_EN |
+				((u64) 0x1 << SPU2_CIPH_TYPE_SHIFT) |
+				((u64) 0x0 << SPU2_CIPH_MODE_SHIFT);
+
+			fmd->ctrl1 = ((AES_ECB_CIPHER_KEY_LEN <<
+				SPU2_CIPH_KEY_LEN_SHIFT) &
+				SPU2_CIPH_KEY_LEN) |
+				((u64) SPU2_RET_FMD_ONLY <<
+				SPU2_RETURN_MD_SHIFT);
+
+			fmd->ctrl3 = test->src_size & SPU2_PL_LEN;
+
+			/* Cipher Key 16 bytes */
+			memset((u8 *) (fmd + 1), 0xFF, AES_ECB_CIPHER_KEY_LEN +
+				test->src_size);
+			sg_init_one(&src[b], cmsg->src[b], test->src_size +
+					sizeof(struct SPU2_FMD) +
+					AES_ECB_CIPHER_KEY_LEN);
+			sg_init_one(&dst[b], cmsg->dst[b], dst_size +
+					sizeof(struct SPU2_FMD) +
+					SPU2_STATUS_LEN);
+		} else {
+			cmsg->src[b] = devm_kzalloc(test->dev, test->src_size
+						+ sizeof(struct SPU2_FMD),
+						GFP_KERNEL);
+			if (!cmsg->src[b])
+				goto free_src;
+
+			cmsg->dst[b] = devm_kzalloc(test->dev, dst_size +
+						sizeof(struct SPU2_FMD) +
+						SHA1_DIGEST_LEN +
+						SPU2_STATUS_LEN,
+						GFP_KERNEL);
+			if (!cmsg->dst[b])
+				goto free_dst;
+
+			fmd = (struct SPU2_FMD *)cmsg->src[b];
+			/*SPU2_HASH_TYPE_SHA1 */
+			fmd->ctrl0 = ((u64) 0x7 << SPU2_HASH_TYPE_SHIFT);
+			fmd->ctrl1 = ((u64) SPU2_RET_FMD_ONLY
+					<< SPU2_RETURN_MD_SHIFT);
+
+			fmd->ctrl3 = test->src_size & SPU2_PL_LEN;
+
+			sg_init_one(&src[b], cmsg->src[b],
+				test->src_size + sizeof(struct SPU2_FMD));
+			sg_init_one(&dst[b], cmsg->dst[b],
+				dst_size + sizeof(struct SPU2_FMD) +
+				SPU2_STATUS_LEN);
+		}
+	}
+
+	fs4_debug(test, "src_size=0x%x, batch_count: %d\n",
+		  (u32)test->src_size, test->batch_count);
+	for (b = 0; b < test->batch_count; b++) {
+		cmsg->msg[b].type = BRCM_MESSAGE_SPU;
+		cmsg->msg[b].spu.src = &src[b];
+		cmsg->msg[b].spu.dst = &dst[b];
+		cmsg->msg[b].ctx = cmsg;
+		cmsg->msg[b].error = 0;
+		cmsg->msg_count = 1;
+	}
+
+	cmsg->msg_count = test->batch_count;
+	b = cmsg->msg_count / test->mchans_count;
+	if ((b * test->mchans_count) < cmsg->msg_count)
+		b++;
+	s = 0;
+	cmsg->bmsg_count = 0;
+
+	while (s < cmsg->msg_count) {
+		i = min((cmsg->msg_count - s), b);
+		cmsg->bmsg[cmsg->bmsg_count].type = BRCM_MESSAGE_BATCH;
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs = &cmsg->msg[s];
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs_queued = 0;
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs_count = i;
+		fs4_debug(test, "batch%d msg_idx=%d msg_count=%d\n",
+			  cmsg->bmsg_count, s, i);
+		cmsg->bmsg_count++;
+		s += i;
+	}
+
+	for (start = jiffies, end = start + test->secs * HZ;
+			 time_before(jiffies, end);) {
+
+		atomic_set(&cmsg->done_count, cmsg->msg_count);
+		init_completion(&cmsg->done);
+		cmsg->start_ktime = ktime_get();
+		cmsg->runtime_usecs = 0;
+		input_bytes_count = test->src_size * test->batch_count;
+
+		for (b = 0; b < cmsg->bmsg_count; b++) {
+			chan = test->mchans[test->chan];
+			test->chan++;
+			if (test->chan >= test->mchans_count)
+				test->chan = 0;
+
+			cmsg->bmsg[b].batch.msgs_queued = 0;
+			rc = mbox_send_message(chan, &cmsg->bmsg[b]);
+			if (rc < 0) {
+				fs4_info(test, "iter=%u send error\n", iter);
+				break;
+			}
+			rc = 0;
+
+			if (cmsg->bmsg[b].error < 0) {
+				rc = cmsg->bmsg[b].error;
+				break;
+			}
+			/* Signal txdone for mailbox channel */
+			mbox_client_txdone(chan, rc);
+		}
+		if (rc < 0)
+			break;
+
+		if (test->poll) {
+			while (atomic_read(&cmsg->done_count) > 0)
+				for (i = 0; i < test->mchans_count; i++)
+					mbox_client_peek_data(test->mchans[i]);
+		} else {
+			tout = (unsigned long)test->timeout * 1000;
+			tout = msecs_to_jiffies(tout);
+			tout = wait_for_completion_timeout(&cmsg->done, tout);
+			if (!tout) {
+				fs4_info(test, "iter=%u wait timeout\n", iter);
+				rc = -ETIMEDOUT;
+				break;
+			}
+		}
+
+		rc = 0;
+		for (i = 0; i < cmsg->msg_count; i++)
+			if (cmsg->msg[b].error < 0) {
+				fs4_info(test, "iter=%u msg=%d rx error\n",
+					 iter, i);
+				rc = cmsg->msg[b].error;
+			}
+		if (rc < 0)
+			break;
+
+		iter_usecs = cmsg->runtime_usecs;
+		iter_KBs =
+		fs4_test_KBs(cmsg->runtime_usecs, input_bytes_count);
+		min_usecs = (iter == 0) ?
+				iter_usecs : min(min_usecs, iter_usecs);
+		max_usecs = (iter == 0) ?
+				iter_usecs : max(max_usecs, iter_usecs);
+		avg_usecs += iter_usecs;
+		min_KBs = (iter == 0) ?
+			  iter_KBs : min(min_KBs, iter_KBs);
+		max_KBs = (iter == 0) ?
+			  iter_KBs : max(max_KBs, iter_KBs);
+		avg_KBs += iter_KBs;
+		fs4_info(test, "iter=%u usecs=%ld KBs=%llu",
+			 iter, (long)iter_usecs, iter_KBs);
+		iter++;
+	}
+
+	if (iter) {
+		avg_usecs = avg_usecs / iter;
+		avg_KBs = avg_KBs / iter;
+	}
+
+	fs4_info(test, "completed %u in %u\n",
+		 iter, test->secs);
+	fs4_info(test, "min_usecs=%ld min_KBs=\t%8llu\n",
+		 (long)min_usecs, min_KBs);
+	fs4_info(test, "max_usecs=%ld max_KBs=\t%8llu\n",
+		 (long)max_usecs, max_KBs);
+	fs4_info(test, "avg_KBs=\t%8llu\n", avg_KBs);
+
+free_dst:
+	for (b = 0; b < test->batch_count; b++)
+		if (cmsg->dst[b])
+			devm_kfree(test->dev, cmsg->dst[b]);
+free_src:
+	for (b = 0; b < test->batch_count; b++)
+		if (cmsg->src[b])
+			devm_kfree(test->dev, cmsg->src[b]);
+	devm_kfree(test->dev, dst);
+free_src_scatlist:
+	devm_kfree(test->dev, src);
+free_cmsg:
+	devm_kfree(test->dev, cmsg);
+	return rc;
+}
+
+/* SBA command helper macros */
+#define SBA_DEC(_d, _s, _m)		(((_d) >> (_s)) & (_m))
+#define SBA_ENC(_d, _v, _s, _m)		\
+			do { \
+				(_d) &= ~((u64)(_m) << (_s)); \
+				(_d) |= (((u64)(_v) & (_m)) << (_s)); \
+			} while (0)
+
+/* SBA command encoding */
+#define SBA_TYPE_SHIFT				48
+#define SBA_TYPE_MASK				0x3
+#define SBA_TYPE_A				0x0
+#define SBA_TYPE_B				0x2
+#define SBA_TYPE_C				0x3
+#define SBA_USER_DEF_SHIFT			32
+#define SBA_USER_DEF_MASK			0xffff
+#define SBA_R_MDATA_SHIFT			24
+#define SBA_R_MDATA_MASK			0xff
+#define SBA_C_MDATA_MS_SHIFT			18
+#define SBA_C_MDATA_MS_MASK			0x3
+#define SBA_INT_SHIFT				17
+#define SBA_INT_MASK				0x1
+#define SBA_RESP_SHIFT				16
+#define SBA_RESP_MASK				0x1
+#define SBA_C_MDATA_SHIFT			8
+#define SBA_C_MDATA_MASK			0xff
+#define SBA_CMD_SHIFT				0
+#define SBA_CMD_MASK				0xf
+#define SBA_CMD_ZERO_ALL_BUFFERS		0x8
+#define SBA_CMD_LOAD_BUFFER			0x9
+#define SBA_CMD_XOR				0xa
+#define SBA_CMD_GALOIS_XOR			0xb
+#define SBA_CMD_GALOIS				0xe
+#define SBA_CMD_ZERO_BUFFER			0x4
+#define SBA_CMD_WRITE_BUFFER			0xc
+
+/* SBA C_MDATA helper macros */
+#define SBA_C_MDATA_LOAD_VAL(__bnum0)		((__bnum0) & 0x3)
+#define SBA_C_MDATA_WRITE_VAL(__bnum0)		((__bnum0) & 0x3)
+#define SBA_C_MDATA_XOR_VAL(__bnum1, __bnum0)			\
+			({	u32 __v = ((__bnum0) & 0x3);	\
+				__v |= ((__bnum1) & 0x3) << 2;	\
+				__v;				\
+			})
+#define SBA_C_MDATA_PQ_VAL(__dnum, __bnum1, __bnum0)		\
+			({	u32 __v = ((__bnum0) & 0x3);	\
+				__v |= ((__bnum1) & 0x3) << 2;	\
+				__v |= ((__dnum) & 0x1f) << 5;	\
+				__v;				\
+			})
+#define SBA_C_MDATA_LS(__c_mdata_val)	((__c_mdata_val) & 0xff)
+#define SBA_C_MDATA_MS(__c_mdata_val)	(((__c_mdata_val) >> 8) & 0x3)
+
+/* SBA response encoding */
+#define SBA_RESP_SIZE				0x8
+
+/* SBA limits */
+#define SBA_HW_BUF_SIZE				(4*1024)
+
+static const u8 sba_memcpy_ref[] = {
+0xd0, 0x0d, 0xfe, 0xed, 0xaa, 0xaa, 0x55, 0x55,
+0xde, 0xad, 0xc0, 0x01, 0xa5, 0xa5, 0xa5, 0xa5,
+0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
+0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
+0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
+0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
+0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
+};
+
+#define SBA_MEMCPY_SPLIT_CMD_COUNT(test, split_buf_count)	\
+		(((test)->src_count * 2) * (split_buf_count))
+#define SBA_MEMCPY_REF_SIZE		sizeof(sba_memcpy_ref)
+#define SBA_MEMCPY_CMD_COUNT(test, split_count, split_buf_count)	\
+	((split_count) * SBA_MEMCPY_SPLIT_CMD_COUNT(test, split_buf_count))
+
+/* Note: Must be called with test->lock held */
+static unsigned int __sba_memcpy_split_cmds(struct fs4_test *test,
+					    struct brcm_sba_command *cmds,
+					    unsigned int split,
+					    unsigned int cur_split_size,
+					    unsigned int split_size,
+					    dma_addr_t src_dma_base,
+					    dma_addr_t dst_dma_base,
+					    dma_addr_t dst_resp_dma_base)
+{
+	int s;
+	u64 cmd;
+	unsigned int cpos = 0, csize;
+	unsigned int cmds_count = 0;
+
+	while (cur_split_size) {
+		csize = (cur_split_size < SBA_HW_BUF_SIZE) ?
+					cur_split_size : SBA_HW_BUF_SIZE;
+
+		for (s = 0; s < test->src_count; s++) {
+			/* Type-B command to load data into buf0 */
+			cmd = 0;
+			SBA_ENC(cmd, SBA_TYPE_B,
+				SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+			SBA_ENC(cmd, csize,
+				SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+			SBA_ENC(cmd, 0x0, SBA_RESP_SHIFT, SBA_RESP_MASK);
+			SBA_ENC(cmd, 0x0,
+				SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+			SBA_ENC(cmd, SBA_CMD_LOAD_BUFFER,
+				SBA_CMD_SHIFT, SBA_CMD_MASK);
+			cmds[cmds_count].cmd = cmd;
+			cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_B;
+			cmds[cmds_count].data =
+					src_dma_base + s * test->src_size +
+					split * split_size + cpos;
+			cmds[cmds_count].data_len = csize;
+			cmds_count++;
+
+			/* Type-A command to write buf0 */
+			cmd = 0;
+			SBA_ENC(cmd, SBA_TYPE_A,
+				SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+			SBA_ENC(cmd, csize,
+				SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+			SBA_ENC(cmd, 0x1, SBA_RESP_SHIFT, SBA_RESP_MASK);
+			SBA_ENC(cmd, 0x0,
+			SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+			SBA_ENC(cmd, SBA_CMD_WRITE_BUFFER,
+				SBA_CMD_SHIFT, SBA_CMD_MASK);
+			cmds[cmds_count].cmd = cmd;
+			cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_A;
+			cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_RESP;
+			cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_OUTPUT;
+			cmds[cmds_count].resp =
+				dst_resp_dma_base + split * SBA_RESP_SIZE;
+			cmds[cmds_count].resp_len = SBA_RESP_SIZE;
+			cmds[cmds_count].data =
+				dst_dma_base + s * test->src_size +
+				split * split_size + cpos;
+			cmds[cmds_count].data_len = csize;
+			cmds_count++;
+		}
+
+		cpos += csize;
+		cur_split_size -= csize;
+	}
+
+	return cmds_count;
+}
+
+/* Note: Must be called with test->lock held */
+static void __sba_memcpy_free(struct fs4_test *test,
+			      struct fs4_test_msg *cmsg,
+			      unsigned int split_count)
+{
+	int b;
+
+	if (!test || !cmsg)
+		return;
+
+	for (b = 0; b < test->batch_count; b++) {
+		if (cmsg->dst_resp[b]) {
+			dma_free_coherent(
+				  test->mbox_dev,
+				  SBA_RESP_SIZE * split_count,
+				  cmsg->dst_resp[b], cmsg->dst_resp_dma[b]);
+			cmsg->dst_resp[b] = NULL;
+		}
+		if (cmsg->dst[b]) {
+			dma_free_coherent(
+					test->mbox_dev,
+					test->src_count * test->src_size,
+					cmsg->dst[b], cmsg->dst_dma[b]);
+			cmsg->dst[b] = NULL;
+		}
+		if (cmsg->src[b]) {
+			dma_free_coherent(
+					test->mbox_dev,
+					test->src_count * test->src_size,
+					cmsg->src[b], cmsg->src_dma[b]);
+			cmsg->src[b] = NULL;
+		}
+		if (cmsg->cmds[b]) {
+			devm_kfree(test->dev, cmsg->cmds[b]);
+			cmsg->cmds[b] = NULL;
+		}
+	}
+
+	devm_kfree(test->dev, cmsg);
+}
+
+/* Note: Must be called with test->lock held */
+static struct fs4_test_msg *__sba_memcpy_alloc(struct fs4_test *test,
+					       unsigned int split_count,
+					       unsigned int split_size,
+					       unsigned int split_buf_count)
+{
+	unsigned int b, s, i;
+	struct fs4_test_msg *cmsg = NULL;
+	unsigned int cmds_idx, cmds_count;
+	unsigned int cur_split_size, src_size;
+
+	if (!test)
+		return NULL;
+
+	cmsg = devm_kzalloc(test->dev, sizeof(*cmsg), GFP_KERNEL);
+	if (!cmsg)
+		return NULL;
+
+	for (b = 0; b < test->batch_count; b++) {
+		cmsg->cmds[b] = devm_kcalloc(test->dev,
+		SBA_MEMCPY_CMD_COUNT(test, split_count, split_buf_count),
+		sizeof(*cmsg->cmds[b]), GFP_KERNEL);
+		if (!cmsg->cmds[b]) {
+			fs4_info(test, "failed to alloc sba command array\n");
+			__sba_memcpy_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		cmsg->src[b] = dma_alloc_coherent(
+				test->mbox_dev,
+				test->src_count * test->src_size,
+				&cmsg->src_dma[b], GFP_KERNEL);
+		if (!cmsg->src[b]) {
+			fs4_info(test, "failed to alloc src buffer\n");
+			__sba_memcpy_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		fs4_debug(test, "src[%d]=0x%p src_dma[%d]=0x%lx\n",
+		b, cmsg->src[b], b, (unsigned long)cmsg->src_dma[b]);
+
+		for (s = 0; s < test->src_count; s++) {
+			for (i = 0;
+			     i < (test->src_size / SBA_MEMCPY_REF_SIZE);
+			     i++)
+				memcpy(cmsg->src[b] +
+				s * test->src_size + i * SBA_MEMCPY_REF_SIZE,
+				sba_memcpy_ref, SBA_MEMCPY_REF_SIZE);
+		}
+
+		cmsg->dst[b] = dma_alloc_coherent(
+					test->mbox_dev,
+					test->src_count * test->src_size,
+					&cmsg->dst_dma[b], GFP_KERNEL);
+		if (!cmsg->dst[b]) {
+			fs4_info(test, "failed to alloc dst buffer\n");
+			__sba_memcpy_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		fs4_debug(test, "dst[%d]=0x%p dst_dma[%d]=0x%lx\n",
+		b, cmsg->dst[b], b, (unsigned long)cmsg->dst_dma[b]);
+
+		cmsg->dst_resp[b] = dma_alloc_coherent(
+					test->mbox_dev,
+					SBA_RESP_SIZE * split_count,
+					&cmsg->dst_resp_dma[b], GFP_KERNEL);
+		if (!cmsg->dst_resp[b]) {
+			fs4_info(test, "failed to alloc dst_resp buffer\n");
+			__sba_memcpy_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		fs4_debug(test, "dst_resp[%d]=0x%p dst_resp_dma[%d]=0x%lx\n",
+		b, cmsg->dst_resp[b], b, (unsigned long)cmsg->dst_resp_dma[b]);
+
+		src_size = test->src_size;
+		for (s = 0; (s < split_count) && src_size; s++) {
+			cur_split_size = min(src_size, split_size);
+
+			cmds_idx =
+			s * SBA_MEMCPY_SPLIT_CMD_COUNT(test, split_buf_count);
+			cmds_count = __sba_memcpy_split_cmds(test,
+					   &cmsg->cmds[b][cmds_idx],
+					   s, cur_split_size, split_size,
+					   cmsg->src_dma[b], cmsg->dst_dma[b],
+					   cmsg->dst_resp_dma[b]);
+
+			cmsg->msg[cmsg->msg_count + s].type =
+						BRCM_MESSAGE_SBA;
+			cmsg->msg[cmsg->msg_count + s].sba.cmds =
+						&cmsg->cmds[b][cmds_idx];
+			cmsg->msg[cmsg->msg_count + s].sba.cmds_count =
+						cmds_count;
+			cmsg->msg[cmsg->msg_count + s].ctx = cmsg;
+			cmsg->msg[cmsg->msg_count + s].error = 0;
+
+			src_size -= cur_split_size;
+		}
+
+		cmsg->msg_count += split_count;
+	}
+
+	b = cmsg->msg_count / test->mchans_count;
+	if ((b * test->mchans_count) < cmsg->msg_count)
+		b++;
+	s = 0;
+	cmsg->bmsg_count = 0;
+	while (s < cmsg->msg_count) {
+		i = min((cmsg->msg_count - s), b);
+		cmsg->bmsg[cmsg->bmsg_count].type = BRCM_MESSAGE_BATCH;
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs = &cmsg->msg[s];
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs_queued = 0;
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs_count = i;
+		fs4_debug(test, "batch%d msg_idx=%d msg_count=%d\n",
+			  cmsg->bmsg_count, s, i);
+		cmsg->bmsg_count++;
+		s += i;
+	}
+
+	fs4_debug(test, "msgs_count=%d msgs_per_chan=%d batch_msg_count=%d\n",
+		  cmsg->msg_count, b, cmsg->bmsg_count);
+
+	return cmsg;
+}
+
+/* Note: Must be called with test->lock held */
+static bool __sba_memcpy_verify(struct fs4_test *test,
+				struct fs4_test_msg *cmsg,
+				unsigned int iter)
+{
+	int b, i, t;
+	bool ret = true;
+
+	for (b = 0; b < test->batch_count; b++) {
+		for (i = 0; i < (test->src_size * test->src_count) / 8; i++)
+			if (((u64 *)cmsg->dst[b])[i] !=
+						((u64 *)cmsg->src[b])[i])
+				break;
+		if (i != ((test->src_size * test->src_count) / 8)) {
+			i *= 8;
+			fs4_info(test, "iter=%u batch=%u mismatch at %d\n",
+				 iter, b, i);
+			t = test->src_size - i;
+			if (t >= SBA_MEMCPY_REF_SIZE)
+				t = SBA_MEMCPY_REF_SIZE;
+			print_hex_dump(KERN_INFO, "src: ",
+					DUMP_PREFIX_ADDRESS,
+					8, 1, cmsg->src[b] + i,
+					t, true);
+			print_hex_dump(KERN_INFO, "dst_resp: ",
+					DUMP_PREFIX_ADDRESS,
+					8, 1, cmsg->dst_resp[b],
+					SBA_RESP_SIZE, true);
+			print_hex_dump(KERN_INFO, "dst: ",
+					DUMP_PREFIX_ADDRESS,
+					8, 1, cmsg->dst[b] + i,
+					t, true);
+			ret = false;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/* Note: Must be called with test->lock held */
+static int __sba_memcpy_exec(struct fs4_test *test)
+{
+	int rc = 0, i;
+	unsigned long tout;
+	struct mbox_chan *chan;
+	struct fs4_test_msg *cmsg;
+	unsigned long long input_bytes_count;
+	unsigned int cur_split_size, src_size, iter = 0;
+	unsigned int split_count, split_size, split_buf_count;
+	s64 iter_usecs, min_usecs = 0, max_usecs = 0, avg_usecs = 0;
+	unsigned long long iter_KBs, min_KBs = 0, max_KBs = 0, avg_KBs = 0;
+
+	if (test->batch_count > FS4_MAX_BATCH_COUNT) {
+		fs4_info(test, "batch_count should be less than %d\n",
+			 (int)FS4_MAX_BATCH_COUNT);
+		return -EINVAL;
+	}
+	if ((SBA_HW_BUF_SIZE/4) > test->min_split_size) {
+		fs4_info(test, "min_split_size should be greater than %d\n",
+			 (int)(SBA_HW_BUF_SIZE/4 - 1));
+		return -EINVAL;
+	}
+	if (test->min_split_size > 0x10000) {
+		fs4_info(test, "min_split_size can be upto 1MB or less\n");
+		return -EINVAL;
+	}
+	if ((SBA_HW_BUF_SIZE/4 > test->src_size)) {
+		fs4_info(test, "src_size should be greater than %d\n",
+			 (int)(SBA_HW_BUF_SIZE/4 - 1));
+		return -EINVAL;
+	}
+	if (test->src_size & (SBA_MEMCPY_REF_SIZE - 1)) {
+		fs4_info(test, "src_size has to be multiple of %d\n",
+			 (int)SBA_MEMCPY_REF_SIZE);
+		return -EINVAL;
+	}
+	if ((test->src_size * test->src_count) > 0x200000) {
+		fs4_info(test, "memory requirement greater than 2M\n");
+		return -EINVAL;
+	}
+
+	if (test->src_size <= test->min_split_size) {
+		split_size = test->src_size;
+	} else {
+		split_size = test->src_size / test->mchans_count;
+		if (split_size * test->mchans_count < test->src_size)
+			split_size++;
+		if (split_size <= test->min_split_size)
+			split_size = test->min_split_size;
+		if (split_size > test->src_size)
+			split_size = test->src_size;
+	}
+	split_buf_count = split_size / SBA_HW_BUF_SIZE;
+	if ((split_buf_count * SBA_HW_BUF_SIZE) < split_size)
+		split_buf_count++;
+	split_count = 0;
+	src_size = test->src_size;
+	while (src_size) {
+		cur_split_size = min(src_size, split_size);
+		split_count++;
+		src_size -= cur_split_size;
+	}
+
+	fs4_info(test, "split_count=%u split_size=%u split_buf_count=%u\n",
+		 split_count, split_size, split_buf_count);
+
+	cmsg = __sba_memcpy_alloc(test, split_count,
+				  split_size, split_buf_count);
+	if (!cmsg)
+		return -ENOMEM;
+
+	while (iter < test->iterations) {
+		fs4_info(test, "iter=%u started", iter);
+
+		input_bytes_count = test->src_count * test->src_size;
+		input_bytes_count *= test->batch_count;
+		for (i = 0; i < test->batch_count; i++) {
+			memset(cmsg->dst[i], 0,
+				test->src_count * test->src_size);
+			memset(cmsg->dst_resp[i], 0,
+				SBA_RESP_SIZE * split_count);
+		}
+
+		cmsg->start_ktime = ktime_get();
+		cmsg->runtime_usecs = 0;
+
+		if (test->software) {
+			for (i = 0; i < test->batch_count; i++)
+				memcpy(cmsg->dst[i], cmsg->src[i],
+					test->src_count * test->src_size);
+			cmsg->runtime_usecs =
+			ktime_us_delta(ktime_get(), cmsg->start_ktime);
+			goto skip_mailbox;
+		}
+
+		atomic_set(&cmsg->done_count, cmsg->msg_count);
+		init_completion(&cmsg->done);
+
+		rc = 0;
+		for (i = 0; i < cmsg->bmsg_count; i++) {
+			chan = test->mchans[test->chan];
+			test->chan++;
+			if (test->chan >= test->mchans_count)
+				test->chan = 0;
+
+			cmsg->bmsg[i].batch.msgs_queued = 0;
+			rc = mbox_send_message(chan, &cmsg->bmsg[i]);
+			if (rc < 0) {
+				fs4_info(test, "iter=%u msg=%d send error %d\n",
+					 iter, i, rc);
+				break;
+			}
+			rc = 0;
+
+			if (cmsg->bmsg[i].error < 0) {
+				rc = cmsg->bmsg[i].error;
+				break;
+			}
+			/* Signal txdone for mailbox channel */
+			mbox_client_txdone(chan, rc);
+		}
+		if (rc < 0)
+			break;
+
+		if (test->poll) {
+			while (atomic_read(&cmsg->done_count) > 0)
+				for (i = 0; i < test->mchans_count; i++)
+					mbox_client_peek_data(test->mchans[i]);
+		} else {
+			tout = (unsigned long)test->timeout * 1000;
+			tout = msecs_to_jiffies(tout);
+			tout = wait_for_completion_timeout(&cmsg->done, tout);
+			if (!tout) {
+				fs4_info(test, "iter=%u wait timeout\n", iter);
+				rc = -ETIMEDOUT;
+				break;
+			}
+		}
+
+		rc = 0;
+		for (i = 0; i < cmsg->msg_count; i++)
+			if (cmsg->msg[i].error < 0) {
+				fs4_info(test, "iter=%u msg=%d rx error\n",
+					 iter, i);
+				rc = cmsg->msg[i].error;
+			}
+		if (rc < 0)
+			break;
+
+skip_mailbox:
+		if (test->verify) {
+			if (!__sba_memcpy_verify(test, cmsg, iter))
+				break;
+		}
+
+		iter_usecs = cmsg->runtime_usecs;
+		iter_KBs =
+		fs4_test_KBs(cmsg->runtime_usecs, input_bytes_count);
+		min_usecs = (iter == 0) ?
+			    iter_usecs : min(min_usecs, iter_usecs);
+		max_usecs = (iter == 0) ?
+			    iter_usecs : max(max_usecs, iter_usecs);
+		avg_usecs += iter_usecs;
+		min_KBs = (iter == 0) ?
+			  iter_KBs : min(min_KBs, iter_KBs);
+		max_KBs = (iter == 0) ?
+			  iter_KBs : max(max_KBs, iter_KBs);
+		avg_KBs += iter_KBs;
+
+		fs4_info(test, "iter=%u usecs=%ld KBs=%llu",
+			 iter, (long)iter_usecs, iter_KBs);
+
+		iter++;
+	}
+
+	__sba_memcpy_free(test, cmsg, split_count);
+
+	if (iter) {
+		avg_usecs = avg_usecs / iter;
+		avg_KBs = avg_KBs / iter;
+	}
+
+	fs4_info(test, "completed %u/%u iterations\n",
+		 iter, test->iterations);
+	fs4_info(test, "min_usecs=%ld min_KBs=%llu",
+		 (long)min_usecs, min_KBs);
+	fs4_info(test, "max_usecs=%ld max_KBs=%llu",
+		 (long)max_usecs, max_KBs);
+	fs4_info(test, "avg_usecs=%ld avg_KBs=%llu",
+		 (long)avg_usecs, avg_KBs);
+
+	return rc;
+}
+
+static const u8 sba_xor_ref1[] = {
+0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+};
+
+static const u8 sba_xor_ref2[] = {
+0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
+};
+
+static const u8 sba_xor_ref3[] = {
+0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+};
+
+static const u8 sba_xor_ref4[] = {
+0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+};
+
+#define SBA_XOR_MAX_SRC_COUNT		14
+#define SBA_XOR_SPLIT_CMD_COUNT(test, split_buf_count)	\
+		(((test)->src_count + 1) * (split_buf_count))
+#define SBA_XOR_REF_SIZE		sizeof(sba_xor_ref1)
+#define SBA_XOR_CMD_COUNT(test, split_count, split_buf_count)	\
+	((split_count) * SBA_XOR_SPLIT_CMD_COUNT(test, split_buf_count))
+
+/* Note: Must be called with test->lock held */
+static unsigned int __sba_xor_split_cmds(struct fs4_test *test,
+					 struct brcm_sba_command *cmds,
+					 unsigned int split,
+					 unsigned int cur_split_size,
+					 unsigned int split_size,
+					 dma_addr_t src_dma_base,
+					 dma_addr_t dst_dma_base,
+					 dma_addr_t dst_resp_dma_base)
+{
+	int s;
+	u64 cmd;
+	unsigned int cpos = 0, csize;
+	unsigned int cmds_count = 0;
+
+	while (cur_split_size) {
+		csize = (cur_split_size < SBA_HW_BUF_SIZE) ?
+					cur_split_size : SBA_HW_BUF_SIZE;
+
+		/* Type-B command to load data into buf0 */
+		cmd = 0;
+		SBA_ENC(cmd, SBA_TYPE_B,
+			SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+		SBA_ENC(cmd, csize,
+			SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+		SBA_ENC(cmd, 0x0, SBA_RESP_SHIFT, SBA_RESP_MASK);
+		SBA_ENC(cmd, 0x0,
+			SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+		SBA_ENC(cmd, SBA_CMD_LOAD_BUFFER,
+			SBA_CMD_SHIFT, SBA_CMD_MASK);
+		cmds[cmds_count].cmd = cmd;
+		cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_B;
+		cmds[cmds_count].data =
+			src_dma_base + split * split_size + cpos;
+		cmds[cmds_count].data_len = csize;
+		cmds_count++;
+
+		/* Type-B command to xor data onto buf0 */
+		for (s = 1; s < test->src_count; s++) {
+			cmd = 0;
+			SBA_ENC(cmd, SBA_TYPE_B,
+				SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+			SBA_ENC(cmd, csize,
+				SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+			SBA_ENC(cmd, 0x0, SBA_RESP_SHIFT, SBA_RESP_MASK);
+			SBA_ENC(cmd, 0x0,
+				SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+			SBA_ENC(cmd, SBA_CMD_XOR,
+				SBA_CMD_SHIFT, SBA_CMD_MASK);
+			cmds[cmds_count].cmd = cmd;
+			cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_B;
+			cmds[cmds_count].data =
+				src_dma_base + s * test->src_size +
+				split * split_size + cpos;
+			cmds[cmds_count].data_len = csize;
+			cmds_count++;
+		}
+
+		/* Type-A command to write buf0 */
+		cmd = 0;
+		SBA_ENC(cmd, SBA_TYPE_A,
+			SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+		SBA_ENC(cmd, csize,
+			SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+		SBA_ENC(cmd, 0x1, SBA_RESP_SHIFT, SBA_RESP_MASK);
+		SBA_ENC(cmd, 0x0,
+			SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+		SBA_ENC(cmd, SBA_CMD_WRITE_BUFFER,
+			SBA_CMD_SHIFT, SBA_CMD_MASK);
+		cmds[cmds_count].cmd = cmd;
+		cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_A;
+		cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_RESP;
+		cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_OUTPUT;
+		cmds[cmds_count].resp =
+				dst_resp_dma_base + split * SBA_RESP_SIZE;
+		cmds[cmds_count].resp_len = SBA_RESP_SIZE;
+		cmds[cmds_count].data =
+				dst_dma_base + split * split_size + cpos;
+		cmds[cmds_count].data_len = csize;
+		cmds_count++;
+
+		cpos += csize;
+		cur_split_size -= csize;
+	}
+
+	return cmds_count;
+}
+
+/* Note: Must be called with test->lock held */
+static void __sba_software_xor(struct fs4_test *test, void *dst, void *src)
+{
+	int s, src_off, src_cnt, xor_src_cnt;
+	void *srcs[SBA_XOR_MAX_SRC_COUNT];
+
+	preempt_disable();
+
+	for (s = 0; s < test->src_count; s++)
+		srcs[s] = src + s * test->src_size;
+
+	src_off = 0;
+	src_cnt = test->src_count;
+	while (src_cnt > 0) {
+		/* process up to 'MAX_XOR_BLOCKS' sources */
+		xor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);
+		xor_blocks(xor_src_cnt, test->src_size, dst, &srcs[src_off]);
+
+		/* drop completed sources */
+		src_cnt -= xor_src_cnt;
+		src_off += xor_src_cnt;
+	}
+
+	preempt_enable();
+}
+
+/* Note: Must be called with test->lock held */
+static void __sba_xor_free(struct fs4_test *test,
+			   struct fs4_test_msg *cmsg,
+			   unsigned int split_count)
+{
+	int b;
+
+	if (!test || !cmsg)
+		return;
+
+	for (b = 0; b < test->batch_count; b++) {
+		if (cmsg->dst_resp[b]) {
+			dma_free_coherent(
+				  test->mbox_dev,
+				  SBA_RESP_SIZE * split_count,
+				  cmsg->dst_resp[b], cmsg->dst_resp_dma[b]);
+			cmsg->dst_resp[b] = NULL;
+		}
+		if (cmsg->dst[b]) {
+			dma_free_coherent(
+					test->mbox_dev,
+					test->src_size,
+					cmsg->dst[b], cmsg->dst_dma[b]);
+			cmsg->dst[b] = NULL;
+		}
+		if (cmsg->src[b]) {
+			dma_free_coherent(
+					test->mbox_dev,
+					test->src_count * test->src_size,
+					cmsg->src[b], cmsg->src_dma[b]);
+			cmsg->src[b] = NULL;
+		}
+		if (cmsg->cmds[b]) {
+			devm_kfree(test->dev, cmsg->cmds[b]);
+			cmsg->cmds[b] = NULL;
+		}
+	}
+
+	devm_kfree(test->dev, cmsg);
+}
+
+/* Note: Must be called with test->lock held */
+static struct fs4_test_msg *__sba_xor_alloc(struct fs4_test *test,
+					    unsigned int split_count,
+					    unsigned int split_size,
+					    unsigned int split_buf_count)
+{
+	unsigned int b, s, i;
+	const u8 *ref_split;
+	struct fs4_test_msg *cmsg = NULL;
+	unsigned int cmds_idx, cmds_count;
+	unsigned int cur_split_size, src_size;
+
+	if (!test)
+		return NULL;
+
+	cmsg = devm_kzalloc(test->dev, sizeof(*cmsg), GFP_KERNEL);
+	if (!cmsg)
+		return NULL;
+
+	for (b = 0; b < test->batch_count; b++) {
+		cmsg->cmds[b] = devm_kcalloc(test->dev,
+			SBA_XOR_CMD_COUNT(test, split_count, split_buf_count),
+			sizeof(*cmsg->cmds[b]), GFP_KERNEL);
+		if (!cmsg->cmds[b]) {
+			fs4_info(test, "failed to alloc sba command array\n");
+			__sba_xor_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		cmsg->src[b] = dma_alloc_coherent(
+				test->mbox_dev,
+				test->src_count * test->src_size,
+				&cmsg->src_dma[b], GFP_KERNEL);
+		if (!cmsg->src[b]) {
+			fs4_info(test, "failed to alloc src buffer\n");
+			__sba_xor_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		fs4_debug(test, "src[%d]=0x%p src_dma[%d]=0x%lx\n",
+		b, cmsg->src[b], b, (unsigned long)cmsg->src_dma[b]);
+
+		for (s = 0; s < test->src_count; s++) {
+			switch (s & 0x3) {
+			case 0:
+				ref_split = sba_xor_ref1;
+				break;
+			case 1:
+				ref_split = sba_xor_ref2;
+				break;
+			case 2:
+				ref_split = sba_xor_ref3;
+				break;
+			case 3:
+				ref_split = sba_xor_ref4;
+				break;
+			}
+			for (i = 0; i < test->src_size / SBA_XOR_REF_SIZE; i++)
+				memcpy(cmsg->src[b] +
+				s * test->src_size + i * SBA_XOR_REF_SIZE,
+				ref_split, SBA_XOR_REF_SIZE);
+		}
+
+		cmsg->dst[b] = dma_alloc_coherent(
+					test->mbox_dev,
+					test->src_size, &cmsg->dst_dma[b],
+					GFP_KERNEL);
+		if (!cmsg->dst[b]) {
+			fs4_info(test, "failed to alloc dst buffer\n");
+			__sba_xor_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		fs4_debug(test, "dst[%d]=0x%p dst_dma[%d]=0x%lx\n",
+		b, cmsg->dst[b], b, (unsigned long)cmsg->dst_dma[b]);
+
+		cmsg->dst_resp[b] = dma_alloc_coherent(
+					test->mbox_dev,
+					SBA_RESP_SIZE * split_count,
+					&cmsg->dst_resp_dma[b], GFP_KERNEL);
+		if (!cmsg->dst_resp[b]) {
+			fs4_info(test, "failed to alloc dst_resp buffer\n");
+			__sba_xor_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		fs4_debug(test, "dst_resp[%d]=0x%p dst_resp_dma[%d]=0x%lx\n",
+		b, cmsg->dst_resp[b], b, (unsigned long)cmsg->dst_resp_dma[b]);
+
+		src_size = test->src_size;
+		for (s = 0; (s < split_count) && src_size; s++) {
+			cur_split_size = min(src_size, split_size);
+
+			cmds_idx =
+			s * SBA_XOR_SPLIT_CMD_COUNT(test, split_buf_count);
+			cmds_count = __sba_xor_split_cmds(test,
+					   &cmsg->cmds[b][cmds_idx],
+					   s, cur_split_size, split_size,
+					   cmsg->src_dma[b], cmsg->dst_dma[b],
+					   cmsg->dst_resp_dma[b]);
+
+			cmsg->msg[cmsg->msg_count + s].type =
+						BRCM_MESSAGE_SBA;
+			cmsg->msg[cmsg->msg_count + s].sba.cmds =
+						&cmsg->cmds[b][cmds_idx];
+			cmsg->msg[cmsg->msg_count + s].sba.cmds_count =
+						cmds_count;
+			cmsg->msg[cmsg->msg_count + s].ctx = cmsg;
+			cmsg->msg[cmsg->msg_count + s].error = 0;
+
+			src_size -= cur_split_size;
+		}
+
+		cmsg->msg_count += split_count;
+	}
+
+	b = cmsg->msg_count / test->mchans_count;
+	if ((b * test->mchans_count) < cmsg->msg_count)
+		b++;
+	s = 0;
+	cmsg->bmsg_count = 0;
+	while (s < cmsg->msg_count) {
+		i = min((cmsg->msg_count - s), b);
+		cmsg->bmsg[cmsg->bmsg_count].type = BRCM_MESSAGE_BATCH;
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs = &cmsg->msg[s];
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs_queued = 0;
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs_count = i;
+		fs4_debug(test, "batch%d msg_idx=%d msg_count=%d\n",
+			  cmsg->bmsg_count, s, i);
+		cmsg->bmsg_count++;
+		s += i;
+	}
+
+	fs4_debug(test, "msgs_count=%d msgs_per_chan=%d batch_msg_count=%d\n",
+		  cmsg->msg_count, b, cmsg->bmsg_count);
+
+	return cmsg;
+}
+
+/* Note: Must be called with test->lock held */
+static bool __sba_xor_verify(struct fs4_test *test,
+			     struct fs4_test_msg *cmsg,
+			     unsigned int iter, u64 ref_out_magic)
+{
+	int b, i, t;
+	bool ret = true;
+
+	for (b = 0; b < test->batch_count; b++) {
+		for (i = 0; i < (test->src_size / 8); i++)
+			if (((u64 *)cmsg->dst[b])[i] != ref_out_magic) {
+				fs4_info(test, "got=0x%lx exp=0x%lx\n",
+				(unsigned long)((u64 *)cmsg->dst[b])[i],
+				(unsigned long)ref_out_magic);
+				ret = false;
+				break;
+			}
+		if (i != (test->src_size / 8)) {
+			i *= 8;
+			fs4_info(test, "iter=%u batch=%u mismatch at %d\n",
+				 iter, b, i);
+			t = test->src_size - i;
+			if (t >= SBA_XOR_REF_SIZE)
+				t = SBA_XOR_REF_SIZE;
+			print_hex_dump(KERN_INFO, "dst_resp: ",
+					DUMP_PREFIX_ADDRESS,
+					8, 1, cmsg->dst_resp[b],
+					SBA_RESP_SIZE, true);
+			print_hex_dump(KERN_INFO, "dst: ",
+					DUMP_PREFIX_ADDRESS,
+					8, 1, cmsg->dst[b] + i,
+					t, true);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/* Note: Must be called with test->lock held */
+static int __sba_xor_exec(struct fs4_test *test)
+{
+	int rc = 0, i;
+	u64 ref_out_magic;
+	unsigned long tout;
+	struct mbox_chan *chan;
+	struct fs4_test_msg *cmsg;
+	unsigned long long input_bytes_count;
+	unsigned int cur_split_size, src_size, iter = 0;
+	unsigned int split_count, split_size, split_buf_count;
+	s64 iter_usecs, min_usecs = 0, max_usecs = 0, avg_usecs = 0;
+	unsigned long long iter_KBs, min_KBs = 0, max_KBs = 0, avg_KBs = 0;
+
+	if (test->batch_count > FS4_MAX_BATCH_COUNT) {
+		fs4_info(test, "batch_count should be less than %d\n",
+			 (int)FS4_MAX_BATCH_COUNT);
+		return -EINVAL;
+	}
+	if ((SBA_HW_BUF_SIZE/4) > test->min_split_size) {
+		fs4_info(test, "min_split_size should be greater than %d\n",
+			 (int)(SBA_HW_BUF_SIZE/4 - 1));
+		return -EINVAL;
+	}
+	if (test->min_split_size > 0x10000) {
+		fs4_info(test, "min_split_size can be upto 1MB or less\n");
+		return -EINVAL;
+	}
+	if ((SBA_HW_BUF_SIZE/4) > test->src_size) {
+		fs4_info(test, "src_size should be greater than %d\n",
+			 (int)(SBA_HW_BUF_SIZE/4 - 1));
+		return -EINVAL;
+	}
+	if (test->src_size & (SBA_XOR_REF_SIZE - 1)) {
+		fs4_info(test, "src_size has to be multiple of %d\n",
+			 (int)SBA_XOR_REF_SIZE);
+		return -EINVAL;
+	}
+	if (test->src_count < 2) {
+		fs4_info(test, "src_count cannot be less than 2\n");
+		return -EINVAL;
+	}
+	if (test->update && (test->src_count != 3)) {
+		fs4_info(test, "src_count has to be 3 for update mode\n");
+		return -EINVAL;
+	}
+	if (test->src_count > SBA_XOR_MAX_SRC_COUNT) {
+		fs4_info(test, "src_count cannot be greater than %d\n",
+			 (int)SBA_XOR_MAX_SRC_COUNT);
+		return -EINVAL;
+	}
+	if ((test->src_size * test->src_count) > 0x200000) {
+		fs4_info(test, "memory requirement greater than 2M\n");
+		return -EINVAL;
+	}
+
+	if (test->src_size <= test->min_split_size) {
+		split_size = test->src_size;
+	} else {
+		split_size = test->src_size / test->mchans_count;
+		if (split_size * test->mchans_count < test->src_size)
+			split_size++;
+		if (split_size <= test->min_split_size)
+			split_size = test->min_split_size;
+		if (split_size > test->src_size)
+			split_size = test->src_size;
+	}
+	split_buf_count = split_size / SBA_HW_BUF_SIZE;
+	if ((split_buf_count * SBA_HW_BUF_SIZE) < split_size)
+		split_buf_count++;
+	split_count = 0;
+	src_size = test->src_size;
+	while (src_size) {
+		cur_split_size = min(src_size, split_size);
+		split_count++;
+		src_size -= cur_split_size;
+	}
+
+	fs4_info(test, "split_count=%u split_size=%u split_buf_count=%u\n",
+		 split_count, split_size, split_buf_count);
+
+	cmsg = __sba_xor_alloc(test,
+			split_count, split_size, split_buf_count);
+	if (!cmsg)
+		return -ENOMEM;
+
+	ref_out_magic = 0x0;
+	for (i = 0; i < test->src_count; i++)
+		ref_out_magic = ref_out_magic ^
+				(*(u64 *)(cmsg->src[0] + i * test->src_size));
+
+	while (iter < test->iterations) {
+		fs4_info(test, "iter=%u started", iter);
+
+		input_bytes_count = test->src_size * test->src_count;
+		input_bytes_count *= test->batch_count;
+		for (i = 0; i < test->batch_count; i++) {
+			memset(cmsg->dst[i], 0, test->src_size);
+			memset(cmsg->dst_resp[i], 0,
+				SBA_RESP_SIZE * split_count);
+		}
+
+		cmsg->start_ktime = ktime_get();
+		cmsg->runtime_usecs = 0;
+
+		if (test->software) {
+			for (i = 0; i < test->batch_count; i++)
+				__sba_software_xor(test,
+						cmsg->dst[i], cmsg->src[i]);
+			cmsg->runtime_usecs =
+			ktime_us_delta(ktime_get(), cmsg->start_ktime);
+			goto skip_mailbox;
+		}
+
+		atomic_set(&cmsg->done_count, cmsg->msg_count);
+		init_completion(&cmsg->done);
+
+		rc = 0;
+		for (i = 0; i < cmsg->bmsg_count; i++) {
+			chan = test->mchans[test->chan];
+			test->chan++;
+			if (test->chan >= test->mchans_count)
+				test->chan = 0;
+
+			cmsg->bmsg[i].batch.msgs_queued = 0;
+			rc = mbox_send_message(chan, &cmsg->bmsg[i]);
+			if (rc < 0) {
+				fs4_info(test, "iter=%u msg=%d send error %d\n",
+					 iter, i, rc);
+				break;
+			}
+			rc = 0;
+
+			if (cmsg->bmsg[i].error < 0) {
+				rc = cmsg->bmsg[i].error;
+				break;
+			}
+			/* Signal txdone for mailbox channel */
+			mbox_client_txdone(chan, rc);
+		}
+		if (rc < 0)
+			break;
+
+		if (test->poll) {
+			while (atomic_read(&cmsg->done_count) > 0)
+				for (i = 0; i < test->mchans_count; i++)
+					mbox_client_peek_data(test->mchans[i]);
+		} else {
+			tout = (unsigned long)test->timeout * 1000;
+			tout = msecs_to_jiffies(tout);
+			tout = wait_for_completion_timeout(&cmsg->done, tout);
+			if (!tout) {
+				fs4_info(test, "iter=%u wait timeout\n", iter);
+				rc = -ETIMEDOUT;
+				break;
+			}
+		}
+
+		rc = 0;
+		for (i = 0; i < cmsg->msg_count; i++)
+			if (cmsg->msg[i].error < 0) {
+				fs4_info(test, "iter=%u msg=%d rx error\n",
+					 iter, i);
+				rc = cmsg->msg[i].error;
+			}
+		if (rc < 0)
+			break;
+
+skip_mailbox:
+		if (test->verify) {
+			if (!__sba_xor_verify(test, cmsg,
+					      iter, ref_out_magic))
+				break;
+		}
+
+		iter_usecs = cmsg->runtime_usecs;
+		iter_KBs =
+		fs4_test_KBs(cmsg->runtime_usecs, input_bytes_count);
+		min_usecs = (iter == 0) ?
+			    iter_usecs : min(min_usecs, iter_usecs);
+		max_usecs = (iter == 0) ?
+			    iter_usecs : max(max_usecs, iter_usecs);
+		avg_usecs += iter_usecs;
+		min_KBs = (iter == 0) ?
+			  iter_KBs : min(min_KBs, iter_KBs);
+		max_KBs = (iter == 0) ?
+			  iter_KBs : max(max_KBs, iter_KBs);
+		avg_KBs += iter_KBs;
+
+		fs4_info(test, "iter=%u usecs=%ld KBs=%llu",
+			 iter, (long)iter_usecs, iter_KBs);
+
+		iter++;
+	}
+
+	__sba_xor_free(test, cmsg, split_count);
+
+	if (iter) {
+		avg_usecs = avg_usecs / iter;
+		avg_KBs = avg_KBs / iter;
+	}
+
+	fs4_info(test, "completed %u/%u iterations\n",
+		 iter, test->iterations);
+	fs4_info(test, "min_usecs=%ld min_KBs=%llu",
+		 (long)min_usecs, min_KBs);
+	fs4_info(test, "max_usecs=%ld max_KBs=%llu",
+		 (long)max_usecs, max_KBs);
+	fs4_info(test, "avg_usecs=%ld avg_KBs=%llu",
+		 (long)avg_usecs, avg_KBs);
+
+	return rc;
+}
+
+static const u8 sba_pq_ref1[] = {
+0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+};
+
+static const u8 sba_pq_ref2[] = {
+0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
+};
+
+static const u8 sba_pq_ref3[] = {
+0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+};
+
+static const u8 sba_pq_ref4[] = {
+0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+};
+
+#define SBA_PQ_MAX_SRC_COUNT		12
+#define SBA_UPD_PQ_NEW_D		0
+#define SBA_UPD_PQ_OLD_D		1
+#define SBA_UPD_PQ_OLD_P		2
+#define SBA_UPD_PQ_OLD_Q		3
+#define SBA_UPD_PQ_POS			(SBA_PQ_MAX_SRC_COUNT / 2)
+#define SBA_PQ_SPLIT_CMD_COUNT(test, split_buf_count)	\
+		(((test)->src_count + 3) * (split_buf_count))
+#define SBA_PQ_REF_SIZE		sizeof(sba_pq_ref1)
+#define SBA_PQ_CMD_COUNT(test, split_count, split_buf_count)	\
+	((split_count) * SBA_PQ_SPLIT_CMD_COUNT(test, split_buf_count))
+
+static unsigned int __sba_upd_pq_split_cmds(struct fs4_test *test,
+					    struct brcm_sba_command *cmds,
+					    unsigned int split,
+					    unsigned int cur_split_size,
+					    unsigned int split_size,
+					    dma_addr_t src_dma_base,
+					    dma_addr_t dst_dma_base,
+					    dma_addr_t dst1_dma_base,
+					    dma_addr_t dst_resp_dma_base)
+{
+	u64 cmd;
+	unsigned int cmds_count = 0;
+	unsigned int cpos = 0, c_mdata, csize;
+
+	while (cur_split_size) {
+		csize = (cur_split_size < SBA_HW_BUF_SIZE) ?
+					cur_split_size : SBA_HW_BUF_SIZE;
+
+		/* Type-B command to load old P into buf0 */
+		cmd = 0;
+		SBA_ENC(cmd, SBA_TYPE_B, SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+		SBA_ENC(cmd, csize, SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+		SBA_ENC(cmd, 0x0, SBA_RESP_SHIFT, SBA_RESP_MASK);
+		c_mdata = SBA_C_MDATA_LOAD_VAL(0);
+		SBA_ENC(cmd, SBA_C_MDATA_LS(c_mdata),
+			SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+		SBA_ENC(cmd, SBA_CMD_LOAD_BUFFER,
+			SBA_CMD_SHIFT, SBA_CMD_MASK);
+		cmds[cmds_count].cmd = cmd;
+		cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_B;
+		cmds[cmds_count].data = src_dma_base +
+					SBA_UPD_PQ_OLD_P * test->src_size +
+					split * split_size + cpos;
+		cmds[cmds_count].data_len = csize;
+		cmds_count++;
+
+		/* Type-B command to load old Q into buf1 */
+		cmd = 0;
+		SBA_ENC(cmd, SBA_TYPE_B, SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+		SBA_ENC(cmd, csize, SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+		SBA_ENC(cmd, 0x0, SBA_RESP_SHIFT, SBA_RESP_MASK);
+		c_mdata = SBA_C_MDATA_LOAD_VAL(1);
+		SBA_ENC(cmd, SBA_C_MDATA_LS(c_mdata),
+			SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+		SBA_ENC(cmd, SBA_CMD_LOAD_BUFFER,
+			SBA_CMD_SHIFT, SBA_CMD_MASK);
+		cmds[cmds_count].cmd = cmd;
+		cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_B;
+		cmds[cmds_count].data = src_dma_base +
+					SBA_UPD_PQ_OLD_Q * test->src_size +
+					split * split_size + cpos;
+		cmds[cmds_count].data_len = csize;
+		cmds_count++;
+
+		/* Type-B commands for generate P onto buf0 and Q onto buf1 */
+		cmd = 0;
+		SBA_ENC(cmd, SBA_TYPE_B,
+			SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+		SBA_ENC(cmd, csize,
+			SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+		SBA_ENC(cmd, 0x0, SBA_RESP_SHIFT, SBA_RESP_MASK);
+		c_mdata = SBA_C_MDATA_PQ_VAL(SBA_UPD_PQ_POS, 1, 0);
+		SBA_ENC(cmd, SBA_C_MDATA_LS(c_mdata),
+			SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+		SBA_ENC(cmd, SBA_C_MDATA_MS(c_mdata),
+			SBA_C_MDATA_MS_SHIFT, SBA_C_MDATA_MS_MASK);
+		SBA_ENC(cmd, SBA_CMD_GALOIS_XOR,
+			SBA_CMD_SHIFT, SBA_CMD_MASK);
+		cmds[cmds_count].cmd = cmd;
+		cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_B;
+		cmds[cmds_count].data = src_dma_base +
+					SBA_UPD_PQ_OLD_D * test->src_size +
+					split * split_size + cpos;
+		cmds[cmds_count].data_len = csize;
+		cmds_count++;
+
+		/* Type-B commands for generate P onto buf0 and Q onto buf1 */
+		cmd = 0;
+		SBA_ENC(cmd, SBA_TYPE_B,
+			SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+		SBA_ENC(cmd, csize,
+			SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+		SBA_ENC(cmd, 0x0, SBA_RESP_SHIFT, SBA_RESP_MASK);
+		c_mdata = SBA_C_MDATA_PQ_VAL(SBA_UPD_PQ_POS, 1, 0);
+		SBA_ENC(cmd, SBA_C_MDATA_LS(c_mdata),
+			SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+		SBA_ENC(cmd, SBA_C_MDATA_MS(c_mdata),
+			SBA_C_MDATA_MS_SHIFT, SBA_C_MDATA_MS_MASK);
+		SBA_ENC(cmd, SBA_CMD_GALOIS_XOR,
+			SBA_CMD_SHIFT, SBA_CMD_MASK);
+		cmds[cmds_count].cmd = cmd;
+		cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_B;
+		cmds[cmds_count].data = src_dma_base +
+					SBA_UPD_PQ_NEW_D * test->src_size +
+					split * split_size + cpos;
+		cmds[cmds_count].data_len = csize;
+		cmds_count++;
+
+		/* Type-A command to write buf0 */
+		cmd = 0;
+		SBA_ENC(cmd, SBA_TYPE_A,
+			SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+		SBA_ENC(cmd, csize,
+			SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+		SBA_ENC(cmd, 0x1, SBA_RESP_SHIFT, SBA_RESP_MASK);
+		c_mdata = SBA_C_MDATA_WRITE_VAL(0);
+		SBA_ENC(cmd, SBA_C_MDATA_LS(c_mdata),
+			SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+		SBA_ENC(cmd, SBA_CMD_WRITE_BUFFER,
+			SBA_CMD_SHIFT, SBA_CMD_MASK);
+		cmds[cmds_count].cmd = cmd;
+		cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_A;
+		cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_RESP;
+		cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_OUTPUT;
+		cmds[cmds_count].resp =
+				dst_resp_dma_base + split * SBA_RESP_SIZE;
+		cmds[cmds_count].resp_len = SBA_RESP_SIZE;
+		cmds[cmds_count].data =
+				dst_dma_base + split * split_size + cpos;
+		cmds[cmds_count].data_len = csize;
+		cmds_count++;
+
+		/* Type-A command to write buf1 */
+		cmd = 0;
+		SBA_ENC(cmd, SBA_TYPE_A,
+			SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+		SBA_ENC(cmd, csize,
+			SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+		SBA_ENC(cmd, 0x1, SBA_RESP_SHIFT, SBA_RESP_MASK);
+		c_mdata = SBA_C_MDATA_WRITE_VAL(1);
+		SBA_ENC(cmd, SBA_C_MDATA_LS(c_mdata),
+			SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+		SBA_ENC(cmd, SBA_CMD_WRITE_BUFFER,
+			SBA_CMD_SHIFT, SBA_CMD_MASK);
+		cmds[cmds_count].cmd = cmd;
+		cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_A;
+		cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_RESP;
+		cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_OUTPUT;
+		cmds[cmds_count].resp =
+				dst_resp_dma_base + split * SBA_RESP_SIZE;
+		cmds[cmds_count].resp_len = SBA_RESP_SIZE;
+		cmds[cmds_count].data =
+				dst1_dma_base + split * split_size + cpos;
+		cmds[cmds_count].data_len = csize;
+		cmds_count++;
+
+		cpos += csize;
+		cur_split_size -= csize;
+	}
+
+	return cmds_count;
+}
+
+static unsigned int __sba_gen_pq_split_cmds(struct fs4_test *test,
+					    struct brcm_sba_command *cmds,
+					    unsigned int split,
+					    unsigned int cur_split_size,
+					    unsigned int split_size,
+					    dma_addr_t src_dma_base,
+					    dma_addr_t dst_dma_base,
+					    dma_addr_t dst1_dma_base,
+					    dma_addr_t dst_resp_dma_base)
+{
+	u64 cmd;
+	unsigned int s, cmds_count = 0;
+	unsigned int cpos = 0, c_mdata, csize;
+
+	while (cur_split_size) {
+		csize = (cur_split_size < SBA_HW_BUF_SIZE) ?
+					cur_split_size : SBA_HW_BUF_SIZE;
+
+		/* Type-A command to zero-out buffers */
+		cmd = 0;
+		SBA_ENC(cmd, SBA_TYPE_A, SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+		SBA_ENC(cmd, csize,
+			SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+		SBA_ENC(cmd, SBA_CMD_ZERO_ALL_BUFFERS,
+			SBA_CMD_SHIFT, SBA_CMD_MASK);
+		cmds[cmds_count].cmd = cmd;
+		cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_A;
+		cmds_count++;
+
+		/* Type-B commands for generate P onto buf0 and Q onto buf1 */
+		for (s = 0; s < test->src_count; s++) {
+			cmd = 0;
+			SBA_ENC(cmd, SBA_TYPE_B,
+				SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+			SBA_ENC(cmd, csize,
+				SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+			SBA_ENC(cmd, 0x0, SBA_RESP_SHIFT, SBA_RESP_MASK);
+			c_mdata = SBA_C_MDATA_PQ_VAL(s, 1, 0);
+			SBA_ENC(cmd, SBA_C_MDATA_LS(c_mdata),
+				SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+			SBA_ENC(cmd, SBA_C_MDATA_MS(c_mdata),
+				SBA_C_MDATA_MS_SHIFT, SBA_C_MDATA_MS_MASK);
+			SBA_ENC(cmd, SBA_CMD_GALOIS_XOR,
+				SBA_CMD_SHIFT, SBA_CMD_MASK);
+			cmds[cmds_count].cmd = cmd;
+			cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_B;
+			cmds[cmds_count].data =
+				src_dma_base + s * test->src_size +
+				split * split_size + cpos;
+			cmds[cmds_count].data_len = csize;
+			cmds_count++;
+		}
+
+		/* Type-A command to write buf0 */
+		cmd = 0;
+		SBA_ENC(cmd, SBA_TYPE_A,
+			SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+		SBA_ENC(cmd, csize,
+			SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+		SBA_ENC(cmd, 0x1, SBA_RESP_SHIFT, SBA_RESP_MASK);
+		c_mdata = SBA_C_MDATA_WRITE_VAL(0);
+		SBA_ENC(cmd, SBA_C_MDATA_LS(c_mdata),
+			SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+		SBA_ENC(cmd, SBA_CMD_WRITE_BUFFER,
+			SBA_CMD_SHIFT, SBA_CMD_MASK);
+		cmds[cmds_count].cmd = cmd;
+		cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_A;
+		cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_RESP;
+		cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_OUTPUT;
+		cmds[cmds_count].resp =
+				dst_resp_dma_base + split * SBA_RESP_SIZE;
+		cmds[cmds_count].resp_len = SBA_RESP_SIZE;
+		cmds[cmds_count].data =
+				dst_dma_base + split * split_size + cpos;
+		cmds[cmds_count].data_len = csize;
+		cmds_count++;
+
+		/* Type-A command to write buf1 */
+		cmd = 0;
+		SBA_ENC(cmd, SBA_TYPE_A,
+			SBA_TYPE_SHIFT, SBA_TYPE_MASK);
+		SBA_ENC(cmd, csize,
+			SBA_USER_DEF_SHIFT, SBA_USER_DEF_MASK);
+		SBA_ENC(cmd, 0x1, SBA_RESP_SHIFT, SBA_RESP_MASK);
+		c_mdata = SBA_C_MDATA_WRITE_VAL(1);
+		SBA_ENC(cmd, SBA_C_MDATA_LS(c_mdata),
+			SBA_C_MDATA_SHIFT, SBA_C_MDATA_MASK);
+		SBA_ENC(cmd, SBA_CMD_WRITE_BUFFER,
+			SBA_CMD_SHIFT, SBA_CMD_MASK);
+		cmds[cmds_count].cmd = cmd;
+		cmds[cmds_count].flags = BRCM_SBA_CMD_TYPE_A;
+		cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_RESP;
+		cmds[cmds_count].flags |= BRCM_SBA_CMD_HAS_OUTPUT;
+		cmds[cmds_count].resp =
+				dst_resp_dma_base + split * SBA_RESP_SIZE;
+		cmds[cmds_count].resp_len = SBA_RESP_SIZE;
+		cmds[cmds_count].data =
+				dst1_dma_base + split * split_size + cpos;
+		cmds[cmds_count].data_len = csize;
+		cmds_count++;
+
+		cpos += csize;
+		cur_split_size -= csize;
+	}
+
+	return cmds_count;
+}
+
+/* Note: Must be called with test->lock held */
+static unsigned int __sba_pq_split_cmds(struct fs4_test *test,
+					struct brcm_sba_command *cmds,
+					unsigned int split,
+					unsigned int cur_split_size,
+					unsigned int split_size,
+					dma_addr_t src_dma_base,
+					dma_addr_t dst_dma_base,
+					dma_addr_t dst1_dma_base,
+					dma_addr_t dst_resp_dma_base)
+{
+	if (test->update)
+		return __sba_upd_pq_split_cmds(test,
+					       cmds,
+					       split,
+					       cur_split_size,
+					       split_size,
+					       src_dma_base,
+					       dst_dma_base,
+					       dst1_dma_base,
+					       dst_resp_dma_base);
+	else
+		return __sba_gen_pq_split_cmds(test,
+					       cmds,
+					       split,
+					       cur_split_size,
+					       split_size,
+					       src_dma_base,
+					       dst_dma_base,
+					       dst1_dma_base,
+					       dst_resp_dma_base);
+}
+
+/* Note: Must be called with test->lock held */
+static void __sba_software_pq(struct fs4_test *test,
+			      void *dst, void *dst1, void *src)
+{
+	int s;
+	unsigned int pos = 0, size;
+	void *old, *new, *srcs[SBA_PQ_MAX_SRC_COUNT + 2];
+
+	preempt_disable();
+
+	if (test->update) {
+		for (s = 0; s < SBA_PQ_MAX_SRC_COUNT; s++)
+			srcs[s] = (void *)raid6_empty_zero_page;
+		srcs[SBA_PQ_MAX_SRC_COUNT] = dst;
+		srcs[SBA_PQ_MAX_SRC_COUNT + 1] = dst1;
+		old = src + SBA_UPD_PQ_OLD_D * test->src_size;
+		new = src + SBA_UPD_PQ_NEW_D * test->src_size;
+	} else {
+		for (s = 0; s < test->src_count; s++)
+			srcs[s] = src + s * test->src_size;
+		srcs[test->src_count] = dst;
+		srcs[test->src_count + 1] = dst1;
+		old = new = NULL;
+	}
+
+	while (pos < test->src_size) {
+		size = ((test->src_size - pos) < PAGE_SIZE) ?
+			(test->src_size - pos) : PAGE_SIZE;
+
+		if (test->update) {
+			old += pos;
+			new += pos;
+			srcs[SBA_PQ_MAX_SRC_COUNT] += pos;
+			srcs[SBA_PQ_MAX_SRC_COUNT + 1] += pos;
+			srcs[SBA_UPD_PQ_POS] = old;
+			raid6_call.xor_syndrome(SBA_PQ_MAX_SRC_COUNT + 2,
+						SBA_UPD_PQ_POS,
+						SBA_UPD_PQ_POS + 1,
+						size, srcs);
+			srcs[SBA_UPD_PQ_POS] = new;
+			raid6_call.xor_syndrome(SBA_PQ_MAX_SRC_COUNT + 2,
+						SBA_UPD_PQ_POS,
+						SBA_UPD_PQ_POS + 1,
+						size, srcs);
+		} else {
+			for (s = 0; s < test->src_count + 2; s++)
+				srcs[s] += pos;
+
+			raid6_call.gen_syndrome(test->src_count + 2,
+						size, srcs);
+		}
+
+		pos += size;
+	}
+
+	preempt_enable();
+}
+
+/* Note: Must be called with test->lock held */
+static void __sba_pq_free(struct fs4_test *test,
+			   struct fs4_test_msg *cmsg,
+			   unsigned int split_count)
+{
+	int b;
+
+	if (!test || !cmsg)
+		return;
+
+	for (b = 0; b < test->batch_count; b++) {
+		if (cmsg->dst_resp[b]) {
+			dma_free_coherent(
+				  test->mbox_dev,
+				  SBA_RESP_SIZE * split_count,
+				  cmsg->dst_resp[b], cmsg->dst_resp_dma[b]);
+			cmsg->dst_resp[b] = NULL;
+		}
+		if (cmsg->dst1[b]) {
+			dma_free_coherent(
+					test->mbox_dev,
+					test->src_size,
+					cmsg->dst1[b], cmsg->dst1_dma[b]);
+			cmsg->dst1[b] = NULL;
+		}
+		if (cmsg->dst[b]) {
+			dma_free_coherent(
+					test->mbox_dev,
+					test->src_size,
+					cmsg->dst[b], cmsg->dst_dma[b]);
+			cmsg->dst[b] = NULL;
+		}
+		if (cmsg->src[b]) {
+			dma_free_coherent(
+					test->mbox_dev,
+					test->src_count * test->src_size,
+					cmsg->src[b], cmsg->src_dma[b]);
+			cmsg->src[b] = NULL;
+		}
+		if (cmsg->cmds[b]) {
+			devm_kfree(test->dev, cmsg->cmds[b]);
+			cmsg->cmds[b] = NULL;
+		}
+	}
+
+	devm_kfree(test->dev, cmsg);
+}
+
+/* Note: Must be called with test->lock held */
+static struct fs4_test_msg *__sba_pq_alloc(struct fs4_test *test,
+					   unsigned int split_count,
+					   unsigned int split_size,
+					   unsigned int split_buf_count)
+{
+	unsigned int b, s, i;
+	const u8 *ref_split;
+	struct fs4_test_msg *cmsg = NULL;
+	unsigned int cmds_idx, cmds_count;
+	unsigned int cur_split_size, src_size;
+
+	if (!test)
+		return NULL;
+
+	cmsg = devm_kzalloc(test->dev, sizeof(*cmsg), GFP_KERNEL);
+	if (!cmsg)
+		return NULL;
+
+	for (b = 0; b < test->batch_count; b++) {
+		cmsg->cmds[b] = devm_kcalloc(test->dev,
+			SBA_PQ_CMD_COUNT(test, split_count, split_buf_count),
+			sizeof(*cmsg->cmds[b]), GFP_KERNEL);
+		if (!cmsg->cmds[b]) {
+			fs4_info(test, "failed to alloc sba command array\n");
+			__sba_pq_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		cmsg->src[b] = dma_alloc_coherent(
+				test->mbox_dev,
+				test->src_count * test->src_size,
+				&cmsg->src_dma[b], GFP_KERNEL);
+		if (!cmsg->src[b]) {
+			fs4_info(test, "failed to alloc src buffer\n");
+			__sba_pq_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		fs4_debug(test, "src[%d]=0x%p src_dma[%d]=0x%lx\n",
+		b, cmsg->src[b], b, (unsigned long)cmsg->src_dma[b]);
+
+		for (s = 0; s < test->src_count; s++) {
+			switch (s & 0x3) {
+			case 0:
+				ref_split = sba_pq_ref1;
+				break;
+			case 1:
+				ref_split = sba_pq_ref2;
+				break;
+			case 2:
+				ref_split = sba_pq_ref3;
+				break;
+			case 3:
+				ref_split = sba_pq_ref4;
+				break;
+			}
+			for (i = 0; i < test->src_size / SBA_PQ_REF_SIZE; i++)
+				memcpy(cmsg->src[b] +
+				s * test->src_size + i * SBA_PQ_REF_SIZE,
+				ref_split, SBA_PQ_REF_SIZE);
+		}
+
+		cmsg->dst[b] = dma_alloc_coherent(
+					test->mbox_dev,
+					test->src_size, &cmsg->dst_dma[b],
+					GFP_KERNEL);
+		if (!cmsg->dst[b]) {
+			fs4_info(test, "failed to alloc dst buffer\n");
+			__sba_pq_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		fs4_debug(test, "dst[%d]=0x%p dst_dma[%d]=0x%lx\n",
+		b, cmsg->dst[b], b, (unsigned long)cmsg->dst_dma[b]);
+
+		cmsg->dst1[b] = dma_alloc_coherent(
+					test->mbox_dev,
+					test->src_size, &cmsg->dst1_dma[b],
+					GFP_KERNEL);
+		if (!cmsg->dst1[b]) {
+			fs4_info(test, "failed to alloc dst1 buffer\n");
+			__sba_pq_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		fs4_debug(test, "dst1[%d]=0x%p dst1_dma[%d]=0x%lx\n",
+		b, cmsg->dst1[b], b, (unsigned long)cmsg->dst1_dma[b]);
+
+		cmsg->dst_resp[b] = dma_alloc_coherent(
+					test->mbox_dev,
+					SBA_RESP_SIZE * split_count,
+					&cmsg->dst_resp_dma[b], GFP_KERNEL);
+		if (!cmsg->dst_resp[b]) {
+			fs4_info(test, "failed to alloc dst_resp buffer\n");
+			__sba_pq_free(test, cmsg, split_count);
+			return NULL;
+		}
+
+		fs4_debug(test, "dst_resp[%d]=0x%p dst_resp_dma[%d]=0x%lx\n",
+		b, cmsg->dst_resp[b], b, (unsigned long)cmsg->dst_resp_dma[b]);
+
+		src_size = test->src_size;
+		for (s = 0; (s < split_count) && src_size; s++) {
+			cur_split_size = min(src_size, split_size);
+
+			cmds_idx =
+			s * SBA_PQ_SPLIT_CMD_COUNT(test, split_buf_count);
+			cmds_count = __sba_pq_split_cmds(test,
+					   &cmsg->cmds[b][cmds_idx],
+					   s, cur_split_size, split_size,
+					   cmsg->src_dma[b],
+					   cmsg->dst_dma[b],
+					   cmsg->dst1_dma[b],
+					   cmsg->dst_resp_dma[b]);
+
+			cmsg->msg[cmsg->msg_count + s].type =
+						BRCM_MESSAGE_SBA;
+			cmsg->msg[cmsg->msg_count + s].sba.cmds =
+						&cmsg->cmds[b][cmds_idx];
+			cmsg->msg[cmsg->msg_count + s].sba.cmds_count =
+						cmds_count;
+			cmsg->msg[cmsg->msg_count + s].ctx = cmsg;
+			cmsg->msg[cmsg->msg_count + s].error = 0;
+
+			src_size -= cur_split_size;
+		}
+
+		cmsg->msg_count += split_count;
+	}
+
+	b = cmsg->msg_count / test->mchans_count;
+	if ((b * test->mchans_count) < cmsg->msg_count)
+		b++;
+	s = 0;
+	cmsg->bmsg_count = 0;
+	while (s < cmsg->msg_count) {
+		i = min((cmsg->msg_count - s), b);
+		cmsg->bmsg[cmsg->bmsg_count].type = BRCM_MESSAGE_BATCH;
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs = &cmsg->msg[s];
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs_queued = 0;
+		cmsg->bmsg[cmsg->bmsg_count].batch.msgs_count = i;
+		fs4_debug(test, "batch%d msg_idx=%d msg_count=%d\n",
+			  cmsg->bmsg_count, s, i);
+		cmsg->bmsg_count++;
+		s += i;
+	}
+
+	fs4_debug(test, "msgs_count=%d msgs_per_chan=%d batch_msg_count=%d\n",
+		  cmsg->msg_count, b, cmsg->bmsg_count);
+
+	return cmsg;
+}
+
+/* Note: Must be called with test->lock held */
+static bool __sba_pq_verify(struct fs4_test *test,
+			    struct fs4_test_msg *cmsg, unsigned int iter,
+			    u64 ref_out_magic, u64 ref_out1_magic)
+{
+	int b, i, t;
+	bool ret = true;
+
+	for (b = 0; b < test->batch_count; b++) {
+		for (i = 0; i < (test->src_size / 8); i++)
+			if (((u64 *)cmsg->dst[b])[i] != ref_out_magic) {
+				fs4_info(test, "got=0x%lx exp=0x%lx\n",
+				(unsigned long)((u64 *)cmsg->dst[b])[i],
+				(unsigned long)ref_out_magic);
+				ret = false;
+				break;
+			}
+		if (i != (test->src_size / 8)) {
+			i *= 8;
+			fs4_info(test, "iter=%u batch=%u P mismatch at %d\n",
+				 iter, b, i);
+			t = test->src_size - i;
+			if (t >= SBA_PQ_REF_SIZE)
+				t = SBA_PQ_REF_SIZE;
+			print_hex_dump(KERN_INFO, "dst_resp: ",
+					DUMP_PREFIX_ADDRESS,
+					8, 1, cmsg->dst_resp[b],
+					SBA_RESP_SIZE, true);
+			print_hex_dump(KERN_INFO, "dst: ",
+					DUMP_PREFIX_ADDRESS,
+					8, 1, cmsg->dst[b] + i,
+					t, true);
+			break;
+		}
+	}
+	for (b = 0; b < test->batch_count; b++) {
+		for (i = 0; i < (test->src_size / 8); i++)
+			if (((u64 *)cmsg->dst1[b])[i] != ref_out1_magic) {
+				fs4_info(test, "got=0x%lx exp=0x%lx\n",
+				(unsigned long)((u64 *)cmsg->dst1[b])[i],
+				(unsigned long)ref_out1_magic);
+				ret = false;
+				break;
+			}
+		if (i != (test->src_size / 8)) {
+			i *= 8;
+			fs4_info(test, "iter=%u batch=%u Q mismatch at %d\n",
+				 iter, b, i);
+			t = test->src_size - i;
+			if (t >= SBA_PQ_REF_SIZE)
+				t = SBA_PQ_REF_SIZE;
+			print_hex_dump(KERN_INFO, "dst_resp: ",
+					DUMP_PREFIX_ADDRESS,
+					8, 1, cmsg->dst_resp[b],
+					SBA_RESP_SIZE, true);
+			print_hex_dump(KERN_INFO, "dst1: ",
+					DUMP_PREFIX_ADDRESS,
+					8, 1, cmsg->dst1[b] + i,
+					t, true);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+u64 raid6_gf_mul_uint64(int pos, u64 val)
+{
+	u64 ret = 0x0;
+	u8 coef = raid6_gfexp[pos];
+	u8 *valp = (u8 *)&val;
+	u8 *retp = (u8 *)&ret;
+	const u8 *mul_table = raid6_gfmul[coef];
+
+	retp[0] = mul_table[valp[0]];
+	retp[1] = mul_table[valp[1]];
+	retp[2] = mul_table[valp[2]];
+	retp[3] = mul_table[valp[3]];
+	retp[4] = mul_table[valp[4]];
+	retp[5] = mul_table[valp[5]];
+	retp[6] = mul_table[valp[6]];
+	retp[7] = mul_table[valp[7]];
+
+	return ret;
+}
+
+/* Note: Must be called with test->lock held */
+static int __sba_pq_exec(struct fs4_test *test)
+{
+	int rc = 0, i;
+	unsigned long tout;
+	struct mbox_chan *chan;
+	struct fs4_test_msg *cmsg;
+	u64 tmp, ref_out_magic, ref_out1_magic;
+	unsigned long long input_bytes_count;
+	unsigned int cur_split_size, src_size, iter = 0;
+	unsigned int split_count, split_size, split_buf_count;
+	s64 iter_usecs, min_usecs = 0, max_usecs = 0, avg_usecs = 0;
+	unsigned long long iter_KBs, min_KBs = 0, max_KBs = 0, avg_KBs = 0;
+
+	if (test->batch_count > FS4_MAX_BATCH_COUNT) {
+		fs4_info(test, "batch_count should be less than %d\n",
+			 (int)FS4_MAX_BATCH_COUNT);
+		return -EINVAL;
+	}
+	if ((SBA_HW_BUF_SIZE/4) > test->min_split_size) {
+		fs4_info(test, "min_split_size should be greater than %d\n",
+			 (int)(SBA_HW_BUF_SIZE/4 - 1));
+		return -EINVAL;
+	}
+	if (test->min_split_size > 0x10000) {
+		fs4_info(test, "min_split_size can be upto 1MB or less\n");
+		return -EINVAL;
+	}
+	if ((SBA_HW_BUF_SIZE/4) > test->src_size) {
+		fs4_info(test, "src_size should be greater than %d\n",
+			 (int)(SBA_HW_BUF_SIZE/4 - 1));
+		return -EINVAL;
+	}
+	if (test->src_size & (SBA_PQ_REF_SIZE - 1)) {
+		fs4_info(test, "src_size has to be multiple of %d\n",
+			 (int)SBA_PQ_REF_SIZE);
+		return -EINVAL;
+	}
+	if (test->src_count < 2) {
+		fs4_info(test, "src_count cannot be less than 2\n");
+		return -EINVAL;
+	}
+	if (test->update && (test->src_count != 4)) {
+		fs4_info(test, "src_count has to be 4 for update mode\n");
+		return -EINVAL;
+	}
+	if (test->src_count > SBA_PQ_MAX_SRC_COUNT) {
+		fs4_info(test, "src_count cannot be greater than %d\n",
+			 (int)SBA_PQ_MAX_SRC_COUNT);
+		return -EINVAL;
+	}
+	if ((test->src_size * test->src_count) > 0x200000) {
+		fs4_info(test, "memory requirement greater than 2M\n");
+		return -EINVAL;
+	}
+
+	if (test->src_size <= test->min_split_size) {
+		split_size = test->src_size;
+	} else {
+		split_size = test->src_size / test->mchans_count;
+		if (split_size * test->mchans_count < test->src_size)
+			split_size++;
+		if (split_size <= test->min_split_size)
+			split_size = test->min_split_size;
+		if (split_size > test->src_size)
+			split_size = test->src_size;
+	}
+	split_buf_count = split_size / SBA_HW_BUF_SIZE;
+	if ((split_buf_count * SBA_HW_BUF_SIZE) < split_size)
+		split_buf_count++;
+	split_count = 0;
+	src_size = test->src_size;
+	while (src_size) {
+		cur_split_size = min(src_size, split_size);
+		split_count++;
+		src_size -= cur_split_size;
+	}
+
+	fs4_info(test, "split_count=%u split_size=%u split_buf_count=%u\n",
+		 split_count, split_size, split_buf_count);
+
+	cmsg = __sba_pq_alloc(test,
+			split_count, split_size, split_buf_count);
+	if (!cmsg)
+		return -ENOMEM;
+
+	if (test->update) {
+		tmp = *(u64 *)(cmsg->src[0] +
+			       SBA_UPD_PQ_OLD_D * test->src_size);
+		tmp = tmp ^ *(u64 *)(cmsg->src[0] +
+				     SBA_UPD_PQ_NEW_D * test->src_size);
+		ref_out_magic =	*(u64 *)(cmsg->src[0] +
+					 SBA_UPD_PQ_OLD_P * test->src_size);
+		ref_out_magic = ref_out_magic ^ tmp;
+		ref_out1_magic = *(u64 *)(cmsg->src[0] +
+					  SBA_UPD_PQ_OLD_Q * test->src_size);
+		ref_out1_magic = ref_out1_magic ^
+				 raid6_gf_mul_uint64(SBA_UPD_PQ_POS, tmp);
+	} else {
+		ref_out_magic = 0x0;
+		ref_out1_magic = 0x0;
+		for (i = 0; i < test->src_count; i++) {
+			tmp = *(u64 *)(cmsg->src[0] + i * test->src_size);
+			ref_out_magic = ref_out_magic ^ tmp;
+			ref_out1_magic = ref_out1_magic ^
+					 raid6_gf_mul_uint64(i, tmp);
+		}
+	}
+
+	while (iter < test->iterations) {
+		fs4_info(test, "iter=%u started", iter);
+
+		input_bytes_count = test->src_size * test->src_count;
+		input_bytes_count *= test->batch_count;
+		for (i = 0; i < test->batch_count; i++) {
+			if (test->update) {
+				memcpy(cmsg->dst[i],
+				       (cmsg->src[0] +
+					SBA_UPD_PQ_OLD_P * test->src_size),
+				       test->src_size);
+				memcpy(cmsg->dst1[i],
+				       (cmsg->src[0] +
+					SBA_UPD_PQ_OLD_Q * test->src_size),
+				       test->src_size);
+			} else {
+				memset(cmsg->dst[i], 0, test->src_size);
+				memset(cmsg->dst1[i], 0, test->src_size);
+			}
+			memset(cmsg->dst_resp[i], 0,
+				SBA_RESP_SIZE * split_count);
+		}
+
+		cmsg->start_ktime = ktime_get();
+		cmsg->runtime_usecs = 0;
+
+		if (test->software) {
+			for (i = 0; i < test->batch_count; i++)
+				__sba_software_pq(test,
+				cmsg->dst[i], cmsg->dst1[i], cmsg->src[i]);
+			cmsg->runtime_usecs =
+			ktime_us_delta(ktime_get(), cmsg->start_ktime);
+			goto skip_mailbox;
+		}
+
+		atomic_set(&cmsg->done_count, cmsg->msg_count);
+		init_completion(&cmsg->done);
+
+		rc = 0;
+		for (i = 0; i < cmsg->bmsg_count; i++) {
+			chan = test->mchans[test->chan];
+			test->chan++;
+			if (test->chan >= test->mchans_count)
+				test->chan = 0;
+
+			cmsg->bmsg[i].batch.msgs_queued = 0;
+			rc = mbox_send_message(chan, &cmsg->bmsg[i]);
+			if (rc < 0) {
+				fs4_info(test, "iter=%u msg=%d send error %d\n",
+					 iter, i, rc);
+				break;
+			}
+			rc = 0;
+
+			if (cmsg->bmsg[i].error < 0) {
+				rc = cmsg->bmsg[i].error;
+				break;
+			}
+			/* Signal txdone for mailbox channel */
+			mbox_client_txdone(chan, rc);
+		}
+		if (rc < 0)
+			break;
+
+		if (test->poll) {
+			while (atomic_read(&cmsg->done_count) > 0)
+				for (i = 0; i < test->mchans_count; i++)
+					mbox_client_peek_data(test->mchans[i]);
+		} else {
+			tout = (unsigned long)test->timeout * 1000;
+			tout = msecs_to_jiffies(tout);
+			tout = wait_for_completion_timeout(&cmsg->done, tout);
+			if (!tout) {
+				fs4_info(test, "iter=%u wait timeout\n", iter);
+				rc = -ETIMEDOUT;
+				break;
+			}
+		}
+
+		rc = 0;
+		for (i = 0; i < cmsg->msg_count; i++)
+			if (cmsg->msg[i].error < 0) {
+				fs4_info(test, "iter=%u msg=%d rx error\n",
+					 iter, i);
+				rc = cmsg->msg[i].error;
+			}
+		if (rc < 0)
+			break;
+
+skip_mailbox:
+		if (test->verify) {
+			if (!__sba_pq_verify(test, cmsg,
+					iter, ref_out_magic, ref_out1_magic))
+				break;
+		}
+
+		iter_usecs = cmsg->runtime_usecs;
+		iter_KBs =
+		fs4_test_KBs(cmsg->runtime_usecs, input_bytes_count);
+		min_usecs = (iter == 0) ?
+			    iter_usecs : min(min_usecs, iter_usecs);
+		max_usecs = (iter == 0) ?
+			    iter_usecs : max(max_usecs, iter_usecs);
+		avg_usecs += iter_usecs;
+		min_KBs = (iter == 0) ?
+			  iter_KBs : min(min_KBs, iter_KBs);
+		max_KBs = (iter == 0) ?
+			  iter_KBs : max(max_KBs, iter_KBs);
+		avg_KBs += iter_KBs;
+
+		fs4_info(test, "iter=%u usecs=%ld KBs=%llu",
+			 iter, (long)iter_usecs, iter_KBs);
+
+		iter++;
+	}
+
+	__sba_pq_free(test, cmsg, split_count);
+
+	if (iter) {
+		avg_usecs = avg_usecs / iter;
+		avg_KBs = avg_KBs / iter;
+	}
+
+	fs4_info(test, "completed %u/%u iterations\n",
+		 iter, test->iterations);
+	fs4_info(test, "min_usecs=%ld min_KBs=%llu",
+		 (long)min_usecs, min_KBs);
+	fs4_info(test, "max_usecs=%ld max_KBs=%llu",
+		 (long)max_usecs, max_KBs);
+	fs4_info(test, "avg_usecs=%ld avg_KBs=%llu",
+		 (long)avg_usecs, avg_KBs);
+
+	return rc;
+}
+
+#define FS4_TEST_DECLARE_DEV_ATTR_UINT(__name) \
+static ssize_t __name##_show(struct device *dev, \
+			     struct device_attribute *attr, \
+			     char *buf) \
+{ \
+	ssize_t ret; \
+	struct platform_device *pdev = to_platform_device(dev); \
+	struct fs4_test *test = platform_get_drvdata(pdev); \
+\
+	mutex_lock(&test->lock); \
+	ret = sprintf(buf, "%u\n", test->__name); \
+	mutex_unlock(&test->lock); \
+\
+	return ret; \
+} \
+\
+static ssize_t __name##_store(struct device *dev, \
+			      struct device_attribute *attr, \
+			      const char *buf, size_t count) \
+{ \
+	int rc; \
+	unsigned int state; \
+	struct platform_device *pdev = to_platform_device(dev); \
+	struct fs4_test *test = platform_get_drvdata(pdev); \
+\
+	rc = kstrtouint(buf, 0, &state); \
+	if (rc) \
+		return rc; \
+\
+	if (state < 1) \
+		return -EINVAL; \
+\
+	mutex_lock(&test->lock); \
+	test->__name = state; \
+	mutex_unlock(&test->lock); \
+\
+	return strnlen(buf, count); \
+} \
+\
+static DEVICE_ATTR(__name, S_IRUGO | S_IWUSR, \
+		   __name##_show, __name##_store)
+
+FS4_TEST_DECLARE_DEV_ATTR_UINT(batch_count);
+FS4_TEST_DECLARE_DEV_ATTR_UINT(min_split_size);
+FS4_TEST_DECLARE_DEV_ATTR_UINT(src_size);
+FS4_TEST_DECLARE_DEV_ATTR_UINT(src_count);
+FS4_TEST_DECLARE_DEV_ATTR_UINT(iterations);
+FS4_TEST_DECLARE_DEV_ATTR_UINT(timeout);
+FS4_TEST_DECLARE_DEV_ATTR_UINT(secs);
+FS4_TEST_DECLARE_DEV_ATTR_UINT(algo);
+
+static void __fs4_do_test(struct fs4_test *test)
+{
+	int rc;
+
+	if (test->start) {
+		fs4_info(test, "test started\n");
+		fs4_info(test, "iterations=%u secs=%u timeout=%u verify=%u ",
+			 test->iterations, test->secs, test->timeout,
+			 test->verify);
+		fs4_info(test, "verbose=%u poll=%u software=%u\n",
+			 test->verbose, test->poll, test->software);
+		fs4_info(test, "batch_count=%u min_split_size=%u\n",
+			 test->batch_count, test->min_split_size);
+		fs4_info(test, "update=%u src_size=%u src_count=%u\n",
+			 test->update, test->src_size, test->src_count);
+		rc = test->exec_func(test);
+		test->start = 0;
+
+		fs4_info(test, "test finished (error %d)\n", rc);
+	}
+}
+
+#define FS4_TEST_DECLARE_DEV_ATTR_BOOL(__name, __change_func) \
+static ssize_t __name##_show(struct device *dev, \
+			     struct device_attribute *attr, \
+			     char *buf) \
+{ \
+	ssize_t ret; \
+	struct platform_device *pdev = to_platform_device(dev); \
+	struct fs4_test *test = platform_get_drvdata(pdev); \
+\
+	mutex_lock(&test->lock); \
+	ret = sprintf(buf, "%u\n", test->__name); \
+	mutex_unlock(&test->lock); \
+\
+	return ret; \
+} \
+\
+static ssize_t __name##_store(struct device *dev, \
+			      struct device_attribute *attr, \
+			      const char *buf, size_t count) \
+{ \
+	int rc; \
+	unsigned int state; \
+	struct platform_device *pdev = to_platform_device(dev); \
+	struct fs4_test *test = platform_get_drvdata(pdev); \
+	void (*cfunc)(struct fs4_test *) = __change_func; \
+\
+	rc = kstrtouint(buf, 0, &state); \
+	if (rc) \
+		return rc; \
+\
+	if ((state != 0) && (state != 1)) \
+		return -EINVAL; \
+\
+	mutex_lock(&test->lock); \
+	test->__name = state; \
+	if (cfunc) \
+		cfunc(test); \
+	mutex_unlock(&test->lock); \
+\
+	return strnlen(buf, count); \
+} \
+\
+static DEVICE_ATTR(__name, S_IRUGO | S_IWUSR, \
+		   __name##_show, __name##_store)
+
+FS4_TEST_DECLARE_DEV_ATTR_BOOL(update, NULL);
+FS4_TEST_DECLARE_DEV_ATTR_BOOL(verify, NULL);
+FS4_TEST_DECLARE_DEV_ATTR_BOOL(verbose, NULL);
+FS4_TEST_DECLARE_DEV_ATTR_BOOL(poll, NULL);
+FS4_TEST_DECLARE_DEV_ATTR_BOOL(software, NULL);
+FS4_TEST_DECLARE_DEV_ATTR_BOOL(start, __fs4_do_test);
+
+static const struct of_device_id fs4_test_of_match[] = {
+{ .compatible = "brcm,fs4-test-spu2", .data = __spu2_exec, },
+{ .compatible = "brcm,fs4-test-sba-memcpy", .data = __sba_memcpy_exec, },
+{ .compatible = "brcm,fs4-test-sba-xor", .data = __sba_xor_exec, },
+{ .compatible = "brcm,fs4-test-sba-pq", .data = __sba_pq_exec, },
+{},};
+MODULE_DEVICE_TABLE(of, fs4_test_of_match);
+
+static int fs4_test_probe(struct platform_device *pdev)
+{
+	int i, ret = 0;
+	struct of_phandle_args args;
+	const struct of_device_id *of_id;
+	struct platform_device *mbox_pdev;
+	struct resource *iomem;
+	struct fs4_test *test;
+
+	of_id = of_match_node(fs4_test_of_match, pdev->dev.of_node);
+	if (!of_id)
+		return -ENODEV;
+
+	test = devm_kzalloc(&pdev->dev, sizeof(*test), GFP_KERNEL);
+	if (!test)
+		return -ENOMEM;
+
+	test->dev = &pdev->dev;
+
+	test->exec_func = of_id->data;
+
+	platform_set_drvdata(pdev, test);
+
+	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (iomem) {
+		test->regs = devm_ioremap_resource(&pdev->dev, iomem);
+		if (IS_ERR(test->regs)) {
+			ret = PTR_ERR(test->regs);
+			dev_err(&pdev->dev, "Failed to remap regs: %d\n", ret);
+			return ret;
+		}
+		test->engine_count =
+			resource_size(iomem) / FS4_ENGINE_REG_SIZE;
+	} else {
+		test->regs = NULL;
+		test->engine_count = 0;
+	}
+
+	test->client.dev		= &pdev->dev;
+	test->client.rx_callback	= fs4_test_receive_message;
+	test->client.tx_block		= false;
+	test->client.knows_txdone	= false;
+	test->client.tx_tout		= 0;
+
+	ret = device_create_file(&pdev->dev, &dev_attr_batch_count);
+	if (ret < 0)
+		goto fail;
+	ret = device_create_file(&pdev->dev, &dev_attr_min_split_size);
+	if (ret < 0)
+		goto fail_remove_attr_batch_count;
+	ret = device_create_file(&pdev->dev, &dev_attr_src_size);
+	if (ret < 0)
+		goto fail_remove_attr_min_split_size;
+	ret = device_create_file(&pdev->dev, &dev_attr_src_count);
+	if (ret < 0)
+		goto fail_remove_attr_src_size;
+	ret = device_create_file(&pdev->dev, &dev_attr_iterations);
+	if (ret < 0)
+		goto fail_remove_attr_src_count;
+	ret = device_create_file(&pdev->dev, &dev_attr_timeout);
+	if (ret < 0)
+		goto fail_remove_attr_iterations;
+	ret = device_create_file(&pdev->dev, &dev_attr_update);
+	if (ret < 0)
+		goto fail_remove_attr_timeout;
+	ret = device_create_file(&pdev->dev, &dev_attr_verify);
+	if (ret < 0)
+		goto fail_remove_attr_update;
+	ret = device_create_file(&pdev->dev, &dev_attr_verbose);
+	if (ret < 0)
+		goto fail_remove_attr_verify;
+	ret = device_create_file(&pdev->dev, &dev_attr_poll);
+	if (ret < 0)
+		goto fail_remove_attr_verbose;
+	ret = device_create_file(&pdev->dev, &dev_attr_software);
+	if (ret < 0)
+		goto fail_remove_attr_poll;
+	ret = device_create_file(&pdev->dev, &dev_attr_start);
+	if (ret < 0)
+		goto fail_remove_attr_software;
+	ret = device_create_file(&pdev->dev, &dev_attr_secs);
+	if (ret < 0)
+		goto fail_remove_attr_start;
+	ret = device_create_file(&pdev->dev, &dev_attr_algo);
+	if (ret < 0)
+		goto fail_remove_attr_secs;
+
+	ret = of_parse_phandle_with_args(pdev->dev.of_node,
+					"mboxes", "#mbox-cells", 0, &args);
+	if (ret)
+		goto fail_remove_attr_algo;
+
+	mbox_pdev = of_find_device_by_node(args.np);
+	of_node_put(args.np);
+	if (!mbox_pdev) {
+		ret = -ENODEV;
+		goto fail_remove_attr_algo;
+	}
+	test->mbox_dev = &mbox_pdev->dev;
+
+	ret = of_count_phandle_with_args(pdev->dev.of_node,
+					 "mboxes", "#mbox-cells");
+	test->mchans_count = ret;
+	if ((ret <= 0) || (ret > FS4_MAX_CHANNELS)) {
+		ret = -ENODEV;
+		goto fail_remove_attr_algo;
+	}
+
+	for (i = 0; i < test->mchans_count; i++) {
+		test->mchans[i] = mbox_request_channel(&test->client, i);
+		if (!IS_ERR(test->mchans[i]))
+			continue;
+		ret = PTR_ERR(test->mchans[i]);
+		test->mchans[i] = NULL;
+		goto fail_free_channels;
+	}
+
+	mutex_init(&test->lock);
+
+	/* Default values of test parameters */
+	test->chan = 0;
+	test->batch_count = 32;
+	test->min_split_size = 4096;
+	test->src_size = 8192;
+	test->src_count = 3;
+	test->iterations = 50;
+	test->secs = 1;
+	test->algo = 1;
+	test->timeout = 300;
+	test->update = 0;
+	test->verify = 0;
+	test->software = 0;
+	test->verbose = 1;
+	test->poll = 0;
+	test->start = 0;
+
+	fs4_info(test, "fs4 test ready with %d channels",
+		 test->mchans_count);
+
+	return 0;
+
+fail_free_channels:
+	for (i = 0; i < test->mchans_count; i++)
+		if (test->mchans[i]) {
+			mbox_free_channel(test->mchans[i]);
+			test->mchans[i] = NULL;
+		}
+	test->mchans_count = 0;
+fail_remove_attr_algo:
+	device_remove_file(&pdev->dev, &dev_attr_algo);
+fail_remove_attr_secs:
+	device_remove_file(&pdev->dev, &dev_attr_secs);
+fail_remove_attr_start:
+	device_remove_file(&pdev->dev, &dev_attr_start);
+fail_remove_attr_software:
+	device_remove_file(&pdev->dev, &dev_attr_software);
+fail_remove_attr_poll:
+	device_remove_file(&pdev->dev, &dev_attr_poll);
+fail_remove_attr_verbose:
+	device_remove_file(&pdev->dev, &dev_attr_verbose);
+fail_remove_attr_verify:
+	device_remove_file(&pdev->dev, &dev_attr_verify);
+fail_remove_attr_update:
+	device_remove_file(&pdev->dev, &dev_attr_update);
+fail_remove_attr_timeout:
+	device_remove_file(&pdev->dev, &dev_attr_timeout);
+fail_remove_attr_iterations:
+	device_remove_file(&pdev->dev, &dev_attr_iterations);
+fail_remove_attr_src_count:
+	device_remove_file(&pdev->dev, &dev_attr_src_count);
+fail_remove_attr_src_size:
+	device_remove_file(&pdev->dev, &dev_attr_src_size);
+fail_remove_attr_min_split_size:
+	device_remove_file(&pdev->dev, &dev_attr_min_split_size);
+fail_remove_attr_batch_count:
+	device_remove_file(&pdev->dev, &dev_attr_batch_count);
+fail:
+	return ret;
+}
+
+static int fs4_test_remove(struct platform_device *pdev)
+{
+	int i;
+	struct fs4_test *test = platform_get_drvdata(pdev);
+
+	for (i = 0; i < test->mchans_count; i++)
+		if (test->mchans[i]) {
+			mbox_free_channel(test->mchans[i]);
+			test->mchans[i] = NULL;
+		}
+	test->mchans_count = 0;
+
+	device_remove_file(&pdev->dev, &dev_attr_start);
+	device_remove_file(&pdev->dev, &dev_attr_software);
+	device_remove_file(&pdev->dev, &dev_attr_poll);
+	device_remove_file(&pdev->dev, &dev_attr_verbose);
+	device_remove_file(&pdev->dev, &dev_attr_verify);
+	device_remove_file(&pdev->dev, &dev_attr_update);
+	device_remove_file(&pdev->dev, &dev_attr_timeout);
+	device_remove_file(&pdev->dev, &dev_attr_iterations);
+	device_remove_file(&pdev->dev, &dev_attr_src_count);
+	device_remove_file(&pdev->dev, &dev_attr_src_size);
+	device_remove_file(&pdev->dev, &dev_attr_min_split_size);
+	device_remove_file(&pdev->dev, &dev_attr_batch_count);
+
+	return 0;
+}
+
+static struct platform_driver fs4_test_driver = {
+	.driver = {
+		.name = "brcm-fs4-test",
+		.of_match_table = fs4_test_of_match,
+	},
+	.probe		= fs4_test_probe,
+	.remove		= fs4_test_remove,
+};
+module_platform_driver(fs4_test_driver);
+
+MODULE_AUTHOR("Anup Patel <anup.patel@broadcom.com>");
+MODULE_DESCRIPTION("Broadcom FlexSparx4 Test Client");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/mailbox/bcm-iproc-mailbox.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2017 Broadcom.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/mailbox_controller.h>
+#include <linux/bcm_iproc_mailbox.h>
+#include <linux/delay.h>
+
+#define IPROC_CRMU_MAILBOX0_OFFSET       0x0
+#define IPROC_CRMU_MAILBOX1_OFFSET       0x4
+
+#define M0_IPC_CMD_DONE_MASK             0x80000000
+#define M0_IPC_CMD_REPLY_MASK            0x3fff0000
+#define M0_IPC_CMD_REPLY_SHIFT           16
+
+/* Max time the M0 will take to respond to a message. */
+#define MAX_M0_TIMEOUT_MS                2
+
+struct iproc_mbox {
+	struct device         *dev;
+	void __iomem          *base;
+	spinlock_t            lock;
+	struct mbox_controller controller;
+	u32                   num_chans;
+};
+
+static const struct of_device_id iproc_mbox_of_match[] = {
+	{ .compatible = "brcm,iproc-mailbox" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, iproc_mbox_of_match);
+
+/*
+ * Sends a message to M0. The mailbox framework prevents multiple accesses to
+ * the same channel but there is only one h/w "channel". This driver allows
+ * multiple clients to create channels to the controller but must serialize
+ * access to the mailbox registers used to communicate with the M0.
+ */
+static int iproc_mbox_send_data_m0(struct mbox_chan *chan, void *data)
+{
+	struct iproc_mbox *mbox = dev_get_drvdata(chan->mbox->dev);
+	struct iproc_mbox_msg *msg = (struct iproc_mbox_msg *)data;
+		unsigned long flags;
+	int err = 0;
+	const int poll_period_us = 5;
+	const int max_retries = (MAX_M0_TIMEOUT_MS * 1000) / poll_period_us;
+
+	if (!msg)
+		return -EINVAL;
+
+	spin_lock_irqsave(&mbox->lock, flags);
+
+	dev_dbg(mbox->dev, "Send msg to M0: cmd=0x%x, param=0x%x, wait_ack=%d\n",
+		msg->cmd, msg->param, msg->wait_ack);
+
+	writel(msg->cmd, mbox->base + IPROC_CRMU_MAILBOX0_OFFSET);
+	writel(msg->param, mbox->base + IPROC_CRMU_MAILBOX1_OFFSET);
+
+	if (msg->wait_ack) {
+		int retries;
+
+		err = msg->reply_code = -ETIMEDOUT;
+		for (retries = 0; retries < max_retries; retries++) {
+			u32 val = readl(
+				mbox->base + IPROC_CRMU_MAILBOX0_OFFSET);
+			if (val & M0_IPC_CMD_DONE_MASK) {
+				/*
+				 * M0 replied - save reply code and
+				 * clear error.
+				 */
+				msg->reply_code = (val &
+					M0_IPC_CMD_REPLY_MASK) >>
+					M0_IPC_CMD_REPLY_SHIFT;
+				err = 0;
+				break;
+			}
+			udelay(poll_period_us);
+		}
+	}
+
+	spin_unlock_irqrestore(&mbox->lock, flags);
+
+	return err;
+}
+
+static int iproc_mbox_startup(struct mbox_chan *chan)
+{
+	/* Do nothing. */
+	return 0;
+}
+
+static void iproc_mbox_shutdown(struct mbox_chan *chan)
+{
+	/* Do nothing. */
+}
+
+static struct mbox_chan_ops iproc_mbox_ops = {
+	.send_data    = iproc_mbox_send_data_m0,
+	.startup      = iproc_mbox_startup,
+	.shutdown     = iproc_mbox_shutdown,
+};
+
+static int iproc_mbox_probe(struct platform_device *pdev)
+{
+	int err;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct iproc_mbox *iproc_mbox;
+	struct device_node *node;
+	const char *mbox_prop_name = "mboxes";
+	struct mbox_chan *chans;
+
+	dev_info(&pdev->dev, "Initializing iproc mailbox controller\n");
+
+	iproc_mbox = devm_kzalloc(dev, sizeof(*iproc_mbox), GFP_KERNEL);
+	if (!iproc_mbox)
+		return -ENOMEM;
+
+	iproc_mbox->dev = dev;
+	spin_lock_init(&iproc_mbox->lock);
+
+	platform_set_drvdata(pdev, iproc_mbox);
+
+	/* Count number of "mboxes" properties to determine # channels. */
+	for_each_of_allnodes(node) {
+		struct property *prop = of_find_property(
+			node, mbox_prop_name, NULL);
+		if (prop) {
+			struct device_node *mbox_phandle = of_parse_phandle(
+				node, mbox_prop_name, 0);
+			if (mbox_phandle == dev->of_node)
+				iproc_mbox->num_chans++;
+		}
+	}
+
+	if (iproc_mbox->num_chans == 0) {
+		dev_err(dev, "No mailbox clients configured\n");
+		return -ENODEV;
+	}
+
+	chans = devm_kzalloc(&pdev->dev,
+		sizeof(*chans) * iproc_mbox->num_chans, GFP_KERNEL);
+	if (!chans)
+		return -ENOMEM;
+
+	/* Initialize mailbox controller. */
+	iproc_mbox->controller.dev = iproc_mbox->dev;
+	iproc_mbox->controller.num_chans = iproc_mbox->num_chans;
+	iproc_mbox->controller.chans = chans;
+	iproc_mbox->controller.ops = &iproc_mbox_ops;
+	iproc_mbox->controller.txdone_irq = false;
+	iproc_mbox->controller.txdone_poll = false;
+	err = mbox_controller_register(&iproc_mbox->controller);
+	if (err) {
+		dev_err(&pdev->dev, "Register mailbox failed\n");
+		return err;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	iproc_mbox->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(iproc_mbox->base)) {
+		dev_err(&pdev->dev, "unable to map I/O memory\n");
+		return PTR_ERR(iproc_mbox->base);
+	}
+
+	return 0;
+}
+
+static struct platform_driver iproc_mbox_driver = {
+	.driver = {
+		.name = "brcm,iproc-mailbox",
+		.of_match_table = iproc_mbox_of_match,
+	},
+	.probe = iproc_mbox_probe,
+};
+
+static int __init iproc_mbox_init(void)
+{
+	return platform_driver_register(&iproc_mbox_driver);
+}
+arch_initcall(iproc_mbox_init);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("Broadcom iProc Mailbox Driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -518,4 +518,26 @@ source "drivers/misc/mic/Kconfig"
 source "drivers/misc/genwqe/Kconfig"
 source "drivers/misc/echo/Kconfig"
 source "drivers/misc/cxl/Kconfig"
+source "drivers/misc/bcm-iproc-ftm/Kconfig"
+
+config NVME_LPM_SSR
+        bool "NVME LPM data-back support"
+        depends on ARCH_BCM_IPROC || COMPILE_TEST
+        depends on OF_GPIO
+        help
+          This module enables support for udpating SSR struct stored in NVM
+          memory and initiate data-back to nvme once poweloss interrupt gets
+          triggered indicating for data-backup.
+
+          If unsure, say N.
+
+config LPM_SSR_DISABLE_NVME
+        bool "Disable NVMe callbacks from SSR driver"
+        depends on NVME_LPM_SSR
+        default n
+        help
+          Disabling NVMe callbacks from SSR driver helps in, triggerig
+          low power mode and debugging SSR(SPI access) related issues,
+          without involving NVMe.
+
 endmenu
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -56,6 +56,7 @@ obj-$(CONFIG_CXL_BASE)		+= cxl/
 obj-$(CONFIG_ASPEED_LPC_CTRL)	+= aspeed-lpc-ctrl.o
 obj-$(CONFIG_ASPEED_LPC_SNOOP)	+= aspeed-lpc-snoop.o
 obj-$(CONFIG_PCI_ENDPOINT_TEST)	+= pci_endpoint_test.o
+obj-y				+= bcm-iproc-ftm/
 
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_core.o
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_bugs.o
@@ -64,6 +65,7 @@ lkdtm-$(CONFIG_LKDTM)		+= lkdtm_perms.o
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_refcount.o
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_rodata_objcopy.o
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_usercopy.o
+obj-$(CONFIG_NVME_LPM_SSR)	+= nvme-lpm-ssr.o
 
 KCOV_INSTRUMENT_lkdtm_rodata.o	:= n
 
--- /dev/null
+++ b/drivers/misc/bcm-iproc-ftm/Kconfig
@@ -0,0 +1,11 @@
+config IPROC_FLEX_TIMER
+	bool "Flextimer support for IPROC based SoCs"
+	depends on MFD_SYSCON && (ARCH_BCM_IPROC || COMPILE_TEST)
+	default ARCH_BCM_IPROC
+	help
+	  Flextimer is used to timestamp the digitised signal
+	  (converted from analog signal) which is fed as input
+	  to flextimer. The time stamps are decoded to get the
+	  final data.
+
+	  If unsure, say N.
--- /dev/null
+++ b/drivers/misc/bcm-iproc-ftm/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_IPROC_FLEX_TIMER) += bcm_ftm.o
+bcm_ftm-objs := ftm_ts_parser.o
+bcm_ftm-objs += bcm_iproc_ftm.o
--- /dev/null
+++ b/drivers/misc/bcm-iproc-ftm/bcm_iproc_ftm.c
@@ -0,0 +1,363 @@
+/*
+* Copyright (C) 2016 Broadcom
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation version 2.
+*
+* This program is distributed "as is" WITHOUT ANY WARRANTY of any
+* kind, whether express or implied; without even the implied warranty
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/interrupt.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/wait.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/clk.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include "bcm_iproc_ftm.h"
+
+static void iproc_ftm_fifo_clear(struct iproc_ftm *ftm)
+{
+	u32 entries;
+	int i, j;
+	u32 dummy;
+
+	for (i = 0; i < FTM_MAX_CHNL; i++) {
+		regmap_read(ftm->regmap, FTM_STATUS0 + i * 4, &entries);
+		entries &= FTM_STATUS0_ENTRIES_MASK;
+
+		for (j = 0; j < entries; j++)
+			regmap_read(ftm->regmap, FTM_DATA_REG0 + i * 4, &dummy);
+	}
+}
+
+static void iproc_ftm_ena_intr(struct iproc_ftm *ftm, bool enable)
+{
+
+	regmap_write(ftm->regmap, FTM_INTR_STATUS, INTR_MASK);
+
+	if (enable) {
+		iproc_ftm_fifo_clear(ftm);
+
+		/* unmask flex timer interrupts */
+		regmap_write(ftm->regmap, FTM_INTR_MASK, INTR_MASK);
+
+		/* unmask ftm modules interrupt from TSC controller*/
+		regmap_update_bits(ftm->regmap, TSC_INTR_MASK_REG,
+				TSC_FTM_INTR_MASK, TSC_FTM_INTR_MASK);
+	} else {
+		/* mask ftm modules interrupt from TSC controller*/
+		regmap_update_bits(ftm->regmap, TSC_INTR_MASK_REG,
+				TSC_FTM_INTR_MASK, 0);
+
+		/* mask flex timer interrupts */
+		regmap_write(ftm->regmap, FTM_INTR_MASK, 0);
+	}
+}
+
+static void iproc_ftm_ena_timeout(struct iproc_ftm *ftm, bool enable)
+{
+	if (enable)
+		regmap_update_bits(ftm->regmap, FLEX_TIMER_CTRL1,
+						TIMEOUT_EN, TIMEOUT_EN);
+	else
+		regmap_update_bits(ftm->regmap, FLEX_TIMER_CTRL1,
+							TIMEOUT_EN, 0);
+}
+
+static void iproc_ftm_init(struct iproc_ftm *ftm)
+{
+	u32 value;
+
+	/* div 100M/8 = 12.5M */
+	regmap_write(ftm->regmap, CLK_PRESCALE, CLK_PRESCALE_DIVIDER);
+
+	/* both edge & timeout */
+	value = FTM_EDGE_HL | FTM_EDGE_LH;
+	value &= ~CONFIG_TIMEOUT_MASK;
+	value |= TIMEOUT_VALUE << CONFIG_TIMEOUT;
+	regmap_write(ftm->regmap, FLEX_TIMER_CTRL1, value);
+
+	/* water mark set to 32 and enable glitch filter */
+	value = WATERMARK_VALUE |
+		(WATERMARK_VALUE << WATERMARK_CHAN2) |
+		(WATERMARK_VALUE << WATERMARK_CHAN3);
+	regmap_write(ftm->regmap, FTM_CTRL2, value);
+
+		/* enable ftm */
+	regmap_update_bits(ftm->regmap, TSC_REG_CTRL2,
+				TSC_FTM_ENA, TSC_FTM_ENA);
+
+	iproc_ftm_ena_timeout(ftm, true);
+}
+
+static irqreturn_t iproc_ftm_isr(int irq, void *drv_ctx)
+{
+	int i, ret;
+	u32 status;
+	u32 entries;
+	u32 v;
+	struct ftm_chnl_desc *ch;
+	struct iproc_ftm *ftm = drv_ctx;
+
+	regmap_read(ftm->regmap, FTM_INTR_STATUS, &status);
+	regmap_write(ftm->regmap, FTM_INTR_STATUS, status);
+
+	if ((status & INTR_MASK) == 0)
+		return IRQ_NONE;
+
+	if (status & INTR_SOS)
+		ftm->sosc += 1;
+
+	if (status & INTR_TIMEOUT)
+		ftm->timeoutc += 1;
+
+	for (i = 0; i < FTM_MAX_CHNL; i++) {
+		ch = &ftm->ch[i];
+		regmap_read(ftm->regmap, FTM_STATUS0 + i * 4, &entries);
+		entries &= FTM_STATUS0_ENTRIES_MASK;
+		dev_dbg(ftm->dev, "Avail data word entries:%X\n", entries);
+
+		if (ch->ts_cnt >= MAX_TS_ENTRIES) {
+			dev_err(ftm->dev, "Dumped %d ts for ch :%d\n",
+							ch->ts_cnt, i);
+			print_hex_dump(KERN_ERR, "ftm ts:", DUMP_PREFIX_NONE,
+				16, 2, ch->ts_buf, ch->ts_cnt * 2, false);
+			memset(ch->ts_buf, 0, MAX_TS_BUFF_SIZE);
+			ch->ts_cnt = 0;
+		}
+
+		while (entries-- && (ch->ts_cnt < MAX_TS_ENTRIES)) {
+			regmap_read(ftm->regmap, FTM_DATA_REG0 + i * 4, &v);
+			ch->ts_buf[ch->ts_cnt] = (u16)v;
+			ch->ts_cnt++;
+		}
+
+		if ((ftm->sosc == ftm->timeoutc) && ch->ts_cnt) {
+			/* decode ts for track data */
+			ret = ftm_decode(ch->ts_buf, ch->ts_cnt, i,
+						ch->track_data, &ch->data_cnt);
+			if (ret) {
+				dev_err(ftm->dev, "TS decoding failed\n");
+			} else {
+				ch->drdy = true;
+				wake_up_interruptible(&ch->wq);
+			}
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static int iproc_ftm_open(struct inode *inode, struct file *filp)
+{
+	struct iproc_ftm *ftm = container_of(inode->i_cdev,
+		struct iproc_ftm, cdev);
+	int minor = iminor(inode);
+
+	dev_dbg(ftm->dev, "%s: minor: %d\n", __func__, minor);
+
+	mutex_lock(&ftm->ulock);
+	if (!(ftm->users & FTM_USER_MASK(minor))) {
+		ftm->users |= FTM_USER_MASK(minor);
+	} else {
+		dev_info(ftm->dev, "ftm%d is already opened\n", minor);
+		mutex_unlock(&ftm->ulock);
+		return -EBUSY;
+	}
+	filp->private_data = ftm;
+	mutex_unlock(&ftm->ulock);
+
+	return 0;
+}
+
+static int iproc_ftm_release(struct inode *inode, struct file *filp)
+{
+	struct iproc_ftm *ftm = filp->private_data;
+	int minor = iminor(inode);
+
+	dev_dbg(ftm->dev, "%s: minor: %d\n", __func__, minor);
+
+	mutex_lock(&ftm->ulock);
+	ftm->users &= ~(FTM_USER_MASK(minor));
+	mutex_unlock(&ftm->ulock);
+
+	return 0;
+}
+
+static ssize_t iproc_ftm_read(struct file *filp, char __user *buf,
+					size_t count, loff_t *offp)
+{
+	int minor;
+	int ret = 0;
+	struct iproc_ftm *ftm = filp->private_data;
+
+	minor = iminor(filp->f_path.dentry->d_inode);
+
+	if (wait_event_interruptible(ftm->ch[minor].wq,
+					ftm->ch[minor].drdy != true))
+		return -EFAULT;
+
+	if (copy_to_user(buf, ftm->ch[minor].track_data,
+					ftm->ch[minor].data_cnt))
+		return -EFAULT;
+
+	dev_dbg(ftm->dev, "copied bytes: %d\n", ftm->ch[minor].data_cnt);
+
+	ret = ftm->ch[minor].data_cnt;
+
+	ftm->ch[minor].data_cnt = 0;
+	ftm->ch[minor].drdy = false;
+
+	return ret;
+}
+
+static const struct file_operations iproc_ftm_cdev_fops = {
+	.open = iproc_ftm_open,
+	.release = iproc_ftm_release,
+	.read = iproc_ftm_read,
+};
+
+static int iproc_ftm_probe(struct platform_device *pdev)
+{
+	struct iproc_ftm *ftm;
+	int ret = 0;
+	int i = 0;
+	struct ftm_chnl_desc *ch;
+	struct device *dev = &pdev->dev;
+
+	ftm = devm_kzalloc(dev, sizeof(*ftm), GFP_KERNEL);
+	if (ftm == NULL)
+		return -ENOMEM;
+
+	mutex_init(&ftm->ulock);
+	ftm->dev = dev;
+	platform_set_drvdata(pdev, ftm);
+
+	/* obtain regmap handle */
+	ftm->regmap = syscon_regmap_lookup_by_phandle(dev->of_node,
+						"flextimer_syscon");
+	if (IS_ERR(ftm->regmap)) {
+		dev_err(dev, "failed to get handle for tsc syscon\n");
+		return PTR_ERR(ftm->regmap);
+	}
+
+	ftm->irq = platform_get_irq(pdev, 0);
+	if (ftm->irq < 0) {
+		dev_err(dev, "Failed to parse interrupt\n");
+		ret = -ENODEV;
+	}
+
+	iproc_ftm_ena_intr(ftm, false);
+	/* init irq */
+	ret = devm_request_irq(dev, ftm->irq, iproc_ftm_isr, IRQF_SHARED,
+							pdev->name, ftm);
+	if (ret) {
+		dev_err(dev, "Failed to register interrupt\n");
+		return ret;
+	}
+
+	ftm->ftm_clk = devm_clk_get(dev, "ftm_clk");
+	if (IS_ERR(ftm->ftm_clk)) {
+		dev_err(dev, "%s Failed getting clock ftm_clk\n", __func__);
+		return PTR_ERR(ftm->ftm_clk);
+	}
+
+	/* alloc ts buff space */
+	for (i = 0; i < FTM_MAX_CHNL; i++) {
+		ch = &ftm->ch[i];
+		ch->ts_buf = devm_kzalloc(dev, MAX_TS_BUFF_SIZE, GFP_KERNEL);
+		if (ch->ts_buf == NULL)
+			return -ENOMEM;
+
+		ch->track_data = devm_kzalloc(dev, MAX_TRACK_DATA_SIZE,
+								GFP_KERNEL);
+		if (ch->track_data == NULL)
+			return -ENOMEM;
+
+		init_waitqueue_head(&ch->wq);
+	}
+
+	/* create device */
+	ret = alloc_chrdev_region(&ftm->devno, 0, FTM_MAX_CHNL, "ft");
+	if (ret) {
+		dev_err(dev, "failed to alloc chardev region\n");
+		return ret;
+	}
+	cdev_init(&ftm->cdev, &iproc_ftm_cdev_fops);
+	ret = cdev_add(&ftm->cdev, ftm->devno, FTM_MAX_CHNL);
+	if (ret) {
+		dev_err(dev, "Failed adding ft cdev file\n");
+		goto free_char_region;
+	}
+
+	/* create class for mdev auto create node /dev/ftm */
+	ftm->class = class_create(THIS_MODULE, "ftm");
+	if (IS_ERR(ftm->class)) {
+		dev_err(dev, "Failed creating class\n");
+		ret = PTR_ERR(ftm->class);
+		goto del_cdev;
+	}
+	for (i = 0; i < FTM_MAX_CHNL; i++)
+		device_create(ftm->class, dev,
+			MKDEV(MAJOR(ftm->devno), i), ftm, "ftm%d", i);
+
+	ret = clk_prepare_enable(ftm->ftm_clk);
+	if (ret) {
+		dev_err(dev, "clk_prepare_enable failed %d\n", ret);
+		goto rm_class;
+	}
+
+	/* hw init */
+	iproc_ftm_init(ftm);
+	iproc_ftm_ena_intr(ftm, true);
+
+	dev_info(dev, "ftm probe done successfully\n");
+	return ret;
+
+rm_class:
+	for (i = 0; i < FTM_MAX_CHNL; i++)
+		device_destroy(ftm->class, MKDEV(MAJOR(ftm->devno), i));
+
+	class_destroy(ftm->class);
+
+del_cdev:
+	cdev_del(&ftm->cdev);
+free_char_region:
+	unregister_chrdev_region(ftm->devno, FTM_MAX_CHNL);
+	return ret;
+}
+
+static const struct of_device_id iproc_ftm_of_match[] = {
+	{.compatible = "brcm,iproc-ftm", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, iproc_ftm_of_match);
+
+static struct platform_driver brcm_iproc_ftm_drv = {
+	.driver = {
+		.name = "brcmftm",
+		.of_match_table = iproc_ftm_of_match,
+	},
+	.probe	= iproc_ftm_probe,
+};
+module_platform_driver(brcm_iproc_ftm_drv);
+
+MODULE_DESCRIPTION("Broadcom Flextimer HW driver");
+MODULE_AUTHOR("Broadcom");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/misc/bcm-iproc-ftm/bcm_iproc_ftm.h
@@ -0,0 +1,85 @@
+/*
+* Copyright (C) 2016 Broadcom
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation version 2.
+*
+* This program is distributed "as is" WITHOUT ANY WARRANTY of any
+* kind, whether express or implied; without even the implied warranty
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*/
+
+#ifndef __BCM_IPROC_FTM_H__
+#define __BCM_IPROC_FTM_H__
+
+#define CLK_PRESCALE 0xC00
+#define FLEX_TIMER_CTRL1 0xC0C
+#define FTM_CTRL2 0xC10
+#define FTM_INTR_STATUS 0xC04
+#define FTM_INTR_MASK 0xC08
+#define FTM_DATA_REG0 0xC20
+#define FTM_STATUS0 0xC14
+
+#define CONFIG_TIMEOUT 12
+#define CONFIG_TIMEOUT_MASK (0xFFFFF << CONFIG_TIMEOUT)
+#define WATERMARK_CHAN2 8
+#define WATERMARK_CHAN3 16
+#define TIMEOUT_EN BIT(11)
+#define FTM_EDGE_LH (7 << 0)
+#define FTM_EDGE_HL (7 << 4)
+
+#define INTR_SOS BIT(18)
+#define INTR_TIMEOUT BIT(17)
+#define INTR_WATERMARK 8
+#define INTR_FIFO_FULL 11
+
+/* TSC register controlling FTM*/
+#define TSC_REG_CTRL2 0x4
+#define TSC_FTM_ENA BIT(17)
+
+#define TSC_INTR_MASK_REG 0x00c
+#define TSC_FTM_INTR_MASK BIT(8)
+
+#define FTM_MAX_CHNL 3
+#define MAX_TS_ENTRIES 1024
+#define MAX_TS_BUFF_SIZE (2 * MAX_TS_ENTRIES)
+#define MAX_TRACK_DATA_SIZE 128
+
+#define TIMEOUT_VALUE 0xFFFF
+#define WATERMARK_VALUE 32
+#define INTR_MASK	((7 << INTR_WATERMARK) |\
+			 (7 << INTR_FIFO_FULL) | \
+			 INTR_SOS | INTR_TIMEOUT)
+
+#define CLK_PRESCALE_DIVIDER 0x08
+#define FTM_STATUS0_ENTRIES_MASK 0xff
+#define FTM_USER_MASK(minor) (1 << minor)
+
+struct ftm_chnl_desc {
+	u16 *ts_buf;  /* buffer to hold time stamp values*/
+	u32 ts_cnt; /* ts counter */
+	u8 *track_data; /* decoded magnetic stripe track data */
+	u32 data_cnt; /* decoded data char cnt */
+	bool drdy; /* flag to indicate data ready to user*/
+	wait_queue_head_t wq;
+};
+
+struct iproc_ftm {
+	struct device *dev;
+	struct cdev cdev;
+	struct class *class;
+	u32 users;
+	int irq;
+	dev_t devno;
+	int timeoutc;
+	int sosc;
+	struct regmap *regmap;
+	struct mutex ulock; /* user lock */
+	struct clk *ftm_clk;
+	struct ftm_chnl_desc ch[FTM_MAX_CHNL];
+};
+
+extern int ftm_decode(u16 *p, u32 size, int chan, u8 *out, u32 *outlen);
+#endif
--- /dev/null
+++ b/drivers/misc/bcm-iproc-ftm/ftm_ts_parser.c
@@ -0,0 +1,202 @@
+/*
+* Copyright (C) 2016 Broadcom
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation version 2.
+*
+* This program is distributed "as is" WITHOUT ANY WARRANTY of any
+* kind, whether express or implied; without even the implied warranty
+* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*/
+
+#include <linux/module.h>
+#include <linux/printk.h>
+
+static const unsigned char track23cset[32] = {
+0x00,  '1',  '2',  0x00,  '4',  0x00,  0x00,  '7',
+'8',  0x00,  0x00,  ';',  0x00,  '=',  '>',  0x00,
+'0',  0x00,  0x00,  '3',  0x00,  '5',  '6',  0x00,
+0x00,  '9',  ':',  0x00,  '<',  0x00,  0x00,  '?',
+};
+
+static const unsigned char track1cset[128] = {
+0x00,  '!',  '"',  0x00,  '$',  0x00,  0x00,  '\'',
+'(',  0x00,  0x00,  '+',  0x00,  '-',  '.',  0x00,
+'0',  0x00,  0x00,  '3',  0x00,  '5',  '6',  0x00,
+0x00,  '9',  ':',  0x00,  '<',  0x00,  0x00,  '?',
+'@',  0x00,  0x00,  'C',  0x00,  'E',  'F',  0x00,
+0x00,  'I',  'J',  0x00,  'L',  0x00,  0x00,  'O',
+0x00,  'Q',  'R',  0x00,  'T',  0x00,  0x00,  'W',
+'X',  0x00,  0x00,  '[',  0x00,  ']',  '^',  0x00,
+' ',  0x00,  0x00,  '#',  0x00,  '%',  '&',  0x00,
+0x00,  ')',  '*',  0x00,  ',',  0x00,  0x00,  '/',
+0x00,  '1',  '2',  0x00,  '4',  0x00,  0x00,  '7',
+'8',  0x00,  0x00,  ';',  0x00,  '=',  '>',  0x00,
+0x00,  'A',  'B',  0x00,  'D',  0x00,  0x00,  'G',
+'H',  0x00,  0x00,  'K',  0x00,  'M',  'N',  0x00,
+'P',  0x00,  0x00,  'S',  0x00,  'U',  'V',  0x00,
+'X',   'Y',  'Z',  0x00,  '\\',  0x00,  0x00,  '-',
+};
+
+static int ftm_convert_bs(unsigned short *p, int len)
+{
+	int bitlen = p[0];
+	bool skip = false;
+	int i, j = 0;
+
+	for (i = 0; i < len - 1; i++) {
+		if (skip) {
+			skip = false;
+			continue;
+		}
+		if ((p[i] < (bitlen * 70 / 100))
+				&& (p[i + 1] < (bitlen * 70 / 100))
+				&& ((p[i] + p[i + 1]) < (bitlen * 140 / 100))
+		   ) {
+			bitlen = bitlen * 80 / 100 +
+				(p[i] + p[i + 1]) * 20 / 100;
+			p[j++] = 1;
+			skip = true;
+		} else {
+			if (p[i] < bitlen * 80 / 100)
+				p[i + 1] -= (bitlen - p[i]) * 80 / 100;
+
+			bitlen = bitlen * 80 / 100 + p[i] * 20 / 100;
+			p[j++] = 0;
+		}
+	}
+	return j;
+}
+
+static void ftm_convert_ts(unsigned short *p, int len)
+{
+	int i;
+
+	for (i = 0; i < len - 1; i++) {
+		if (p[i + 1] > p[i])
+			p[i] = p[i + 1] - p[i];
+		else
+			p[i] = 0xffff + p[i + 1] - p[i];
+	}
+}
+
+static int ftm_convert_char(unsigned short *p, int len, int ch,
+		unsigned char *out)
+{
+	int i = 0, j = 0;
+	int start = 0;
+	unsigned char *pout = (unsigned char *)out;
+	unsigned char c;
+
+	while (i < len) {
+		if (p[i]) {
+			start = i;
+			break;
+		}
+		i++;
+	}
+
+	if (ch == 0) {
+		for (i = start; i < len - 7; i += 7) {
+			c = (p[i + 6] << 6) + (p[i + 5] << 5) +
+				(p[i + 4] << 4) + (p[i + 3] << 3) +
+				(p[i + 2] << 2) + (p[i + 1] << 1) + (p[i]);
+
+			c &= 0x7f;
+
+			if (track1cset[c]) {
+				pout[j] = track1cset[c];
+				p[j++] = c;
+			}
+		}
+	} else {
+		for (i = start; i < len - 5; i += 5) {
+			c = (p[i + 4] << 4) + (p[i + 3] << 3) +
+				(p[i + 2] << 2) + (p[i + 1] << 1) + (p[i]);
+			c &= 0x1f;
+
+			if (track23cset[c]) {
+				pout[j] = track23cset[c];
+				p[j++] = c;
+			}
+		}
+	}
+	pout[j-1] = 0;
+
+	return j-1;
+}
+
+static int ftm_check_lrc(unsigned short *p, int size, int ch)
+{
+	unsigned char startb;
+	unsigned char endb;
+	unsigned char lrc_p = 0;
+	unsigned char lrc = 0;
+	int bits;
+	int i, j;
+
+	if (ch == 0) {
+		startb = 0x45;
+		endb = 0x1f;
+		bits = 6;
+	} else {
+		startb = 0xb;
+		endb = 0x1f;
+		bits = 4;
+	}
+
+	if (p[0] != startb) {
+		pr_err("Failed to get begin mark 0x45/0xb, 0x%2x\n", p[0]);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < (size - 1); i++) {
+		lrc = lrc ^ p[i];
+		if (p[i] == endb)
+			break;
+	}
+
+	if (p[i] != endb) {
+		pr_err("Failed to get end mark 0x1f(?)\n");
+		return -EINVAL;
+	}
+
+	if (i == (size - 1)) {
+		pr_err("lrc not found\n");
+		return -EINVAL;
+	}
+
+	lrc_p = 0;
+	for (j = 0; j < bits; j++)
+		lrc_p ^= (lrc & (1 << j)) >> j;
+
+	lrc_p ^= 1;
+
+	lrc &= (1 << bits) - 1;
+	lrc = lrc | (lrc_p << bits);
+
+	if (p[i + 1] != lrc) {
+		pr_err("lrc not match %x\n", p[i + 1]);
+		pr_err("calculated: 0x%x, P: 0x%x\n", lrc, lrc_p);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int ftm_decode(unsigned short *p, unsigned int size, int chan,
+				unsigned char *out, unsigned int *outlen)
+{
+	int len;
+	int checkr;
+
+	ftm_convert_ts(p, size);
+	len = ftm_convert_bs(p, size - 1);
+	len = ftm_convert_char(p, len, chan, out);
+	checkr =  ftm_check_lrc(p, len, chan);
+	out[len] = 0;
+	*outlen = len;
+
+	return checkr;
+}
--- /dev/null
+++ b/drivers/misc/nvme-lpm-ssr.c
@@ -0,0 +1,541 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright(c) 2018 Broadcom
+ */
+#include <asm/barrier.h>
+#include <asm/spinlock.h>
+#include <linux/bcm_iproc_mailbox.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/gpio/consumer.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/mailbox_client.h>
+#include <linux/module.h>
+#include <linux/nvme-lpm-ssr.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/reboot.h>
+#include <linux/smp.h>
+#include <linux/uaccess.h>
+#include <uapi/asm-generic/errno.h>
+
+/*
+ * Pass SSR command to CRMU
+ * Populate SSR Structure in shared memory which would be flashed to
+ * NVM memory via CRMU
+ * Response - none
+ */
+#define M0_IPC_M0_CMD_SSR_MSG 0x82
+
+struct nvme_lpm {
+	struct device *dev;
+	struct mbox_client client;
+	struct mbox_chan *mbox_chan;
+	void *shared_mem;
+	spinlock_t shmlock;
+	void *shared_nvme_data;
+	struct gpio_desc *gpiod;
+	int irq;
+	struct class *class;
+	struct cdev cdev;
+	struct device *class_dev;
+	dev_t devt;
+	unsigned int ssr_state_armed;
+};
+
+static struct nvme_lpm_drv_ops *nvme_drv_ops;
+
+static int iproc_mbox_send_msg(struct nvme_lpm *nvme_lpm,
+				struct ssr_wrapper *lwrap)
+{
+	int ret, i;
+	struct iproc_mbox_msg msg;
+	struct ssr_wrapper *wrap = nvme_lpm->shared_mem;
+
+	spin_lock(&nvme_lpm->shmlock);
+	memcpy(wrap, lwrap, sizeof(*lwrap));
+	msg.cmd = M0_IPC_M0_CMD_SSR_MSG;
+	msg.param = 0;
+	msg.wait_ack = false;
+
+	wrap->crmu_maia_valid_response = 0x0;
+	wrap->maia_crmu_valid_request = MAIA_CRMU_VALID_REQUEST;
+	dsb(sy);
+	ret = mbox_send_message(nvme_lpm->mbox_chan, &msg);
+	if (ret < 0) {
+		dev_err(nvme_lpm->dev, "Failed to send mbox msg ret:%d\n", ret);
+		goto fail;
+	}
+	ret = 0;
+
+	mbox_client_txdone(nvme_lpm->mbox_chan, 0);
+
+	/* Wait for completion */
+	for (i = 0; i < MAX_CRMU_RESPONSE_TIMEOUT; i++)
+		if (wrap->ssr_cmd_id != 0)
+			udelay(100);
+		else
+			break;
+
+	if (i == MAX_CRMU_RESPONSE_TIMEOUT) {
+		dev_err(nvme_lpm->dev, "CRMU response timed out\n");
+		ret = -ETIMEDOUT;
+		goto fail;
+	}
+
+	if (wrap->crmu_maia_valid_response != CRMU_MAIA_VALID_RESPONSE) {
+		ret = -ENODATA;
+		goto fail;
+	}
+
+	/*
+	 * Data needs to be written back from shared memory to local SSR
+	 * in GET_SSR case
+	 */
+	if (lwrap->ssr_cmd_id == NVME_LPM_CMD_GET_SSR)
+		memcpy(&lwrap->ssr, &wrap->ssr, SSR_SIZE);
+
+fail:
+	spin_unlock(&nvme_lpm->shmlock);
+	return ret;
+}
+
+static int nvme_lpm_get_ssr(struct nvme_lpm *nvme_lpm, void __user *argp)
+{
+	int ret = 0;
+	struct ssr_wrapper wrap = {0,};
+
+	/* send msg to CRMU */
+	wrap.ssr_cmd_id = NVME_LPM_CMD_GET_SSR;
+	ret = iproc_mbox_send_msg(nvme_lpm, &wrap);
+	if (ret)
+		goto fail;
+
+	/* copy SSR */
+	if (copy_to_user(argp, &wrap.ssr, SSR_SIZE)) {
+		dev_err(nvme_lpm->dev, "Failed to copy to user space\n");
+		ret = -EFAULT;
+	}
+fail:
+	return ret;
+}
+
+static int nvme_lpm_erase_ssr(struct nvme_lpm *nvme_lpm, void __user *argp)
+{
+	struct ssr_wrapper wrap = {0,};
+
+	wrap.ssr_cmd_id = NVME_LPM_CMD_ERASE_SSR;
+	wrap.ssr.state = SSR_STATE_INIT;
+
+	/* send msg to CRMU */
+	return iproc_mbox_send_msg(nvme_lpm, &wrap);
+}
+
+static int nvme_lpm_arm_ssr(struct nvme_lpm *nvme_lpm, void __user *argp)
+{
+	struct ssr_wrapper wrap = {0,};
+	struct armed_ssr armed_ssr;
+	int ret = -EINVAL;
+
+#ifndef CONFIG_LPM_SSR_DISABLE_NVME
+	if (!nvme_drv_ops)
+		goto out;
+
+	ret = nvme_drv_ops->nvme_destroy_backup_io_queues(nvme_drv_ops->ctxt);
+	if (ret) {
+		dev_err(nvme_lpm->dev, "Failed to prepare nvme for backup\n");
+		goto out;
+	}
+#endif
+
+	if (copy_from_user(&armed_ssr, argp, sizeof(struct armed_ssr))) {
+		dev_err(nvme_lpm->dev, "Failed to copy armed ssr from user\n");
+		ret = -EFAULT;
+		goto out;
+	}
+
+#ifndef CONFIG_LPM_SSR_DISABLE_NVME
+	ret = nvme_drv_ops->nvme_build_backup_io_queues(nvme_drv_ops->ctxt,
+						    armed_ssr.memory_address,
+						    armed_ssr.disk_address,
+						    armed_ssr.length, true,
+						    nvme_lpm->shared_nvme_data);
+
+	if (ret) {
+		dev_err(nvme_lpm->dev, "Failed to build backup io queues\n");
+		goto out;
+	}
+#endif
+	wrap.ssr_cmd_id = NVME_LPM_CMD_ARM_SSR;
+	wrap.ssr.state = SSR_STATE_ARM;
+	wrap.ssr.sequence = armed_ssr.sequence;
+
+	/* send msg to CRMU */
+	ret = iproc_mbox_send_msg(nvme_lpm, &wrap);
+	if (ret)
+		nvme_lpm->ssr_state_armed = false;
+	else
+		nvme_lpm->ssr_state_armed = true;
+
+out:
+	return ret;
+}
+
+static int nvme_lpm_disarm_cmd(struct nvme_lpm *nvme_lpm, void __user *argp)
+{
+	struct ssr_wrapper wrap = {0,};
+	struct disarmed_ssr disarmed_ssr;
+	int ret = -EINVAL;
+
+#ifndef CONFIG_LPM_SSR_DISABLE_NVME
+	if (!nvme_drv_ops)
+		goto out;
+
+	ret = nvme_drv_ops->nvme_destroy_backup_io_queues(nvme_drv_ops->ctxt);
+	if (ret) {
+		dev_err(nvme_lpm->dev, "Failed to destroy nvme io queues\n");
+		goto out;
+	}
+#endif
+
+	ret = copy_from_user(&disarmed_ssr, argp, sizeof(struct disarmed_ssr));
+	if (ret) {
+		dev_err(nvme_lpm->dev, "Failed to copy disarmed info\n");
+		goto out;
+	}
+	wrap.ssr_cmd_id = NVME_LPM_CMD_DISARM_SSR;
+	wrap.ssr.state = SSR_STATE_DISARM;
+	wrap.ssr.sequence = disarmed_ssr.sequence;
+
+	/* send msg to CRMU */
+	ret = iproc_mbox_send_msg(nvme_lpm, &wrap);
+out:
+	return ret;
+}
+
+static int nvme_lpm_trigger_ssr(struct nvme_lpm *nvme_lpm)
+{
+	console_silent();
+
+#ifndef CONFIG_LPM_SSR_DISABLE_NVME
+	if (nvme_lpm->ssr_state_armed == true) {
+		if (nvme_drv_ops)
+			nvme_drv_ops->nvme_initiate_xfers(nvme_drv_ops->ctxt);
+	}
+	else
+		machine_halt();
+#endif
+
+	smp_send_stop();
+	set_cpu_online(smp_processor_id(), false);
+	cpu_die();
+
+	return 0;
+}
+
+#ifndef CONFIG_LPM_SSR_DISABLE_NVME
+static int nvme_lpm_read_test(struct nvme_lpm *nvme_lpm, void __user *argp)
+{
+	struct armed_ssr armed_ssr;
+	int ret = -EINVAL;
+
+	if (!nvme_drv_ops)
+		goto out;
+
+	ret = nvme_drv_ops->nvme_destroy_backup_io_queues(nvme_drv_ops->ctxt);
+	if (ret) {
+		dev_err(nvme_lpm->dev, "Failed to prepare nvme for backup\n");
+		goto out;
+	}
+
+	if (copy_from_user(&armed_ssr, argp, sizeof(struct armed_ssr))) {
+		dev_err(nvme_lpm->dev, "Failed to copy armed ssr from user\n");
+		ret = -EFAULT;
+		goto out;
+	}
+
+	/*
+	 * Read back case is for testing purpose only, SSR does not get
+	 * accessed for this case
+	 */
+	ret = nvme_drv_ops->nvme_build_backup_io_queues(nvme_drv_ops->ctxt,
+						    armed_ssr.memory_address,
+						    armed_ssr.disk_address,
+						    armed_ssr.length, false,
+						    nvme_lpm->shared_nvme_data);
+
+	if (ret)
+		dev_err(nvme_lpm->dev, "Failed to build read-back io queues\n");
+
+out:
+	return ret;
+}
+
+static int nvme_lpm_poll_xfers_from_ap(struct nvme_lpm *nvme_lpm)
+{
+	int ret = -EINVAL;
+
+	if (!nvme_drv_ops)
+		goto out;
+
+	/* initiate transfers */
+	nvme_drv_ops->nvme_initiate_xfers(nvme_drv_ops->ctxt);
+
+	ret = nvme_drv_ops->nvme_poll_xfers(nvme_drv_ops->ctxt);
+	if (ret) {
+		dev_err(nvme_lpm->dev, "Transfer not completed");
+		goto out;
+	}
+	dev_err(nvme_lpm->dev, "Transfer done");
+
+	ret = nvme_drv_ops->nvme_send_flush_cmd(nvme_drv_ops->ctxt);
+	if (ret)
+		dev_err(nvme_lpm->dev, "Flush not completed");
+	else
+		dev_info(nvme_lpm->dev, "Flush done");
+
+out:
+	return ret;
+}
+#endif
+
+/* IOCTL interface through character device */
+static int nvme_dev_open(struct inode *inode, struct file *file)
+{
+	file->private_data = container_of(inode->i_cdev,
+					  struct nvme_lpm, cdev);
+
+	return 0;
+}
+
+static long nvme_dev_ioctl(struct file *file, unsigned int cmd,
+			   unsigned long arg)
+{
+	struct nvme_lpm *nvme_lpm = file->private_data;
+	void __user *argp = (void __user *)arg;
+	int ret = -1;
+
+	switch (cmd) {
+	case NVME_LPM_IOCTL_GET_SSR:
+		ret = nvme_lpm_get_ssr(nvme_lpm, argp);
+		break;
+	case NVME_LPM_IOCTL_ERASE_SSR:
+		ret = nvme_lpm_erase_ssr(nvme_lpm, argp);
+		break;
+	case NVME_LPM_IOCTL_ARM_SSR:
+		ret = nvme_lpm_arm_ssr(nvme_lpm, argp);
+		break;
+	case NVME_LPM_IOCTL_DISARM_SSR:
+		ret = nvme_lpm_disarm_cmd(nvme_lpm, argp);
+		break;
+	case NVME_LPM_IOCTL_TRIGGER_SSR:
+		ret = nvme_lpm_trigger_ssr(nvme_lpm);
+		break;
+#ifndef CONFIG_LPM_SSR_DISABLE_NVME
+	case NVME_LPM_IOCTL_READ:
+		ret = nvme_lpm_read_test(nvme_lpm, argp);
+		break;
+	case NVME_LPM_IOCTL_AP_POLL:
+		ret = nvme_lpm_poll_xfers_from_ap(nvme_lpm);
+		break;
+#endif
+	default:
+		return -ENOENT;
+	}
+	return ret;
+}
+
+static irqreturn_t iproc_gpio_isr(int irq, void *drv_ctx)
+{
+	struct nvme_lpm *nvme_lpm = (struct nvme_lpm *)drv_ctx;
+
+	nvme_lpm_trigger_ssr(nvme_lpm);
+
+	return IRQ_HANDLED;
+}
+
+int register_nvme_lpm_ops(void *nvme_lpm_drv_ops)
+{
+	int ret = -EINVAL;
+
+	if (!nvme_drv_ops) {
+		nvme_drv_ops = nvme_lpm_drv_ops;
+		ret = 0;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(register_nvme_lpm_ops);
+
+void unregister_nvme_lpm_ops(void)
+{
+	nvme_drv_ops = NULL;
+}
+EXPORT_SYMBOL_GPL(unregister_nvme_lpm_ops);
+
+static const struct file_operations nvme_dev_fops = {
+	.owner		= THIS_MODULE,
+	.open		= nvme_dev_open,
+	.unlocked_ioctl	= nvme_dev_ioctl,
+	.compat_ioctl	= nvme_dev_ioctl,
+};
+
+static int nvme_lpm_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct nvme_lpm *nvme_lpm;
+	struct device *dev = &pdev->dev;
+	struct resource *res, reg;
+	struct device_node *np;
+
+	nvme_lpm = devm_kzalloc(dev, sizeof(struct nvme_lpm), GFP_KERNEL);
+	if (!nvme_lpm) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	nvme_lpm->dev = dev;
+	spin_lock_init(&nvme_lpm->shmlock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	nvme_lpm->shared_mem = devm_memremap(dev, res->start,
+					resource_size(res), MEMREMAP_WB);
+	if (IS_ERR(nvme_lpm->shared_mem)) {
+		dev_err(dev, "failed to get io address\n");
+		ret = PTR_ERR(nvme_lpm->shared_mem);
+		goto out;
+	}
+
+	np = of_parse_phandle(dev->of_node, "memory-region", 0);
+	if (!np) {
+		dev_err(dev, "No memory-region specified\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = of_address_to_resource(np, 0, &reg);
+	if (ret) {
+		dev_err(dev, "No memory address assigned to the region\n");
+		ret = -ENOMEM;
+		goto out_put_node;
+	}
+
+	nvme_lpm->shared_nvme_data = devm_memremap(dev, reg.start,
+					resource_size(&reg), MEMREMAP_WB);
+	if (IS_ERR(nvme_lpm->shared_nvme_data)) {
+		dev_err(dev, "Failed to remap pci_lpm_mem region\n");
+		ret = PTR_ERR(nvme_lpm->shared_nvme_data);
+		goto out_put_node;
+	}
+
+	nvme_lpm->gpiod = devm_gpiod_get(dev, "intrpt", GPIOD_IN);
+	if (IS_ERR(nvme_lpm->gpiod)) {
+		dev_err(dev, "Failed to get interrupt gpio\n");
+		ret = PTR_ERR(nvme_lpm->gpiod);
+		goto out_put_node;
+	}
+
+	nvme_lpm->irq = gpiod_to_irq(nvme_lpm->gpiod);
+	if (nvme_lpm->irq < 0) {
+		dev_err(dev, "Failed to get interrupt gpio IRQ\n");
+		ret = nvme_lpm->irq;
+		goto out_put_node;
+	}
+
+	/* init irq */
+	ret = devm_request_irq(dev, nvme_lpm->irq, iproc_gpio_isr,
+			       IRQF_TRIGGER_RISING,
+			       dev_name(dev), nvme_lpm);
+	if (ret) {
+		dev_err(dev, "Failed to register interrupt\n");
+		goto out_put_node;
+	}
+
+	/* Request mailbox channel. */
+	nvme_lpm->client.dev          = &pdev->dev;
+	nvme_lpm->client.tx_block     = false;
+	nvme_lpm->client.tx_tout      = 1;
+	nvme_lpm->client.knows_txdone = true;
+	nvme_lpm->mbox_chan = mbox_request_channel(&nvme_lpm->client, 0);
+	if (IS_ERR(nvme_lpm->mbox_chan)) {
+		dev_err(dev, "unable to get mbox channel\n");
+		ret = PTR_ERR(nvme_lpm->mbox_chan);
+		goto out_put_node;
+	}
+	dev_dbg(dev, "Mailbox registration done\n");
+	ret = alloc_chrdev_region(&nvme_lpm->devt, 0, 1, "nvme-lpm");
+	if (ret) {
+		dev_err(dev, "cannot get add chrdev, err:%d\n", ret);
+		goto out_mbox;
+	}
+	cdev_init(&nvme_lpm->cdev, &nvme_dev_fops);
+	ret = cdev_add(&nvme_lpm->cdev, nvme_lpm->devt, 1);
+	if (ret) {
+		dev_err(dev, "cannot get add chrdev, err:%d\n", ret);
+		goto out_region;
+	}
+	dev_dbg(dev, "Character device created\n");
+
+	nvme_lpm->class = class_create(THIS_MODULE, "nvme-lpm");
+	if (IS_ERR(nvme_lpm->class)) {
+		ret = PTR_ERR(nvme_lpm->class);
+		goto out_cdev;
+	}
+	dev_dbg(dev, "Class creation done\n");
+
+	nvme_lpm->class_dev = device_create(nvme_lpm->class, nvme_lpm->dev,
+				  nvme_lpm->devt, nvme_lpm, "nvme-lpm");
+	if (IS_ERR(nvme_lpm->class_dev)) {
+		dev_err(dev, "failed to create device\n");
+		ret = PTR_ERR(nvme_lpm->class_dev);
+		goto out_class;
+	}
+	dev_info(dev, "device got added\n");
+	return ret;
+out_class:
+	class_destroy(nvme_lpm->class);
+out_cdev:
+	cdev_del(&nvme_lpm->cdev);
+out_region:
+	unregister_chrdev_region(nvme_lpm->devt, 1);
+out_mbox:
+	mbox_free_channel(nvme_lpm->mbox_chan);
+out_put_node:
+	of_node_put(np);
+out:
+	return ret;
+}
+
+static int nvme_lpm_remove(struct platform_device *pdev)
+{
+	struct nvme_lpm *nvme_lpm = platform_get_drvdata(pdev);
+
+	class_destroy(nvme_lpm->class);
+	cdev_del(&nvme_lpm->cdev);
+	unregister_chrdev_region(nvme_lpm->devt, 1);
+	mbox_free_channel(nvme_lpm->mbox_chan);
+
+	return 0;
+}
+
+static const struct of_device_id nvme_lpm_of_match[] = {
+	{ .compatible = "brcm,nvme-lpm-data-backup", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, nvme_lpm_of_match);
+
+struct platform_driver nvme_lpm_driver = {
+	.driver = {
+		.name = "nvme-lpm-data-backup",
+		.of_match_table = nvme_lpm_of_match,
+	},
+	.probe = nvme_lpm_probe,
+	.remove = nvme_lpm_remove,
+};
+module_platform_driver(nvme_lpm_driver);
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("Broadcom nvme lpm driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -332,6 +332,7 @@ config MMC_SDHCI_IPROC
 	tristate "SDHCI support for the BCM2835 & iProc SD/MMC Controller"
 	depends on ARCH_BCM2835 || ARCH_BCM_IPROC || COMPILE_TEST
 	depends on MMC_SDHCI_PLTFM
+	depends on OF || ACPI
 	default ARCH_BCM_IPROC
 	select MMC_SDHCI_IO_ACCESSORS
 	help
--- a/drivers/mmc/host/sdhci-iproc.c
+++ b/drivers/mmc/host/sdhci-iproc.c
@@ -15,6 +15,7 @@
  * iProc SDHCI platform driver
  */
 
+#include <linux/acpi.h>
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/mmc/host.h>
@@ -162,9 +163,19 @@ static void sdhci_iproc_writeb(struct sdhci_host *host, u8 val, int reg)
 	sdhci_iproc_writel(host, newval, reg & ~3);
 }
 
+static unsigned int sdhci_iproc_get_max_clock(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+
+	if (pltfm_host->clk)
+		return sdhci_pltfm_clk_get_max_clock(host);
+	else
+		return pltfm_host->clock;
+}
+
 static const struct sdhci_ops sdhci_iproc_ops = {
 	.set_clock = sdhci_set_clock,
-	.get_max_clock = sdhci_pltfm_clk_get_max_clock,
+	.get_max_clock = sdhci_iproc_get_max_clock,
 	.set_bus_width = sdhci_set_bus_width,
 	.reset = sdhci_reset,
 	.set_uhs_signaling = sdhci_set_uhs_signaling,
@@ -178,12 +189,18 @@ static void sdhci_iproc_writeb(struct sdhci_host *host, u8 val, int reg)
 	.write_w = sdhci_iproc_writew,
 	.write_b = sdhci_iproc_writeb,
 	.set_clock = sdhci_set_clock,
-	.get_max_clock = sdhci_pltfm_clk_get_max_clock,
+	.get_max_clock = sdhci_iproc_get_max_clock,
 	.set_bus_width = sdhci_set_bus_width,
 	.reset = sdhci_reset,
 	.set_uhs_signaling = sdhci_set_uhs_signaling,
 };
 
+enum sdhci_pltfm_type {
+	SDHCI_PLTFM_IPROC_CYGNUS,
+	SDHCI_PLTFM_IPROC,
+	SDHCI_PLTFM_BCM2835,
+};
+
 static const struct sdhci_pltfm_data sdhci_iproc_cygnus_pltfm_data = {
 	.quirks = SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |
 		  SDHCI_QUIRK_NO_HISPD_BIT,
@@ -191,22 +208,6 @@ static void sdhci_iproc_writeb(struct sdhci_host *host, u8 val, int reg)
 	.ops = &sdhci_iproc_32only_ops,
 };
 
-static const struct sdhci_iproc_data iproc_cygnus_data = {
-	.pdata = &sdhci_iproc_cygnus_pltfm_data,
-	.caps = ((0x1 << SDHCI_MAX_BLOCK_SHIFT)
-			& SDHCI_MAX_BLOCK_MASK) |
-		SDHCI_CAN_VDD_330 |
-		SDHCI_CAN_VDD_180 |
-		SDHCI_CAN_DO_SUSPEND |
-		SDHCI_CAN_DO_HISPD |
-		SDHCI_CAN_DO_ADMA2 |
-		SDHCI_CAN_DO_SDMA,
-	.caps1 = SDHCI_DRIVER_TYPE_C |
-		 SDHCI_DRIVER_TYPE_D |
-		 SDHCI_SUPPORT_DDR50,
-	.mmc_caps = MMC_CAP_1_8V_DDR,
-};
-
 static const struct sdhci_pltfm_data sdhci_iproc_pltfm_data = {
 	.quirks = SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |
 		  SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12 |
@@ -215,21 +216,6 @@ static void sdhci_iproc_writeb(struct sdhci_host *host, u8 val, int reg)
 	.ops = &sdhci_iproc_ops,
 };
 
-static const struct sdhci_iproc_data iproc_data = {
-	.pdata = &sdhci_iproc_pltfm_data,
-	.caps = ((0x1 << SDHCI_MAX_BLOCK_SHIFT)
-			& SDHCI_MAX_BLOCK_MASK) |
-		SDHCI_CAN_VDD_330 |
-		SDHCI_CAN_VDD_180 |
-		SDHCI_CAN_DO_SUSPEND |
-		SDHCI_CAN_DO_HISPD |
-		SDHCI_CAN_DO_ADMA2 |
-		SDHCI_CAN_DO_SDMA,
-	.caps1 = SDHCI_DRIVER_TYPE_C |
-		 SDHCI_DRIVER_TYPE_D |
-		 SDHCI_SUPPORT_DDR50,
-};
-
 static const struct sdhci_pltfm_data sdhci_bcm2835_pltfm_data = {
 	.quirks = SDHCI_QUIRK_BROKEN_CARD_DETECTION |
 		  SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |
@@ -238,38 +224,104 @@ static void sdhci_iproc_writeb(struct sdhci_host *host, u8 val, int reg)
 	.ops = &sdhci_iproc_32only_ops,
 };
 
-static const struct sdhci_iproc_data bcm2835_data = {
-	.pdata = &sdhci_bcm2835_pltfm_data,
-	.caps = ((0x1 << SDHCI_MAX_BLOCK_SHIFT)
-			& SDHCI_MAX_BLOCK_MASK) |
-		SDHCI_CAN_VDD_330 |
-		SDHCI_CAN_DO_HISPD,
-	.caps1 = SDHCI_DRIVER_TYPE_A |
-		 SDHCI_DRIVER_TYPE_C,
-	.mmc_caps = 0x00000000,
+static const struct sdhci_iproc_data sdhci_iproc_data_list[] = {
+	[SDHCI_PLTFM_IPROC_CYGNUS] = {
+		/* SDHCI IPROC CYGNUS */
+		.pdata = &sdhci_iproc_cygnus_pltfm_data,
+		.caps = ((0x1 << SDHCI_MAX_BLOCK_SHIFT)
+				& SDHCI_MAX_BLOCK_MASK) |
+			SDHCI_CAN_VDD_330 |
+			SDHCI_CAN_VDD_180 |
+			SDHCI_CAN_DO_SUSPEND |
+			SDHCI_CAN_DO_HISPD |
+			SDHCI_CAN_DO_ADMA2 |
+			SDHCI_CAN_DO_SDMA,
+		.caps1 = SDHCI_DRIVER_TYPE_C |
+			SDHCI_DRIVER_TYPE_D |
+			SDHCI_SUPPORT_DDR50,
+		.mmc_caps = MMC_CAP_1_8V_DDR,
+	},
+	[SDHCI_PLTFM_IPROC] = {
+		/* SDHCI IPROC */
+		.pdata = &sdhci_iproc_pltfm_data,
+		.caps = ((0x1 << SDHCI_MAX_BLOCK_SHIFT)
+				& SDHCI_MAX_BLOCK_MASK) |
+			SDHCI_CAN_VDD_330 |
+			SDHCI_CAN_VDD_180 |
+			SDHCI_CAN_DO_SUSPEND |
+			SDHCI_CAN_DO_HISPD |
+			SDHCI_CAN_DO_ADMA2 |
+			SDHCI_CAN_DO_SDMA,
+		.caps1 = SDHCI_DRIVER_TYPE_C |
+			SDHCI_DRIVER_TYPE_D |
+			SDHCI_SUPPORT_DDR50,
+	},
+	[SDHCI_PLTFM_BCM2835] = {
+		/* SDHCI BCM2835 */
+		.pdata = &sdhci_bcm2835_pltfm_data,
+		.caps = ((0x1 << SDHCI_MAX_BLOCK_SHIFT)
+				& SDHCI_MAX_BLOCK_MASK) |
+			SDHCI_CAN_VDD_330 |
+			SDHCI_CAN_DO_HISPD,
+		.caps1 = SDHCI_DRIVER_TYPE_A |
+			SDHCI_DRIVER_TYPE_C,
+		.mmc_caps = 0x00000000,
+
+	},
 };
 
 static const struct of_device_id sdhci_iproc_of_match[] = {
-	{ .compatible = "brcm,bcm2835-sdhci", .data = &bcm2835_data },
-	{ .compatible = "brcm,sdhci-iproc-cygnus", .data = &iproc_cygnus_data},
-	{ .compatible = "brcm,sdhci-iproc", .data = &iproc_data },
+	{
+		.compatible = "brcm,bcm2835-sdhci",
+		.data = (void *)SDHCI_PLTFM_BCM2835
+	},
+	{
+		.compatible = "brcm,sdhci-iproc-cygnus",
+		.data = (void *)SDHCI_PLTFM_IPROC_CYGNUS
+	},
+	{
+		.compatible = "brcm,sdhci-iproc",
+		.data = (void *)SDHCI_PLTFM_IPROC
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sdhci_iproc_of_match);
 
+static const struct acpi_device_id sdhci_iproc_acpi_ids[] = {
+	{ .id = "BRCM5871", .driver_data = SDHCI_PLTFM_IPROC_CYGNUS },
+	{ .id = "BRCM5872", .driver_data = SDHCI_PLTFM_IPROC },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(acpi, sdhci_iproc_acpi_ids);
+
 static int sdhci_iproc_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	const struct of_device_id *match;
+	const struct acpi_device_id *acpi_id;
 	const struct sdhci_iproc_data *iproc_data;
 	struct sdhci_host *host;
 	struct sdhci_iproc_host *iproc_host;
 	struct sdhci_pltfm_host *pltfm_host;
 	int ret;
+	enum sdhci_pltfm_type plat_type;
+
+	if (dev->of_node) {
+		match = of_match_device(sdhci_iproc_of_match, dev);
+		if (match)
+			plat_type = (enum sdhci_pltfm_type)match->data;
+		else
+			return -ENODEV;
+	} else if (has_acpi_companion(dev)) {
+		acpi_id = acpi_match_device(sdhci_iproc_acpi_ids, dev);
+		if (acpi_id)
+			plat_type = (enum sdhci_pltfm_type)acpi_id->driver_data;
+		else
+			return -ENODEV;
+	} else
+		return -ENODEV;
 
-	match = of_match_device(sdhci_iproc_of_match, &pdev->dev);
-	if (!match)
-		return -EINVAL;
-	iproc_data = match->data;
+	iproc_data = &sdhci_iproc_data_list[plat_type];
 
 	host = sdhci_pltfm_init(pdev, iproc_data->pdata, sizeof(*iproc_host));
 	if (IS_ERR(host))
@@ -288,17 +340,30 @@ static int sdhci_iproc_probe(struct platform_device *pdev)
 
 	host->mmc->caps |= iproc_host->data->mmc_caps;
 
-	pltfm_host->clk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(pltfm_host->clk)) {
-		ret = PTR_ERR(pltfm_host->clk);
-		goto err;
-	}
-	ret = clk_prepare_enable(pltfm_host->clk);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to enable host clk\n");
-		goto err;
+	if (dev->of_node) {
+		pltfm_host->clk = devm_clk_get(dev, NULL);
+		if (IS_ERR(pltfm_host->clk)) {
+			ret = PTR_ERR(pltfm_host->clk);
+			goto err;
+		}
+		ret = clk_prepare_enable(pltfm_host->clk);
+		if (ret) {
+			dev_err(dev, "failed to enable host clk\n");
+			goto err;
+		}
+	} else if (has_acpi_companion(dev)) {
+		/*
+		 * When Driver probe with ACPI device, clock devices
+		 * are not available, so sdhci clock get from
+		 * clock-frequency property given in _DSD object.
+		 */
+		device_property_read_u32(dev, "clock-frequency",
+					 &pltfm_host->clock);
+		if (!pltfm_host->clock) {
+			ret = -ENODEV;
+			goto err;
+		}
 	}
-
 	if (iproc_host->data->pdata->quirks & SDHCI_QUIRK_MISSING_CAPS) {
 		host->caps = iproc_host->data->caps;
 		host->caps1 = iproc_host->data->caps1;
@@ -311,7 +376,8 @@ static int sdhci_iproc_probe(struct platform_device *pdev)
 	return 0;
 
 err_clk:
-	clk_disable_unprepare(pltfm_host->clk);
+	if (dev->of_node)
+		clk_disable_unprepare(pltfm_host->clk);
 err:
 	sdhci_pltfm_free(pdev);
 	return ret;
@@ -321,6 +387,7 @@ static int sdhci_iproc_probe(struct platform_device *pdev)
 	.driver = {
 		.name = "sdhci-iproc",
 		.of_match_table = sdhci_iproc_of_match,
+		.acpi_match_table = ACPI_PTR(sdhci_iproc_acpi_ids),
 		.pm = &sdhci_pltfm_pmops,
 	},
 	.probe = sdhci_iproc_probe,
--- a/drivers/mtd/nand/brcmnand/brcmnand.c
+++ b/drivers/mtd/nand/brcmnand/brcmnand.c
@@ -1482,23 +1482,31 @@ static void brcmnand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 		*buf = brcmnand_read_byte(mtd);
 }
 
-static void brcmnand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
-				   int len)
+static void brcmnand_write_byte(struct mtd_info *mtd, uint8_t byte)
 {
-	int i;
 	struct nand_chip *chip = mtd_to_nand(mtd);
 	struct brcmnand_host *host = nand_get_controller_data(chip);
 
 	switch (host->last_cmd) {
 	case NAND_CMD_SET_FEATURES:
-		for (i = 0; i < len; i++)
-			brcmnand_low_level_op(host, LL_OP_WR, buf[i],
-						  (i + 1) == len);
+		brcmnand_low_level_op(host, LL_OP_WR, byte,
+				      host->last_byte ==
+				      ONFI_SUBFEATURE_PARAM_LEN - 1);
 		break;
 	default:
 		BUG();
 		break;
 	}
+	host->last_byte++;
+}
+
+static void brcmnand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
+				   int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++, buf++)
+		brcmnand_write_byte(mtd, *buf);
 }
 
 /**
@@ -2234,6 +2242,7 @@ static int brcmnand_init_cs(struct brcmnand_host *host, struct device_node *dn)
 	chip->waitfunc = brcmnand_waitfunc;
 	chip->read_byte = brcmnand_read_byte;
 	chip->read_buf = brcmnand_read_buf;
+	chip->write_byte = brcmnand_write_byte;
 	chip->write_buf = brcmnand_write_buf;
 
 	chip->ecc.mode = NAND_ECC_HW;
@@ -2246,6 +2255,11 @@ static int brcmnand_init_cs(struct brcmnand_host *host, struct device_node *dn)
 	chip->ecc.read_oob = brcmnand_read_oob;
 	chip->ecc.write_oob = brcmnand_write_oob;
 
+	if (ctrl->soc->quirks & BRCMNAND_SOC_QUIRK_GET_SET_FEATURE_BROKEN) {
+		chip->onfi_set_features = nand_onfi_get_set_features_notsupp;
+		chip->onfi_get_features = nand_onfi_get_set_features_notsupp;
+	}
+
 	chip->controller = &ctrl->controller;
 
 	/*
--- a/drivers/mtd/nand/brcmnand/brcmnand.h
+++ b/drivers/mtd/nand/brcmnand/brcmnand.h
@@ -17,6 +17,8 @@
 #include <linux/types.h>
 #include <linux/io.h>
 
+#define BRCMNAND_SOC_QUIRK_GET_SET_FEATURE_BROKEN	0x1
+
 struct platform_device;
 struct dev_pm_ops;
 
@@ -25,6 +27,7 @@ struct brcmnand_soc {
 	void (*ctlrdy_set_enabled)(struct brcmnand_soc *soc, bool en);
 	void (*prepare_data_bus)(struct brcmnand_soc *soc, bool prepare,
 				 bool is_param);
+	u32 quirks;
 };
 
 static inline void brcmnand_soc_data_bus_prepare(struct brcmnand_soc *soc,
--- a/drivers/mtd/nand/brcmnand/iproc_nand.c
+++ b/drivers/mtd/nand/brcmnand/iproc_nand.c
@@ -134,6 +134,19 @@ static int iproc_nand_probe(struct platform_device *pdev)
 	soc->ctlrdy_set_enabled = iproc_nand_intc_set;
 	soc->prepare_data_bus = iproc_nand_apb_access;
 
+	/*
+	 * Disable the onfi set/get feature commands for now due to a problem
+	 * with some Micron nand devices that have on-die ECC.
+	 * The Micron specific initialization is determining if the on-die ECC
+	 * is supported (even if on-die ECC is not configured in device tree) by
+	 * enabling it using onfi_set_feature and checking using
+	 * onfi_get_feature then disabling it if the check found it enabled.
+	 * On cygnus this check finds that on-die ECC is not enabled when
+	 * apparently it is, resulting in leaving it enabled and cause nand
+	 * corruption.
+	 */
+	soc->quirks = BRCMNAND_SOC_QUIRK_GET_SET_FEATURE_BROKEN;
+
 	return brcmnand_probe(pdev, soc);
 }
 
--- a/drivers/net/ethernet/broadcom/bgmac-platform.c
+++ b/drivers/net/ethernet/broadcom/bgmac-platform.c
@@ -33,6 +33,10 @@
 #define NICPM_IOMUX_CTRL_SPD_100M	1
 #define NICPM_IOMUX_CTRL_SPD_1000M	2
 
+static char *ethaddr;
+module_param(ethaddr, charp, 0644);	/* S_IRUGO | S_IWUSR */
+MODULE_PARM_DESC(ethaddr, "MAC address");
+
 static u32 platform_bgmac_read(struct bgmac *bgmac, u16 offset)
 {
 	return readl(bgmac->plat.base + offset);
@@ -115,6 +119,29 @@ static void platform_bgmac_cmn_maskset32(struct bgmac *bgmac, u16 offset,
 	WARN_ON(1);
 }
 
+static bool bgmac_setparam_ethaddr(struct bgmac *bgmac)
+{
+	char parsed_mac_addr[ETH_ALEN];
+
+	if ((!ethaddr) || (!strlen(ethaddr))) {
+		dev_dbg(bgmac->dev, "No ethaddr specified\n");
+		return false;
+	}
+
+	if (!mac_pton(ethaddr, parsed_mac_addr)) {
+		dev_dbg(bgmac->dev, "Invalid ethaddr - %s\n", ethaddr);
+		return false;
+	}
+
+	if (is_valid_ether_addr(parsed_mac_addr)) {
+		dev_dbg(bgmac->dev, "Setting ethaddr to - %s\n", ethaddr);
+		ether_addr_copy(bgmac->net_dev->dev_addr, parsed_mac_addr);
+		return true;
+	}
+
+	return false;
+}
+
 static void bgmac_nicpm_speed_set(struct net_device *net_dev)
 {
 	struct bgmac *bgmac = netdev_priv(net_dev);
@@ -191,11 +218,13 @@ static int bgmac_probe(struct platform_device *pdev)
 	bgmac->dev = &pdev->dev;
 	bgmac->dma_dev = &pdev->dev;
 
-	mac_addr = of_get_mac_address(np);
-	if (mac_addr)
-		ether_addr_copy(bgmac->net_dev->dev_addr, mac_addr);
-	else
-		dev_warn(&pdev->dev, "MAC address not present in device tree\n");
+	if (!bgmac_setparam_ethaddr(bgmac)) {
+		mac_addr = of_get_mac_address(np);
+		if (mac_addr)
+			ether_addr_copy(bgmac->net_dev->dev_addr, mac_addr);
+		else
+			dev_warn(&pdev->dev, "valid MAC address not found\n");
+	}
 
 	bgmac->irq = platform_get_irq(pdev, 0);
 	if (bgmac->irq < 0) {
@@ -238,6 +267,8 @@ static int bgmac_probe(struct platform_device *pdev)
 	bgmac->cco_ctl_maskset = platform_bgmac_cco_ctl_maskset;
 	bgmac->get_bus_clock = platform_bgmac_get_bus_clock;
 	bgmac->cmn_maskset32 = platform_bgmac_cmn_maskset32;
+	bgmac->switch_disable = of_property_read_bool(np,
+						      "brcm,amac-switch-bypass");
 	if (of_parse_phandle(np, "phy-handle", 0)) {
 		bgmac->phy_connect = platform_phy_connect;
 	} else {
--- a/drivers/net/ethernet/broadcom/bgmac.c
+++ b/drivers/net/ethernet/broadcom/bgmac.c
@@ -852,6 +852,9 @@ static void bgmac_mac_speed(struct bgmac *bgmac)
 	if (bgmac->mac_duplex == DUPLEX_HALF)
 		set |= BGMAC_CMDCFG_HD;
 
+	if (bgmac->switch_disable)
+		set |= BGMAC_CMDCFG_AE;
+
 	bgmac_cmdcfg_maskset(bgmac, mask, set, true);
 }
 
@@ -1599,6 +1602,8 @@ int bgmac_enet_resume(struct bgmac *bgmac)
 	if (!netif_running(bgmac->net_dev))
 		return 0;
 
+	bgmac_clk_enable(bgmac, 0);
+
 	rc = bgmac_dma_init(bgmac);
 	if (rc)
 		return rc;
--- a/drivers/net/ethernet/broadcom/bgmac.h
+++ b/drivers/net/ethernet/broadcom/bgmac.h
@@ -520,6 +520,8 @@ struct bgmac {
 
 	bool loopback;
 
+	bool switch_disable;
+
 	u32 (*read)(struct bgmac *bgmac, u16 offset);
 	void (*write)(struct bgmac *bgmac, u16 offset, u32 value);
 	u32 (*idm_read)(struct bgmac *bgmac, u16 offset);
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -22,6 +22,7 @@ config MDIO_BCM_IPROC
 	tristate "Broadcom iProc MDIO bus controller"
 	depends on ARCH_BCM_IPROC || COMPILE_TEST
 	depends on HAS_IOMEM && OF_MDIO
+	default ARCH_BCM_IPROC
 	help
 	  This module provides a driver for the MDIO busses found in the
 	  Broadcom iProc SoC's.
@@ -244,6 +245,7 @@ config BCM_CYGNUS_PHY
 	depends on ARCH_BCM_CYGNUS || COMPILE_TEST
 	depends on MDIO_BCM_IPROC
 	select BCM_NET_PHYLIB
+	default ARCH_BCM_CYGNUS
 	---help---
 	  This PHY driver is for the 1G internal PHYs of the Broadcom
 	  Cygnus Family SoC.
--- a/drivers/net/phy/bcm-phy-lib.c
+++ b/drivers/net/phy/bcm-phy-lib.c
@@ -116,6 +116,32 @@ int bcm_phy_read_misc(struct phy_device *phydev,
 }
 EXPORT_SYMBOL_GPL(bcm_phy_read_misc);
 
+int bcm_phy_write_rdb(struct phy_device *phydev, u16 reg, u16 val)
+{
+	int rc;
+
+	rc = phy_write(phydev, BCM_542XX_RDB_ADDR,
+		       reg & BCM_542XX_RDB_ADDR_MASK);
+	if (rc  < 0)
+		return rc;
+
+	return phy_write(phydev, BCM_542XX_RDB_DATA, val);
+}
+EXPORT_SYMBOL_GPL(bcm_phy_write_rdb);
+
+int bcm_phy_read_rdb(struct phy_device *phydev, u16 reg)
+{
+	int rc;
+
+	rc = phy_write(phydev, BCM_542XX_RDB_ADDR,
+		       reg & BCM_542XX_RDB_ADDR_MASK);
+	if (rc  < 0)
+		return rc;
+
+	return phy_read(phydev, BCM_542XX_RDB_DATA);
+}
+EXPORT_SYMBOL_GPL(bcm_phy_read_rdb);
+
 int bcm_phy_ack_intr(struct phy_device *phydev)
 {
 	int reg;
@@ -146,6 +172,49 @@ int bcm_phy_config_intr(struct phy_device *phydev)
 }
 EXPORT_SYMBOL_GPL(bcm_phy_config_intr);
 
+int bcm_rdb_phy_ack_intr(struct phy_device *phydev)
+{
+	int reg;
+
+	/* Clear pending interrupts.  */
+	reg = bcm_phy_read_rdb(phydev, BCM_542XX_RDB_PHY_ISR);
+	if (reg < 0)
+		return reg;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(bcm_rdb_phy_ack_intr);
+
+int bcm_rdb_phy_config_intr(struct phy_device *phydev)
+{
+	int reg;
+
+	reg = bcm_phy_read_rdb(phydev, BCM_542XX_RDB_PHY_ECR);
+	if (reg < 0)
+		return reg;
+
+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+		reg &= ~MII_BCM54XX_ECR_IM;
+	else
+		reg |= MII_BCM54XX_ECR_IM;
+
+	return bcm_phy_write_rdb(phydev, BCM_542XX_RDB_PHY_ECR, reg);
+}
+EXPORT_SYMBOL_GPL(bcm_rdb_phy_config_intr);
+
+int bcm_phy_power_down(struct phy_device *phydev, bool down)
+{
+	u16 val;
+
+	val = phy_read(phydev, MII_BMCR);
+	if (down)
+		val |= BCM_542XX_POWER_DOWN;
+	else
+		val &= ~BCM_542XX_POWER_DOWN;
+	return phy_write(phydev, MII_BMCR, val);
+}
+EXPORT_SYMBOL_GPL(bcm_phy_power_down);
+
 int bcm_phy_read_shadow(struct phy_device *phydev, u16 shadow)
 {
 	phy_write(phydev, MII_BCM54XX_SHD, MII_BCM54XX_SHD_VAL(shadow));
--- a/drivers/net/phy/bcm-phy-lib.h
+++ b/drivers/net/phy/bcm-phy-lib.h
@@ -38,9 +38,17 @@ int bcm_phy_write_shadow(struct phy_device *phydev, u16 shadow,
 			 u16 val);
 int bcm_phy_read_shadow(struct phy_device *phydev, u16 shadow);
 
+int bcm_phy_write_rdb(struct phy_device *phydev, u16 reg, u16 val);
+int bcm_phy_read_rdb(struct phy_device *phydev, u16 reg);
+
 int bcm_phy_ack_intr(struct phy_device *phydev);
 int bcm_phy_config_intr(struct phy_device *phydev);
 
+int bcm_rdb_phy_ack_intr(struct phy_device *phydev);
+int bcm_rdb_phy_config_intr(struct phy_device *phydev);
+
+int bcm_phy_power_down(struct phy_device *phydev, bool down);
+
 int bcm_phy_enable_apd(struct phy_device *phydev, bool dll_pwr_down);
 
 int bcm_phy_set_eee(struct phy_device *phydev, bool enable);
--- a/drivers/net/phy/broadcom.c
+++ b/drivers/net/phy/broadcom.c
@@ -30,6 +30,99 @@
 MODULE_AUTHOR("Maciej W. Rozycki");
 MODULE_LICENSE("GPL");
 
+static int bcm54210s_config_init(struct phy_device *phydev)
+{
+	int val;
+
+	/* Only RGMII to 1000Base-X/SGMII(slave) mode is supported as of now */
+	if (!phy_interface_is_rgmii(phydev))
+		return -EINVAL;
+
+	/* Enable RGMII interface and configure internal Rx Clock delay */
+	val = bcm_phy_read_rdb(phydev,
+			       BCM_542XX_RDB_COPPER_MISC_CTRL);
+	val |= BCM_542XX_RGMII_EN;
+	val |= BCM_542XX_RXC_INT_DELAY;		/* Enable Rx Clock delay */
+	if (phydev->interface != PHY_INTERFACE_MODE_RGMII_ID &&
+	    phydev->interface != PHY_INTERFACE_MODE_RGMII_RXID)
+		val &= ~BCM_542XX_RXC_INT_DELAY;
+	bcm_phy_write_rdb(phydev, BCM_542XX_RDB_COPPER_MISC_CTRL, val);
+
+	/* Configure internal Tx Clock delay */
+	val = bcm_phy_read_rdb(phydev, BCM_542XX_RDB_CLK_ALIGN_CTRL);
+	val |= BCM_542XX_GTXCLK_INT_DELAY;	/* Enable Tx Clock delay */
+	if (phydev->interface != PHY_INTERFACE_MODE_RGMII_ID &&
+	    phydev->interface != PHY_INTERFACE_MODE_RGMII_TXID)
+		val &= ~BCM_542XX_GTXCLK_INT_DELAY;
+	bcm_phy_write_rdb(phydev, BCM_542XX_RDB_CLK_ALIGN_CTRL, val);
+
+	/* Configure RGMII mode: RGMII 3.3V */
+	bcm_phy_write_rdb(phydev, BCM_542XX_RDB_TOP_LEVEL_CONFIG,
+			  BCM_542XX_RGMII_3P3V);
+
+	/* Enable RGMII-to-Fiber(1000BASE-X mode) and select Copper overlay */
+	val = bcm_phy_read_rdb(phydev, BCM_542XX_RDB_MODE_CTRL);
+	val &= ~BCM_542XX_MODE_SEL;
+	val |= BCM_542XX_1000BASEX & BCM_542XX_MODE_SEL;
+	val &= ~BCM_542XX_REG_1000X_EN;
+	bcm_phy_write_rdb(phydev, BCM_542XX_RDB_MODE_CTRL, val);
+
+	/* Power down Copper interface */
+	bcm_phy_power_down(phydev, true);
+
+	/* Now select Fiber (1000Base-X or SGMII) overlay */
+	val |= BCM_542XX_REG_1000X_EN;
+	bcm_phy_write_rdb(phydev, BCM_542XX_RDB_MODE_CTRL, val);
+
+	/* Turn off auto-medium detect function and enable serdes LED mode */
+	val = bcm_phy_read_rdb(phydev, BCM_542XX_RDB_AUTODET_MEDIUM);
+	val &= ~BCM_542XX_RGMII_AUTO_DET_MED_EN;
+	val |= BCM_542XX_FIBER_LED;
+	bcm_phy_write_rdb(phydev, BCM_542XX_RDB_AUTODET_MEDIUM, val);
+
+	/* Enable SGMII (Slave) mode */
+	val = bcm_phy_read_rdb(phydev, BCM_542XX_RDB_SGMII_SLAVE);
+	val |= BCM_542XX_SGMII_SLAVE_MODE_EN;
+	bcm_phy_write_rdb(phydev, BCM_542XX_RDB_SGMII_SLAVE, val);
+
+	/* Power up the primary serdes interface */
+	bcm_phy_power_down(phydev, false);
+
+	phydev->autoneg = AUTONEG_DISABLE;
+	phydev->speed = SPEED_1000;
+	phydev->duplex = DUPLEX_FULL;
+
+	return 0;
+}
+
+static int bcm_rdb_phy_config_init(struct phy_device *phydev)
+{
+	int val, ret;
+
+	/* Mask the interrupts globally */
+	val = bcm_phy_read_rdb(phydev, BCM_542XX_RDB_PHY_ECR);
+	val |= MII_BCM54XX_ECR_IM;
+	ret = bcm_phy_write_rdb(phydev, BCM_542XX_RDB_PHY_ECR, val);
+	if (ret < 0)
+		return ret;
+
+	/* Unmask events we are interested in.  */
+	val = ~(MII_BCM54XX_INT_DUPLEX |
+		MII_BCM54XX_INT_SPEED |
+		MII_BCM54XX_INT_LINK);
+	ret = bcm_phy_write_rdb(phydev, BCM_542XX_RDB_PHY_IMR, val);
+	if (ret < 0)
+		return ret;
+
+	if (BRCM_PHY_MODEL(phydev) == PHY_ID_BCM54210S) {
+		ret = bcm54210s_config_init(phydev);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+};
+
 static int bcm54210e_config_init(struct phy_device *phydev)
 {
 	int val;
@@ -569,6 +662,17 @@ static int brcm_fet_config_intr(struct phy_device *phydev)
 	.ack_interrupt	= bcm_phy_ack_intr,
 	.config_intr	= bcm_phy_config_intr,
 }, {
+	.phy_id		= PHY_ID_BCM54210S,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "Broadcom BCM54210S",
+	.features	= PHY_GBIT_FEATURES,
+	.flags		= PHY_HAS_INTERRUPT,
+	.config_init	= bcm_rdb_phy_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= bcm_rdb_phy_ack_intr,
+	.config_intr	= bcm_rdb_phy_config_intr,
+}, {
 	.phy_id		= PHY_ID_BCM5461,
 	.phy_id_mask	= 0xfffffff0,
 	.name		= "Broadcom BCM5461",
@@ -708,6 +812,7 @@ static int brcm_fet_config_intr(struct phy_device *phydev)
 	{ PHY_ID_BCM5411, 0xfffffff0 },
 	{ PHY_ID_BCM5421, 0xfffffff0 },
 	{ PHY_ID_BCM54210E, 0xfffffff0 },
+	{ PHY_ID_BCM54210S, 0xfffffff0 },
 	{ PHY_ID_BCM5461, 0xfffffff0 },
 	{ PHY_ID_BCM54612E, 0xfffffff0 },
 	{ PHY_ID_BCM54616S, 0xfffffff0 },
--- a/drivers/net/phy/mdio-bcm-iproc.c
+++ b/drivers/net/phy/mdio-bcm-iproc.c
@@ -68,6 +68,7 @@ static inline void iproc_mdio_config_clk(void __iomem *base)
 
 	val = (IPROC_GPHY_MDCDIV << MII_CTRL_DIV_SHIFT) |
 		  BIT(MII_CTRL_PRE_SHIFT);
+
 	writel(val, base + MII_CTRL_OFFSET);
 }
 
@@ -188,6 +189,23 @@ static int iproc_mdio_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+int iproc_mdio_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct iproc_mdio_priv *priv = platform_get_drvdata(pdev);
+
+	/* restore the mii clock configuration */
+	iproc_mdio_config_clk(priv->base);
+
+	return 0;
+}
+
+static const struct dev_pm_ops iproc_mdio_pm_ops = {
+	.resume = iproc_mdio_resume
+};
+#endif /* CONFIG_PM_SLEEP */
+
 static const struct of_device_id iproc_mdio_of_match[] = {
 	{ .compatible = "brcm,iproc-mdio", },
 	{ /* sentinel */ },
@@ -198,6 +216,9 @@ static int iproc_mdio_remove(struct platform_device *pdev)
 	.driver = {
 		.name = "iproc-mdio",
 		.of_match_table = iproc_mdio_of_match,
+#ifdef CONFIG_PM_SLEEP
+		.pm = &iproc_mdio_pm_ops,
+#endif
 	},
 	.probe = iproc_mdio_probe,
 	.remove = iproc_mdio_remove,
--- a/drivers/net/phy/mdio-mux.c
+++ b/drivers/net/phy/mdio-mux.c
@@ -188,7 +188,8 @@ int mdio_mux_init(struct device *dev,
 err_pb_kz:
 	put_device(&parent_bus->dev);
 err_parent_bus:
-	of_node_put(parent_bus_node);
+	if (!mux_bus)
+		of_node_put(parent_bus_node);
 	return ret_val;
 }
 EXPORT_SYMBOL_GPL(mdio_mux_init);
--- a/drivers/net/phy/mdio_bus.c
+++ b/drivers/net/phy/mdio_bus.c
@@ -671,12 +671,34 @@ static int mdio_bus_restore(struct device *dev)
 	return 0;
 }
 
+static int mdio_bus_suspend_late(struct device *dev)
+{
+	struct mdio_device *mdio = to_mdio_device(dev);
+
+	if (mdio->pm_ops && mdio->pm_ops->suspend_late)
+		return mdio->pm_ops->suspend_late(dev);
+
+	return 0;
+}
+
+static int mdio_bus_resume_early(struct device *dev)
+{
+	struct mdio_device *mdio = to_mdio_device(dev);
+
+	if (mdio->pm_ops && mdio->pm_ops->resume_early)
+		return mdio->pm_ops->resume_early(dev);
+
+	return 0;
+}
+
 static const struct dev_pm_ops mdio_bus_pm_ops = {
 	.suspend = mdio_bus_suspend,
 	.resume = mdio_bus_resume,
 	.freeze = mdio_bus_suspend,
 	.thaw = mdio_bus_resume,
 	.restore = mdio_bus_restore,
+	.suspend_late = mdio_bus_suspend_late,
+	.resume_early = mdio_bus_resume_early,
 };
 
 #define MDIO_BUS_PM_OPS (&mdio_bus_pm_ops)
--- a/drivers/nvme/host/Kconfig
+++ b/drivers/nvme/host/Kconfig
@@ -48,3 +48,15 @@ config NVME_FC
 	  from https://github.com/linux-nvme/nvme-cli.
 
 	  If unsure, say N.
+
+config NVME_LPM_BACKUP
+	tristate "NVM Express low power mode memory backup host driver"
+	depends on HAS_DMA
+	select NVME_CORE
+	select NVME_LPM_SSR
+	help
+	  This provides support for the NVMe low power mode memory backup.
+	  This allows you to backup specified contiguous memory to specified
+	  location on NVMe.
+
+	  If unsure, say N.
--- a/drivers/nvme/host/Makefile
+++ b/drivers/nvme/host/Makefile
@@ -4,6 +4,7 @@ obj-$(CONFIG_BLK_DEV_NVME)		+= nvme.o
 obj-$(CONFIG_NVME_FABRICS)		+= nvme-fabrics.o
 obj-$(CONFIG_NVME_RDMA)			+= nvme-rdma.o
 obj-$(CONFIG_NVME_FC)			+= nvme-fc.o
+obj-$(CONFIG_NVME_LPM_BACKUP)		+= nvme-lpm.o
 
 nvme-core-y				:= core.o
 nvme-core-$(CONFIG_NVM)			+= lightnvm.o
@@ -15,3 +16,5 @@ nvme-fabrics-y				+= fabrics.o
 nvme-rdma-y				+= rdma.o
 
 nvme-fc-y				+= fc.o
+
+nvme-lpm-y				+= pci-lpm.o
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -101,6 +101,11 @@ static int nvme_reset_ctrl_sync(struct nvme_ctrl *ctrl)
 	return ret;
 }
 
+static inline bool nvme_ns_has_pi(struct nvme_ns *ns)
+{
+	return ns->pi_type && ns->ms == sizeof(struct t10_pi_tuple);
+}
+
 static blk_status_t nvme_error_status(struct request *req)
 {
 	switch (nvme_req(req)->status & 0x7ff) {
@@ -467,16 +472,6 @@ static inline blk_status_t nvme_setup_rw(struct nvme_ns *ns,
 	u16 control = 0;
 	u32 dsmgmt = 0;
 
-	/*
-	 * If formated with metadata, require the block layer provide a buffer
-	 * unless this namespace is formated such that the metadata can be
-	 * stripped/generated by the controller with PRACT=1.
-	 */
-	if (ns && ns->ms &&
-	    (!ns->pi_type || ns->ms != sizeof(struct t10_pi_tuple)) &&
-	    !blk_integrity_rq(req) && !blk_rq_is_passthrough(req))
-		return BLK_STS_NOTSUPP;
-
 	if (req->cmd_flags & REQ_FUA)
 		control |= NVME_RW_FUA;
 	if (req->cmd_flags & (REQ_FAILFAST_DEV | REQ_RAHEAD))
@@ -495,6 +490,18 @@ static inline blk_status_t nvme_setup_rw(struct nvme_ns *ns,
 		nvme_assign_write_stream(ctrl, req, &control, &dsmgmt);
 
 	if (ns->ms) {
+		/*
+		 * If formated with metadata, the block layer always provides a
+		 * metadata buffer if CONFIG_BLK_DEV_INTEGRITY is enabled.  Else
+		 * we enable the PRACT bit for protection information or set the
+		 * namespace capacity to zero to prevent any I/O.
+		 */
+		if (!blk_integrity_rq(req)) {
+			if (WARN_ON_ONCE(!nvme_ns_has_pi(ns)))
+				return BLK_STS_NOTSUPP;
+			control |= NVME_RW_PRINFO_PRACT;
+		}
+
 		switch (ns->pi_type) {
 		case NVME_NS_DPS_PI_TYPE3:
 			control |= NVME_RW_PRINFO_PRCHK_GUARD;
@@ -507,8 +514,6 @@ static inline blk_status_t nvme_setup_rw(struct nvme_ns *ns,
 					nvme_block_nr(ns, blk_rq_pos(req)));
 			break;
 		}
-		if (!blk_integrity_rq(req))
-			control |= NVME_RW_PRINFO_PRACT;
 	}
 
 	cmnd->rw.control = cpu_to_le16(control);
@@ -1084,29 +1089,6 @@ static int nvme_getgeo(struct block_device *bdev, struct hd_geometry *geo)
 }
 
 #ifdef CONFIG_BLK_DEV_INTEGRITY
-static void nvme_prep_integrity(struct gendisk *disk, struct nvme_id_ns *id,
-		u16 bs)
-{
-	struct nvme_ns *ns = disk->private_data;
-	u16 old_ms = ns->ms;
-	u8 pi_type = 0;
-
-	ns->ms = le16_to_cpu(id->lbaf[id->flbas & NVME_NS_FLBAS_LBA_MASK].ms);
-	ns->ext = ns->ms && (id->flbas & NVME_NS_FLBAS_META_EXT);
-
-	/* PI implementation requires metadata equal t10 pi tuple size */
-	if (ns->ms == sizeof(struct t10_pi_tuple))
-		pi_type = id->dps & NVME_NS_DPS_PI_MASK;
-
-	if (blk_get_integrity(disk) &&
-	    (ns->pi_type != pi_type || ns->ms != old_ms ||
-	     bs != queue_logical_block_size(disk->queue) ||
-	     (ns->ms && ns->ext)))
-		blk_integrity_unregister(disk);
-
-	ns->pi_type = pi_type;
-}
-
 static void nvme_init_integrity(struct nvme_ns *ns)
 {
 	struct blk_integrity integrity;
@@ -1133,10 +1115,6 @@ static void nvme_init_integrity(struct nvme_ns *ns)
 	blk_queue_max_integrity_segments(ns->queue, 1);
 }
 #else
-static void nvme_prep_integrity(struct gendisk *disk, struct nvme_id_ns *id,
-		u16 bs)
-{
-}
 static void nvme_init_integrity(struct nvme_ns *ns)
 {
 }
@@ -1205,17 +1183,24 @@ static void __nvme_revalidate_disk(struct gendisk *disk, struct nvme_id_ns *id)
 		ns->lba_shift = 9;
 	bs = 1 << ns->lba_shift;
 	ns->noiob = le16_to_cpu(id->noiob);
+	ns->ms = le16_to_cpu(id->lbaf[id->flbas & NVME_NS_FLBAS_LBA_MASK].ms);
+	ns->ext = ns->ms && (id->flbas & NVME_NS_FLBAS_META_EXT);
+	/* the PI implementation requires metadata equal t10 pi tuple size */
+	if (ns->ms == sizeof(struct t10_pi_tuple))
+		ns->pi_type = id->dps & NVME_NS_DPS_PI_MASK;
+	else
+		ns->pi_type = 0;
 
 	blk_mq_freeze_queue(disk->queue);
+	blk_integrity_unregister(disk);
 
-	if (ctrl->ops->flags & NVME_F_METADATA_SUPPORTED)
-		nvme_prep_integrity(disk, id, bs);
 	blk_queue_logical_block_size(ns->queue, bs);
 	if (ns->noiob)
 		nvme_set_chunk_size(ns);
-	if (ns->ms && !blk_get_integrity(disk) && !ns->ext)
+	if (ns->ms && !ns->ext &&
+	    (ctrl->ops->flags & NVME_F_METADATA_SUPPORTED))
 		nvme_init_integrity(ns);
-	if (ns->ms && !(ns->ms == 8 && ns->pi_type) && !blk_get_integrity(disk))
+	if (ns->ms && !nvme_ns_has_pi(ns) && !blk_get_integrity(disk))
 		set_capacity(disk, 0);
 	else
 		set_capacity(disk, le64_to_cpup(&id->nsze) << (ns->lba_shift - 9));
--- /dev/null
+++ b/drivers/nvme/host/nvme-lpm.h
@@ -0,0 +1,79 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright(c) 2018 Broadcom
+ */
+
+#ifndef _NVME_LPM_H
+#define _NVME_LPM_H
+
+#include "nvme.h"
+
+#define SQ_SIZE(depth)    ((depth) * sizeof(struct nvme_command))
+#define CQ_SIZE(depth)    ((depth) * sizeof(struct nvme_completion))
+
+#define NVME_AQ_BLK_MQ_DEPTH	(NVME_AQ_DEPTH - NVME_NR_AERS)
+
+struct nvme_lpm_dev {
+	unsigned int lba_shift;
+	unsigned int max_transfer_shift;
+	unsigned int used_io_queues;
+	phys_addr_t mem_addr;
+	u64 slba;
+	u64 xfer_length;
+	bool nvme_write;
+};
+
+struct prp_list_addr {
+	void *vaddr;
+	dma_addr_t paddr;
+};
+
+/*
+ * Represents an NVM Express device.  Each nvme_dev is a PCI function.
+ */
+struct nvme_dev {
+	struct nvme_queue **queues;
+	void __iomem *dbs;
+	struct device *dev;
+	unsigned int online_queues;
+	unsigned int max_qid;
+	unsigned int q_depth;
+	u32 db_stride;
+	void __iomem *bar;
+	unsigned long bar_mapped_size;
+	bool subsystem;
+	struct nvme_ctrl ctrl;
+	struct nvme_lpm_dev lpm_dev;
+	struct prp_list_addr *prp_addr;
+	unsigned int num_prp_pages;
+};
+
+static inline struct nvme_dev *to_nvme_dev(struct nvme_ctrl *ctrl)
+{
+	return container_of(ctrl, struct nvme_dev, ctrl);
+}
+
+/*
+ * An NVM Express queue.  Each device has at least two (one for admin
+ * commands and one for I/O commands).
+ */
+struct nvme_queue {
+	struct nvme_dev *dev;
+	spinlock_t q_lock;
+	struct nvme_command *sq_cmds;
+	struct nvme_completion *cqes;
+	dma_addr_t sq_dma_addr;
+	dma_addr_t cq_dma_addr;
+	void __iomem *q_db;
+	u16 q_depth;
+	s16 cq_vector;
+	u16 sq_tail;
+	u16 cq_head;
+	u16 qid;
+	u8 cq_phase;
+	unsigned int cqe_seen;
+	bool poll_done;
+	unsigned int cmd_id;
+};
+
+#endif /* _NVME_LPM_H */
--- /dev/null
+++ b/drivers/nvme/host/pci-lpm.c
@@ -0,0 +1,1279 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright(c) 2018 Broadcom
+ */
+
+#include <linux/aer.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/io-64-nonatomic-lo-hi.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/nvme-lpm-ssr.h>
+#include <linux/sizes.h>
+#include <linux/types.h>
+
+#include "nvme-lpm.h"
+
+#define ADMIN_CMD_TIMEOUT_MS    50  /* Admin command timeout(ms) */
+#define IO_CMD_TIMEOUT_MS       2   /* IO command timeout(ms) */
+#define SHUTDOWN_TIMEOUT_SEC    5   /* controller shutdown timeout(seconds) */
+#define MIN_PAGE_SHIFT_CTRL     12  /* Minimum page shift supported by NVMe */
+#define MAX_IO_QPAIR            32
+
+struct memory_window {
+	u64 start_addr;
+	u64 offset;
+};
+
+/* FIXME: have to get memory map from kernel to make following table generic */
+static const struct memory_window memory_map[] = {
+	{
+		.start_addr = 0x80000000,
+		.offset = 0x80000000,
+	},
+	{
+		.start_addr = 0x880000000,
+		.offset = 0x800000000,
+	},
+	{
+		.start_addr = 0x9000000000,
+		.offset = 0x400000000,
+	},
+	{
+		.start_addr = 0xa000000000,
+		.offset = 0x400000000,
+	},
+};
+
+static int get_current_memmap(phys_addr_t memaddr)
+{
+	int i;
+	u64 start_addr, end_addr;
+
+	for (i = 0; i < ARRAY_SIZE(memory_map); i++) {
+		start_addr = memory_map[i].start_addr;
+		end_addr = memory_map[i].start_addr + memory_map[i].offset - 1;
+		if (memaddr >= start_addr && memaddr <= end_addr)
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+static void check_memaddr(phys_addr_t *memaddr, unsigned int *current_memmap)
+{
+	int ret;
+
+	ret = get_current_memmap(*memaddr);
+	if (ret < 0 && *current_memmap < (ARRAY_SIZE(memory_map) - 1)) {
+		(*current_memmap)++;
+		*memaddr = memory_map[*current_memmap].start_addr;
+	}
+}
+
+static void nvme_init_queue(struct nvme_queue *nvmeq, u16 qid)
+{
+	struct nvme_dev *dev = nvmeq->dev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&nvmeq->q_lock, flags);
+	nvmeq->sq_tail = 0;
+	nvmeq->cq_head = 0;
+	nvmeq->cq_phase = 1;
+	nvmeq->poll_done = false;
+	nvmeq->cmd_id = 0;
+	nvmeq->q_db = (u32 *)dev->dbs + (qid * 2 * dev->db_stride);
+	memset((void *)nvmeq->cqes, 0, CQ_SIZE(nvmeq->q_depth));
+	dev->online_queues++;
+	dev_dbg(dev->dev, "QP-%d init'ed", qid);
+	spin_unlock_irqrestore(&nvmeq->q_lock, flags);
+}
+
+/* We read the CQE phase first to check if the rest of the entry is valid */
+static inline bool nvme_cqe_valid(struct nvme_queue *nvmeq, u16 head,
+				  u16 phase)
+{
+	return (le16_to_cpu(nvmeq->cqes[head].status) & 1) == phase;
+}
+
+static inline void nvme_ring_cq_doorbell(struct nvme_queue *nvmeq)
+{
+	u16 head = nvmeq->cq_head;
+
+	if (likely(nvmeq->cq_vector >= 0))
+		writel(head, (u32 *)nvmeq->q_db + nvmeq->dev->db_stride);
+}
+
+static inline void nvme_handle_cqe(struct nvme_queue *nvmeq,
+				   struct nvme_completion *cqe)
+{
+	if (unlikely(cqe->command_id >= nvmeq->q_depth)) {
+		dev_warn(nvmeq->dev->dev,
+			"invalid id %d completed on queue %d\n",
+			cqe->command_id, le16_to_cpu(cqe->sq_id));
+		return;
+	}
+
+	if (unlikely(nvmeq->qid == 0 &&
+			cqe->command_id >= NVME_AQ_BLK_MQ_DEPTH)) {
+		dev_warn(nvmeq->dev->dev,
+			"invalid id %d completed on queue %d\n",
+			cqe->command_id, le16_to_cpu(cqe->sq_id));
+		return;
+	}
+
+	if ((le16_to_cpu(cqe->status) & 0xfe))
+		dev_warn(nvmeq->dev->dev,
+			"Error %#x seen for id %d on queue %d\n",
+			le16_to_cpu(cqe->status), cqe->command_id,
+			le16_to_cpu(cqe->sq_id));
+
+	nvmeq->cqe_seen++;
+}
+
+static inline bool nvme_read_cqe(struct nvme_queue *nvmeq,
+				 struct nvme_completion *cqe)
+{
+	if (nvme_cqe_valid(nvmeq, nvmeq->cq_head, nvmeq->cq_phase)) {
+		*cqe = nvmeq->cqes[nvmeq->cq_head];
+
+		if (++nvmeq->cq_head == nvmeq->q_depth) {
+			nvmeq->cq_head = 0;
+			nvmeq->cq_phase = !nvmeq->cq_phase;
+		}
+		return true;
+	}
+	return false;
+}
+
+static int nvme_poll(struct nvme_queue *nvmeq, unsigned int tag)
+{
+	bool found = false;
+	unsigned int consumed = 0;
+	unsigned long flags;
+	struct nvme_completion cqe;
+
+	if (!nvme_cqe_valid(nvmeq, nvmeq->cq_head, nvmeq->cq_phase))
+		return 0;
+
+	spin_lock_irqsave(&nvmeq->q_lock, flags);
+	while (nvme_read_cqe(nvmeq, &cqe)) {
+		nvme_handle_cqe(nvmeq, &cqe);
+		consumed++;
+
+		if (tag == cqe.command_id) {
+			found = true;
+			break;
+		}
+	}
+
+	if (consumed)
+		nvme_ring_cq_doorbell(nvmeq);
+	spin_unlock_irqrestore(&nvmeq->q_lock, flags);
+
+	return found;
+}
+
+static int __nvme_submit_cmd_sync(struct nvme_command *cmd,
+				  struct nvme_queue *q,
+				  union nvme_result *result,
+				  unsigned int timeout)
+{
+	struct nvme_completion *cqe;
+	int cqe_num, ret = 0;
+	u16 tail = q->sq_tail;
+	unsigned int cmd_id = q->cmd_id;
+	unsigned int cmd_timeout = timeout ? timeout : ADMIN_CMD_TIMEOUT_MS;
+	unsigned int max_cmd_id = (q->qid) ? (q->q_depth)
+					   : NVME_AQ_BLK_MQ_DEPTH;
+
+	cmd->common.command_id = (++cmd_id == max_cmd_id) ?
+				 (q->cmd_id = 1) : (q->cmd_id = cmd_id);
+	memcpy(&q->sq_cmds[tail], cmd, sizeof(*cmd));
+
+	if (++tail == q->q_depth)
+		tail = 0;
+
+	/* ring SQ tail doorbell */
+	writel(tail, q->q_db);
+	q->sq_tail = tail;
+
+	while (!ret && cmd_timeout--) {
+		ret = nvme_poll(q, cmd->identify.command_id);
+		usleep_range(1000, 1010);
+	}
+
+	if (!ret) {
+		dev_err(q->dev->dev, "nvme SQ%d command-%d timed out: %d!",
+			q->qid, cmd->identify.command_id, ret);
+		return -ETIMEDOUT;
+	}
+	dev_dbg(q->dev->dev, "nvme SQ%d command-%d done!: %d",
+		q->qid, cmd->identify.command_id, cmd_timeout);
+
+	if (result) {
+		cqe_num = (q->cq_head == 0) ? max_cmd_id : (q->cq_head - 1);
+		cqe = &q->cqes[cqe_num];
+		memcpy(result, &cqe->result, sizeof(*result));
+	}
+
+	return 0;
+}
+
+static int nvme_submit_cmd_sync(struct nvme_command *cmd, struct nvme_queue *q,
+				union nvme_result *result)
+{
+	return __nvme_submit_cmd_sync(cmd, q, result, 0);
+}
+
+static int nvme_submit_cmd(struct nvme_command *cmd, struct nvme_queue *q)
+{
+	u16 tail = q->sq_tail;
+	unsigned int cmd_id = q->cmd_id;
+
+	cmd->common.command_id = (++cmd_id == q->dev->q_depth) ?
+				 (q->cmd_id = 1) : (q->cmd_id = cmd_id);
+
+	memcpy(&q->sq_cmds[tail], cmd, sizeof(*cmd));
+
+	if (++tail == q->q_depth) {
+		dev_info(q->dev->dev, "nvme IO SQ%d command-%d done!",
+					q->qid, cmd->rw.command_id);
+		dev_info(q->dev->dev, "Queue %d is full\n", q->qid);
+		tail = 0;
+		return -EBUSY;
+	}
+	q->sq_tail = tail;
+	return 0;
+}
+
+static int nvme_identify_controller(struct nvme_ctrl *ctrl,
+				    struct nvme_id_ctrl **id)
+{
+	struct nvme_dev *dev = to_nvme_dev(ctrl);
+	struct nvme_queue *q =  dev->queues[0];
+	struct nvme_command c = { };
+	dma_addr_t id_phys;
+
+	memset(&c, 0, sizeof(c));
+	c.identify.opcode = nvme_admin_identify;
+	c.identify.cns = NVME_ID_CNS_CTRL;
+
+	*id = dmam_alloc_coherent(dev->dev, sizeof(struct nvme_id_ctrl),
+				&id_phys, GFP_KERNEL);
+	if (!*id)
+		return -ENOMEM;
+	c.identify.dptr.prp1 = id_phys;
+
+	return nvme_submit_cmd_sync(&c, q, NULL);
+}
+
+static int nvme_set_features(struct nvme_ctrl *ctrl, unsigned int fid,
+			     unsigned int dword11, u32 *result)
+{
+	struct nvme_command c;
+	struct nvme_dev *dev = to_nvme_dev(ctrl);
+	struct nvme_queue *q =  dev->queues[0];
+	union nvme_result res;
+	int ret;
+
+	memset(&c, 0, sizeof(c));
+	c.features.opcode = nvme_admin_set_features;
+	c.features.fid = cpu_to_le32(fid);
+	c.features.dword11 = cpu_to_le32(dword11);
+
+	ret = nvme_submit_cmd_sync(&c, q, &res);
+	if (ret >= 0 && result)
+		*result = le32_to_cpu(res.u32);
+
+	return ret;
+}
+
+static int nvme_set_qcount(struct nvme_ctrl *ctrl, int *count)
+{
+	u32 q_count = (*count - 1) | ((*count - 1) << 16);
+	u32 result = 0, ret;
+	int nr_io_queues;
+
+	dev_info(ctrl->dev, "requested Qs: %d", *count);
+	ret = nvme_set_features(ctrl, NVME_FEAT_NUM_QUEUES, q_count, &result);
+
+	if (ret < 0) {
+		dev_err(ctrl->dev, "Could not set queue count (%d)\n", *count);
+		*count = 0;
+	} else {
+		nr_io_queues = min(result & 0xffff, result >> 16) + 1;
+		*count = min(*count, nr_io_queues);
+	}
+
+	return 0;
+}
+
+static int adapter_alloc_cq(struct nvme_dev *dev, u16 qid,
+			    struct nvme_queue *nvmeq)
+{
+	struct nvme_command c;
+	int flags = NVME_QUEUE_PHYS_CONTIG | NVME_CQ_IRQ_ENABLED;
+	struct nvme_queue *q = dev->queues[0];
+
+	/*
+	 * Note: we (ab)use the fact that the prp fields survive if no data
+	 * is attached to the request.
+	 */
+	memset(&c, 0, sizeof(c));
+	c.create_cq.opcode = nvme_admin_create_cq;
+	c.create_cq.prp1 = cpu_to_le64(nvmeq->cq_dma_addr);
+	c.create_cq.cqid = cpu_to_le16(qid);
+	c.create_cq.qsize = cpu_to_le16(nvmeq->q_depth - 1);
+	c.create_cq.cq_flags = cpu_to_le16(flags);
+	c.create_cq.irq_vector = cpu_to_le16(nvmeq->cq_vector);
+
+	return nvme_submit_cmd_sync(&c, q, NULL);
+}
+
+static int adapter_alloc_sq(struct nvme_dev *dev, u16 qid,
+			    struct nvme_queue *nvmeq)
+{
+	struct nvme_command c;
+	int flags = NVME_QUEUE_PHYS_CONTIG;
+	struct nvme_queue *q = dev->queues[0];
+
+	/*
+	 * Note: we (ab)use the fact that the prp fields survive if no data
+	 * is attached to the request.
+	 */
+	memset(&c, 0, sizeof(c));
+	c.create_sq.opcode = nvme_admin_create_sq;
+	c.create_sq.prp1 = cpu_to_le64(nvmeq->sq_dma_addr);
+	c.create_sq.sqid = cpu_to_le16(qid);
+	c.create_sq.qsize = cpu_to_le16(nvmeq->q_depth - 1);
+	c.create_sq.sq_flags = cpu_to_le16(flags);
+	c.create_sq.cqid = cpu_to_le16(qid);
+
+	return nvme_submit_cmd_sync(&c, q, NULL);
+}
+
+static int adapter_delete_queue(struct nvme_dev *dev, u8 opcode, u16 id)
+{
+	struct nvme_command c;
+	struct nvme_queue *q =  dev->queues[0];
+
+	memset(&c, 0, sizeof(c));
+	c.delete_queue.opcode = opcode;
+	c.delete_queue.qid = cpu_to_le16(id);
+
+	return nvme_submit_cmd_sync(&c, q, NULL);
+}
+
+static int adapter_delete_cq(struct nvme_dev *dev, u16 cqid)
+{
+	return adapter_delete_queue(dev, nvme_admin_delete_cq, cqid);
+}
+
+static int adapter_delete_sq(struct nvme_dev *dev, u16 sqid)
+{
+	return adapter_delete_queue(dev, nvme_admin_delete_sq, sqid);
+}
+
+static unsigned long db_bar_size(struct nvme_dev *dev,
+				 unsigned int nr_io_queues)
+{
+	return NVME_REG_DBS + ((nr_io_queues + 1) * 8 * dev->db_stride);
+}
+
+static int nvme_remap_bar(struct nvme_dev *dev, unsigned long size)
+{
+	struct pci_dev *pdev = to_pci_dev(dev->dev);
+
+	if (size <= dev->bar_mapped_size)
+		return 0;
+	if (size > pci_resource_len(pdev, 0))
+		return -ENOMEM;
+	if (dev->bar)
+		iounmap(dev->bar);
+	dev->bar = ioremap(pci_resource_start(pdev, 0), size);
+	if (!dev->bar) {
+		dev->bar_mapped_size = 0;
+		return -ENOMEM;
+	}
+	dev->bar_mapped_size = size;
+	dev->dbs = dev->bar + NVME_REG_DBS;
+
+	return 0;
+}
+
+static struct nvme_queue *nvme_alloc_queue(struct nvme_dev *dev, int qid,
+					   int depth)
+{
+	struct nvme_queue *nvmeq = devm_kzalloc(dev->dev,
+						sizeof(*nvmeq), GFP_KERNEL);
+
+	if (!nvmeq)
+		return NULL;
+
+	/* Admin/IO completion queue allocation */
+	nvmeq->cqes = dma_zalloc_coherent(dev->dev, CQ_SIZE(depth),
+					  &nvmeq->cq_dma_addr, GFP_KERNEL);
+	dev_dbg(dev->dev, "CQ%d @ 0x%llx\n", qid, nvmeq->cq_dma_addr);
+	if (!nvmeq->cqes)
+		goto free_nvmeq;
+
+	/* Admin/IO submission command queues allocation */
+	nvmeq->sq_cmds = dma_alloc_coherent(dev->dev, SQ_SIZE(depth),
+					    &nvmeq->sq_dma_addr, GFP_KERNEL);
+	if (!nvmeq->sq_cmds)
+		goto free_nvme_cq;
+	dev_dbg(dev->dev, "SQ%d @ 0x%llx\n", qid, nvmeq->sq_dma_addr);
+
+	nvmeq->dev = dev;
+	spin_lock_init(&nvmeq->q_lock);
+	nvmeq->cq_head = 0;
+	nvmeq->cq_phase = 1;
+	nvmeq->q_db = (u32 *)dev->dbs + (qid * 2 * dev->db_stride);
+	nvmeq->q_depth = depth;
+	nvmeq->qid = qid;
+	nvmeq->cq_vector = -1;
+	dev->queues[qid] = nvmeq;
+	dev->ctrl.queue_count++;
+
+	return nvmeq;
+
+ free_nvme_cq:
+	dma_free_coherent(dev->dev, CQ_SIZE(depth), (void *)nvmeq->cqes,
+			  nvmeq->cq_dma_addr);
+ free_nvmeq:
+	return NULL;
+}
+
+static int nvme_create_queue(struct nvme_queue *nvmeq, int qid)
+{
+	struct nvme_dev *dev = nvmeq->dev;
+	int result;
+
+	nvmeq->cq_vector = qid - 1;
+	result = adapter_alloc_cq(dev, qid, nvmeq);
+	if (result < 0)
+		return result;
+
+	result = adapter_alloc_sq(dev, qid, nvmeq);
+	if (result < 0)
+		goto release_cq;
+
+	nvme_init_queue(nvmeq, qid);
+
+	return result;
+
+ release_cq:
+	adapter_delete_cq(dev, qid);
+	return result;
+}
+
+static int nvme_create_io_queues(struct nvme_dev *dev)
+{
+	unsigned int i, max;
+	int ret = 0;
+
+	for (i = dev->ctrl.queue_count; i <= dev->max_qid; i++) {
+		/* vector == qid - 1, match nvme_create_queue */
+		if (!nvme_alloc_queue(dev, i, dev->q_depth)) {
+			ret = -ENOMEM;
+			break;
+		}
+	}
+
+	max = min(dev->max_qid, dev->ctrl.queue_count - 1);
+	for (i = dev->online_queues; i <= max; i++) {
+		ret = nvme_create_queue(dev->queues[i], i);
+		if (ret)
+			break;
+	}
+
+	/*
+	 * Ignore failing Create SQ/CQ commands, we can continue with less
+	 * than the desired amount of queues, and even a controller without
+	 * I/O queues can still be used to issue admin commands.  This might
+	 * be useful to upgrade a buggy firmware for example.
+	 */
+	return ret >= 0 ? 0 : ret;
+}
+
+static int nvme_setup_io_queues(struct nvme_dev *dev)
+{
+	struct nvme_queue *adminq = dev->queues[0];
+	int result, nr_io_queues;
+	unsigned long size;
+
+	nr_io_queues = MAX_IO_QPAIR;
+	result = nvme_set_qcount(&dev->ctrl, &nr_io_queues);
+	if (result < 0) {
+		dev_err(dev->dev, "nvme_set_queue_count failed\n");
+		return result;
+	}
+
+	if (nr_io_queues == 0)
+		return 0;
+
+	do {
+		size = db_bar_size(dev, nr_io_queues);
+		result = nvme_remap_bar(dev, size);
+		if (!result)
+			break;
+		if (!--nr_io_queues)
+			return -ENOMEM;
+	} while (1);
+	adminq->q_db = dev->dbs;
+
+	dev->max_qid = nr_io_queues;
+
+	return nvme_create_io_queues(dev);
+}
+
+static int nvme_ctrl_init_identify(struct nvme_ctrl *ctrl,
+				   struct nvme_id_ctrl **id)
+{
+	u64 cap;
+	int ret, page_shift;
+
+	ret = ctrl->ops->reg_read32(ctrl, NVME_REG_VS, &ctrl->vs);
+	if (ret) {
+		dev_err(ctrl->dev, "Reading VS failed (%d)\n", ret);
+		return ret;
+	}
+
+	if (ctrl->vs >= NVME_VS(1, 1, 0))
+		ctrl->subsystem = NVME_CAP_NSSRC(cap);
+
+	ret = ctrl->ops->reg_read64(ctrl, NVME_REG_CAP, &cap);
+	if (ret) {
+		dev_err(ctrl->dev, "Reading CAP failed (%d)\n", ret);
+		return ret;
+	}
+	page_shift = NVME_CAP_MPSMIN(cap) + 12;
+
+	ret = nvme_identify_controller(ctrl, id);
+	if (ret) {
+		dev_err(ctrl->dev, "Identify Controller failed (%d)\n", ret);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int nvme_pci_configure_admin_queue(struct nvme_dev *dev)
+{
+	int result;
+	u32 aqa;
+	struct nvme_queue *nvmeq;
+
+	result = nvme_remap_bar(dev, db_bar_size(dev, 0));
+	if (result < 0)
+		return result;
+
+	dev->subsystem = readl(dev->bar + NVME_REG_VS) >= NVME_VS(1, 1, 0) ?
+				NVME_CAP_NSSRC(dev->ctrl.cap) : 0;
+
+	if (dev->subsystem &&
+	    (readl(dev->bar + NVME_REG_CSTS) & NVME_CSTS_NSSRO))
+		writel(NVME_CSTS_NSSRO, dev->bar + NVME_REG_CSTS);
+
+	result = nvme_disable_ctrl(&dev->ctrl, dev->ctrl.cap);
+	if (result < 0)
+		return result;
+
+	nvmeq = dev->queues[0];
+	if (!nvmeq) {
+		nvmeq = nvme_alloc_queue(dev, 0, NVME_AQ_DEPTH);
+		if (!nvmeq)
+			return -ENOMEM;
+	}
+
+	aqa = nvmeq->q_depth - 1;
+	aqa |= aqa << 16;
+
+	writel(aqa, dev->bar + NVME_REG_AQA);
+	lo_hi_writeq(nvmeq->sq_dma_addr, dev->bar + NVME_REG_ASQ);
+	lo_hi_writeq(nvmeq->cq_dma_addr, dev->bar + NVME_REG_ACQ);
+
+	result = nvme_enable_ctrl(&dev->ctrl, dev->ctrl.cap);
+	if (result)
+		return result;
+
+	nvmeq->cq_vector = 0;
+	nvme_init_queue(nvmeq, 0);
+
+	return result;
+}
+
+static int nvme_pci_enable(struct nvme_dev *dev)
+{
+	int result = -ENOMEM;
+	struct pci_dev *pdev = to_pci_dev(dev->dev);
+
+	if (pci_enable_device_mem(pdev))
+		return result;
+
+	pci_set_master(pdev);
+
+	/* Restricting CQ/SQ allocation below 4 GB */
+	if (dma_set_mask_and_coherent(dev->dev, DMA_BIT_MASK(32)))
+		goto disable;
+
+	if (readl(dev->bar + NVME_REG_CSTS) == -1) {
+		result = -ENODEV;
+		goto disable;
+	}
+
+	/*
+	 * Some devices and/or platforms don't advertise or work with INTx
+	 * interrupts. Pre-enable a single MSIX or MSI vec for setup. We'll
+	 * adjust this later.
+	 */
+	result = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);
+	if (result < 0)
+		return result;
+
+	dev->ctrl.cap = lo_hi_readq(dev->bar + NVME_REG_CAP);
+
+	/* configuring maximum queue depth */
+	dev->q_depth = NVME_CAP_MQES(dev->ctrl.cap);
+	dev->db_stride = 1 << NVME_CAP_STRIDE(dev->ctrl.cap);
+	dev->dbs = dev->bar + NVME_REG_DBS;
+
+	dev_info(dev->dev, "CAP:%#llx, queue depth=%u, doorbell stride=%d\n",
+		 dev->ctrl.cap, dev->q_depth, dev->db_stride);
+
+	pci_enable_pcie_error_reporting(pdev);
+	pci_save_state(pdev);
+	return 0;
+
+ disable:
+	pci_disable_device(pdev);
+	return result;
+}
+
+static void nvme_dev_unmap(struct nvme_dev *dev)
+{
+	if (dev->bar)
+		iounmap(dev->bar);
+
+	pci_release_mem_regions(to_pci_dev(dev->dev));
+}
+
+static void nvme_pci_disable(struct nvme_dev *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev->dev);
+
+	pci_free_irq_vectors(pdev);
+
+	if (pci_is_enabled(pdev)) {
+		pci_disable_pcie_error_reporting(pdev);
+		pci_disable_device(pdev);
+	}
+}
+
+static void nvme_dev_disable(struct nvme_dev *dev, bool shutdown)
+{
+	if (shutdown)
+		nvme_shutdown_ctrl(&dev->ctrl);
+	else
+		nvme_disable_ctrl(&dev->ctrl, dev->ctrl.cap);
+
+	nvme_pci_disable(dev);
+}
+
+static int nvme_pci_reg_read32(struct nvme_ctrl *ctrl, u32 off, u32 *val)
+{
+	*val = readl(to_nvme_dev(ctrl)->bar + off);
+	return 0;
+}
+
+static int nvme_pci_reg_write32(struct nvme_ctrl *ctrl, u32 off, u32 val)
+{
+	writel(val, to_nvme_dev(ctrl)->bar + off);
+	return 0;
+}
+
+static int nvme_pci_reg_read64(struct nvme_ctrl *ctrl, u32 off, u64 *val)
+{
+	*val = readq(to_nvme_dev(ctrl)->bar + off);
+	return 0;
+}
+
+static const struct nvme_ctrl_ops nvme_pci_ctrl_ops = {
+	.name			= "pcie-lpm",
+	.module			= THIS_MODULE,
+	.reg_read32		= nvme_pci_reg_read32,
+	.reg_write32		= nvme_pci_reg_write32,
+	.reg_read64		= nvme_pci_reg_read64,
+};
+
+static int nvme_dev_map(struct nvme_dev *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev->dev);
+
+	if (pci_request_mem_regions(pdev, "nvme"))
+		return -ENODEV;
+
+	dev_dbg(dev->dev, "BAR0 allocated @%llx of size 0x%llx\n",
+		pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));
+	if (nvme_remap_bar(dev, NVME_REG_DBS + 4096))
+		goto release;
+
+	return 0;
+ release:
+	pci_release_mem_regions(pdev);
+	return -ENODEV;
+}
+
+/* Read Write Ops */
+int nvme_used_io_queues(struct nvme_dev *dev)
+{
+	return dev->lpm_dev.used_io_queues;
+}
+
+static struct nvme_id_ns *nvme_identify_ns(struct nvme_ctrl *ctrl,
+					   unsigned int nsid)
+{
+	struct nvme_id_ns *id;
+	struct nvme_command c = { };
+	struct nvme_dev *dev = to_nvme_dev(ctrl);
+	struct nvme_queue *q =  dev->queues[0];
+	dma_addr_t id_phys;
+	int error;
+
+	memset(&c, 0, sizeof(c));
+	c.identify.opcode = nvme_admin_identify;
+	c.identify.nsid = cpu_to_le32(nsid);
+	c.identify.cns = NVME_ID_CNS_NS;
+
+	id = dmam_alloc_coherent(dev->dev, sizeof(*id),
+				&id_phys, GFP_KERNEL);
+	if (!id)
+		return NULL;
+	c.identify.dptr.prp1 = id_phys;
+
+	error = nvme_submit_cmd_sync(&c, q, NULL);
+	if (error) {
+		dev_warn(ctrl->dev, "Identify namespace failed\n");
+		return NULL;
+	}
+
+	return id;
+}
+
+static void nvme_pci_free_prps(struct nvme_dev *dev)
+{
+	unsigned int i;
+	int page_size = dev->ctrl.page_size;
+
+	for (i = 0; i < dev->num_prp_pages; i++)
+		dma_free_coherent(dev->dev, page_size,
+				  dev->prp_addr[i].vaddr,
+				  dev->prp_addr[i].paddr);
+
+	vfree(dev->prp_addr);
+}
+
+static int nvme_pci_setup_prps(struct nvme_dev *dev, phys_addr_t *mem_addr,
+			       u64 *prp2, u16 lbas)
+{
+	struct nvme_lpm_dev *lpm_dev = &dev->lpm_dev;
+	unsigned int page_size = dev->ctrl.page_size;
+	unsigned int offset = *mem_addr & (page_size - 1);
+	int xfer_length = lbas << lpm_dev->lba_shift;
+	unsigned int nprps, i;
+	int current_memmap;
+	dma_addr_t *prp_list;
+	dma_addr_t prp_dma_addr;
+
+	xfer_length -= page_size - offset;
+	if (xfer_length <= 0) {
+		*prp2 = 0;
+		return 0;
+	}
+
+	current_memmap = get_current_memmap(*mem_addr);
+	check_memaddr(mem_addr, &current_memmap);
+
+	if (xfer_length) {
+		*mem_addr += page_size - offset;
+		check_memaddr(mem_addr, &current_memmap);
+	}
+
+	if (xfer_length <= page_size) {
+		*prp2 = *mem_addr;
+		return 0;
+	}
+
+	prp_list = dma_alloc_coherent(dev->dev, page_size,
+				      &prp_dma_addr, GFP_KERNEL);
+	if (!prp_list)
+		return -ENOMEM;
+
+	dev->prp_addr[dev->num_prp_pages].vaddr = prp_list;
+	dev->prp_addr[dev->num_prp_pages].paddr = prp_dma_addr;
+	dev->num_prp_pages++;
+
+	nprps = DIV_ROUND_UP(xfer_length, page_size);
+
+	for (i = 0; i < nprps; i++) {
+		prp_list[i] = cpu_to_le64(*mem_addr);
+		*mem_addr += page_size;
+		check_memaddr(mem_addr, &current_memmap);
+	}
+
+	*prp2 = prp_dma_addr;
+
+	return 0;
+}
+
+static int nvme_send_flush_cmd(void *ndev_cntxt)
+{
+	struct nvme_dev *dev = ndev_cntxt;
+	struct nvme_command cmnd = { };
+	unsigned int qid = nvme_used_io_queues(dev);
+	struct nvme_queue *q =  dev->queues[qid];
+	unsigned int timeout = dev->num_prp_pages * IO_CMD_TIMEOUT_MS;
+
+	memset(&cmnd, 0, sizeof(cmnd));
+
+	cmnd.common.opcode = nvme_cmd_flush;
+	cmnd.common.nsid = cpu_to_le32(1);
+
+	return __nvme_submit_cmd_sync(&cmnd, q, NULL, timeout);
+}
+
+static int nvme_build_io_queue(struct nvme_dev *ndev, int qid,
+			       phys_addr_t *mem_addr,
+			       int nsid, u64 slba, u16 lbas, bool write)
+{
+	struct nvme_command cmnd = { };
+	struct nvme_queue *q =  ndev->queues[qid];
+	struct device *dev = ndev->dev;
+	int error;
+	u64 prp2;
+
+	memset(&cmnd, 0, sizeof(cmnd));
+
+	if (write)
+		cmnd.rw.opcode = nvme_cmd_write;
+	else
+		cmnd.rw.opcode = nvme_cmd_read;
+
+	cmnd.rw.nsid = cpu_to_le32(nsid);
+
+	cmnd.rw.slba = cpu_to_le64(slba);
+	cmnd.rw.length = cpu_to_le16(lbas - 1);
+
+	cmnd.rw.dptr.prp1 = cpu_to_le64(*mem_addr);
+
+	error = nvme_pci_setup_prps(ndev, mem_addr, &prp2, lbas);
+	if (error) {
+		dev_warn(dev, "PRP setup for SQ%d entry-%d failed\n",
+				q->qid, cmnd.rw.command_id);
+		return -EIO;
+	}
+
+	cmnd.rw.dptr.prp2 = cpu_to_le64(prp2);
+
+	error = nvme_submit_cmd(&cmnd, q);
+	if (error) {
+		dev_warn(dev, "SQ%d entry-%d failed\n", q->qid, q->cmd_id);
+		return -EIO;
+	}
+	dev_dbg(dev, "SQ%d entry-%d done\n", q->qid, q->cmd_id);
+
+	return 0;
+}
+
+static int nvme_alloc_ns(struct nvme_ctrl *ctrl, unsigned int nsid)
+{
+	struct nvme_id_ns *id;
+	int lba_shift;
+	struct nvme_dev *dev = to_nvme_dev(ctrl);
+
+	id = nvme_identify_ns(ctrl, nsid);
+	if (!id)
+		return -EINVAL;
+
+	if (id->ncap == 0)
+		return -EINVAL;
+
+	lba_shift = id->lbaf[id->flbas & NVME_NS_FLBAS_LBA_MASK].ds;
+	dev->lpm_dev.lba_shift = lba_shift;
+
+	return 0;
+}
+
+static int nvme_initiate_xfers(void *ndev_cntxt)
+{
+	struct nvme_dev *ndev = ndev_cntxt;
+	unsigned int qid, used_queues = nvme_used_io_queues(ndev);
+	struct nvme_queue *q;
+
+	/* Ringing SQDB for all Qs */
+	for (qid = 1; qid <= used_queues; qid++) {
+		q = ndev->queues[qid];
+		dev_info(ndev->dev, "qid:%d q->sq_tail:%d", q->qid, q->sq_tail);
+		writel(q->sq_tail, q->q_db);
+	}
+
+	return 0;
+}
+
+static void nvme_poll_xfers_on_queue(struct nvme_dev *dev, int qid)
+{
+	struct nvme_queue *q = dev->queues[qid];
+	int consumed;
+
+	if (q->poll_done)
+		return;
+
+	dev_dbg(dev->dev, "polling on CQ%d, entries seen till now: %d",
+				qid, q->cqe_seen);
+	nvme_poll(q, q->cmd_id);
+	consumed = q->cqe_seen;
+	if (consumed == q->cmd_id) {
+		q->poll_done = true;
+		dev_info(dev->dev, "CQ%d poll done", qid);
+	}
+}
+
+static int nvme_poll_xfers(void *ndev_cntxt)
+{
+	struct nvme_dev *dev = ndev_cntxt;
+	unsigned int qid, polled_cqs;
+	unsigned int used_queues = nvme_used_io_queues(dev);
+	int timeout = dev->num_prp_pages * IO_CMD_TIMEOUT_MS;
+	struct nvme_queue *q;
+
+	while (timeout--) {
+		polled_cqs = 0;
+
+		for (qid = 1; qid <= used_queues; qid++) {
+			q = dev->queues[qid];
+
+			if (q->poll_done)
+				polled_cqs++;
+
+			nvme_poll_xfers_on_queue(dev, qid);
+		}
+
+		if (polled_cqs == used_queues)
+			break;
+
+		usleep_range(1000, 1010);
+	}
+
+	if (timeout < 0)
+		return -ETIMEDOUT;
+	else
+		return 0;
+}
+
+/**
+ * nvme_destroy_backup_io_queues: Destroy any previously created command Qs
+ */
+static int nvme_destroy_backup_io_queues(void *ndev_cntxt)
+{
+	int i;
+	struct nvme_dev *dev = ndev_cntxt;
+	struct nvme_queue *nvmeq;
+
+	if (dev->online_queues == 1)
+		return 0;
+
+	dev_info(dev->dev, "online Qs: %d", dev->online_queues);
+	/* reset the IO Queues */
+	for (i = dev->ctrl.queue_count - 1; i >= 1; i--) {
+		nvmeq = dev->queues[i];
+		if (adapter_delete_sq(dev, i)) {
+			dev_err(dev->dev, "SQ-%d deletion failed", i);
+			return -EIO;
+		}
+		if (adapter_delete_cq(dev, i)) {
+			dev_err(dev->dev, "CQ-%d deletion failed", i);
+			return -EIO;
+		}
+		dev->online_queues--;
+
+		dma_free_coherent(dev->dev, SQ_SIZE(dev->q_depth),
+				  (void *)nvmeq->sq_cmds, nvmeq->sq_dma_addr);
+		dma_free_coherent(dev->dev, CQ_SIZE(dev->q_depth),
+				  (void *)nvmeq->cqes, nvmeq->cq_dma_addr);
+		dev->ctrl.queue_count--;
+		dev_dbg(dev->dev, "QP-%d deletion done", i);
+	}
+	dev_info(dev->dev, "online Qs: %d", dev->online_queues);
+
+	nvme_pci_free_prps(dev);
+
+	return 0;
+}
+
+struct nvme_lpm_data {
+	unsigned int used_queues;
+	unsigned int q_depth;
+	unsigned int sq_addr[MAX_IO_QPAIR + 1];
+	unsigned int cq_addr[MAX_IO_QPAIR + 1];
+	unsigned int last_cmd_id[MAX_IO_QPAIR + 1];
+	unsigned int bar;
+};
+
+static void nvme_put_shared_data(struct nvme_dev *ndev, void *shared_data)
+{
+	int i;
+	struct nvme_lpm_data *data = shared_data;
+	struct pci_dev *pdev = to_pci_dev(ndev->dev);
+
+	data->used_queues = nvme_used_io_queues(ndev);
+	data->q_depth = ndev->q_depth;
+
+	for (i = 0; i < ndev->online_queues; i++) {
+		/* put SQ addresses */
+		data->sq_addr[i] = ndev->queues[i]->sq_dma_addr;
+		/* put CQ addresses */
+		data->cq_addr[i] = ndev->queues[i]->cq_dma_addr;
+		/* put last cmd_id for each used QP */
+		data->last_cmd_id[i] = ndev->queues[i]->cmd_id;
+	}
+
+	/* put nvme registers(BAR0) address */
+	data->bar = pci_resource_start(pdev, 0);
+}
+
+/**
+ * nvme_build_backup_io_queues - Build NVMe command queue as per memory backup
+ *				 requirement
+ * @ blknr: starting backup NVMe logical block address (SLBA)
+ * @ mem_addr : starting backup memory address
+ * @ xfer_length: data transfer length in bytes, corresponding required logical
+ *		  block count is stoted in blkcnt
+ * @ write: when set, nvme write is done; when unset, nvme read is done
+ * @ data: pointer to memory region shared with CRMU for CQ polling,
+ *	   this region must be mapped prior to using it
+ */
+static int nvme_build_backup_io_queues(void *ndev_cntxt, u64 mem_addr,
+				       u64 blknr, u64 xfer_length, bool write,
+				       void *data)
+{
+	struct nvme_dev *dev = ndev_cntxt;
+	struct nvme_lpm_dev *lpm_dev = &dev->lpm_dev;
+	unsigned int lba_shift, i = 0, qid = 1;
+	u64 blkcnt;
+	u16 max_lbas_per_xfer;
+	int ret;
+
+	if (get_current_memmap(mem_addr) < 0) {
+		dev_err(dev->dev, "Invalid memory address!\n");
+		return -EINVAL;
+	}
+
+	ret = nvme_setup_io_queues(dev);
+	if (ret) {
+		dev_err(dev->dev, "Failed to setup io queues!\n");
+		return -EIO;
+	}
+	dev_info(dev->dev, "online Qs: %d", dev->online_queues);
+
+	dev->prp_addr = vmalloc((dev->max_qid) * (dev->q_depth)
+				* sizeof(struct prp_list_addr));
+	if (!dev->prp_addr)
+		return -ENOMEM;
+	dev->num_prp_pages = 0;
+
+	/* At least 1 IO Queue will be used */
+	lpm_dev->used_io_queues = 1;
+
+	lba_shift = lpm_dev->lba_shift;
+	blkcnt = DIV_ROUND_UP(xfer_length, 1 << lba_shift);
+	max_lbas_per_xfer = 1 << (lpm_dev->max_transfer_shift - lba_shift);
+
+	dev_info(dev->dev, "requested xfer size:%#llx->lbas:%#llx;"
+		 "max_lbas_per_xfer:%#x start mem_addr:%#llx start lba: %#llx",
+		 xfer_length, blkcnt, max_lbas_per_xfer, mem_addr, blknr);
+
+	do {
+		if (blkcnt < max_lbas_per_xfer) {
+			max_lbas_per_xfer = blkcnt;
+			blkcnt = 0;
+		} else
+			blkcnt -= max_lbas_per_xfer;
+
+		if (i == dev->q_depth - 1) {
+			dev_info(dev->dev, "Q%d is full now", qid);
+			qid++;
+			lpm_dev->used_io_queues++;
+			i = 0;
+		}
+
+		ret = nvme_build_io_queue(dev, qid, &mem_addr, 1, blknr,
+					  max_lbas_per_xfer, write);
+		if (ret < 0)
+			return ret;
+
+		blknr += max_lbas_per_xfer;
+
+		i++;
+	} while (blkcnt);
+
+	dev_info(dev->dev, "command queues(%d) built", qid);
+	dev_info(dev->dev, "last lba:%#llx last mem_addr:%#llx",
+		 blknr, mem_addr);
+
+	/* share NVMe device queues data with CRMU */
+	if (data) {
+		nvme_put_shared_data(dev, data);
+		dev_info(dev->dev, "NVMe data shared with CRMU\n");
+	}
+
+	return 0;
+}
+
+struct nvme_lpm_drv_ops nvme_lpm_driver_ops = {
+	.nvme_destroy_backup_io_queues = nvme_destroy_backup_io_queues,
+	.nvme_build_backup_io_queues = nvme_build_backup_io_queues,
+	.nvme_initiate_xfers = nvme_initiate_xfers,
+	.nvme_poll_xfers = nvme_poll_xfers,
+	.nvme_send_flush_cmd = nvme_send_flush_cmd,
+};
+
+static int nvme_lpm_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	int ret = -ENOMEM;
+	struct nvme_dev *dev;
+	struct nvme_ctrl *ctrl;
+	struct nvme_lpm_dev *lpm_dev;
+	struct nvme_id_ctrl *id_ctrl;
+	unsigned int nn;
+	int min_page_shift;
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	dev->queues = devm_kzalloc(&pdev->dev,
+			(MAX_IO_QPAIR + 1) * sizeof(void *), GFP_KERNEL);
+	if (!dev->queues)
+		return -ENOMEM;
+
+	dev->dev = get_device(&pdev->dev);
+	pci_set_drvdata(pdev, dev);
+	lpm_dev = &dev->lpm_dev;
+
+	/* ioremap the nvme bar registers(IORESOURCE_MEM) to outbound memory */
+	ret = nvme_dev_map(dev);
+	if (ret)
+		goto put_pci;
+
+	/* nvme controller regs read-write callbacks */
+	ctrl = &dev->ctrl;
+	ctrl->dev = dev->dev;
+	ctrl->ops = &nvme_pci_ctrl_ops;
+
+	ret = register_nvme_lpm_ops(&nvme_lpm_driver_ops);
+	if (ret) {
+		dev_err(dev->dev, "Failed to register LPM ioctls\n");
+		goto put_pci;
+	}
+	nvme_lpm_driver_ops.ctxt = dev;
+
+	ret = nvme_pci_enable(dev);
+	if (ret)
+		goto put_pci;
+
+	ret = nvme_pci_configure_admin_queue(dev);
+	if (ret)
+		goto put_pci;
+
+	/* nvme_init_identify: identify controller */
+	ret = nvme_ctrl_init_identify(ctrl, &id_ctrl);
+	if (ret)
+		goto put_pci;
+
+	dev_info(dev->dev, "pci-lpm function %s\n", dev_name(&pdev->dev));
+
+	/* Honor RTD3 entry latency if provided */
+	if (id_ctrl->rtd3e) {
+		/* us -> s */
+		u32 transition_time = le32_to_cpu(id_ctrl->rtd3e) / 1000000;
+
+		/* Latency value clamped to a range of 5 to 60 seconds */
+		ctrl->shutdown_timeout = clamp_t(unsigned int, transition_time,
+						 SHUTDOWN_TIMEOUT_SEC, 60);
+
+		if (ctrl->shutdown_timeout != SHUTDOWN_TIMEOUT_SEC)
+			dev_warn(dev->dev,
+				 "Shutdown timeout set to %u seconds\n",
+				 dev->ctrl.shutdown_timeout);
+	} else
+		ctrl->shutdown_timeout = SHUTDOWN_TIMEOUT_SEC;
+
+	min_page_shift = NVME_CAP_MPSMIN(ctrl->cap) + MIN_PAGE_SHIFT_CTRL;
+	if (!id_ctrl->mdts)
+		/**
+		 * Maximum Data Transfer Size (MDTS) field indicates the maximum
+		 * data transfer size between the host and the controller.
+		 * The Spec says value of 0h indicates no restrictions on
+		 * transfer size. We default to 2 MB in such case.
+		 */
+		lpm_dev->max_transfer_shift = 21;
+	else
+		lpm_dev->max_transfer_shift = (id_ctrl->mdts + min_page_shift);
+
+	nn = le32_to_cpu(id_ctrl->nn);
+	if (nn > 1) {
+		dev_err(dev->dev, "Multiple namespaces not supported");
+		ret = -ENOTSUPP;
+		goto put_pci;
+	}
+
+	ret = nvme_alloc_ns(ctrl, nn);
+	if (ret) {
+		dev_err(dev->dev, "Invalid namespace");
+		goto put_pci;
+	}
+
+	return 0;
+
+put_pci:
+	put_device(dev->dev);
+	return ret;
+}
+
+static const struct pci_device_id nvme_lpm_id_table[] = {
+	{ PCI_VDEVICE(INTEL, 0x0953), },    /* Intel 750 SSD */
+	{ PCI_DEVICE(0x144d, 0xa804), },    /* Samsung SM961/PM961 SSD */
+	{ PCI_DEVICE(0x126f, 0x2263), },    /* Silicon Motion SSD */
+};
+
+static void nvme_lpm_remove(struct pci_dev *pdev)
+{
+	struct nvme_dev *dev = pci_get_drvdata(pdev);
+
+	unregister_nvme_lpm_ops();
+	nvme_destroy_backup_io_queues(dev);
+
+	if (!pci_device_is_present(pdev))
+		nvme_dev_disable(dev, false);
+
+	nvme_dev_disable(dev, true);
+	nvme_dev_unmap(dev);
+}
+
+static struct pci_driver nvme_driver = {
+	.name		= "nvme-lpm",
+	.id_table	= nvme_lpm_id_table,
+	.probe		= nvme_lpm_probe,
+	.remove		= nvme_lpm_remove,
+};
+
+module_pci_driver(nvme_driver);
+
+MODULE_AUTHOR("Abhishek Shah <abhishek.shah@broadcom.com>");
+MODULE_DESCRIPTION("Low Power Mode Memory backup driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@ -1196,9 +1196,6 @@ static void nvme_disable_admin_queue(struct nvme_dev *dev, bool shutdown)
 {
 	struct nvme_queue *nvmeq = &dev->queues[0];
 
-	if (nvme_suspend_queue(nvmeq))
-		return;
-
 	if (shutdown)
 		nvme_shutdown_ctrl(&dev->ctrl);
 	else
@@ -1884,9 +1881,9 @@ static int nvme_delete_queue(struct nvme_queue *nvmeq, u8 opcode)
 	return 0;
 }
 
-static void nvme_disable_io_queues(struct nvme_dev *dev, int queues)
+static void nvme_disable_io_queues(struct nvme_dev *dev)
 {
-	int pass;
+	int pass, queues = dev->online_queues - 1;
 	unsigned long timeout;
 	u8 opcode = nvme_admin_delete_sq;
 
@@ -2045,7 +2042,7 @@ static void nvme_pci_disable(struct nvme_dev *dev)
 
 static void nvme_dev_disable(struct nvme_dev *dev, bool shutdown)
 {
-	int i, queues;
+	int i;
 	bool dead = true;
 	struct pci_dev *pdev = to_pci_dev(dev->dev);
 
@@ -2067,7 +2064,11 @@ static void nvme_dev_disable(struct nvme_dev *dev, bool shutdown)
 	if (!dead) {
 		if (shutdown)
 			nvme_wait_freeze_timeout(&dev->ctrl, NVME_IO_TIMEOUT);
+	}
 
+	nvme_stop_queues(&dev->ctrl);
+
+	if (!dead && dev->ctrl.queue_count > 0) {
 		/*
 		 * If the controller is still alive tell it to stop using the
 		 * host memory buffer.  In theory the shutdown / reset should
@@ -2076,25 +2077,12 @@ static void nvme_dev_disable(struct nvme_dev *dev, bool shutdown)
 		 */
 		if (dev->host_mem_descs)
 			nvme_set_host_mem(dev, 0);
-
+		nvme_disable_io_queues(dev);
+		nvme_disable_admin_queue(dev, shutdown);
 	}
-	nvme_stop_queues(&dev->ctrl);
-
-	queues = dev->online_queues - 1;
-	for (i = dev->ctrl.queue_count - 1; i > 0; i--)
+	for (i = dev->ctrl.queue_count - 1; i >= 0; i--)
 		nvme_suspend_queue(&dev->queues[i]);
 
-	if (dead) {
-		/* A device might become IO incapable very soon during
-		 * probe, before the admin queue is configured. Thus,
-		 * queue_count can be 0 here.
-		 */
-		if (dev->ctrl.queue_count)
-			nvme_suspend_queue(&dev->queues[0]);
-	} else {
-		nvme_disable_io_queues(dev, queues);
-		nvme_disable_admin_queue(dev, shutdown);
-	}
 	nvme_pci_disable(dev);
 
 	blk_mq_tagset_busy_iter(&dev->tagset, nvme_cancel_request, &dev->ctrl);
--- a/drivers/nvmem/bcm-ocotp.c
+++ b/drivers/nvmem/bcm-ocotp.c
@@ -11,13 +11,14 @@
  * GNU General Public License for more details.
  */
 
+#include <linux/acpi.h>
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/nvmem-provider.h>
 #include <linux/of.h>
-#include <linux/of_address.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
 
 /*
@@ -65,16 +66,22 @@ struct otpc_map {
 	u16 data_w_offset[4];
 };
 
-static struct otpc_map otp_map = {
-	.otpc_row_size = 1,
-	.data_r_offset = {0x10},
-	.data_w_offset = {0x2c},
+enum otpc_map_type {
+	OTP_MAP_V1,
+	OTP_MAP_V2,
 };
 
-static struct otpc_map otp_map_v2 = {
-	.otpc_row_size = 2,
-	.data_r_offset = {0x10, 0x5c},
-	.data_w_offset = {0x2c, 0x64},
+static struct otpc_map otp_map[] = {
+	[OTP_MAP_V1] = {
+		.otpc_row_size = 1,
+		.data_r_offset = {0x10},
+		.data_w_offset = {0x2c},
+	},
+	[OTP_MAP_V2] = {
+		.otpc_row_size = 2,
+		.data_r_offset = {0x10, 0x5c},
+		.data_w_offset = {0x2c, 0x64},
+	}
 };
 
 struct otpc_priv {
@@ -238,35 +245,51 @@ static int bcm_otpc_write(void *context, unsigned int offset, void *val,
 };
 
 static const struct of_device_id bcm_otpc_dt_ids[] = {
-	{ .compatible = "brcm,ocotp" },
-	{ .compatible = "brcm,ocotp-v2" },
+	{ .compatible = "brcm,ocotp", .data = (void *)OTP_MAP_V1 },
+	{ .compatible = "brcm,ocotp-v2", .data = (void *)OTP_MAP_V2 },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, bcm_otpc_dt_ids);
 
+static const struct acpi_device_id bcm_otpc_acpi_ids[] = {
+	{ .id = "BRCM0700", .driver_data = OTP_MAP_V1 },
+	{ .id = "BRCM0701", .driver_data = OTP_MAP_V2 },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(acpi, bcm_otpc_acpi_ids);
+
 static int bcm_otpc_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct device_node *dn = dev->of_node;
+	const struct of_device_id *match;
+	const struct acpi_device_id *acpi_id;
 	struct resource *res;
 	struct otpc_priv *priv;
 	struct nvmem_device *nvmem;
 	int err;
 	u32 num_words;
+	enum otpc_map_type map_type;
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
-	if (of_device_is_compatible(dev->of_node, "brcm,ocotp"))
-		priv->map = &otp_map;
-	else if (of_device_is_compatible(dev->of_node, "brcm,ocotp-v2"))
-		priv->map = &otp_map_v2;
-	else {
-		dev_err(&pdev->dev,
-			"%s otpc config map not defined\n", __func__);
-		return -EINVAL;
-	}
+	if (dev->of_node) {
+		match = of_match_device(bcm_otpc_dt_ids, dev);
+		if (match)
+			map_type = (enum otpc_map_type)match->data;
+		else
+			return -ENODEV;
+	} else if (has_acpi_companion(dev)) {
+		acpi_id = acpi_match_device(bcm_otpc_acpi_ids, dev);
+		if (acpi_id)
+			map_type = (enum otpc_map_type)acpi_id->driver_data;
+		else
+			return -ENODEV;
+	} else
+		return -ENODEV;
+
+	priv->map = &otp_map[map_type];
 
 	/* Get OTP base address register. */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -283,7 +306,7 @@ static int bcm_otpc_probe(struct platform_device *pdev)
 	reset_start_bit(priv->base);
 
 	/* Read size of memory in words. */
-	err = of_property_read_u32(dn, "brcm,ocotp-size", &num_words);
+	err = device_property_read_u32(dev, "brcm,ocotp-size", &num_words);
 	if (err) {
 		dev_err(dev, "size parameter not specified\n");
 		return -EINVAL;
@@ -296,7 +319,7 @@ static int bcm_otpc_probe(struct platform_device *pdev)
 	bcm_otpc_nvmem_config.dev = dev;
 	bcm_otpc_nvmem_config.priv = priv;
 
-	if (of_device_is_compatible(dev->of_node, "brcm,ocotp-v2")) {
+	if (map_type == OTP_MAP_V2) {
 		bcm_otpc_nvmem_config.word_size = 8;
 		bcm_otpc_nvmem_config.stride = 8;
 	}
@@ -327,6 +350,7 @@ static int bcm_otpc_remove(struct platform_device *pdev)
 	.driver = {
 		.name	= "brcm-otpc",
 		.of_match_table = bcm_otpc_dt_ids,
+		.acpi_match_table = ACPI_PTR(bcm_otpc_acpi_ids),
 	},
 };
 module_platform_driver(bcm_otpc_driver);
--- a/drivers/of/of_pci.c
+++ b/drivers/of/of_pci.c
@@ -338,6 +338,7 @@ int of_pci_map_rid(struct device_node *np, u32 rid,
 		of_property_read_u32(np, map_mask_name, &map_mask);
 
 	masked_rid = map_mask & rid;
+
 	for ( ; map_len > 0; map_len -= 4 * sizeof(*map), map += 4) {
 		struct device_node *phandle_node;
 		u32 rid_base = be32_to_cpup(map + 0);
--- a/drivers/pci/access.c
+++ b/drivers/pci/access.c
@@ -161,9 +161,19 @@ int pci_generic_config_write32(struct pci_bus *bus, unsigned int devfn,
 	 * write happen to have any RW1C (write-one-to-clear) bits set, we
 	 * just inadvertently cleared something we shouldn't have.
 	 */
+
+	/*
+	 * FIXME
+	 *
+	 * Disable the following warning print from open source PCI stack to
+	 * prevent developers from mistakenly treating this warning as fatal
+	 * errors
+	 */
+#if 0
 	dev_warn_ratelimited(&bus->dev, "%d-byte config write to %04x:%02x:%02x.%d offset %#x may corrupt adjacent RW1C bits\n",
 			     size, pci_domain_nr(bus), bus->number,
 			     PCI_SLOT(devfn), PCI_FUNC(devfn), where);
+#endif
 
 	mask = ~(((1 << (size * 8)) - 1) << ((where & 0x3) * 8));
 	tmp = readl(addr) & mask;
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -311,6 +311,7 @@ void __weak pcibios_bus_add_device(struct pci_dev *pdev) { }
 void pci_bus_add_device(struct pci_dev *dev)
 {
 	int retval;
+	unsigned long flags;
 
 	/*
 	 * Can not put in pci_device_add yet because resources
@@ -331,7 +332,9 @@ void pci_bus_add_device(struct pci_dev *dev)
 		return;
 	}
 
+	spin_lock_irqsave(&dev->lock, flags);
 	dev->is_added = 1;
+	spin_unlock_irqrestore(&dev->lock, flags);
 }
 EXPORT_SYMBOL_GPL(pci_bus_add_device);
 
--- a/drivers/pci/host/Makefile
+++ b/drivers/pci/host/Makefile
@@ -36,3 +36,4 @@ obj-$(CONFIG_VMD) += vmd.o
 obj-$(CONFIG_ARM64) += pci-thunder-ecam.o
 obj-$(CONFIG_ARM64) += pci-thunder-pem.o
 obj-$(CONFIG_ARM64) += pci-xgene.o
+obj-$(CONFIG_ARM64) += pcie-iproc.o pcie-iproc-ecam.o
--- /dev/null
+++ b/drivers/pci/host/pcie-iproc-ecam.c
@@ -0,0 +1,59 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 Broadcom
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/pci-acpi.h>
+#include <linux/pci-ecam.h>
+
+#include "pcie-iproc.h"
+#include "../pci.h"
+
+#if defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS)
+
+static int iproc_pcie_ecam_init(struct pci_config_window *cfg)
+{
+	struct device *dev = cfg->parent;
+	struct iproc_pcie *pcie;
+	struct resource *res = &cfg->res;
+	struct pci_host_bridge *bridge;
+	int ret;
+
+	bridge = devm_pci_alloc_host_bridge(dev, sizeof(*pcie));
+	if (!bridge)
+		return -ENOMEM;
+	pcie = pci_host_bridge_priv(bridge);
+
+	pcie->dev = dev;
+	pcie->type = IPROC_PCIE_PAXC_V2;
+
+	pcie->base = devm_pci_remap_cfgspace(dev, res->start,
+					     resource_size(res));
+	if (!pcie->base) {
+		dev_err(dev, "unable to map controller registers\n");
+		return -ENOMEM;
+	}
+	pcie->base_addr = res->start;
+	cfg->priv = pcie;
+
+	ret = iproc_pcie_rev_init(pcie);
+	if (ret) {
+		dev_err(dev, "unable to initialize iProc PCIe controller\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+struct pci_ecam_ops iproc_pcie_paxcv2_ecam_ops = {
+	.init = iproc_pcie_ecam_init,
+	.pci_ops = {
+		.map_bus = iproc_pcie_bus_map_cfg_bus,
+		.read = iproc_pcie_config_read32,
+		.write = iproc_pcie_config_write32,
+	}
+};
+
+#endif
--- a/drivers/pci/host/pcie-iproc-msi.c
+++ b/drivers/pci/host/pcie-iproc-msi.c
@@ -377,7 +377,7 @@ static void iproc_msi_handler(struct irq_desc *desc)
 	chained_irq_exit(chip, desc);
 }
 
-static void iproc_msi_enable(struct iproc_msi *msi)
+void iproc_msi_enable(struct iproc_msi *msi)
 {
 	int i, eq;
 	u32 val;
@@ -419,8 +419,9 @@ static void iproc_msi_enable(struct iproc_msi *msi)
 		}
 	}
 }
+EXPORT_SYMBOL(iproc_msi_enable);
 
-static void iproc_msi_disable(struct iproc_msi *msi)
+void iproc_msi_disable(struct iproc_msi *msi)
 {
 	u32 eq, val;
 
@@ -437,6 +438,7 @@ static void iproc_msi_disable(struct iproc_msi *msi)
 		iproc_msi_write_reg(msi, IPROC_MSI_CTRL, eq, val);
 	}
 }
+EXPORT_SYMBOL(iproc_msi_disable);
 
 static int iproc_msi_alloc_domains(struct device_node *node,
 				   struct iproc_msi *msi)
--- a/drivers/pci/host/pcie-iproc-platform.c
+++ b/drivers/pci/host/pcie-iproc-platform.c
@@ -78,6 +78,8 @@ static int iproc_pcie_pltfm_probe(struct platform_device *pdev)
 	}
 	pcie->base_addr = reg.start;
 
+	pcie->irq = platform_get_irq(pdev, 0);
+
 	if (of_property_read_bool(np, "brcm,pcie-ob")) {
 		u32 val;
 
@@ -141,21 +143,43 @@ static int iproc_pcie_pltfm_remove(struct platform_device *pdev)
 	return iproc_pcie_remove(pcie);
 }
 
-static void iproc_pcie_pltfm_shutdown(struct platform_device *pdev)
+#ifdef CONFIG_PM_SLEEP
+static int iproc_pcie_pltfm_suspend(struct device *dev)
 {
+	struct platform_device *pdev = to_platform_device(dev);
 	struct iproc_pcie *pcie = platform_get_drvdata(pdev);
 
-	iproc_pcie_shutdown(pcie);
+	return iproc_pcie_suspend(pcie);
 }
 
+static int iproc_pcie_pltfm_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct iproc_pcie *pcie = platform_get_drvdata(pdev);
+
+	return iproc_pcie_resume(pcie);
+}
+#endif
+
+static const struct dev_pm_ops iproc_pcie_pltfm_pm_ops = {
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(iproc_pcie_pltfm_suspend,
+				      iproc_pcie_pltfm_resume)
+};
+
+#ifdef CONFIG_PM_SLEEP
+#define IPROC_PCIE_PLTFM_PM_OPS (&iproc_pcie_pltfm_pm_ops)
+#else
+#define IPROC_PCIE_PLTFM_PM_OPS NULL
+#endif /* CONFIG_PM */
+
 static struct platform_driver iproc_pcie_pltfm_driver = {
 	.driver = {
 		.name = "iproc-pcie",
 		.of_match_table = of_match_ptr(iproc_pcie_of_match_table),
+		.pm = IPROC_PCIE_PLTFM_PM_OPS,
 	},
 	.probe = iproc_pcie_pltfm_probe,
 	.remove = iproc_pcie_pltfm_remove,
-	.shutdown = iproc_pcie_pltfm_shutdown,
 };
 module_platform_driver(iproc_pcie_pltfm_driver);
 
--- a/drivers/pci/host/pcie-iproc.c
+++ b/drivers/pci/host/pcie-iproc.c
@@ -12,6 +12,7 @@
  * GNU General Public License for more details.
  */
 
+#include <linux/acpi.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/msi.h>
@@ -22,54 +23,70 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/irqchip/arm-gic-v3.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/pci-ecam.h>
 #include <linux/platform_device.h>
 #include <linux/of_address.h>
 #include <linux/of_pci.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/phy/phy.h>
-
 #include "pcie-iproc.h"
 
-#define EP_PERST_SOURCE_SELECT_SHIFT	2
-#define EP_PERST_SOURCE_SELECT		BIT(EP_PERST_SOURCE_SELECT_SHIFT)
-#define EP_MODE_SURVIVE_PERST_SHIFT	1
-#define EP_MODE_SURVIVE_PERST		BIT(EP_MODE_SURVIVE_PERST_SHIFT)
-#define RC_PCIE_RST_OUTPUT_SHIFT	0
-#define RC_PCIE_RST_OUTPUT		BIT(RC_PCIE_RST_OUTPUT_SHIFT)
-#define PAXC_RESET_MASK			0x7f
-
-#define GIC_V3_CFG_SHIFT		0
-#define GIC_V3_CFG			BIT(GIC_V3_CFG_SHIFT)
-
-#define MSI_ENABLE_CFG_SHIFT		0
-#define MSI_ENABLE_CFG			BIT(MSI_ENABLE_CFG_SHIFT)
-
-#define CFG_IND_ADDR_MASK		0x00001ffc
-
-#define CFG_ADDR_BUS_NUM_SHIFT		20
-#define CFG_ADDR_BUS_NUM_MASK		0x0ff00000
-#define CFG_ADDR_DEV_NUM_SHIFT		15
-#define CFG_ADDR_DEV_NUM_MASK		0x000f8000
-#define CFG_ADDR_FUNC_NUM_SHIFT		12
-#define CFG_ADDR_FUNC_NUM_MASK		0x00007000
-#define CFG_ADDR_REG_NUM_SHIFT		2
-#define CFG_ADDR_REG_NUM_MASK		0x00000ffc
-#define CFG_ADDR_CFG_TYPE_SHIFT		0
-#define CFG_ADDR_CFG_TYPE_MASK		0x00000003
-
-#define SYS_RC_INTX_MASK		0xf
-
-#define PCIE_PHYLINKUP_SHIFT		3
-#define PCIE_PHYLINKUP			BIT(PCIE_PHYLINKUP_SHIFT)
-#define PCIE_DL_ACTIVE_SHIFT		2
-#define PCIE_DL_ACTIVE			BIT(PCIE_DL_ACTIVE_SHIFT)
-
-#define APB_ERR_EN_SHIFT		0
-#define APB_ERR_EN			BIT(APB_ERR_EN_SHIFT)
-
-#define CFG_RETRY_STATUS		0xffff0001
-#define CFG_RETRY_STATUS_TIMEOUT_US	500000 /* 500 milliseconds */
+#define EP_PERST_SOURCE_SELECT_SHIFT 2
+#define EP_PERST_SOURCE_SELECT       BIT(EP_PERST_SOURCE_SELECT_SHIFT)
+#define EP_MODE_SURVIVE_PERST_SHIFT  1
+#define EP_MODE_SURVIVE_PERST        BIT(EP_MODE_SURVIVE_PERST_SHIFT)
+#define RC_PCIE_RST_OUTPUT_SHIFT     0
+#define RC_PCIE_RST_OUTPUT           BIT(RC_PCIE_RST_OUTPUT_SHIFT)
+#define PAXC_RESET_MASK              0x7f
+
+#define GIC_V3_CFG_SHIFT             0
+#define GIC_V3_CFG                   BIT(GIC_V3_CFG_SHIFT)
+
+#define MSI_ENABLE_CFG_SHIFT         0
+#define MSI_ENABLE_CFG               BIT(MSI_ENABLE_CFG_SHIFT)
+
+#define CFG_IND_ADDR_MASK            0x00001ffc
+
+#define CFG_ADDR_BUS_NUM_SHIFT       20
+#define CFG_ADDR_BUS_NUM_MASK        0x0ff00000
+#define CFG_ADDR_DEV_NUM_SHIFT       15
+#define CFG_ADDR_DEV_NUM_MASK        0x000f8000
+#define CFG_ADDR_FUNC_NUM_SHIFT      12
+#define CFG_ADDR_FUNC_NUM_MASK       0x00007000
+#define CFG_ADDR_REG_NUM_SHIFT       2
+#define CFG_ADDR_REG_NUM_MASK        0x00000ffc
+#define CFG_ADDR_CFG_TYPE_SHIFT      0
+#define CFG_ADDR_CFG_TYPE_MASK       0x00000003
+
+#define SYS_RC_INTX_MASK             0xf
+
+#define PCIE_PHYLINKUP_SHIFT         3
+#define PCIE_PHYLINKUP               BIT(PCIE_PHYLINKUP_SHIFT)
+#define PCIE_DL_ACTIVE_SHIFT         2
+#define PCIE_DL_ACTIVE               BIT(PCIE_DL_ACTIVE_SHIFT)
+
+#define CFG_RC_LTSSM                 0x1cf8
+#define CFG_RC_PHY_CTL               0x1804
+#define CFG_RC_LTSSM_TIMEOUT         1000
+#define CFG_RC_LTSSM_STATE_MASK      0xff
+#define CFG_RC_LTSSM_STATE_L1        0x1
+
+#define CFG_RC_CLR_LTSSM_HIST_SHIFT  29
+#define CFG_RC_CLR_LTSSM_HIST_MASK   BIT(CFG_RC_CLR_LTSSM_HIST_SHIFT)
+#define CFG_RC_CLR_RECOV_HIST_SHIFT  31
+#define CFG_RC_CLR_RECOV_HIST_MASK   BIT(CFG_RC_CLR_RECOV_HIST_SHIFT)
+
+#define APB_ERR_EN_SHIFT             0
+#define APB_ERR_EN                   BIT(APB_ERR_EN_SHIFT)
+
+#define CFG_RD_SUCCESS               0
+#define CFG_RD_UR                    1
+#define CFG_RD_CRS                   2
+#define CFG_RD_CA                    3
+#define CFG_RETRY_STATUS             0xffff0001
+#define CFG_RETRY_STATUS_TIMEOUT_US  500000 /* 500 milli-seconds. */
 
 /* derive the enum index of the outbound/inbound mapping registers */
 #define MAP_REG(base_reg, index)	((base_reg) + (index) * 2)
@@ -93,10 +110,16 @@
 #define IMAP_VALID_SHIFT		0
 #define IMAP_VALID			BIT(IMAP_VALID_SHIFT)
 
+#define IPROC_PCI_PM_CAP		0x48
+#define IPROC_PCI_PM_CAP_MASK		0xffff
 #define IPROC_PCI_EXP_CAP		0xac
 
 #define IPROC_PCIE_REG_INVALID		0xffff
 
+#define NUM_INTX                     4
+
+#define HOTPLUG_DEBOUNCE             100
+
 /**
  * iProc PCIe outbound mapping controller specific parameters
  *
@@ -272,6 +295,7 @@ enum iproc_pcie_reg {
 
 	/* enable INTx */
 	IPROC_PCIE_INTX_EN,
+	IPROC_PCIE_INTX_CSR,
 
 	/* outbound address mapping */
 	IPROC_PCIE_OARR0,
@@ -295,6 +319,9 @@ enum iproc_pcie_reg {
 	IPROC_PCIE_IARR4,
 	IPROC_PCIE_IMAP4,
 
+	/* config read status */
+	IPROC_PCIE_CFG_RD_STATUS,
+
 	/* link status */
 	IPROC_PCIE_LINK_STATUS,
 
@@ -313,6 +340,7 @@ enum iproc_pcie_reg {
 	[IPROC_PCIE_CFG_ADDR]		= 0x1f8,
 	[IPROC_PCIE_CFG_DATA]		= 0x1fc,
 	[IPROC_PCIE_INTX_EN]		= 0x330,
+	[IPROC_PCIE_INTX_CSR]		= 0x334,
 	[IPROC_PCIE_LINK_STATUS]	= 0xf0c,
 };
 
@@ -324,6 +352,7 @@ enum iproc_pcie_reg {
 	[IPROC_PCIE_CFG_ADDR]		= 0x1f8,
 	[IPROC_PCIE_CFG_DATA]		= 0x1fc,
 	[IPROC_PCIE_INTX_EN]		= 0x330,
+	[IPROC_PCIE_INTX_CSR]		= 0x334,
 	[IPROC_PCIE_OARR0]		= 0xd20,
 	[IPROC_PCIE_OMAP0]		= 0xd40,
 	[IPROC_PCIE_OARR1]		= 0xd28,
@@ -340,6 +369,7 @@ enum iproc_pcie_reg {
 	[IPROC_PCIE_CFG_ADDR]		= 0x1f8,
 	[IPROC_PCIE_CFG_DATA]		= 0x1fc,
 	[IPROC_PCIE_INTX_EN]		= 0x330,
+	[IPROC_PCIE_INTX_CSR]		= 0x334,
 	[IPROC_PCIE_OARR0]		= 0xd20,
 	[IPROC_PCIE_OMAP0]		= 0xd40,
 	[IPROC_PCIE_OARR1]		= 0xd28,
@@ -356,6 +386,7 @@ enum iproc_pcie_reg {
 	[IPROC_PCIE_IMAP3]		= 0xe08,
 	[IPROC_PCIE_IARR4]		= 0xe68,
 	[IPROC_PCIE_IMAP4]		= 0xe70,
+	[IPROC_PCIE_CFG_RD_STATUS]	= 0xee0,
 	[IPROC_PCIE_LINK_STATUS]	= 0xf0c,
 	[IPROC_PCIE_APB_ERR_EN]		= 0xf40,
 };
@@ -383,6 +414,24 @@ enum iproc_pcie_reg {
 	[IPROC_PCIE_CFG_DATA]		= 0x1fc,
 };
 
+static int iproc_pci_raw_config_read32(struct iproc_pcie *pcie,
+				       unsigned int devfn, int where,
+				       int size, u32 *val);
+static int iproc_pci_raw_config_write32(struct iproc_pcie *pcie,
+					unsigned int devfn, int where,
+					int size, u32 val);
+
+/*
+ * List of device IDs of controllers that have corrupted capability list that
+ * require SW fixup
+ */
+static const u16 iproc_pcie_corrupt_cap_did[] = {
+	0x16cd,
+	0x16f0,
+	0xd802,
+	0xd804
+};
+
 static inline struct iproc_pcie *iproc_data(struct pci_bus *bus)
 {
 	struct iproc_pcie *pcie;
@@ -391,7 +440,14 @@ static inline struct iproc_pcie *iproc_data(struct pci_bus *bus)
 
 	pcie = sys->private_data;
 #else
-	pcie = bus->sysdata;
+	struct pci_config_window *cfg;
+
+	if (acpi_disabled) {
+		pcie = bus->sysdata;
+	} else {
+		cfg = bus->sysdata;
+		pcie = cfg->priv;
+	}
 #endif
 	return pcie;
 }
@@ -429,6 +485,14 @@ static inline void iproc_pcie_write_reg(struct iproc_pcie *pcie,
 	writel(val, pcie->base + offset);
 }
 
+static inline bool iproc_pcie_link_is_active(struct iproc_pcie *pcie)
+{
+	u32 val;
+
+	val = iproc_pcie_read_reg(pcie, IPROC_PCIE_LINK_STATUS);
+	return !!((val & PCIE_PHYLINKUP) && (val & PCIE_DL_ACTIVE));
+}
+
 /**
  * APB error forwarding can be disabled during access of configuration
  * registers of the endpoint device, to prevent unsupported requests
@@ -476,10 +540,12 @@ static void __iomem *iproc_pcie_map_ep_cfg_reg(struct iproc_pcie *pcie,
 	return (pcie->base + offset);
 }
 
-static unsigned int iproc_pcie_cfg_retry(void __iomem *cfg_data_p)
+static unsigned int iproc_pcie_cfg_retry(struct iproc_pcie *pcie,
+					 void __iomem *cfg_data_p)
 {
 	int timeout = CFG_RETRY_STATUS_TIMEOUT_US;
 	unsigned int data;
+	u32 status;
 
 	/*
 	 * As per PCIe spec r3.1, sec 2.3.2, CRS Software Visibility only
@@ -500,6 +566,18 @@ static unsigned int iproc_pcie_cfg_retry(void __iomem *cfg_data_p)
 	 */
 	data = readl(cfg_data_p);
 	while (data == CFG_RETRY_STATUS && timeout--) {
+		/*
+		 * Stingray B0 PAXB controller CRS state is set
+		 * in CFG_RD status register
+		 * This will handle the case where CFG_RETRY_STATUS is
+		 * valid config data.
+		 */
+		if (pcie->srp_check) {
+			status = iproc_pcie_read_reg(pcie,
+						     IPROC_PCIE_CFG_RD_STATUS);
+			if (status != CFG_RD_CRS)
+				return data;
+		}
 		udelay(1);
 		data = readl(cfg_data_p);
 	}
@@ -510,6 +588,68 @@ static unsigned int iproc_pcie_cfg_retry(void __iomem *cfg_data_p)
 	return data;
 }
 
+static void iproc_pcie_cmd_fix(struct iproc_pcie *pcie, int where)
+
+{
+	u32 cmd;
+
+	if (pcie->ep_is_internal || !iproc_pcie_link_is_active(pcie))
+		return;
+
+	/*
+	 * When link is active, upon the first config read for vendor ID,
+	 * one needs to enable the memory access and bus master explicitly
+	 */
+	if ((where & ~0x3) == PCI_VENDOR_ID) {
+		iproc_pci_raw_config_read32(pcie, 0, PCI_COMMAND, 2, &cmd);
+		cmd |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;
+		iproc_pci_raw_config_write32(pcie, 0, PCI_COMMAND, 2, cmd);
+	}
+}
+
+static void iproc_pcie_fix_cap(struct iproc_pcie *pcie, int where, u32 *val)
+{
+	u32 i, dev_id;
+
+	switch (where & ~0x3) {
+	case PCI_VENDOR_ID:
+		dev_id = *val >> 16;
+
+		/*
+		 * Activate fixup for those controllers that have corrupted
+		 * capability list registers
+		 */
+		for (i = 0; i < ARRAY_SIZE(iproc_pcie_corrupt_cap_did); i++)
+			if (dev_id == iproc_pcie_corrupt_cap_did[i])
+				pcie->fix_paxc_cap = true;
+		break;
+
+	case IPROC_PCI_PM_CAP:
+		if (pcie->fix_paxc_cap) {
+			/* advertise PM, force next capability to PCIe */
+			*val &= ~IPROC_PCI_PM_CAP_MASK;
+			*val |= IPROC_PCI_EXP_CAP << 8 | PCI_CAP_ID_PM;
+		}
+		break;
+
+	case IPROC_PCI_EXP_CAP:
+		if (pcie->fix_paxc_cap) {
+			/* advertise root port, version 2, terminate here */
+			*val = (PCI_EXP_TYPE_ROOT_PORT << 4 | 2) << 16 |
+				PCI_CAP_ID_EXP;
+		}
+		break;
+
+	case IPROC_PCI_EXP_CAP + PCI_EXP_RTCTL:
+		/* Don't advertise CRS SV support */
+		*val &= ~(PCI_EXP_RTCAP_CRSVIS << 16);
+		break;
+
+	default:
+		break;
+	}
+}
+
 static int iproc_pcie_config_read(struct pci_bus *bus, unsigned int devfn,
 				  int where, int size, u32 *val)
 {
@@ -523,14 +663,13 @@ static int iproc_pcie_config_read(struct pci_bus *bus, unsigned int devfn,
 
 	/* root complex access */
 	if (busno == 0) {
+		iproc_pcie_cmd_fix(pcie, where);
+
 		ret = pci_generic_config_read32(bus, devfn, where, size, val);
-		if (ret != PCIBIOS_SUCCESSFUL)
-			return ret;
+		if (ret == PCIBIOS_SUCCESSFUL)
+			iproc_pcie_fix_cap(pcie, where, val);
 
-		/* Don't advertise CRS SV support */
-		if ((where & ~0x3) == IPROC_PCI_EXP_CAP + PCI_EXP_RTCTL)
-			*val &= ~(PCI_EXP_RTCAP_CRSVIS << 16);
-		return PCIBIOS_SUCCESSFUL;
+		return ret;
 	}
 
 	cfg_data_p = iproc_pcie_map_ep_cfg_reg(pcie, busno, slot, fn, where);
@@ -538,12 +677,31 @@ static int iproc_pcie_config_read(struct pci_bus *bus, unsigned int devfn,
 	if (!cfg_data_p)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
-	data = iproc_pcie_cfg_retry(cfg_data_p);
+	data = iproc_pcie_cfg_retry(pcie, cfg_data_p);
 
 	*val = data;
 	if (size <= 2)
 		*val = (data >> (8 * (where & 3))) & ((1 << (size * 8)) - 1);
 
+	/*
+	 * For PAXC and PAXCv2, the total number of PFs that one can enumerate
+	 * depends on the firmware configuration. Unfortunately, due to an ASIC
+	 * bug, unconfigured PFs cannot be properly hidden from the root
+	 * complex. As a result, write access to these PFs will cause bus lock
+	 * up on the embedded processor
+	 *
+	 * Since all unconfigured PFs are left with an incorrect, staled device
+	 * ID of 0x168e (PCI_DEVICE_ID_NX2_57810), we try to catch those access
+	 * early here and reject them all
+	 */
+#define DEVICE_ID_MASK     0xffff0000
+#define DEVICE_ID_SHIFT    16
+	if (pcie->rej_unconfig_pf &&
+	    (where & CFG_ADDR_REG_NUM_MASK) == PCI_VENDOR_ID)
+		if ((*val & DEVICE_ID_MASK) ==
+		    (PCI_DEVICE_ID_NX2_57810 << DEVICE_ID_SHIFT))
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+
 	return PCIBIOS_SUCCESSFUL;
 }
 
@@ -573,20 +731,17 @@ static void __iomem *iproc_pcie_map_cfg_bus(struct iproc_pcie *pcie,
 			return (pcie->base + offset);
 	}
 
-	/*
-	 * PAXC is connected to an internally emulated EP within the SoC.  It
-	 * allows only one device.
-	 */
-	if (pcie->ep_is_internal)
-		if (slot > 0)
+	if (pcie->ep_is_internal) {
+		/* only enumerate up to supported number of PFs */
+		if (pcie->nr_pf && fn >= pcie->nr_pf)
 			return NULL;
+	}
 
 	return iproc_pcie_map_ep_cfg_reg(pcie, busno, slot, fn, where);
 }
 
-static void __iomem *iproc_pcie_bus_map_cfg_bus(struct pci_bus *bus,
-						unsigned int devfn,
-						int where)
+void __iomem *iproc_pcie_bus_map_cfg_bus(struct pci_bus *bus,
+					 unsigned int devfn, int where)
 {
 	return iproc_pcie_map_cfg_bus(iproc_data(bus), bus->number, devfn,
 				      where);
@@ -636,14 +791,24 @@ static int iproc_pci_raw_config_write32(struct iproc_pcie *pcie,
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int iproc_pcie_config_read32(struct pci_bus *bus, unsigned int devfn,
-				    int where, int size, u32 *val)
+int iproc_pcie_config_read32(struct pci_bus *bus, unsigned int devfn,
+			     int where, int size, u32 *val)
 {
 	int ret;
 	struct iproc_pcie *pcie = iproc_data(bus);
 
+	if (!pcie->ep_is_internal) {
+		if (bus->number && ((where & ~0x3) == PCI_VENDOR_ID)) {
+			if (!iproc_pcie_link_is_active(pcie)) {
+				dev_dbg(pcie->dev,
+					"LinkDown so skipping downstream read req\n");
+				return PCIBIOS_DEVICE_NOT_FOUND;
+			}
+		}
+	}
+
 	iproc_pcie_apb_err_disable(bus, true);
-	if (pcie->type == IPROC_PCIE_PAXB_V2)
+	if (pcie->iproc_cfg_read)
 		ret = iproc_pcie_config_read(bus, devfn, where, size, val);
 	else
 		ret = pci_generic_config_read32(bus, devfn, where, size, val);
@@ -652,8 +817,8 @@ static int iproc_pcie_config_read32(struct pci_bus *bus, unsigned int devfn,
 	return ret;
 }
 
-static int iproc_pcie_config_write32(struct pci_bus *bus, unsigned int devfn,
-				     int where, int size, u32 val)
+int iproc_pcie_config_write32(struct pci_bus *bus, unsigned int devfn,
+			      int where, int size, u32 val)
 {
 	int ret;
 
@@ -670,7 +835,7 @@ static int iproc_pcie_config_write32(struct pci_bus *bus, unsigned int devfn,
 	.write = iproc_pcie_config_write32,
 };
 
-static void iproc_pcie_perst_ctrl(struct iproc_pcie *pcie, bool assert)
+static void iproc_pcie_reset(struct iproc_pcie *pcie)
 {
 	u32 val;
 
@@ -682,33 +847,52 @@ static void iproc_pcie_perst_ctrl(struct iproc_pcie *pcie, bool assert)
 	if (pcie->ep_is_internal)
 		return;
 
-	if (assert) {
-		val = iproc_pcie_read_reg(pcie, IPROC_PCIE_CLK_CTRL);
-		val &= ~EP_PERST_SOURCE_SELECT & ~EP_MODE_SURVIVE_PERST &
-			~RC_PCIE_RST_OUTPUT;
-		iproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);
-		udelay(250);
-	} else {
-		val = iproc_pcie_read_reg(pcie, IPROC_PCIE_CLK_CTRL);
-		val |= RC_PCIE_RST_OUTPUT;
-		iproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);
-		msleep(100);
-	}
+	/*
+	 * Select perst_b signal as reset source. Put the device into reset,
+	 * and then bring it out of reset
+	 */
+	val = iproc_pcie_read_reg(pcie, IPROC_PCIE_CLK_CTRL);
+	val &= ~EP_PERST_SOURCE_SELECT & ~EP_MODE_SURVIVE_PERST &
+		~RC_PCIE_RST_OUTPUT;
+	iproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);
+	udelay(250);
+
+	val |= RC_PCIE_RST_OUTPUT;
+	iproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);
+	msleep(100);
 }
 
-int iproc_pcie_shutdown(struct iproc_pcie *pcie)
+static bool iproc_pci_hp_check_ltssm(struct iproc_pcie *pcie)
 {
-	iproc_pcie_perst_ctrl(pcie, true);
-	msleep(500);
-
-	return 0;
+	u32 val, timeout = CFG_RC_LTSSM_TIMEOUT;
+
+	/* Clear LTSSM history. */
+	iproc_pci_raw_config_read32(pcie, 0,
+				  CFG_RC_PHY_CTL, 4, &val);
+	iproc_pci_raw_config_write32(pcie, 0, CFG_RC_PHY_CTL, 4,
+				     val | CFG_RC_CLR_RECOV_HIST_MASK |
+				     CFG_RC_CLR_LTSSM_HIST_MASK);
+	/* write back the origional value. */
+	iproc_pci_raw_config_write32(pcie, 0, CFG_RC_PHY_CTL, 4, val);
+
+	do {
+		usleep_range(500, 1000);
+		iproc_pci_raw_config_read32(pcie, 0,
+					    CFG_RC_LTSSM, 4, &val);
+		/* check link state to see if link moved to L1 state. */
+		if ((val & CFG_RC_LTSSM_STATE_MASK) ==
+		     CFG_RC_LTSSM_STATE_L1)
+			return true;
+		timeout--;
+	} while (timeout);
+
+	return false;
 }
-EXPORT_SYMBOL_GPL(iproc_pcie_shutdown);
 
 static int iproc_pcie_check_link(struct iproc_pcie *pcie)
 {
 	struct device *dev = pcie->dev;
-	u32 hdr_type, link_ctrl, link_status, class, val;
+	u32 hdr_type, link_ctrl, link_status, class;
 	bool link_is_active = false;
 
 	/*
@@ -718,12 +902,6 @@ static int iproc_pcie_check_link(struct iproc_pcie *pcie)
 	if (pcie->ep_is_internal)
 		return 0;
 
-	val = iproc_pcie_read_reg(pcie, IPROC_PCIE_LINK_STATUS);
-	if (!(val & PCIE_PHYLINKUP) || !(val & PCIE_DL_ACTIVE)) {
-		dev_err(dev, "PHY or data link is INACTIVE!\n");
-		return -ENODEV;
-	}
-
 	/* make sure we are not in EP mode */
 	iproc_pci_raw_config_read32(pcie, 0, PCI_HEADER_TYPE, 1, &hdr_type);
 	if ((hdr_type & 0x7f) != PCI_HEADER_TYPE_BRIDGE) {
@@ -742,6 +920,13 @@ static int iproc_pcie_check_link(struct iproc_pcie *pcie)
 	iproc_pci_raw_config_write32(pcie, 0, PCI_BRIDGE_CTRL_REG_OFFSET,
 				     4, class);
 
+	if (!iproc_pcie_link_is_active(pcie)) {
+		if (!iproc_pci_hp_check_ltssm(pcie)) {
+			dev_err(dev, "PHY or data link is INACTIVE!\n");
+			return -ENODEV;
+		}
+	}
+
 	/* check link status to see if link is active */
 	iproc_pci_raw_config_read32(pcie, 0, IPROC_PCI_EXP_CAP + PCI_EXP_LNKSTA,
 				    2, &link_status);
@@ -753,6 +938,8 @@ static int iproc_pcie_check_link(struct iproc_pcie *pcie)
 #define PCI_TARGET_LINK_SPEED_MASK	0xf
 #define PCI_TARGET_LINK_SPEED_GEN2	0x2
 #define PCI_TARGET_LINK_SPEED_GEN1	0x1
+#define PCI_TARGET_LINK_WIDTH_MASK	0x3f
+#define PCI_TARGET_LINK_WIDTH_OFFSET	0x4
 		iproc_pci_raw_config_read32(pcie, 0,
 					    IPROC_PCI_EXP_CAP + PCI_EXP_LNKCTL2,
 					    4, &link_ctrl);
@@ -773,14 +960,102 @@ static int iproc_pcie_check_link(struct iproc_pcie *pcie)
 		}
 	}
 
-	dev_info(dev, "link: %s\n", link_is_active ? "UP" : "DOWN");
+	if (link_is_active) {
+		dev_info(dev, "link UP @ Speed Gen-%d and width-x%d\n",
+				link_status & PCI_TARGET_LINK_SPEED_MASK,
+				(link_status >> PCI_TARGET_LINK_WIDTH_OFFSET) &
+				PCI_TARGET_LINK_WIDTH_MASK);
+	} else {
+		dev_info(dev, "link DOWN\n");
+	}
 
 	return link_is_active ? 0 : -ENODEV;
 }
 
-static void iproc_pcie_enable(struct iproc_pcie *pcie)
+static int iproc_pcie_intx_map(struct irq_domain *domain, unsigned int irq,
+			       irq_hw_number_t hwirq)
+{
+	irq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);
+	irq_set_chip_data(irq, domain->host_data);
+
+	return 0;
+}
+
+static const struct irq_domain_ops intx_domain_ops = {
+	.map = iproc_pcie_intx_map,
+};
+
+static void iproc_pcie_isr(struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct iproc_pcie *pcie;
+	struct device *dev;
+	unsigned long status;
+	u32 bit, virq;
+
+	chained_irq_enter(chip, desc);
+	pcie = irq_desc_get_handler_data(desc);
+	dev = pcie->dev;
+
+	/* go through INTx A, B, C, D until all interrupts are handled */
+	while ((status = iproc_pcie_read_reg(pcie, IPROC_PCIE_INTX_CSR) &
+		SYS_RC_INTX_MASK) != 0) {
+		for_each_set_bit(bit, &status, NUM_INTX) {
+			virq = irq_find_mapping(pcie->irq_domain, bit + 1);
+			if (virq)
+				generic_handle_irq(virq);
+			else
+				dev_err(dev, "unexpected INTx%u\n", bit);
+		}
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static int iproc_pcie_intx_enable(struct iproc_pcie *pcie)
 {
+	struct device *dev = pcie->dev;
+	struct device_node *node = dev->of_node;
+	int ret;
+
 	iproc_pcie_write_reg(pcie, IPROC_PCIE_INTX_EN, SYS_RC_INTX_MASK);
+
+	/*
+	 * BCMA devices do not map INTx the same way as platform devices. All
+	 * BCMA needs is the above code to enable INTx
+	 */
+	if (pcie->irq <= 0)
+		return 0;
+
+	/* set IRQ handler */
+	irq_set_chained_handler_and_data(pcie->irq, iproc_pcie_isr, pcie);
+
+	/* add IRQ domain for INTx */
+	pcie->irq_domain = irq_domain_add_linear(node, NUM_INTX + 1,
+						 &intx_domain_ops, pcie);
+	if (!pcie->irq_domain) {
+		dev_err(dev, "failed to add INTx IRQ domain\n");
+		ret = -ENOMEM;
+		goto err_rm_handler_data;
+	}
+
+	return 0;
+
+err_rm_handler_data:
+	irq_set_chained_handler_and_data(pcie->irq, NULL, NULL);
+
+	return ret;
+}
+
+static void iproc_pcie_intx_disable(struct iproc_pcie *pcie)
+{
+	iproc_pcie_write_reg(pcie, IPROC_PCIE_INTX_EN, 0x0);
+
+	if (pcie->irq <= 0)
+		return;
+
+	irq_domain_remove(pcie->irq_domain);
+	irq_set_chained_handler_and_data(pcie->irq, NULL, NULL);
 }
 
 static inline bool iproc_pcie_ob_is_valid(struct iproc_pcie *pcie,
@@ -823,14 +1098,14 @@ static inline int iproc_pcie_ob_write(struct iproc_pcie *pcie, int window_idx,
 	writel(lower_32_bits(pci_addr), pcie->base + omap_offset);
 	writel(upper_32_bits(pci_addr), pcie->base + omap_offset + 4);
 
-	dev_info(dev, "ob window [%d]: offset 0x%x axi %pap pci %pap\n",
-		 window_idx, oarr_offset, &axi_addr, &pci_addr);
-	dev_info(dev, "oarr lo 0x%x oarr hi 0x%x\n",
-		 readl(pcie->base + oarr_offset),
-		 readl(pcie->base + oarr_offset + 4));
-	dev_info(dev, "omap lo 0x%x omap hi 0x%x\n",
-		 readl(pcie->base + omap_offset),
-		 readl(pcie->base + omap_offset + 4));
+	dev_dbg(dev, "ob window [%d]: offset 0x%x axi %pap pci %pap\n",
+		window_idx, oarr_offset, &axi_addr, &pci_addr);
+	dev_dbg(dev, "oarr lo 0x%x oarr hi 0x%x\n",
+		readl(pcie->base + oarr_offset),
+		readl(pcie->base + oarr_offset + 4));
+	dev_dbg(dev, "omap lo 0x%x omap hi 0x%x\n",
+		readl(pcie->base + omap_offset),
+		readl(pcie->base + omap_offset + 4));
 
 	return 0;
 }
@@ -887,8 +1162,25 @@ static int iproc_pcie_setup_ob(struct iproc_pcie *pcie, u64 axi_addr,
 			resource_size_t window_size =
 				ob_map->window_sizes[size_idx] * SZ_1M;
 
-			if (size < window_size)
-				continue;
+			/*
+			 * Keep iterating until we reach the last window and
+			 * with the minimal window size at index zero. In this
+			 * case, we take a compromise by mapping it using the
+			 * minimum window size that can be supported
+			 */
+			if (size < window_size) {
+				if (size_idx > 0 || window_idx > 0)
+					continue;
+
+				/*
+				 * For the corner case of reaching the minimal
+				 * window size that can be supported on the
+				 * last window
+				 */
+				axi_addr = ALIGN_DOWN(axi_addr, window_size);
+				pci_addr = ALIGN_DOWN(pci_addr, window_size);
+				size = window_size;
+			}
 
 			if (!IS_ALIGNED(axi_addr, window_size) ||
 			    !IS_ALIGNED(pci_addr, window_size)) {
@@ -997,8 +1289,8 @@ static int iproc_pcie_ib_write(struct iproc_pcie *pcie, int region_idx,
 	    iproc_pcie_reg_is_invalid(imap_offset))
 		return -EINVAL;
 
-	dev_info(dev, "ib region [%d]: offset 0x%x axi %pap pci %pap\n",
-		 region_idx, iarr_offset, &axi_addr, &pci_addr);
+	dev_dbg(dev, "ib region [%d]: offset 0x%x axi %pap pci %pap\n",
+		region_idx, iarr_offset, &axi_addr, &pci_addr);
 
 	/*
 	 * Program the IARR registers.  The upper 32-bit IARR register is
@@ -1008,9 +1300,9 @@ static int iproc_pcie_ib_write(struct iproc_pcie *pcie, int region_idx,
 	       pcie->base + iarr_offset);
 	writel(upper_32_bits(pci_addr), pcie->base + iarr_offset + 4);
 
-	dev_info(dev, "iarr lo 0x%x iarr hi 0x%x\n",
-		 readl(pcie->base + iarr_offset),
-		 readl(pcie->base + iarr_offset + 4));
+	dev_dbg(dev, "iarr lo 0x%x iarr hi 0x%x\n",
+		readl(pcie->base + iarr_offset),
+		readl(pcie->base + iarr_offset + 4));
 
 	/*
 	 * Now program the IMAP registers.  Each IARR region may have one or
@@ -1024,10 +1316,10 @@ static int iproc_pcie_ib_write(struct iproc_pcie *pcie, int region_idx,
 		writel(upper_32_bits(axi_addr),
 		       pcie->base + imap_offset + ib_map->imap_addr_offset);
 
-		dev_info(dev, "imap window [%d] lo 0x%x hi 0x%x\n",
-			 window_idx, readl(pcie->base + imap_offset),
-			 readl(pcie->base + imap_offset +
-			       ib_map->imap_addr_offset));
+		dev_dbg(dev, "imap window [%d] lo 0x%x hi 0x%x\n",
+			window_idx, readl(pcie->base + imap_offset),
+			readl(pcie->base + imap_offset +
+			      ib_map->imap_addr_offset));
 
 		imap_offset += ib_map->imap_window_offset;
 		axi_addr += size;
@@ -1115,25 +1407,75 @@ static int pci_dma_range_parser_init(struct of_pci_range_parser *parser,
 	return 0;
 }
 
+static int
+iproc_pcie_add_dma_resv_range(struct device *dev, struct list_head *resources,
+			      uint64_t start, uint64_t end)
+{
+	struct resource *res;
+
+	res = devm_kzalloc(dev, sizeof(struct resource), GFP_KERNEL);
+	if (!res)
+		return -ENOMEM;
+
+	res->start = (resource_size_t)start;
+	res->end = (resource_size_t)end;
+	pci_add_resource_offset(resources, res, 0);
+
+	return 0;
+}
+
 static int iproc_pcie_map_dma_ranges(struct iproc_pcie *pcie)
 {
+	struct pci_host_bridge *host = pci_host_bridge_from_priv(pcie);
 	struct of_pci_range range;
 	struct of_pci_range_parser parser;
 	int ret;
+	uint64_t start, end;
+	LIST_HEAD(resources);
 
 	/* Get the dma-ranges from DT */
 	ret = pci_dma_range_parser_init(&parser, pcie->dev->of_node);
 	if (ret)
 		return ret;
 
+	start = 0;
 	for_each_of_pci_range(&parser, &range) {
+		end = range.pci_addr;
+		/* dma-ranges list expected in sorted order */
+		if (end < start) {
+			ret = -EINVAL;
+			goto out;
+		}
+
 		/* Each range entry corresponds to an inbound mapping region */
 		ret = iproc_pcie_setup_ib(pcie, &range, IPROC_PCIE_IB_MAP_MEM);
 		if (ret)
-			return ret;
+			goto out;
+
+		if (end - start) {
+			ret = iproc_pcie_add_dma_resv_range(pcie->dev,
+							    &resources,
+							    start, end);
+			if (ret)
+				goto out;
+		}
+		start = range.pci_addr + range.size;
 	}
 
+	end = DMA_BIT_MASK(sizeof(dma_addr_t) * BITS_PER_BYTE);
+	if (end - start) {
+		ret = iproc_pcie_add_dma_resv_range(pcie->dev, &resources,
+						    start, end);
+		if (ret)
+			goto out;
+	}
+
+	list_splice_init(&resources, &host->dma_resv);
+
 	return 0;
+out:
+	pci_free_resource_list(&resources);
+	return ret;
 }
 
 static int iproce_pcie_get_msi(struct iproc_pcie *pcie,
@@ -1177,10 +1519,22 @@ static int iproc_pcie_paxb_v2_msi_steer(struct iproc_pcie *pcie, u64 msi_addr)
 	return ret;
 }
 
-static void iproc_pcie_paxc_v2_msi_steer(struct iproc_pcie *pcie, u64 msi_addr)
+static void iproc_pcie_paxc_v2_msi_steer(struct iproc_pcie *pcie, u64 msi_addr,
+					 bool enable)
 {
 	u32 val;
 
+	if (!enable) {
+		/*
+		 * Disable PAXC MSI steering. All write transfers will be
+		 * treated as non-MSI transfers
+		 */
+		val = iproc_pcie_read_reg(pcie, IPROC_PCIE_MSI_EN_CFG);
+		val &= ~MSI_ENABLE_CFG;
+		iproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_EN_CFG, val);
+		return;
+	}
+
 	/*
 	 * Program bits [43:13] of address of GITS_TRANSLATER register into
 	 * bits [30:0] of the MSI base address register.  In fact, in all iProc
@@ -1234,7 +1588,7 @@ static int iproc_pcie_msi_steer(struct iproc_pcie *pcie,
 			return ret;
 		break;
 	case IPROC_PCIE_PAXC_V2:
-		iproc_pcie_paxc_v2_msi_steer(pcie, msi_addr);
+		iproc_pcie_paxc_v2_msi_steer(pcie, msi_addr, true);
 		break;
 	default:
 		return -EINVAL;
@@ -1292,7 +1646,7 @@ static void iproc_pcie_msi_disable(struct iproc_pcie *pcie)
 	iproc_msi_exit(pcie);
 }
 
-static int iproc_pcie_rev_init(struct iproc_pcie *pcie)
+int iproc_pcie_rev_init(struct iproc_pcie *pcie)
 {
 	struct device *dev = pcie->dev;
 	unsigned int reg_idx;
@@ -1312,6 +1666,7 @@ static int iproc_pcie_rev_init(struct iproc_pcie *pcie)
 		break;
 	case IPROC_PCIE_PAXB_V2:
 		regs = iproc_pcie_reg_paxb_v2;
+		pcie->iproc_cfg_read = true;
 		pcie->has_apb_err_disable = true;
 		if (pcie->need_ob_cfg) {
 			pcie->ob_map = paxb_v2_ob_map;
@@ -1326,10 +1681,14 @@ static int iproc_pcie_rev_init(struct iproc_pcie *pcie)
 	case IPROC_PCIE_PAXC:
 		regs = iproc_pcie_reg_paxc;
 		pcie->ep_is_internal = true;
+		pcie->rej_unconfig_pf = true;
+		pcie->nr_pf = 4;
 		break;
 	case IPROC_PCIE_PAXC_V2:
 		regs = iproc_pcie_reg_paxc_v2;
 		pcie->ep_is_internal = true;
+		pcie->iproc_cfg_read = true;
+		pcie->rej_unconfig_pf = true;
 		pcie->need_msi_steer = true;
 		break;
 	default:
@@ -1353,13 +1712,38 @@ static int iproc_pcie_rev_init(struct iproc_pcie *pcie)
 	return 0;
 }
 
+int iproc_pcie_detect_enable(struct iproc_pcie *pcie)
+{
+	struct pci_host_bridge *host = pci_host_bridge_from_priv(pcie);
+	struct pci_bus *child;
+	int ret;
+
+	host->dev.parent = pcie->dev;
+	ret = pci_scan_root_bus_bridge(host);
+	if (ret < 0) {
+		dev_err(pcie->dev, "failed to scan host: %d\n", ret);
+		return ret;
+	}
+
+	pci_assign_unassigned_bus_resources(host->bus);
+
+	pcie->root_bus = host->bus;
+
+	list_for_each_entry(child, &host->bus->children, node)
+		pcie_bus_configure_settings(child);
+
+	pci_bus_add_devices(host->bus);
+
+	return 0;
+}
+
 int iproc_pcie_setup(struct iproc_pcie *pcie, struct list_head *res)
 {
 	struct device *dev;
 	int ret;
 	void *sysdata;
-	struct pci_bus *child;
 	struct pci_host_bridge *host = pci_host_bridge_from_priv(pcie);
+	bool is_link_active;
 
 	dev = pcie->dev;
 
@@ -1373,6 +1757,14 @@ int iproc_pcie_setup(struct iproc_pcie *pcie, struct list_head *res)
 	if (ret)
 		return ret;
 
+#if CONFIG_PM_SLEEP
+	pcie->paxb_map_regs = devm_kcalloc(dev, IPROC_PCIE_MAX_NUM_REG * 2,
+					   sizeof(*pcie->paxb_map_regs),
+					   GFP_KERNEL);
+	if (!pcie->paxb_map_regs)
+		return -ENOMEM;
+#endif
+
 	ret = phy_init(pcie->phy);
 	if (ret) {
 		dev_err(dev, "unable to initialize PCIe PHY\n");
@@ -1385,8 +1777,7 @@ int iproc_pcie_setup(struct iproc_pcie *pcie, struct list_head *res)
 		goto err_exit_phy;
 	}
 
-	iproc_pcie_perst_ctrl(pcie, true);
-	iproc_pcie_perst_ctrl(pcie, false);
+	iproc_pcie_reset(pcie);
 
 	if (pcie->need_ob_cfg) {
 		ret = iproc_pcie_map_ranges(pcie, res);
@@ -1409,41 +1800,34 @@ int iproc_pcie_setup(struct iproc_pcie *pcie, struct list_head *res)
 	sysdata = pcie;
 #endif
 
-	ret = iproc_pcie_check_link(pcie);
+
+	is_link_active = iproc_pcie_check_link(pcie);
+	if (is_link_active)
+		dev_info(dev, "no PCIe EP device detected\n");
+
+	ret = iproc_pcie_intx_enable(pcie);
 	if (ret) {
-		dev_err(dev, "no PCIe EP device detected\n");
+		dev_err(dev, "failed to enable INTx\n");
 		goto err_power_off_phy;
 	}
 
-	iproc_pcie_enable(pcie);
-
 	if (IS_ENABLED(CONFIG_PCI_MSI))
 		if (iproc_pcie_msi_enable(pcie))
 			dev_info(dev, "not using iProc MSI\n");
 
 	list_splice_init(res, &host->windows);
 	host->busnr = 0;
-	host->dev.parent = dev;
 	host->ops = &iproc_pcie_ops;
 	host->sysdata = sysdata;
 	host->map_irq = pcie->map_irq;
 	host->swizzle_irq = pci_common_swizzle;
 
-	ret = pci_scan_root_bus_bridge(host);
+	ret = iproc_pcie_detect_enable(pcie);
 	if (ret < 0) {
-		dev_err(dev, "failed to scan host: %d\n", ret);
+		dev_err(dev, "failed to enable: %d\n", ret);
 		goto err_power_off_phy;
 	}
 
-	pci_assign_unassigned_bus_resources(host->bus);
-
-	pcie->root_bus = host->bus;
-
-	list_for_each_entry(child, &host->bus->children, node)
-		pcie_bus_configure_settings(child);
-
-	pci_bus_add_devices(host->bus);
-
 	return 0;
 
 err_power_off_phy:
@@ -1460,6 +1844,7 @@ int iproc_pcie_remove(struct iproc_pcie *pcie)
 	pci_remove_root_bus(pcie->root_bus);
 
 	iproc_pcie_msi_disable(pcie);
+	iproc_pcie_intx_disable(pcie);
 
 	phy_power_off(pcie->phy);
 	phy_exit(pcie->phy);
@@ -1468,6 +1853,235 @@ int iproc_pcie_remove(struct iproc_pcie *pcie)
 }
 EXPORT_SYMBOL(iproc_pcie_remove);
 
+int iproc_pcie_save_paxb_map_regs(struct iproc_pcie *pcie)
+{
+	struct iproc_pcie_ib *ib = &pcie->ib;
+	int window_idx, region_idx;
+	u16 offset, iarr_offset, imap_offset;
+	unsigned int i, j = 0;
+
+	/* save outbound mapping registers */
+	for (i = IPROC_PCIE_OARR0; i <= IPROC_PCIE_OMAP3; i++) {
+		offset = iproc_pcie_reg_offset(pcie, i);
+
+		if (iproc_pcie_reg_is_invalid(offset))
+			continue;
+
+		pcie->paxb_map_regs[j++] = readl(pcie->base + offset);
+		pcie->paxb_map_regs[j++] = readl(pcie->base + offset + 4);
+	}
+
+	/* save inbound mapping registers */
+	for (region_idx = 0; region_idx < ib->nr_regions; region_idx++) {
+		const struct iproc_pcie_ib_map *ib_map =
+			&pcie->ib_map[region_idx];
+
+		iarr_offset = iproc_pcie_reg_offset(pcie,
+					MAP_REG(IPROC_PCIE_IARR0, region_idx));
+		imap_offset = iproc_pcie_reg_offset(pcie,
+					MAP_REG(IPROC_PCIE_IMAP0, region_idx));
+
+		if (iproc_pcie_reg_is_invalid(iarr_offset) ||
+		    iproc_pcie_reg_is_invalid(imap_offset))
+			continue;
+
+		pcie->paxb_map_regs[j++] = readl(pcie->base + iarr_offset);
+		pcie->paxb_map_regs[j++] = readl(pcie->base + iarr_offset + 4);
+
+		for (window_idx = 0; window_idx < ib_map->nr_windows;
+		     window_idx++) {
+			pcie->paxb_map_regs[j++] =
+					readl(pcie->base + imap_offset);
+			pcie->paxb_map_regs[j++] =
+					readl(pcie->base + imap_offset +
+					      ib_map->imap_addr_offset);
+
+			imap_offset += ib_map->imap_window_offset;
+		}
+	}
+	return 0;
+}
+
+int iproc_pcie_restore_paxb_map_regs(struct iproc_pcie *pcie)
+{
+	struct iproc_pcie_ib *ib = &pcie->ib;
+	int window_idx, region_idx;
+	u16 offset, iarr_offset, imap_offset;
+	unsigned int i, j = 0;
+
+	/* restore outbound mapping registers */
+	for (i = IPROC_PCIE_OARR0; i <= IPROC_PCIE_OMAP3; i++) {
+		offset = iproc_pcie_reg_offset(pcie, i);
+
+		if (iproc_pcie_reg_is_invalid(offset))
+			continue;
+
+		writel(pcie->paxb_map_regs[j++], pcie->base + offset);
+		writel(pcie->paxb_map_regs[j++], pcie->base + offset + 4);
+	}
+
+	/* restore inbound mapping registers */
+	for (region_idx = 0; region_idx < ib->nr_regions; region_idx++) {
+		const struct iproc_pcie_ib_map *ib_map =
+			&pcie->ib_map[region_idx];
+
+		iarr_offset = iproc_pcie_reg_offset(pcie,
+					MAP_REG(IPROC_PCIE_IARR0, region_idx));
+		imap_offset = iproc_pcie_reg_offset(pcie,
+					MAP_REG(IPROC_PCIE_IMAP0, region_idx));
+
+		if (iproc_pcie_reg_is_invalid(iarr_offset) ||
+		    iproc_pcie_reg_is_invalid(imap_offset))
+			continue;
+
+		writel(pcie->paxb_map_regs[j++], pcie->base + iarr_offset);
+		writel(pcie->paxb_map_regs[j++], pcie->base + iarr_offset + 4);
+
+		for (window_idx = 0; window_idx < ib_map->nr_windows;
+		     window_idx++) {
+			writel(pcie->paxb_map_regs[j++],
+			       pcie->base + imap_offset);
+			writel(pcie->paxb_map_regs[j++],
+			       pcie->base + imap_offset +
+			       ib_map->imap_addr_offset);
+
+			imap_offset += ib_map->imap_window_offset;
+		}
+	}
+	return 0;
+}
+
+int iproc_pcie_resume(struct iproc_pcie *pcie)
+{
+	int ret;
+
+	if (pcie->phy) {
+		ret = phy_init(pcie->phy);
+		if (ret) {
+			dev_err(pcie->dev, "unable to initialize PCIe PHY\n");
+			return ret;
+		}
+
+		ret = phy_power_on(pcie->phy);
+		if (ret) {
+			dev_err(pcie->dev, "unable to power on PCIe PHY\n");
+			goto err_exit_phy;
+		}
+	}
+
+	iproc_pcie_reset(pcie);
+
+	iproc_pcie_restore_paxb_map_regs(pcie);
+
+	iproc_pcie_write_reg(pcie, IPROC_PCIE_INTX_EN, SYS_RC_INTX_MASK);
+	if (pcie->msi)
+		iproc_msi_enable(pcie->msi);
+
+	return 0;
+
+err_exit_phy:
+	phy_exit(pcie->phy);
+	return ret;
+}
+EXPORT_SYMBOL(iproc_pcie_resume);
+
+int iproc_pcie_suspend(struct iproc_pcie *pcie)
+{
+	if (pcie->msi)
+		iproc_msi_disable(pcie->msi);
+	iproc_pcie_write_reg(pcie, IPROC_PCIE_INTX_EN, 0x0);
+
+	iproc_pcie_save_paxb_map_regs(pcie);
+
+	if (pcie->phy) {
+		phy_power_off(pcie->phy);
+		phy_exit(pcie->phy);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(iproc_pcie_suspend);
+
+/**
+ * FIXME
+ * Hacky code to work around the ASIC issue with PAXC and Nitro
+ *
+ * 1. The bridge header fix should eventually be moved to pci/quirks.c
+ * 2. The Nitro fix should be moved to either Chimp firmware or the Nitro
+ * kernel driver, which we have no control at this point. Or, hopefully this
+ * may be fixed in NS2 B0
+ */
+static void quirk_paxc_bridge(struct pci_dev *pdev)
+{
+	struct iproc_pcie *pcie = iproc_data(pdev->bus);
+	int pf;
+
+	if (pdev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
+		pdev->class = PCI_CLASS_BRIDGE_PCI << 8;
+		return;
+	}
+#define MAX_NUM_PAXC_PF              4
+#define PAXC_CFG_ECM_ADDR_OFFSET     0x1e0
+#define PAXC_CFG_ECM_DBG_EN_SHIFT    31
+#define PAXC_CFG_ECM_DBG_EN          BIT(PAXC_CFG_ECM_DBG_EN_SHIFT)
+#define PAXC_CFG_FUNC_SHIFT          12
+#define PAXC_CFG_FUNC_MASK           0x7000
+#define PAXC_CFG_FUNC(pf)            (((pf) << PAXC_CFG_FUNC_SHIFT) & \
+				      PAXC_CFG_FUNC_MASK)
+#define PAXC_CFG_ECM_DATA_OFFSET     0x1e4
+
+#define NITRO_MSI_CFG_OFFSET         0x4c4
+#define NITRO_QSIZE_OFFSET           0x4c0
+	for (pf = 0; pf < MAX_NUM_PAXC_PF; pf++) {
+		u32 val;
+
+		/*
+		 * TODO:
+		 * Need to figure out what these hardcoded values mean.
+		 * It's unbelievable that after weeks of poking around and
+		 * digging, there's still no one who can point me to a proper
+		 * Nitro documentation
+		 */
+		val = PAXC_CFG_ECM_DBG_EN | PAXC_CFG_FUNC(pf) |
+			NITRO_MSI_CFG_OFFSET;
+		writel(val, pcie->base + PAXC_CFG_ECM_ADDR_OFFSET);
+		writel(0x4, pcie->base + PAXC_CFG_ECM_DATA_OFFSET);
+
+		val = PAXC_CFG_ECM_DBG_EN | PAXC_CFG_FUNC(pf) |
+			NITRO_QSIZE_OFFSET;
+		writel(val, pcie->base + PAXC_CFG_ECM_ADDR_OFFSET);
+		writel(0xba80b, pcie->base + PAXC_CFG_ECM_DATA_OFFSET);
+	}
+	writel(0, pcie->base + PAXC_CFG_ECM_ADDR_OFFSET);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0x16cd, quirk_paxc_bridge);
+
+static void quirk_paxb_srp_check(struct pci_dev *pdev)
+{
+	struct iproc_pcie *pcie = iproc_data(pdev->bus);
+	/* CRS support is added in Stingray B0 */
+	pcie->srp_check = true;
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0xd714, quirk_paxb_srp_check);
+
+/*
+ * The MSI parsing logic within the PAXCv2 root complex block in Stingray A1/A2
+ * does not work and needs to be disabled
+ */
+static void quirk_paxc_disable_msi_parsing(struct pci_dev *pdev)
+{
+	struct iproc_pcie *pcie = iproc_data(pdev->bus);
+
+	if (pdev->hdr_type == PCI_HEADER_TYPE_BRIDGE)
+		iproc_pcie_paxc_v2_msi_steer(pcie, 0, false);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0x16f0,
+			quirk_paxc_disable_msi_parsing);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0xd802,
+			quirk_paxc_disable_msi_parsing);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0xd804,
+			quirk_paxc_disable_msi_parsing);
+
 MODULE_AUTHOR("Ray Jui <rjui@broadcom.com>");
 MODULE_DESCRIPTION("Broadcom iPROC PCIe common driver");
 MODULE_LICENSE("GPL v2");
--- a/drivers/pci/host/pcie-iproc.h
+++ b/drivers/pci/host/pcie-iproc.h
@@ -22,6 +22,9 @@
  *
  * PAXC is the wrapper used in root complex dedicated for internal emulated
  * endpoint devices.
+ *
+ * PAXC v2 is the second generation of root complex wrapper dedicated for
+ * internal emulated endpoint devices.
  */
 enum iproc_pcie_type {
 	IPROC_PCIE_PAXB_BCMA = 0,
@@ -67,8 +70,15 @@ struct iproc_pcie_ib {
  * @phy: optional PHY device that controls the Serdes
  * @map_irq: function callback to map interrupts
  * @ep_is_internal: indicates an internal emulated endpoint device is connected
+ * @nr_pf: number of physical functions (only valid for internally emulated
+ * EPs)
+ * @iproc_cfg_read: indicates the iProc config read function should be used
+ * @rej_unconfig_pf: indicates the root complex needs to detect and reject
+ * enumeration against unconfigured physical functions emulated in the ASIC
  * @has_apb_err_disable: indicates the controller can be configured to prevent
  * unsupported request from being forwarded as an APB bus error
+ * @fix_paxc_cap: indicates the controller has corrupted capability list in its
+ * config space registers and requires SW based fixup
  *
  * @need_ob_cfg: indicates SW needs to configure the outbound mapping window
  * @ob: outbound mapping related parameters
@@ -78,9 +88,17 @@ struct iproc_pcie_ib {
  * @ib: inbound mapping related parameters
  * @ib_map: outbound mapping region related parameters
  *
+ * @irq: interrupt line wired to the generic GIC for INTx
+ * @irq_domain: IRQ domain for INTx
+ *
  * @need_msi_steer: indicates additional configuration of the iProc PCIe
  * controller is required to steer MSI writes to external interrupt controller
  * @msi: MSI data
+ * @srp_check: Stingray B0 check.
+ * In Stingray B0 has new features
+ * CFG_RD_STATUS register gives CRS state,
+ * RO configuration
+ * this flag will be set in Stingray B0 PAXB core.
  */
 struct iproc_pcie {
 	struct device *dev;
@@ -88,6 +106,7 @@ struct iproc_pcie {
 	u16 *reg_offsets;
 	void __iomem *base;
 	phys_addr_t base_addr;
+
 #ifdef CONFIG_ARM
 	struct pci_sys_data sysdata;
 #endif
@@ -96,7 +115,11 @@ struct iproc_pcie {
 	struct phy *phy;
 	int (*map_irq)(const struct pci_dev *, u8, u8);
 	bool ep_is_internal;
+	unsigned int nr_pf;
+	bool iproc_cfg_read;
+	bool rej_unconfig_pf;
 	bool has_apb_err_disable;
+	bool fix_paxc_cap;
 
 	bool need_ob_cfg;
 	struct iproc_pcie_ob ob;
@@ -106,17 +129,31 @@ struct iproc_pcie {
 	struct iproc_pcie_ib ib;
 	const struct iproc_pcie_ib_map *ib_map;
 
+	int irq;
+	struct irq_domain *irq_domain;
+
 	bool need_msi_steer;
+	struct delayed_work work;
 	struct iproc_msi *msi;
+#ifdef CONFIG_PM_SLEEP
+	unsigned int *paxb_map_regs;
+#endif
+	bool srp_check;
 };
 
 int iproc_pcie_setup(struct iproc_pcie *pcie, struct list_head *res);
 int iproc_pcie_remove(struct iproc_pcie *pcie);
-int iproc_pcie_shutdown(struct iproc_pcie *pcie);
+
+#ifdef CONFIG_PM_SLEEP
+int iproc_pcie_suspend(struct iproc_pcie *pcie);
+int iproc_pcie_resume(struct iproc_pcie *pcie);
+#endif
 
 #ifdef CONFIG_PCIE_IPROC_MSI
 int iproc_msi_init(struct iproc_pcie *pcie, struct device_node *node);
 void iproc_msi_exit(struct iproc_pcie *pcie);
+void iproc_msi_enable(struct iproc_msi *msi);
+void iproc_msi_disable(struct iproc_msi *msi);
 #else
 static inline int iproc_msi_init(struct iproc_pcie *pcie,
 				 struct device_node *node)
@@ -126,6 +163,20 @@ static inline int iproc_msi_init(struct iproc_pcie *pcie,
 static inline void iproc_msi_exit(struct iproc_pcie *pcie)
 {
 }
+static inline void iproc_msi_enable(struct iproc_msi *msi)
+{
+}
+static inline void iproc_msi_disable(struct iproc_msi *msi)
+{
+}
 #endif
 
+int iproc_pcie_rev_init(struct iproc_pcie *pcie);
+void __iomem *iproc_pcie_bus_map_cfg_bus(struct pci_bus *bus,
+					 unsigned int devfn, int where);
+int iproc_pcie_config_read32(struct pci_bus *bus, unsigned int devfn,
+			     int where, int size, u32 *val);
+int iproc_pcie_config_write32(struct pci_bus *bus, unsigned int devfn,
+			      int where, int size, u32 val);
+
 #endif /* _PCIE_IPROC_H */
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -123,6 +123,7 @@ static ssize_t new_id_store(struct device_driver *driver, const char *buf,
 		pdev->subsystem_vendor = subvendor;
 		pdev->subsystem_device = subdevice;
 		pdev->class = class;
+		spin_lock_init(&pdev->lock);
 
 		if (pci_match_id(pdrv->id_table, pdev))
 			retval = -EEXIST;
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1796,6 +1796,9 @@ static umode_t sriov_attrs_are_visible(struct kobject *kobj,
 #endif
 	&pci_bridge_attr_group,
 	&pcie_dev_attr_group,
+#ifdef CONFIG_PCIEAER
+	&aer_stats_attr_group,
+#endif
 	NULL,
 };
 
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1356,7 +1356,9 @@ static void pci_enable_bridge(struct pci_dev *dev)
 {
 	struct pci_dev *bridge;
 	int retval;
+	struct mutex *lock = &dev->bridge_lock;
 
+	mutex_lock(lock);
 	bridge = pci_upstream_bridge(dev);
 	if (bridge)
 		pci_enable_bridge(bridge);
@@ -1364,6 +1366,7 @@ static void pci_enable_bridge(struct pci_dev *dev)
 	if (pci_is_enabled(dev)) {
 		if (!dev->is_busmaster)
 			pci_set_master(dev);
+		mutex_unlock(lock);
 		return;
 	}
 
@@ -1372,6 +1375,7 @@ static void pci_enable_bridge(struct pci_dev *dev)
 		dev_err(&dev->dev, "Error enabling bridge (%d), continuing\n",
 			retval);
 	pci_set_master(dev);
+	mutex_unlock(lock);
 }
 
 static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
@@ -1643,6 +1647,7 @@ void pci_disable_enabled_device(struct pci_dev *dev)
 void pci_disable_device(struct pci_dev *dev)
 {
 	struct pci_devres *dr;
+	unsigned long flags;
 
 	dr = find_pci_dr(dev);
 	if (dr)
@@ -1656,7 +1661,9 @@ void pci_disable_device(struct pci_dev *dev)
 
 	do_pci_disable_device(dev);
 
+	spin_lock_irqsave(&dev->lock, flags);
 	dev->is_busmaster = 0;
+	spin_unlock_irqrestore(&dev->lock, flags);
 }
 EXPORT_SYMBOL(pci_disable_device);
 
@@ -3587,6 +3594,7 @@ void __iomem *devm_pci_remap_cfg_resource(struct device *dev,
 static void __pci_set_master(struct pci_dev *dev, bool enable)
 {
 	u16 old_cmd, cmd;
+	unsigned long flags;
 
 	pci_read_config_word(dev, PCI_COMMAND, &old_cmd);
 	if (enable)
@@ -3598,7 +3606,9 @@ static void __pci_set_master(struct pci_dev *dev, bool enable)
 			enable ? "enabling" : "disabling");
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
+	spin_lock_irqsave(&dev->lock, flags);
 	dev->is_busmaster = enable;
+	spin_unlock_irqrestore(&dev->lock, flags);
 }
 
 /**
@@ -3919,6 +3929,11 @@ static void pci_flr_wait(struct pci_dev *dev)
 	 */
 	pci_read_config_dword(dev, PCI_COMMAND, &id);
 	while (id == ~0) {
+		if (pci_dev_is_disconnected(dev)) {
+			dev_warn(&dev->dev, "device is disonnected\n");
+			return;
+		}
+
 		if (delay > timeout) {
 			dev_warn(&dev->dev, "not ready %dms after FLR; giving up\n",
 				 100 + delay - 1);
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@ -367,4 +367,15 @@ int acpi_get_rc_resources(struct device *dev, const char *hid, u16 segment,
 			  struct resource *res);
 #endif
 
+#ifdef CONFIG_PCIEAER
+void pci_no_aer(void);
+void pci_aer_init(struct pci_dev *dev);
+void pci_aer_exit(struct pci_dev *dev);
+extern const struct attribute_group aer_stats_attr_group;
+#else
+static inline void pci_no_aer(void) { }
+static inline int pci_aer_init(struct pci_dev *d) { return -ENODEV; }
+static inline void pci_aer_exit(struct pci_dev *d) { }
+#endif
+
 #endif /* DRIVERS_PCI_H */
--- a/drivers/pci/pcie/aer/aerdrv.h
+++ b/drivers/pci/pcie/aer/aerdrv.h
@@ -33,6 +33,10 @@
 					PCI_ERR_UNC_MALF_TLP)
 
 #define AER_MAX_MULTI_ERR_DEVICES	5	/* Not likely to have more */
+
+#define AER_MAX_TYPEOF_COR_ERRS		16	/* as per PCI_ERR_COR_STATUS */
+#define AER_MAX_TYPEOF_UNCOR_ERRS	26	/* as per PCI_ERR_UNCOR_STATUS*/
+
 struct aer_err_info {
 	struct pci_dev *dev[AER_MAX_MULTI_ERR_DEVICES];
 	int error_dev_num;
@@ -76,6 +80,42 @@ struct aer_rpc {
 					 */
 };
 
+/* AER stats for the device */
+struct aer_stats {
+
+	/*
+	 * Fields for all AER capable devices. They indicate the errors
+	 * "as seen by this device". Note that this may mean that if an
+	 * end point is causing problems, the AER counters may increment
+	 * at its link partner (e.g. root port) because the errors will be
+	 * "seen" by the link partner and not the the problematic end point
+	 * itself (which may report all counters as 0 as it never saw any
+	 * problems).
+	 */
+	/* Counters for different type of correctable errors */
+	u64 dev_cor_errs[AER_MAX_TYPEOF_COR_ERRS];
+	/* Counters for different type of fatal uncorrectable errors */
+	u64 dev_fatal_errs[AER_MAX_TYPEOF_UNCOR_ERRS];
+	/* Counters for different type of nonfatal uncorrectable errors */
+	u64 dev_nonfatal_errs[AER_MAX_TYPEOF_UNCOR_ERRS];
+	/* Total number of ERR_COR sent by this device */
+	u64 dev_total_cor_errs;
+	/* Total number of ERR_FATAL sent by this device */
+	u64 dev_total_fatal_errs;
+	/* Total number of ERR_NONFATAL sent by this device */
+	u64 dev_total_nonfatal_errs;
+
+	/*
+	 * Fields for Root ports & root complex event collectors only, these
+	 * indicate the total number of ERR_COR, ERR_FATAL, and ERR_NONFATAL
+	 * messages received by the root port / event collector, INCLUDING the
+	 * ones that are generated internally (by the rootport itself)
+	 */
+	u64 rootport_total_cor_errs;
+	u64 rootport_total_fatal_errs;
+	u64 rootport_total_nonfatal_errs;
+};
+
 struct aer_broadcast_data {
 	enum pci_channel_state state;
 	enum pci_ers_result result;
@@ -111,6 +151,8 @@ static inline pci_ers_result_t merge_result(enum pci_ers_result orig,
 void aer_print_error(struct pci_dev *dev, struct aer_err_info *info);
 void aer_print_port_info(struct pci_dev *dev, struct aer_err_info *info);
 irqreturn_t aer_irq(int irq, void *context);
+void pci_rootport_aer_stats_incr(struct pci_dev *pdev,
+				 struct aer_err_source *e_src);
 
 #ifdef CONFIG_ACPI_APEI
 int pcie_aer_get_firmware_first(struct pci_dev *pci_dev);
--- a/drivers/pci/pcie/aer/aerdrv_core.c
+++ b/drivers/pci/pcie/aer/aerdrv_core.c
@@ -97,10 +97,20 @@ int pci_cleanup_aer_error_status_regs(struct pci_dev *dev)
 	return 0;
 }
 
-int pci_aer_init(struct pci_dev *dev)
+void pci_aer_init(struct pci_dev *dev)
 {
 	dev->aer_cap = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
-	return pci_cleanup_aer_error_status_regs(dev);
+
+	if (dev->aer_cap)
+		dev->aer_stats = kzalloc(sizeof(struct aer_stats), GFP_KERNEL);
+
+	pci_cleanup_aer_error_status_regs(dev);
+}
+
+void pci_aer_exit(struct pci_dev *dev)
+{
+	kfree(dev->aer_stats);
+	dev->aer_stats = NULL;
 }
 
 /**
@@ -725,8 +735,11 @@ static void aer_isr_one_error(struct pcie_device *p_device,
 		struct aer_err_source *e_src)
 {
 	struct aer_rpc *rpc = get_service_data(p_device);
+	struct pci_dev *pdev = p_device->port;
 	struct aer_err_info *e_info = &rpc->e_info;
 
+	pci_rootport_aer_stats_incr(pdev, e_src);
+
 	/*
 	 * There is a possibility that both correctable error and
 	 * uncorrectable error being logged. Report correctable error first.
--- a/drivers/pci/pcie/aer/aerdrv_errprint.c
+++ b/drivers/pci/pcie/aer/aerdrv_errprint.c
@@ -74,52 +74,52 @@
 	"Transaction Layer"
 };
 
-static const char *aer_correctable_error_string[] = {
-	"Receiver Error",		/* Bit Position 0	*/
+static const char *aer_correctable_error_string[AER_MAX_TYPEOF_COR_ERRS] = {
+	"RxErr",			/* Bit Position 0	*/
 	NULL,
 	NULL,
 	NULL,
 	NULL,
 	NULL,
-	"Bad TLP",			/* Bit Position 6	*/
-	"Bad DLLP",			/* Bit Position 7	*/
-	"RELAY_NUM Rollover",		/* Bit Position 8	*/
+	"BadTLP",			/* Bit Position 6	*/
+	"BadDLLP",			/* Bit Position 7	*/
+	"Rollover",			/* Bit Position 8	*/
 	NULL,
 	NULL,
 	NULL,
-	"Replay Timer Timeout",		/* Bit Position 12	*/
-	"Advisory Non-Fatal",		/* Bit Position 13	*/
-	"Corrected Internal Error",	/* Bit Position 14	*/
-	"Header Log Overflow",		/* Bit Position 15	*/
+	"Timeout",			/* Bit Position 12	*/
+	"NonFatalErr",			/* Bit Position 13	*/
+	"CorrIntErr",			/* Bit Position 14	*/
+	"HeaderOF",			/* Bit Position 15	*/
 };
 
-static const char *aer_uncorrectable_error_string[] = {
+static const char *aer_uncorrectable_error_string[AER_MAX_TYPEOF_UNCOR_ERRS] = {
 	"Undefined",			/* Bit Position 0	*/
 	NULL,
 	NULL,
 	NULL,
-	"Data Link Protocol",		/* Bit Position 4	*/
-	"Surprise Down Error",		/* Bit Position 5	*/
+	"DLP",				/* Bit Position 4	*/
+	"SDES",				/* Bit Position 5	*/
 	NULL,
 	NULL,
 	NULL,
 	NULL,
 	NULL,
 	NULL,
-	"Poisoned TLP",			/* Bit Position 12	*/
-	"Flow Control Protocol",	/* Bit Position 13	*/
-	"Completion Timeout",		/* Bit Position 14	*/
-	"Completer Abort",		/* Bit Position 15	*/
-	"Unexpected Completion",	/* Bit Position 16	*/
-	"Receiver Overflow",		/* Bit Position 17	*/
-	"Malformed TLP",		/* Bit Position 18	*/
+	"TLP",				/* Bit Position 12	*/
+	"FCP",				/* Bit Position 13	*/
+	"CmpltTO",			/* Bit Position 14	*/
+	"CmpltAbrt",			/* Bit Position 15	*/
+	"UnxCmplt",			/* Bit Position 16	*/
+	"RxOF",				/* Bit Position 17	*/
+	"MalfTLP",			/* Bit Position 18	*/
 	"ECRC",				/* Bit Position 19	*/
-	"Unsupported Request",		/* Bit Position 20	*/
-	"ACS Violation",		/* Bit Position 21	*/
-	"Uncorrectable Internal Error",	/* Bit Position 22	*/
-	"MC Blocked TLP",		/* Bit Position 23	*/
-	"AtomicOp Egress Blocked",	/* Bit Position 24	*/
-	"TLP Prefix Blocked Error",	/* Bit Position 25	*/
+	"UnsupReq",			/* Bit Position 20	*/
+	"ACSViol",			/* Bit Position 21	*/
+	"UncorrIntErr",			/* Bit Position 22	*/
+	"BlockedTLP",			/* Bit Position 23	*/
+	"AtomicOpBlocked",		/* Bit Position 24	*/
+	"TLPBlockedErr",		/* Bit Position 25	*/
 };
 
 static const char *aer_agent_string[] = {
@@ -129,6 +129,144 @@
 	"Transmitter ID"
 };
 
+#define aer_stats_dev_attr(name, stats_array, strings_array,		\
+			   total_string, total_field)			\
+	static ssize_t							\
+	name##_show(struct device *dev, struct device_attribute *attr,	\
+		     char *buf)						\
+{									\
+	unsigned int i;							\
+	char *str = buf;						\
+	struct pci_dev *pdev = to_pci_dev(dev);				\
+	u64 *stats = pdev->aer_stats->stats_array;			\
+									\
+	for (i = 0; i < ARRAY_SIZE(strings_array); i++) {		\
+		if (strings_array[i])					\
+			str += sprintf(str, "%s %llu\n",		\
+				       strings_array[i], stats[i]);	\
+		else if (stats[i])					\
+			str += sprintf(str, #stats_array "_bit[%d] %llu\n",\
+				       i, stats[i]);			\
+	}								\
+	str += sprintf(str, "TOTAL_%s %llu\n", total_string,		\
+		       pdev->aer_stats->total_field);			\
+	return str-buf;							\
+}									\
+static DEVICE_ATTR_RO(name)
+
+aer_stats_dev_attr(aer_dev_correctable, dev_cor_errs,
+		   aer_correctable_error_string, "ERR_COR",
+		   dev_total_cor_errs);
+aer_stats_dev_attr(aer_dev_fatal, dev_fatal_errs,
+		   aer_uncorrectable_error_string, "ERR_FATAL",
+		   dev_total_fatal_errs);
+aer_stats_dev_attr(aer_dev_nonfatal, dev_nonfatal_errs,
+		   aer_uncorrectable_error_string, "ERR_NONFATAL",
+		   dev_total_nonfatal_errs);
+
+#define aer_stats_rootport_attr(name, field)				\
+	static ssize_t							\
+	name##_show(struct device *dev, struct device_attribute *attr,	\
+		     char *buf)						\
+{									\
+	struct pci_dev *pdev = to_pci_dev(dev);				\
+	return sprintf(buf, "%llu\n", pdev->aer_stats->field);		\
+}									\
+static DEVICE_ATTR_RO(name)
+
+aer_stats_rootport_attr(aer_rootport_total_err_cor,
+			rootport_total_cor_errs);
+aer_stats_rootport_attr(aer_rootport_total_err_fatal,
+			rootport_total_fatal_errs);
+aer_stats_rootport_attr(aer_rootport_total_err_nonfatal,
+			rootport_total_nonfatal_errs);
+
+static struct attribute *aer_stats_attrs[] __ro_after_init = {
+	&dev_attr_aer_dev_correctable.attr,
+	&dev_attr_aer_dev_fatal.attr,
+	&dev_attr_aer_dev_nonfatal.attr,
+	&dev_attr_aer_rootport_total_err_cor.attr,
+	&dev_attr_aer_rootport_total_err_fatal.attr,
+	&dev_attr_aer_rootport_total_err_nonfatal.attr,
+	NULL
+};
+
+static umode_t aer_stats_attrs_are_visible(struct kobject *kobj,
+					   struct attribute *a, int n)
+{
+	struct device *dev = kobj_to_dev(kobj);
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	if (!pdev->aer_stats)
+		return 0;
+
+	if ((a == &dev_attr_aer_rootport_total_err_cor.attr ||
+	     a == &dev_attr_aer_rootport_total_err_fatal.attr ||
+	     a == &dev_attr_aer_rootport_total_err_nonfatal.attr) &&
+	    pci_pcie_type(pdev) != PCI_EXP_TYPE_ROOT_PORT)
+		return 0;
+
+	return a->mode;
+}
+
+const struct attribute_group aer_stats_attr_group = {
+	.attrs  = aer_stats_attrs,
+	.is_visible = aer_stats_attrs_are_visible,
+};
+
+static void pci_dev_aer_stats_incr(struct pci_dev *pdev,
+				   struct aer_err_info *info)
+{
+	int status, i, max = -1;
+	u64 *counter = NULL;
+	struct aer_stats *aer_stats = pdev->aer_stats;
+
+	if (!aer_stats)
+		return;
+
+	switch (info->severity) {
+	case AER_CORRECTABLE:
+		aer_stats->dev_total_cor_errs++;
+		counter = &aer_stats->dev_cor_errs[0];
+		max = AER_MAX_TYPEOF_COR_ERRS;
+		break;
+	case AER_NONFATAL:
+		aer_stats->dev_total_nonfatal_errs++;
+		counter = &aer_stats->dev_nonfatal_errs[0];
+		max = AER_MAX_TYPEOF_UNCOR_ERRS;
+		break;
+	case AER_FATAL:
+		aer_stats->dev_total_fatal_errs++;
+		counter = &aer_stats->dev_fatal_errs[0];
+		max = AER_MAX_TYPEOF_UNCOR_ERRS;
+		break;
+	}
+
+	status = (info->status & ~info->mask);
+	for (i = 0; i < max; i++)
+		if (status & (1 << i))
+			counter[i]++;
+}
+
+void pci_rootport_aer_stats_incr(struct pci_dev *pdev,
+				 struct aer_err_source *e_src)
+{
+	struct aer_stats *aer_stats = pdev->aer_stats;
+
+	if (!aer_stats)
+		return;
+
+	if (e_src->status & PCI_ERR_ROOT_COR_RCV)
+		aer_stats->rootport_total_cor_errs++;
+
+	if (e_src->status & PCI_ERR_ROOT_UNCOR_RCV) {
+		if (e_src->status & PCI_ERR_ROOT_FATAL_RCV)
+			aer_stats->rootport_total_fatal_errs++;
+		else
+			aer_stats->rootport_total_nonfatal_errs++;
+	}
+}
+
 static void __print_tlp_header(struct pci_dev *dev,
 			       struct aer_header_log_regs *t)
 {
@@ -161,6 +299,7 @@ static void __aer_print_error(struct pci_dev *dev,
 			dev_err(&dev->dev, "   [%2d] Unknown Error Bit%s\n",
 				i, info->first_error == i ? " (First)" : "");
 	}
+	pci_dev_aer_stats_incr(dev, info);
 }
 
 void aer_print_error(struct pci_dev *dev, struct aer_err_info *info)
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -535,6 +535,7 @@ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 		return NULL;
 
 	INIT_LIST_HEAD(&bridge->windows);
+	INIT_LIST_HEAD(&bridge->dma_resv);
 	bridge->dev.release = pci_release_host_bridge_dev;
 
 	return bridge;
@@ -551,6 +552,7 @@ struct pci_host_bridge *devm_pci_alloc_host_bridge(struct device *dev,
 		return NULL;
 
 	INIT_LIST_HEAD(&bridge->windows);
+	INIT_LIST_HEAD(&bridge->dma_resv);
 	bridge->dev.release = devm_pci_release_host_bridge_dev;
 
 	return bridge;
@@ -560,6 +562,7 @@ struct pci_host_bridge *devm_pci_alloc_host_bridge(struct device *dev,
 void pci_free_host_bridge(struct pci_host_bridge *bridge)
 {
 	pci_free_resource_list(&bridge->windows);
+	pci_free_resource_list(&bridge->dma_resv);
 
 	kfree(bridge);
 }
@@ -908,6 +911,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	child->dev.parent = child->bridge;
 	pci_set_bus_of_node(child);
 	pci_set_bus_speed(child);
+	mutex_init(&bridge->bridge_lock);
 
 	/* Set up default resource pointers and names.. */
 	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {
@@ -1861,6 +1865,7 @@ static void pci_configure_device(struct pci_dev *dev)
 
 static void pci_release_capabilities(struct pci_dev *dev)
 {
+	pci_aer_exit(dev);
 	pci_vpd_release(dev);
 	pci_iov_release(dev);
 	pci_free_cap_save_buffers(dev);
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -2316,6 +2316,9 @@ static void quirk_paxc_bridge(struct pci_dev *pdev)
 }
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0x16cd, quirk_paxc_bridge);
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0x16f0, quirk_paxc_bridge);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0xd802, quirk_paxc_bridge);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0xd804, quirk_paxc_bridge);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0xd750, quirk_paxc_bridge);
 #endif
 
 /* Originally in EDAC sources for i82875P:
@@ -3388,6 +3391,13 @@ static void quirk_no_bus_reset(struct pci_dev *dev)
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0033, quirk_no_bus_reset);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0034, quirk_no_bus_reset);
 
+/*
+ * Root port on some Cavium CN8xxx chips do not successfully complete a bus
+ * reset when used with certain child devices.  After the reset, config
+ * accesses to the child may fail.
+ */
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_CAVIUM, 0xa100, quirk_no_bus_reset);
+
 static void quirk_no_pm_reset(struct pci_dev *dev)
 {
 	/*
@@ -4475,6 +4485,15 @@ static int pci_quirk_mf_endpoint_acs(struct pci_dev *dev, u16 acs_flags)
 	return acs_flags ? 0 : 1;
 }
 
+static int pcie_quirk_brcm_bridge_acs(struct pci_dev *dev, u16 acs_flags)
+{
+	u16 flags = (PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF | PCI_ACS_SV);
+	int ret = acs_flags & ~flags ? 0 : 1;
+
+	return ret;
+}
+
+
 static const struct pci_dev_acs_enabled {
 	u16 vendor;
 	u16 device;
@@ -4557,6 +4576,7 @@ static int pci_quirk_mf_endpoint_acs(struct pci_dev *dev, u16 acs_flags)
 	{ PCI_VENDOR_ID_CAVIUM, PCI_ANY_ID, pci_quirk_cavium_acs },
 	/* APM X-Gene */
 	{ PCI_VENDOR_ID_AMCC, 0xE004, pci_quirk_xgene_acs },
+	{ PCI_VENDOR_ID_BROADCOM, 0xD714, pcie_quirk_brcm_bridge_acs },
 	{ 0 }
 };
 
@@ -4872,3 +4892,27 @@ static void quirk_no_ats(struct pci_dev *pdev)
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x98e4, quirk_no_ats);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x6900, quirk_no_ats);
 #endif /* CONFIG_PCI_ATS */
+
+/* Freescale PCIe doesn't support MSI in RC mode */
+static void quirk_fsl_no_msi(struct pci_dev *pdev)
+{
+	if (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT)
+		pdev->no_msi = 1;
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_FREESCALE, PCI_ANY_ID, quirk_fsl_no_msi);
+
+/*
+ * classless end points are not enumarted by pci framework, because
+ * of which, resources are not aligned into pci bus addresses, and
+ * hence, no BAR populated.
+ */
+static void quirk_avip_force_class(struct pci_dev *pdev)
+{
+	u32 class;
+
+	pci_read_config_dword(pdev, PCI_CLASS_REVISION, &class);
+	class = class >> 8;
+	if (class == PCI_CLASS_NOT_DEFINED)
+		pdev->class = PCI_CLASS_MEMORY_OTHER;
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_CADENCE, PCI_DEVICE_ID_CADENCE_AVIP, quirk_avip_force_class);
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -16,13 +16,17 @@ static void pci_free_resources(struct pci_dev *dev)
 
 static void pci_stop_dev(struct pci_dev *dev)
 {
+	unsigned long flags;
+
 	pci_pme_active(dev, false);
 
 	if (dev->is_added) {
 		device_release_driver(&dev->dev);
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);
+		spin_lock_irqsave(&dev->lock, flags);
 		dev->is_added = 0;
+		spin_unlock_irqrestore(&dev->lock, flags);
 	}
 }
 
--- a/drivers/phy/broadcom/Kconfig
+++ b/drivers/phy/broadcom/Kconfig
@@ -10,6 +10,43 @@ config PHY_CYGNUS_PCIE
 	  Enable this to support the Broadcom Cygnus PCIe PHY.
 	  If unsure, say N.
 
+config PHY_OMEGA_PCIE
+	tristate "Broadcom Omega PCIe PHY driver"
+	depends on OF && (ARCH_BCM_IPROC || COMPILE_TEST)
+	select GENERIC_PHY
+	default ARCH_BCM_IPROC
+	help
+	  Enable this to support the Broadcom Omega PCIe PHY.
+	  If unsure, say N.
+
+config PHY_SR_PCIE_DIAG
+	tristate "Broadcom Stingray PCIe PHY Diag driver"
+	depends on OF && (ARCH_BCM_IPROC || COMPILE_TEST)
+	select GENERIC_PHY
+	default ARCH_BCM_IPROC
+	help
+	  Enable this to support the Broadcom Stingray PCIe PHY diag test.
+	  If unsure, say N.
+
+config PHY_STINGRAY_SATA_PRBS
+	tristate "Broadcom Stingray SATA PHY PRBS driver"
+	depends on OF && (ARCH_BCM_IPROC || COMPILE_TEST)
+	select GENERIC_PHY
+	default ARCH_BCM_IPROC
+	help
+	  Enable this to support the Broadcom Stingray SATA PHY PRBS test.
+	  If unsure, say N.
+
+config PHY_STINGRAY_USB
+	tristate "Broadcom Stingray USB2 DRD PHY driver"
+	depends on OF && (ARCH_BCM_IPROC || COMPILE_TEST)
+	select GENERIC_PHY
+	default ARCH_BCM_IPROC
+	help
+	  Enable this to support the Broadcom Stingray USB PHY for DRDU3,
+	  DRDU2 and USB3H.
+	  If unsure, say N.
+
 config BCM_KONA_USB2_PHY
 	tristate "Broadcom Kona USB2 PHY Driver"
 	depends on HAS_IOMEM
@@ -67,3 +104,13 @@ config PHY_BRCM_SATA
 	help
 	  Enable this to support the Broadcom SATA PHY.
 	  If unsure, say N.
+
+config PHY_BCM_SR_PCIE
+	tristate "Broadcom Stingray PCIe PHY driver"
+	depends on OF && (ARCH_BCM_IPROC || COMPILE_TEST)
+	select GENERIC_PHY
+	select MFD_SYSCON
+	default ARCH_BCM_IPROC
+	help
+	  Enable this to support the Broadcom Stingray PCIe PHY
+	  If unsure, say N.
--- a/drivers/phy/broadcom/Makefile
+++ b/drivers/phy/broadcom/Makefile
@@ -1,8 +1,14 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_PHY_CYGNUS_PCIE)		+= phy-bcm-cygnus-pcie.o
+obj-$(CONFIG_PHY_NS2_USB2)		+= phy-bcm-ns2-usb2.o
+obj-$(CONFIG_PHY_NS2_USB3)		+= phy-bcm-ns2-usb3.o
+obj-$(CONFIG_PHY_SR_PCIE_DIAG)          += phy-bcm-sr-pcie-diag.o
+obj-$(CONFIG_PHY_STINGRAY_SATA_PRBS)	+= phy-bcm-stingray-sata-prbs.o
+obj-$(CONFIG_PHY_STINGRAY_USB)		+= phy-bcm-stingray-usb.o
 obj-$(CONFIG_BCM_KONA_USB2_PHY)		+= phy-bcm-kona-usb2.o
 obj-$(CONFIG_PHY_BCM_NS_USB2)		+= phy-bcm-ns-usb2.o
 obj-$(CONFIG_PHY_BCM_NS_USB3)		+= phy-bcm-ns-usb3.o
 obj-$(CONFIG_PHY_NS2_PCIE)		+= phy-bcm-ns2-pcie.o
 obj-$(CONFIG_PHY_NS2_USB_DRD)		+= phy-bcm-ns2-usbdrd.o
 obj-$(CONFIG_PHY_BRCM_SATA)		+= phy-brcm-sata.o
+obj-$(CONFIG_PHY_BCM_SR_PCIE)           += phy-bcm-sr-pcie.o
--- /dev/null
+++ b/drivers/phy/broadcom/phy-bcm-sr-eye-ref.h
@@ -0,0 +1,93 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright(c) 2018 Broadcom
+ */
+
+#ifndef _PHY_BCM_SR_EYE_REF_H
+#define _PHY_BCM_SR_EYE_REF_H
+
+static const u8 pcie_eye_ref[] = {
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x2d,
+	0x2e, 0x20, 0x20, 0x2e, 0x2d, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x22, 0x2d, 0x2e, 0x20, 0x20, 0x2e, 0x2d, 0x2d, 0x2e, 0x0a, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x20, 0x2e, 0x2e, 0x20,
+	0x5c, 0x2f, 0x20, 0x20, 0x2e, 0x2d, 0x2e, 0x20, 0x2e, 0x2d, 0x2e,
+	0x20, 0x20, 0x5c, 0x2f, 0x20, 0x2e, 0x2e, 0x20, 0x5c, 0x0a, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x7c, 0x20, 0x20, 0x27,
+	0x7c, 0x20, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x59, 0x20, 0x20, 0x20,
+	0x5c, 0x20, 0x20, 0x7c, 0x27, 0x20, 0x20, 0x7c, 0x20, 0x7c, 0x0a,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x5c, 0x20, 0x20,
+	0x20, 0x5c, 0x20, 0x20, 0x5c, 0x20, 0x30, 0x20, 0x7c, 0x20, 0x30,
+	0x20, 0x2f, 0x20, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x2f, 0x20, 0x7c,
+	0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x27,
+	0x2d, 0x20, 0x2c, 0x5c, 0x2e, 0x2d, 0x22, 0x60, 0x60, 0x20, 0x60,
+	0x60, 0x22, 0x2d, 0x2e, 0x2f, 0x2c, 0x20, 0x2d, 0x27, 0x20, 0x2f,
+	0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0x27,
+	0x2d, 0x27, 0x20, 0x2f, 0x5f, 0x20, 0x20, 0x20, 0x5e, 0x20, 0x5e,
+	0x20, 0x20, 0x20, 0x5f, 0x5c, 0x20, 0x27, 0x2d, 0x27, 0x60, 0x0a,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x2d,
+	0x27, 0x7c, 0x20, 0x20, 0x5c, 0x2e, 0x5f, 0x20, 0x20, 0x20, 0x5f,
+	0x2e, 0x2f, 0x20, 0x20, 0x7c, 0x27, 0x2d, 0x2d, 0x2e, 0x20, 0x0a,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x60, 0x20, 0x20, 0x20,
+	0x20, 0x5c, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x60, 0x7e, 0x60, 0x20,
+	0x2f, 0x20, 0x20, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x20, 0x60, 0x5c,
+	0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x27, 0x2e, 0x5f, 0x20, 0x27, 0x2d, 0x2d, 0x2d,
+	0x27, 0x20, 0x5f, 0x2e, 0x27, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x5c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x27, 0x7e, 0x2d,
+	0x2d, 0x2d, 0x7e, 0x27, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x5c, 0x0a, 0x20, 0x20, 0x20, 0x2f, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x2e, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x5c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x0a, 0x20,
+	0x20, 0x2f, 0x20, 0x20, 0x20, 0x2e, 0x27, 0x2d, 0x2e, 0x2f, 0x60,
+	0x2f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2e, 0x27,
+	0x7e, 0x27, 0x2d, 0x2e, 0x7c, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x5c, 0x0a, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x2f, 0x20,
+	0x20, 0x20, 0x20, 0x60, 0x5c, 0x3a, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0x5c,
+	0x27, 0x2e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x0a, 0x2f,
+	0x20, 0x20, 0x20, 0x7c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x3b, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x27, 0x2e, 0x60, 0x3b, 0x20,
+	0x20, 0x20, 0x20, 0x2f, 0x0a, 0x5c, 0x20, 0x20, 0x20, 0x5c, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3b, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x5c, 0x2f, 0x20, 0x20, 0x20, 0x2f, 0x0a, 0x20,
+	0x27, 0x2e, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x3b, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x60, 0x20,
+	0x20, 0x2f, 0x0a, 0x20, 0x20, 0x20, 0x27, 0x2e, 0x5f, 0x27, 0x2e,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x27, 0x2e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7c,
+	0x20, 0x20, 0x20, 0x3b, 0x2f, 0x5f, 0x0a, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x2f, 0x5f, 0x5f, 0x3e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x27,
+	0x2e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x5f, 0x20,
+	0x5f, 0x20, 0x5f, 0x2f, 0x20, 0x20, 0x20, 0x2c, 0x20, 0x20, 0x27,
+	0x2d, 0x2d, 0x2e, 0x0a, 0x20, 0x20, 0x20, 0x2e, 0x27, 0x20, 0x20,
+	0x20, 0x27, 0x2e, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x7e, 0x7e, 0x7e,
+	0x7e, 0x7e, 0x2d, 0x2e, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x7c, 0x2d, 0x2d, 0x27, 0x60, 0x7e, 0x7e, 0x2d, 0x2e, 0x20, 0x20,
+	0x5c, 0x0a, 0x20, 0x20, 0x2f, 0x2f, 0x20, 0x2f, 0x20, 0x2e, 0x2d,
+	0x2d, 0x2d, 0x27, 0x2f, 0x20, 0x20, 0x2e, 0x2d, 0x7e, 0x7e, 0x2d,
+	0x2e, 0x5f, 0x2f, 0x20, 0x2f, 0x20, 0x2f, 0x20, 0x2f, 0x2d, 0x2d,
+	0x2d, 0x2e, 0x2e, 0x5f, 0x5f, 0x2e, 0x27, 0x20, 0x20, 0x2f, 0x0a,
+	0x20, 0x28, 0x28, 0x5f, 0x28, 0x5f, 0x2f, 0x20, 0x20, 0x20, 0x20,
+	0x2f, 0x20, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x28,
+	0x5f, 0x28, 0x5f, 0x28, 0x5f, 0x28, 0x2d, 0x2d, 0x2d, 0x2e, 0x5f,
+	0x5f, 0x20, 0x20, 0x20, 0x20, 0x2e, 0x27, 0x0a, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x7c,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0x7e,
+	0x7e, 0x60, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x7c, 0x20, 0x7c, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x5c, 0x27, 0x2e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x27, 0x2e, 0x2e, 0x2e,
+	0x2e, 0x27, 0x20, 0x7c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x27, 0x2e, 0x2c, 0x5f,
+	0x5f, 0x5f, 0x2e, 0x27, 0x20, 0x20, 0x20, 0x20, 0x66, 0x6f, 0x72,
+	0x20, 0x54, 0x72, 0x61, 0x63, 0x20, 0x20, 0x20, 0x20, 0x0d
+};
+
+#endif
--- /dev/null
+++ b/drivers/phy/broadcom/phy-bcm-sr-pcie-diag.c
@@ -0,0 +1,2217 @@
+/*
+ * Copyright 2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation (the "GPL").
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License version 2 (GPLv2) for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 (GPLv2) along with this source code.
+ */
+
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "phy-bcm-sr-eye-ref.h"
+
+#define MAX_PHY_COUNT 8
+
+#define CDRU_STRAP_DATA_LSW_OFFSET	0x5c
+
+#define PCIE_PIPEMUX_CFG_OFFSET		0x10c
+#define PCIE_PIPEMUX_SHIFT		19
+#define PCIE_PIPEMUX_MASK		0xf
+
+#define PCIE_CORE0_PMI_SEL_CFG		0x864
+#define PCIE_CORE1_PMI_SEL_CFG		0x964
+#define PCIE_CORE2_PMI_SEL_CFG		0xa64
+#define PCIE_CORE3_PMI_SEL_CFG		0xb64
+#define PCIE_CORE4_PMI_SEL_CFG		0xc64
+#define PCIE_CORE5_PMI_SEL_CFG		0xd64
+#define PCIE_CORE6_PMI_SEL_CFG		0xe64
+#define PCIE_CORE7_PMI_SEL_CFG		0xf64
+
+#define PAXB_CFG_CFG_TYPE_MASK		0x1
+#define PAXB_CFG_IND_ADDR_OFFSET	0x120
+#define PAXB_CFG_IND_ADDR_MASK		0x00001ffc
+#define PAXB_CFG_IND_DATA_OFFSET	0x124
+
+#define CFG_RC_PMI_ADDR			0x1130
+#define CFG_RC_DEV_ID_SHIFT		27
+#define CFG_RC_DEV_ID			BIT(27)
+#define CFG_RC_BCAST_SHIFT		21
+#define CFG_RC_BCAST_VAL		0xf
+#define CFG_RC_LANE_SHIFT		16
+#define LANE_BCAST_VAL			0x1f
+#define NR_LANES_PER_SET		4
+#define NR_LANES_PER_PHY		2
+#define LANE_OFFSET_SHIFT		2
+
+#define CFG_RC_PMI_WDATA		0x1134
+#define CFG_RC_WCMD_SHIFT		31
+#define CFG_RC_WCMD_MASK		(1 << CFG_RC_WCMD_SHIFT)
+#define CFG_RC_RCMD_SHIFT		30
+#define CFG_RC_RCMD_MASK		(1 << CFG_RC_RCMD_SHIFT)
+#define CFG_RC_PMI_RDATA		0x1138
+#define CFG_RC_RWCMD_MASK		(CFG_RC_WCMD_MASK | CFG_RC_RCMD_MASK)
+#define CFG_RC_RDATA_MASK		0xffff
+#define CFG_RC_RACK_SHIFT		31
+#define CFG_RC_RACK_MASK		(1 << CFG_RC_RACK_SHIFT)
+
+#define MERLIN16_PCIE_BLK2_PWRMGMT_7		0x1208
+#define MERLIN16_PCIE_BLK2_PWRMGMT_8		0x1209
+#define MERLIN16_AMS_TX_CTRL_5			0xd0a5
+#define MERLIN16_AMS_TX_CTRL_5_POST2_TO_1	BIT(13)
+#define MERLIN16_AMS_TX_CTRL_5_ENA_PRE		BIT(12)
+#define MERLIN16_AMS_TX_CTRL_5_ENA_POST1	BIT(11)
+#define MERLIN16_AMS_TX_CTRL_5_ENA_POST2	BIT(10)
+#define MERLIN16_PCIE_BLK2_PWRMGMT_7_VAL	0x96
+#define MERLIN16_PCIE_BLK2_PWRMGMT_8_VAL	0x12c
+
+/* microcode related fields */
+#define DSC_A_UC_CTRL			0xd00d
+#define DSC_SUPP_INFO_SHIFT		8
+#define DSC_READY_SHIFT			7
+#define DSC_READY			BIT(DSC_READY_SHIFT)
+#define DSC_ERR_SHIFT			6
+#define DSC_ERR				BIT(DSC_ERR_SHIFT)
+
+#define DSC_SCRATCH			0xd00e
+
+#define DSC_E_CTRL			0xd040
+#define DSC_P1_THRESH_SEL_SHIFT		3
+#define DSC_P1_THRESH_SEL		BIT(DSC_P1_THRESH_SEL_SHIFT)
+
+#define RX_LOCK_STATUS			0xd0dc
+#define RX_LOCK				BIT(0)
+
+#define UC_A_AHB_CTRL0			0xd202
+#define UC_AUTO_INC_RADDR_EN_SHIFT	13
+#define UC_AUTO_INC_RADDR_EN		BIT(UC_AUTO_INC_RADDR_EN_SHIFT)
+#define UC_AUTO_INC_WADDR_EN_SHIFT	12
+#define UC_AUTO_INC_WADDR_EN		BIT(UC_AUTO_INC_WADDR_EN_SHIFT)
+#define UC_RSIZE_SHIFT			4
+#define UC_RSIZE_8			0
+#define UC_RSIZE_16			1
+#define UC_RSIZE_32			2
+#define UC_WORD_SIZE			16
+#define UC_WORD_MASK			(BIT(UC_WORD_SIZE) - 1)
+#define UC_WSIZE_SHIFT			0
+
+#define UC_A_AHB_WADDR_LSW		0xd204
+#define UC_A_AHB_WADDR_MSW		0xd205
+#define UC_A_AHB_WDATA_LSW		0xd206
+#define UC_A_AHB_WDATA_MSW		0xd207
+#define UC_A_AHB_RADDR_LSW		0xd208
+#define UC_A_AHB_RADDR_MSW		0xd209
+#define UC_A_AHB_RDATA_LSW		0xd20a
+#define UC_A_AHB_RDATA_MSW		0xd20b
+
+#define LANE_VAR_RAM_BASE		0x500
+#define LANE_VAR_RAM_SIZE		0x100
+
+#define UC_RAM_BASE			0x0100
+#define UC_SIGNATURE_OFFSET		((UC_RAM_BASE) + 0x0000)
+#define UC_SIGNATURE_MASK		0x00ffffff
+#define UC_SIGNATURE			0x00666e49
+#define UC_VERSION_SHIFT		24
+#define UC_VERSION_MASK			0xff
+
+#define UC_TRACE_LANE_MEM_SIZE_OFFSET	((UC_RAM_BASE) + 0x0008)
+#define UC_DIAG_MEM_SIZE_MASK		0xffff
+#define UC_TRACE_MEM_SIZE_MASK		0xffff
+
+#define UC_OTHER_SIZE_OFFSET		((UC_RAM_BASE) + 0x000c)
+#define UC_LANE_SIZE_SHIFT		0
+#define UC_LANE_SIZE_MASK		0xff
+#define UC_TR_MEM_DESC_WR_MASK		0x1000000
+#define UC_CORE_VAR_RAM_SIZE_SHIFT	8
+#define UC_CORE_VAR_RAM_SIZE_MASK	0xff
+#define UC_LANE_VAR_RAM_SIZE_SHIFT	16
+#define UC_LANE_VAR_RAM_SIZE_MASK	0xffff
+
+#define UC_TRACE_MEM_PTR_OFFSET		((UC_RAM_BASE) + 0x0010)
+#define UC_CORE_MEM_PTR_OFFSET		((UC_RAM_BASE) + 0x0014)
+#define UC_LANE_MEM_PTR_OFFSET		((UC_RAM_BASE) + 0x001c)
+#define UC_MICRO_MEM_PTR_OFFSET		((UC_RAM_BASE) + 0x0064)
+
+#define UC_OTHER_SIZE_2_OFFSET		((UC_RAM_BASE) + 0x0060)
+#define UC_MICRO_MEM_SIZE_SHIFT		4
+#define UC_MICRO_MEM_SIZE_MASK		0xff
+#define UC_MICRO_CNT_MASK		0xf
+
+#define UC_DIAG_TIME_CTRL_OFFSET	0x0011
+#define UC_DIAG_ERR_CTRL_OFFSET		0x0012
+
+#define UC_DIAG_STATUS_OFFSET		0x0014
+#define UC_DIAG_RDY_MASK		0x8000
+#define UC_DIAG_RD_PTR_OFFSET		0x0016
+#define UC_DIAG_VAR_MASK		0xff
+#define UC_DIAG_WR_PTR_OFFSET		0x001c
+
+/* allow up to 5 ms for PMI read/write transaction to finish */
+#define PMI_TIMEOUT_MS			5
+#define GEN1_PRBS_VAL			0x4
+#define GEN2_PRBS_VAL			0x5
+#define GEN3_PRBS_VAL			0x6
+#define GEN_STR_LEN			4
+#define MAX_LANE_RETRIES		10
+#define PMI_PASS_STATUS			0x8000
+
+#define RC_PCIE_RST_OUTPUT_SHIFT	0
+#define RC_PCIE_RST_OUTPUT		BIT(RC_PCIE_RST_OUTPUT_SHIFT)
+
+#define MAX_EYE_Y			63
+#define Y_START				31
+
+#define MAX_EYE_X			64
+#define X_START				(-31)
+#define X_END				31
+#define STRIPE_SIZE			MAX_EYE_X
+
+#define EYE_REF_MODE			11
+
+#define BER_MAX_SAMPLES			64
+#define BER_NR_MODES			4
+
+#define BER_MODE_POS			0
+#define BER_MODE_NEG			1
+#define BER_MODE_VERT			(0 << 1)
+#define BER_MODE_HORZ			(1 << 1)
+
+#define BITS_PER_NIBBLE			4
+#define NIBBLE_MASK			(BIT(BITS_PER_NIBBLE) - 1)
+#define BYTE_MASK			(BIT(BITS_PER_BYTE) - 1)
+
+/* default BER sampling time */
+#define BER_DFT_SAMPLING_TIME		96
+
+/* default BER error number */
+#define BER_MAX_ERR_CTRL		100
+
+/*
+ * Scale actual time down with a factor of 1.33 before sending command to
+ * serdes microcode
+ */
+#define BER_TIME_SCALING(time)		((time) * 3 / 4)
+
+/*
+ * Scale actual error number down with a factor of 16 before sending command to
+ * serdes microcode
+ */
+#define BER_ERR_SCALING(err)		((err) / 16)
+
+#define MAX_BER_SAMPLING_TIME		256
+
+#define BER_SIGNATURE			0x42455253
+
+enum pcie_modes {
+	PCIE_MODE0 = 0,
+	PCIE_MODE1,
+	PCIE_MODE2,
+	PCIE_MODE3,
+	PCIE_MODE4,
+	PCIE_MODE5,
+	PCIE_MODE6,
+	PCIE_MODE7,
+	PCIE_MODE8,
+	PCIE_MODE9,
+	PCIE_MODE10,
+	PCIE_MODE11,
+	PCIE_MODE12,
+	PCIE_MODE13,
+	PCIE_MODE_DEFAULT = -1,
+};
+
+/* UC command */
+enum uc_cmd {
+	UC_CMD_NULL = 0,
+	UC_CMD_UC_CTRL = 1,
+	UC_CMD_EN_DIAG = 5,
+	UC_CMD_CAPTURE_BER_START = 16,
+	UC_CMD_READ_DIAG_DATA_BYTE = 17,
+	UC_CMD_READ_DIAG_DATA_WORD = 18,
+	UC_CMD_CAPTURE_BER_END = 19,
+};
+
+/* UC control command */
+enum uc_cmd_ctrl {
+	UC_CMD_CTRL_STOP_GRACEFULLY = 0,
+	UC_CMD_CTRL_STOP_IMMEDIATE = 1,
+	UC_CMD_CTRL_RESUME = 2
+};
+
+/* UC diag command */
+enum uc_cmd_diag {
+	UC_CMD_DIAG_DISABLE = 3,
+	UC_CMD_DIAG_START_VSCAN_EYE = 4,
+	UC_CMD_DIAG_START_HSCAN_EYE = 5,
+	UC_CMD_DIAG_GET_EYE_SAMPLE = 6,
+};
+
+/* UC parameters stored in RAM */
+struct uc_info {
+	u32 signature;
+	u32 diag_mem_ram_base;
+	u32 diag_mem_ram_size;
+	u32 core_var_ram_base;
+	u32 core_var_ram_size;
+	u32 lane_var_ram_base;
+	u32 lane_var_ram_size;
+	u32 trace_mem_ram_base;
+	u32 trace_mem_ram_size;
+	u32 micro_var_ram_base;
+	u8 lane_count;
+	u8 trace_mem_desc_writes;
+	u8 micro_count;
+	u8 micro_var_ram_size;
+	u16 grp_ram_size;
+	u8 version;
+};
+
+struct pcie_prbs_dev {
+	struct device *dev;
+	struct regmap *pipemux_strap_map;
+	void __iomem *pcie_ss_base;
+	void __iomem *paxb_base[MAX_PHY_COUNT];
+	char test_gen[GEN_STR_LEN];
+	unsigned int test_retries;
+	unsigned int slot_num;
+	unsigned int err_count;
+	unsigned int test_start;
+	unsigned int phy_count;
+	unsigned int lane;
+	unsigned int ber_sampling_time;
+	enum pcie_modes pcie_mode;
+	struct mutex test_lock;
+
+	struct uc_info info;
+};
+
+/*
+ * Following table gives information about PHYs are wired to which
+ * core in given pcie RC mode.
+ */
+static unsigned int phy_mask[][8] = {
+	/* Mode 0: 1x16(EP) */
+	[PCIE_MODE0] = {0x00},
+	/* Mode 1: 1x8 (EP), 1x8 (RC) */
+	[PCIE_MODE1] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0},
+	/* Mode 2: 4x4 (EP) */
+	[PCIE_MODE2] = {0x00},
+	/* Mode 3: 2x8 (RC) */
+	[PCIE_MODE3] = {0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0},
+	/* Mode 4: 4x4 (RC) */
+	[PCIE_MODE4] = {0x03, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x30, 0xc0},
+	/* Mode 5: 8x2 (RC) */
+	[PCIE_MODE5] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80},
+	/* Mode 6: 3x4 , 2x2 (RC) */
+	[PCIE_MODE6] = {0x03, 0x00, 0x04, 0x08, 0x00, 0x00, 0x30, 0xc0},
+	/* Mode 7: 1x4 , 6x2 (RC) */
+	[PCIE_MODE7] = {0x03, 0x00, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80},
+	/* Mode 8: 1x8(EP), 4x2(RC) */
+	[PCIE_MODE8] = {0x00, 0x00, 0x00, 0x00, 0x10, 0x20, 0x40, 0x80},
+	/* Mode 9: 1x8(EP), 2x4(RC) */
+	[PCIE_MODE9] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xc0},
+	/* Mode 10: 2x4(EP), 2x4(RC) */
+	[PCIE_MODE10] = {0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00},
+	/* Mode 11: 2x4(EP), 4x2(RC) */
+	[PCIE_MODE11] = {0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00},
+	/* Mode 12: 1x4(EP), 6x2(RC) */
+	[PCIE_MODE12] = {0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80},
+	/* Mode 13: 2x4(EP), 1x4(RC), 2x2(RC) */
+	[PCIE_MODE13] = {0x00, 0x00, 0x04, 0x08, 0x00, 0x00, 0x30, 0x00}
+};
+
+/* Following table indicates the PHYs requiring work-around */
+static unsigned int phy_workaround_table[] = {
+	/* Mode 0: 1x16(EP) */
+	0x00,
+	/* Mode 1: 1x8 (EP), 1x8 (RC) */
+	0x80,
+	/* Mode 2: 4x4 (EP) */
+	0x00,
+	/* Mode 3: 2x8 (RC) */
+	0x88,		/* work-around is needed for serdes 3 and 7 */
+	/* Mode 4: 4x4 (RC) */
+	0x00,
+	/* Mode 5: 8x2 (RC) */
+	0x00,
+	/* Mode 6: 3x4 , 2x2 (RC) */
+	0x00,
+	/* Mode 7: 1x4 , 6x2 (RC) */
+	0x00,
+	/* Mode 8: 1x8(EP), 4x2(RC) */
+	0x00,
+	/* Mode 9: 1x8(EP), 2x4(RC) */
+	0x00,
+	/* Mode 10: 2x4(EP), 2x4(RC) */
+	0x00,
+	/* Mode 11: 2x4(EP), 4x2(RC) */
+	0x00,
+	/* Mode 12: 1x4(EP), 6x2(RC) */
+	0x00,
+	/* Mode 13: 2x4(EP), 1x4(RC), 2x2(RC) */
+	0x00
+};
+
+static u32 ber_mode[BER_NR_MODES] = {
+	BER_MODE_HORZ | BER_MODE_NEG,
+	BER_MODE_HORZ | BER_MODE_POS,
+	BER_MODE_VERT | BER_MODE_NEG,
+	BER_MODE_VERT | BER_MODE_POS,
+};
+
+static u32 ber_time[BER_NR_MODES][BER_MAX_SAMPLES];
+static u32 ber_err[BER_NR_MODES][BER_MAX_SAMPLES];
+
+/* for eye scan stripe storage */
+static u32 stripe[MAX_EYE_Y][MAX_EYE_X];
+
+static inline u32 pmi_addr(u16 addr, u8 lane)
+{
+	u32 val;
+
+	if (lane == LANE_BCAST_VAL) {
+		val = CFG_RC_DEV_ID |
+		      (CFG_RC_BCAST_VAL << CFG_RC_BCAST_SHIFT) |
+		      (LANE_BCAST_VAL << CFG_RC_LANE_SHIFT) |
+		      addr;
+	} else {
+		lane = ((lane / NR_LANES_PER_SET) << LANE_OFFSET_SHIFT) |
+		       (lane % NR_LANES_PER_SET);
+		val = CFG_RC_DEV_ID | (lane << CFG_RC_LANE_SHIFT) | addr;
+	}
+
+	return val;
+}
+
+static uint32_t pcie_pipemux_strap_read(struct pcie_prbs_dev *pd)
+{
+	uint32_t pipemux;
+
+	/* read the PCIe PIPEMUX strap setting */
+	regmap_read(pd->pipemux_strap_map,
+				CDRU_STRAP_DATA_LSW_OFFSET, &pipemux);
+	pipemux >>= PCIE_PIPEMUX_SHIFT;
+	pipemux &= PCIE_PIPEMUX_MASK;
+
+	return pipemux;
+}
+
+static void paxb_rc_write_config(void __iomem *base, unsigned int where,
+				unsigned int val)
+{
+	writel((where & PAXB_CFG_IND_ADDR_MASK) | PAXB_CFG_CFG_TYPE_MASK,
+		base + PAXB_CFG_IND_ADDR_OFFSET);
+	writel(val, base + PAXB_CFG_IND_DATA_OFFSET);
+}
+
+static unsigned int paxb_rc_read_config(void __iomem *base, unsigned int where)
+{
+	unsigned int val;
+
+	writel((where & PAXB_CFG_IND_ADDR_MASK) | PAXB_CFG_CFG_TYPE_MASK,
+		base + PAXB_CFG_IND_ADDR_OFFSET);
+	val = readl(base + PAXB_CFG_IND_DATA_OFFSET);
+
+	return val;
+}
+
+/*
+ * Function for writes to the Serdes registers through the PMI interface
+ */
+static int pmi_write(struct pcie_prbs_dev *pd, uint32_t pmi_addr,
+		     u16 data)
+{
+	void __iomem *base = pd->paxb_base[pd->slot_num];
+	uint32_t status, val;
+	unsigned int timeout = PMI_TIMEOUT_MS;
+
+	dev_dbg(pd->dev, "%s: pmi = 0x%x, data = 0x%x\n",
+		__func__, pmi_addr, data);
+	paxb_rc_write_config(base, CFG_RC_PMI_ADDR, pmi_addr);
+
+	/* initiate pmi write transaction */
+	val = data | CFG_RC_WCMD_MASK;
+	paxb_rc_write_config(base, CFG_RC_PMI_WDATA, val);
+
+	/* poll for PMI write transaction completion */
+	do {
+		status = paxb_rc_read_config(base, CFG_RC_PMI_WDATA);
+
+		/* wait for write command bit to clear */
+		if ((status & CFG_RC_WCMD_MASK) == 0)
+			return 0;
+	} while (timeout--);
+
+	dev_err(pd->dev, "PMI write timeout!\n");
+	return -EIO;
+}
+
+/*
+ * Function to read the Serdes registers through the PMI interface
+ */
+static int pmi_read(struct pcie_prbs_dev *pd, uint32_t pmi_addr,
+		    u16 *data)
+{
+	void __iomem *base = pd->paxb_base[pd->slot_num];
+	uint32_t status;
+	unsigned int timeout = PMI_TIMEOUT_MS;
+
+	paxb_rc_write_config(base, CFG_RC_PMI_ADDR, pmi_addr);
+
+	/* initiate PMI read transaction */
+	paxb_rc_write_config(base, CFG_RC_PMI_WDATA, CFG_RC_RCMD_MASK);
+
+	/* poll for PMI read transaction completion */
+	*data = 0;
+	do {
+		status = paxb_rc_read_config(base, CFG_RC_PMI_RDATA);
+		/* wait for read ack bit set */
+		if (status & CFG_RC_RACK_MASK) {
+			status = paxb_rc_read_config(base, CFG_RC_PMI_RDATA);
+			*data = status & CFG_RC_RDATA_MASK;
+			dev_dbg(pd->dev, "%s : 0x%x = 0x%x\n",
+				__func__, pmi_addr, *data);
+			return 0;
+		}
+	} while (timeout--);
+
+	dev_err(pd->dev, "PMI read timeout!\n");
+	return -EIO;
+}
+
+static int workaround_needed_for_phy(struct pcie_prbs_dev *pd, int phy_num)
+{
+	if (phy_workaround_table[pd->pcie_mode] & (1 << phy_num))
+		return 1;
+	return 0;
+}
+
+static void uc_ram_write8(struct pcie_prbs_dev *pd, u32 ram_addr, u8 data)
+{
+	u32 paddr;
+	u16 val;
+
+	paddr = pmi_addr(UC_A_AHB_CTRL0, pd->lane);
+	val = UC_RSIZE_8 << UC_WSIZE_SHIFT;
+	pmi_write(pd, paddr, val);
+
+	paddr = pmi_addr(UC_A_AHB_WADDR_MSW, pd->lane);
+	pmi_write(pd, paddr, ram_addr >> UC_WORD_SIZE);
+	paddr = pmi_addr(UC_A_AHB_WADDR_LSW, pd->lane);
+	pmi_write(pd, paddr, ram_addr & UC_WORD_MASK);
+	paddr = pmi_addr(UC_A_AHB_WDATA_LSW, pd->lane);
+	pmi_write(pd, paddr, data);
+}
+
+static u8 uc_ram_read8(struct pcie_prbs_dev *pd, u32 ram_addr)
+{
+	u32 paddr;
+	u16 val, lsw = 0;
+
+	paddr = pmi_addr(UC_A_AHB_CTRL0, pd->lane);
+	val = UC_RSIZE_8 << UC_RSIZE_SHIFT;
+	pmi_write(pd, paddr, val);
+
+	paddr = pmi_addr(UC_A_AHB_RADDR_MSW, pd->lane);
+	pmi_write(pd, paddr, ram_addr >> UC_WORD_SIZE);
+	paddr = pmi_addr(UC_A_AHB_RADDR_LSW, pd->lane);
+	pmi_write(pd, paddr, ram_addr & UC_WORD_MASK);
+	paddr = pmi_addr(UC_A_AHB_RDATA_LSW, pd->lane);
+	pmi_read(pd, paddr, &lsw);
+
+	return (lsw & 0xff);
+}
+
+static u16 uc_ram_read16(struct pcie_prbs_dev *pd, u32 ram_addr)
+{
+	u32 paddr;
+	u16 val, lsw = 0;
+
+	paddr = pmi_addr(UC_A_AHB_CTRL0, pd->lane);
+	val = UC_RSIZE_16 << UC_RSIZE_SHIFT;
+	pmi_write(pd, paddr, val);
+
+	paddr = pmi_addr(UC_A_AHB_RADDR_MSW, pd->lane);
+	pmi_write(pd, paddr, ram_addr >> UC_WORD_SIZE);
+	paddr = pmi_addr(UC_A_AHB_RADDR_LSW, pd->lane);
+	pmi_write(pd, paddr, ram_addr & UC_WORD_MASK);
+	paddr = pmi_addr(UC_A_AHB_RDATA_LSW, pd->lane);
+	pmi_read(pd, paddr, &lsw);
+
+	return lsw;
+}
+
+static int uc_ram_read(struct pcie_prbs_dev *pd, u32 *buf, u32 ram_addr,
+		       u32 len)
+{
+	u32 i, paddr;
+	u16 val, lsw, wsw;
+
+	if (!buf)
+		return -EINVAL;
+
+	ram_addr = ALIGN_DOWN(ram_addr, SZ_4);
+	len = ALIGN_DOWN(len, SZ_4);
+
+	paddr = pmi_addr(UC_A_AHB_CTRL0, pd->lane);
+	val = UC_AUTO_INC_RADDR_EN | (UC_RSIZE_32 << UC_RSIZE_SHIFT);
+	pmi_write(pd, paddr, val);
+
+	paddr = pmi_addr(UC_A_AHB_RADDR_MSW, pd->lane);
+	pmi_write(pd, paddr, ram_addr >> UC_WORD_SIZE);
+	paddr = pmi_addr(UC_A_AHB_RADDR_LSW, pd->lane);
+	pmi_write(pd, paddr, ram_addr & UC_WORD_MASK);
+
+	for (i = 0; i < len; i += SZ_4, buf++) {
+		paddr = pmi_addr(UC_A_AHB_RDATA_MSW, pd->lane);
+		pmi_read(pd, paddr, &wsw);
+		paddr = pmi_addr(UC_A_AHB_RDATA_LSW, pd->lane);
+		pmi_read(pd, paddr, &lsw);
+		*buf = (wsw << UC_WORD_SIZE) | lsw;
+	}
+
+	return 0;
+}
+
+#define UC_CMD_POLL 10
+
+static int uc_cmd_ready(struct pcie_prbs_dev *pd)
+{
+	u32 paddr, poll;
+	u16 val;
+	int ret = 0;
+
+	poll = 0;
+	while (poll < UC_CMD_POLL) {
+		paddr = pmi_addr(DSC_A_UC_CTRL, pd->lane);
+		pmi_read(pd, paddr, &val);
+		if (val & DSC_READY) {
+			if (val & DSC_ERR)
+				ret = -EIO;
+			break;
+		}
+		msleep(20);
+		poll++;
+	}
+
+	if (poll >= UC_CMD_POLL)
+		ret = -ETIMEDOUT;
+
+	return ret;
+}
+
+static int uc_cmd_run(struct pcie_prbs_dev *pd, u8 cmd, u8 supp)
+{
+	int ret;
+	u32 paddr;
+
+	ret = uc_cmd_ready(pd);
+	if (ret) {
+		dev_err(pd->dev,
+			"uc cmd not ready, cmd=0x%02x supp=0x%0x2\n",
+			cmd, supp);
+		return ret;
+	}
+
+	paddr = pmi_addr(DSC_A_UC_CTRL, pd->lane);
+	pmi_write(pd, paddr, cmd | (supp << DSC_SUPP_INFO_SHIFT));
+
+	ret = uc_cmd_ready(pd);
+	if (ret) {
+		dev_err(pd->dev,
+			"uc cmd failed, cmd=0x%02x supp=0x%0x2\n",
+			cmd, supp);
+		return ret;
+	}
+
+	return 0;
+}
+
+static bool uc_rx_lock(struct pcie_prbs_dev *pd)
+{
+	u32 paddr;
+	u16 data;
+
+	paddr = pmi_addr(RX_LOCK_STATUS, pd->lane);
+	pmi_read(pd, paddr, &data);
+
+	return !!(data & RX_LOCK);
+}
+
+static int uc_get_info(struct pcie_prbs_dev *pd)
+{
+	struct uc_info *info = &pd->info;
+	u32 val;
+
+	memset(info, 0, sizeof(*info));
+
+	/* validate signature from uc */
+	uc_ram_read(pd, &val, UC_SIGNATURE_OFFSET, SZ_4);
+	info->signature = val;
+	if ((info->signature & UC_SIGNATURE_MASK) != UC_SIGNATURE)
+		return -ENODEV;
+
+	info->version = (val >> UC_VERSION_SHIFT) & UC_VERSION_MASK;
+
+	uc_ram_read(pd, &val, UC_OTHER_SIZE_OFFSET, SZ_4);
+	info->lane_count = (val >> UC_LANE_SIZE_SHIFT) & UC_LANE_SIZE_MASK;
+	info->trace_mem_desc_writes = !!(val & UC_TR_MEM_DESC_WR_MASK);
+	info->core_var_ram_size = (val >> UC_CORE_VAR_RAM_SIZE_SHIFT) &
+				  UC_CORE_VAR_RAM_SIZE_MASK;
+
+	uc_ram_read(pd, &val, UC_TRACE_LANE_MEM_SIZE_OFFSET, SZ_4);
+	info->lane_var_ram_size = (val >> UC_LANE_VAR_RAM_SIZE_SHIFT) &
+				  UC_LANE_VAR_RAM_SIZE_MASK;
+	if (info->lane_var_ram_size != LANE_VAR_RAM_SIZE)
+		return -EFAULT;
+
+	info->diag_mem_ram_size = (val & UC_DIAG_MEM_SIZE_MASK) /
+				  info->lane_count;
+	info->trace_mem_ram_size = val & UC_TRACE_MEM_SIZE_MASK;
+
+	uc_ram_read(pd, &val, UC_TRACE_MEM_PTR_OFFSET, SZ_4);
+	info->diag_mem_ram_base = val;
+	info->trace_mem_ram_base = info->diag_mem_ram_base;
+
+	uc_ram_read(pd, &val, UC_CORE_MEM_PTR_OFFSET, SZ_4);
+	info->core_var_ram_base = val;
+
+	uc_ram_read(pd, &val, UC_MICRO_MEM_PTR_OFFSET, SZ_4);
+	info->micro_var_ram_base = val;
+
+	uc_ram_read(pd, &val, UC_OTHER_SIZE_2_OFFSET, SZ_4);
+	info->micro_var_ram_size = (val >> UC_MICRO_MEM_SIZE_SHIFT) &
+				   UC_MICRO_MEM_SIZE_MASK;
+
+	/* for uc version below 0x34, micro code count is always 1  */
+	if (info->version < 0x34)
+		info->micro_count = 1;
+	else
+		info->micro_count = val & UC_MICRO_CNT_MASK;
+
+	uc_ram_read(pd, &val, UC_LANE_MEM_PTR_OFFSET, SZ_4);
+	info->lane_var_ram_base = val;
+
+	pr_info("Microcode info for Lane[%u]:", pd->lane);
+	pr_info("Signature = 0x%08x\n", info->signature);
+	pr_info("Diag MEM RAM base = 0x%08x\n", info->diag_mem_ram_base);
+	pr_info("Diag MEM RAM size = 0x%08x\n", info->diag_mem_ram_size);
+	pr_info("Core VAR RAM base = 0x%08x\n", info->core_var_ram_base);
+	pr_info("Core VAR RAM size = 0x%08x\n", info->core_var_ram_size);
+	pr_info("Lane VAR RAM base = 0x%08x\n", info->lane_var_ram_base);
+	pr_info("Lane VAR RAM size = 0x%08x\n", info->lane_var_ram_size);
+	pr_info("Trace MEM RAM base = 0x%08x\n", info->trace_mem_ram_base);
+	pr_info("Trace MEM RAM size = 0x%08x\n", info->trace_mem_ram_size);
+	pr_info("Micro VAR RAM base = 0x%08x\n", info->micro_var_ram_base);
+	pr_info("Lane Count = %u\n", info->lane_count);
+	pr_info("Trace MEM descending writes = %u\n",
+		info->trace_mem_desc_writes);
+	pr_info("Micro Count = %u\n", info->micro_count);
+	pr_info("Micro VAR RAM size =0x%08x\n", info->micro_var_ram_size);
+	pr_info("GRP RAM size = 0x%08x\n", info->grp_ram_size);
+	pr_info("Version = 0x%02x\n", info->version);
+
+	return 0;
+}
+
+static u8 uc_diag_var_read8(struct pcie_prbs_dev *pd, u32 offset)
+{
+	struct uc_info *info = &pd->info;
+	u32 addr;
+
+	addr = info->lane_var_ram_base + (pd->lane * info->lane_var_ram_size) +
+	       offset;
+
+	return uc_ram_read8(pd, addr);
+}
+
+static u16 uc_diag_var_read16(struct pcie_prbs_dev *pd, u32 offset)
+{
+	struct uc_info *info = &pd->info;
+	u32 addr;
+
+	addr = info->lane_var_ram_base + (pd->lane * info->lane_var_ram_size) +
+	       offset;
+
+	return uc_ram_read16(pd, addr);
+}
+
+static void uc_diag_var_write8(struct pcie_prbs_dev *pd, u32 offset, u8 data)
+{
+	struct uc_info *info = &pd->info;
+	u32 addr;
+
+	addr = info->lane_var_ram_base + (pd->lane * info->lane_var_ram_size) +
+	       offset;
+
+	uc_ram_write8(pd, addr, data);
+}
+
+static u8 uc_diag_rd_ptr_read(struct pcie_prbs_dev *pd)
+{
+	return uc_diag_var_read8(pd, UC_DIAG_RD_PTR_OFFSET);
+}
+
+static void uc_diag_rd_ptr_write(struct pcie_prbs_dev *pd, u8 data)
+{
+	uc_diag_var_write8(pd, UC_DIAG_RD_PTR_OFFSET, data);
+}
+
+static u8 uc_diag_wr_ptr_read(struct pcie_prbs_dev *pd)
+{
+	return uc_diag_var_read8(pd, UC_DIAG_WR_PTR_OFFSET);
+}
+
+static void uc_diag_core_var_write8(struct pcie_prbs_dev *pd, u32 offset,
+				    u8 data)
+{
+	struct uc_info *info = &pd->info;
+	u32 addr = info->core_var_ram_base + offset;
+
+	uc_ram_write8(pd, addr, data);
+}
+
+static u16 uc_diag_status_read(struct pcie_prbs_dev *pd)
+{
+	return uc_diag_var_read16(pd, UC_DIAG_STATUS_OFFSET);
+}
+
+static int uc_diag_poll_diag_done(struct pcie_prbs_dev *pd,
+				  unsigned long timeout_ms)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(timeout_ms);
+	u16 status;
+
+	do {
+		status = uc_diag_status_read(pd);
+		status &= UC_DIAG_RDY_MASK;
+		if (time_after(jiffies, timeout))
+			return -ETIMEDOUT;
+
+		cpu_relax();
+		cond_resched();
+	} while (!status);
+
+	return 0;
+}
+
+static u32 float12_to_u32(u8 byte, u8 multi)
+{
+	return ((u32)byte) << multi;
+}
+
+#define BER_NR_SAMPLES_PER_READ     3
+#define BER_NR_SAMPLES_READ_MASK    0xff
+static int uc_ber_read_scan_data(struct pcie_prbs_dev *pd,
+				 unsigned int data_idx)
+{
+	u16 i, sample_cnt, val;
+	u32 paddr;
+	u8 time_byte, time_multi, prbs_byte, prbs_multi;
+	int ret;
+
+	sample_cnt = uc_diag_status_read(pd);
+	if ((sample_cnt & UC_DIAG_RDY_MASK) != UC_DIAG_RDY_MASK) {
+		dev_err(pd->dev, "BER sample is not ready\n");
+		return -EFAULT;
+	}
+
+	memset(ber_time[data_idx], 0, sizeof(u32) * BER_MAX_SAMPLES);
+	memset(ber_err[data_idx], 0, sizeof(u32) * BER_MAX_SAMPLES);
+	sample_cnt = (sample_cnt & BER_NR_SAMPLES_READ_MASK) /
+		     BER_NR_SAMPLES_PER_READ;
+	for (i = 0; i < sample_cnt; i++) {
+		ret = uc_cmd_run(pd, UC_CMD_READ_DIAG_DATA_WORD, 0);
+		paddr = pmi_addr(DSC_SCRATCH, pd->lane);
+		pmi_read(pd, paddr, &val);
+
+		time_byte = (u8)(val >> BITS_PER_BYTE);
+		prbs_multi = (u8)(val & NIBBLE_MASK);
+		time_multi = (u8)val >> BITS_PER_NIBBLE;
+
+		ret = uc_cmd_run(pd, UC_CMD_READ_DIAG_DATA_BYTE, 0);
+		pmi_read(pd, paddr, &val);
+		prbs_byte = val & BYTE_MASK;
+
+		ber_time[data_idx][i] = float12_to_u32(time_byte, time_multi);
+		ber_err[data_idx][i] = float12_to_u32(prbs_byte, prbs_multi);
+	}
+
+	return 0;
+}
+
+static void uc_diag_max_time_ctrl(struct pcie_prbs_dev *pd, u8 time)
+{
+	uc_diag_core_var_write8(pd, UC_DIAG_TIME_CTRL_OFFSET, time);
+}
+
+static void uc_diag_max_err_ctrl(struct pcie_prbs_dev *pd, u8 err)
+{
+	uc_diag_core_var_write8(pd, UC_DIAG_ERR_CTRL_OFFSET, err);
+}
+
+#define UC_DIAG_POLL 1000
+
+static int uc_poll_diag_data(struct pcie_prbs_dev *pd, u8 rdp, u8 len)
+{
+	struct uc_info *info = &pd->info;
+	u32 lane_diag_size = info->diag_mem_ram_size;
+	unsigned int poll;
+
+	/*
+	 * Do not support the case when the len is larger than half of the
+	 * lane_diag_size. In such case, the read pointer cannot be updated
+	 * fast enough
+	 */
+	if (len > (lane_diag_size / 2)) {
+		dev_err(pd->dev, "Excessive len %u detected\n", len);
+		return -EINVAL;
+	}
+
+	/* wait until diag data is ready to be read */
+	poll = 0;
+	while (poll < UC_DIAG_POLL) {
+		u8 wrp, full_count;
+
+		wrp = uc_diag_wr_ptr_read(pd);
+		if (wrp >= rdp)
+			full_count = wrp - rdp;
+		else
+			full_count = (u16)wrp + lane_diag_size - rdp;
+		if (full_count >= len)
+			break;
+
+		msleep(20);
+	}
+
+	if (poll >= UC_DIAG_POLL) {
+		dev_err(pd->dev, "UC diag poll data timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+/*
+ * Magic calculation ported from code from the PCIe Serdes team
+ */
+static s16 ladder_setting_to_mV(s8 ctrl, bool range_250)
+{
+	u16 absv = abs(ctrl);
+	s16 nlmv, nlv;
+
+	nlv = 25 * absv;
+	if (absv > 22)
+		nlv += (absv - 22) * 25;
+
+	if (range_250)
+		nlmv = (nlv + 2) / 4;
+	else
+		nlmv = (nlv * 3 + 10) / 20;
+	return ((ctrl >= 0) ? nlmv : -nlmv);
+}
+
+/*
+ * Magic calculation ported from code from the PCIe Serdes team
+ */
+static u32 float8_to_u32(u8 float8)
+{
+	u32 x;
+
+	if (float8 == 0)
+		return 0;
+
+	x = (float8 >> 5) + 8;
+	if ((float8 & 0x1f) < 3)
+		return (x >> (3 - (float8 & 0x1f)));
+
+	return (x << ((float8 & 0x1f) - 3));
+}
+
+static void uc_eye_scan_convert(u32 *buf, u8 len, u16 data)
+{
+	unsigned int i;
+
+	for (i = 0; i < len; i++)
+		buf[i] = float8_to_u32((data >> (8 * i)) & 0xff);
+}
+
+static void uc_eye_display_header(void)
+{
+	pr_info("\n");
+	pr_info(" Each character N represents approximate error rate 1e-N at that location\n");
+	pr_info("  UI/64  : -30  -25  -20  -15  -10  -5    0    5    10   15   20   25   30\n");
+	pr_info("         : -|----|----|----|----|----|----|----|----|----|----|----|----|-\n");
+}
+
+static void uc_eye_display_footer(void)
+{
+	pr_info("         : -|----|----|----|----|----|----|----|----|----|----|----|----|-");
+	pr_info("  UI/64  : -30  -25  -20  -15  -10  -5    0    5    10   15   20   25   30");
+	pr_info("\n");
+}
+
+#define NR_LIMITS	7
+#define NR_CR		5
+static void uc_eye_display_stripe(struct pcie_prbs_dev *pd, uint32_t *buf, s8 y)
+{
+	const u32 limits[NR_LIMITS] = {917504, 91750, 9175, 917, 91, 9, 1};
+	s8 x, i;
+	s16 level;
+	u32 paddr;
+	u16 val;
+	bool p1_select;
+
+	paddr = pmi_addr(DSC_E_CTRL, pd->lane);
+	pmi_read(pd, paddr, &val);
+	p1_select = !!(val & DSC_P1_THRESH_SEL);
+	level = ladder_setting_to_mV(y, p1_select);
+
+	printk(KERN_INFO "%6dmV : ", level);
+
+	for (x = X_START; x <= X_END; x++) {
+		for (i = 0; i < NR_LIMITS; i++) {
+			if (buf[x + abs(X_START)] >= limits[i]) {
+				printk(KERN_CONT "%c", '0' + i + 1);
+				break;
+			}
+		}
+
+		if (i == NR_LIMITS) {
+			if ((x % NR_CR) == 0 && (y % NR_CR) == 0)
+				printk(KERN_CONT "+");
+			else if ((x % NR_CR) != 0 && (y % NR_CR) == 0)
+				printk(KERN_CONT "-");
+			else if ((x % NR_CR) == 0 && (y % NR_CR) != 0)
+				printk(KERN_CONT ":");
+			else
+				printk(KERN_CONT " ");
+		}
+	}
+}
+
+static void uc_eye_display_ref(void)
+{
+	unsigned int i;
+
+	printk(KERN_INFO "\n");
+
+	for (i = 0; i < sizeof(pcie_eye_ref); i++)
+		printk(KERN_CONT "%c", pcie_eye_ref[i]);
+
+	printk(KERN_INFO"\n");
+}
+
+static int uc_blk_read_generic_ram(struct pcie_prbs_dev *pd, u32 blk_addr,
+				   u16 blk_size, u16 offset, u16 cnt,
+				   u32 *buf)
+{
+	u32 val, read_val = 0;
+	u8 defecit = 0;
+	u32 paddr, addr = blk_addr + offset;
+	u16 lsw;
+	unsigned int lane = pd->lane;
+	unsigned int word_size = sizeof(u16);
+
+	if (offset >= blk_size)
+		return -EINVAL;
+
+	while (cnt > 0) {
+		u16 bytes_left = blk_size - offset;
+		u16 blk_cnt = min(cnt, bytes_left);
+
+		cnt -= blk_cnt;
+
+		/* set up for word reads */
+		paddr = pmi_addr(UC_A_AHB_CTRL0, lane);
+		val = UC_AUTO_INC_RADDR_EN | (UC_RSIZE_16 << UC_RSIZE_SHIFT);
+		pmi_write(pd, paddr, val);
+
+		paddr = pmi_addr(UC_A_AHB_RADDR_MSW, lane);
+		pmi_write(pd, paddr, addr >> UC_WORD_SIZE);
+		paddr = pmi_addr(UC_A_AHB_RADDR_LSW, lane);
+		pmi_write(pd, paddr, addr & UC_WORD_MASK);
+
+		/* read the leading byte, if starting at an odd address */
+		if ((addr & 1)) {
+			paddr = pmi_addr(UC_A_AHB_RDATA_LSW, lane);
+			pmi_read(pd, paddr, &lsw);
+
+			read_val |= ((lsw >> 8) << defecit);
+			if (defecit == 8) {
+				uc_eye_scan_convert(buf, word_size,
+						    (u16)read_val);
+				read_val = 0;
+				buf += word_size;
+			}
+
+			defecit ^= 8;
+			blk_cnt--;
+		}
+
+		/* read the whole word */
+		while (blk_cnt >= 2) {
+			paddr = pmi_addr(UC_A_AHB_RDATA_LSW, lane);
+			pmi_read(pd, paddr, &lsw);
+			read_val |= (lsw << defecit);
+			uc_eye_scan_convert(buf, word_size, (u16)read_val);
+			read_val >>= 16;
+			buf += word_size;
+			blk_cnt -= word_size;
+		}
+
+		/* read the trailing byte */
+		if (blk_cnt > 0) {
+			paddr = pmi_addr(UC_A_AHB_RDATA_LSW, lane);
+			pmi_read(pd, paddr, &lsw);
+			read_val |= ((lsw & 0xff) << defecit);
+			if (defecit == 8) {
+				uc_eye_scan_convert(buf, word_size,
+						    (u16)read_val);
+				read_val = 0;
+				buf += word_size;
+			}
+			defecit ^= 8;
+			blk_cnt--;
+		}
+		addr = blk_addr;
+		offset = 0;
+	}
+
+	/* when the last odd byte is left behind */
+	if (defecit > 0)
+		uc_eye_scan_convert(buf, 1, (u16)read_val);
+
+	return 0;
+}
+
+static int uc_eye_scan_start(struct pcie_prbs_dev *pd, bool vertical)
+{
+	enum uc_cmd_diag diag;
+
+	diag = vertical ?
+	       UC_CMD_DIAG_START_VSCAN_EYE : UC_CMD_DIAG_START_HSCAN_EYE;
+
+	return uc_cmd_run(pd, UC_CMD_EN_DIAG, diag);
+}
+
+static int uc_eye_scan_done(struct pcie_prbs_dev *pd)
+{
+	return uc_cmd_run(pd, UC_CMD_EN_DIAG, UC_CMD_DIAG_DISABLE);
+}
+
+static int uc_eye_scan_stripe(struct pcie_prbs_dev *pd, u32 *buf)
+{
+	struct uc_info *info = &pd->info;
+	u32 lane_diag_base;
+	unsigned int lane = pd->lane;
+	u8 rdp;
+	int ret;
+
+	lane_diag_base = info->diag_mem_ram_base +
+			 ((lane % info->lane_count) * info->diag_mem_ram_size);
+
+	/* obtain the read pointer from uc and wait for data to be ready */
+	rdp = uc_diag_rd_ptr_read(pd);
+	ret = uc_poll_diag_data(pd, rdp, STRIPE_SIZE);
+	if (ret)
+		return ret;
+
+	/* now reading eye diagram data into buffer */
+	ret = uc_blk_read_generic_ram(pd, lane_diag_base,
+				      info->diag_mem_ram_size,
+				      rdp, STRIPE_SIZE, buf);
+	if (ret)
+		return ret;
+
+	/* update the read pointer and write back to uc */
+	rdp = (rdp + STRIPE_SIZE) % info->diag_mem_ram_size;
+	uc_diag_rd_ptr_write(pd, rdp);
+
+	return 0;
+}
+
+/* PCIe PRBS loopback test sequence */
+static int pcie_phy_bert_setup(struct pcie_prbs_dev *pd, int phy_num)
+{
+	struct device *dev = pd->dev;
+	u32 addr;
+
+	dev_info(dev, "Setting up BERT for PHY 0x%x\n", phy_num);
+
+	/*
+	 * Although, signal integrity code is already present in firmware,
+	 * if this driver tries to write PIPEMUX register to change PIPEMUX
+	 * setting, then SERDES registers are seen be changed causing GEN2
+	 * PRBS failure. So applying signal integrity code to SERDES here.
+	 */
+
+	/* Enable pre/post cursors */
+	addr = pmi_addr(MERLIN16_AMS_TX_CTRL_5, LANE_BCAST_VAL);
+	pmi_write(pd, addr,
+		  MERLIN16_AMS_TX_CTRL_5_POST2_TO_1 |
+		  MERLIN16_AMS_TX_CTRL_5_ENA_PRE |
+		  MERLIN16_AMS_TX_CTRL_5_ENA_POST1 |
+		  MERLIN16_AMS_TX_CTRL_5_ENA_POST2);
+
+	/* Configure Ref Clock sense counters */
+	addr = pmi_addr(MERLIN16_PCIE_BLK2_PWRMGMT_7, LANE_BCAST_VAL);
+	pmi_write(pd, addr, MERLIN16_PCIE_BLK2_PWRMGMT_7_VAL);
+
+	addr = pmi_addr(MERLIN16_PCIE_BLK2_PWRMGMT_8, LANE_BCAST_VAL);
+	pmi_write(pd, addr, MERLIN16_PCIE_BLK2_PWRMGMT_8_VAL);
+
+	addr = pmi_addr(0x1300, LANE_BCAST_VAL);
+	pmi_write(pd, addr, 0x2080);
+
+	/* set speed */
+	addr = pmi_addr(0x1301, LANE_BCAST_VAL);
+	if (!strncasecmp(pd->test_gen, "gen1", GEN_STR_LEN)) {
+		pmi_write(pd, addr, GEN1_PRBS_VAL);
+	} else if (!strncasecmp(pd->test_gen, "gen2", GEN_STR_LEN)) {
+		pmi_write(pd, addr, GEN2_PRBS_VAL);
+	} else if (!strncasecmp(pd->test_gen, "gen3", GEN_STR_LEN)) {
+		pmi_write(pd, addr, GEN3_PRBS_VAL);
+	} else {
+		dev_err(pd->dev, "PCIe GEN: Invalid option\n");
+		return -EINVAL;
+	}
+
+	/* Disable 8b10b & verify. */
+	addr = pmi_addr(0x1402, LANE_BCAST_VAL);
+	pmi_write(pd, addr, 0x0000);
+
+	/* PRBS7 is default order ;Set PRBS enable */
+	addr = pmi_addr(0x1501, LANE_BCAST_VAL);
+	pmi_write(pd, addr, 0xffff);
+
+	/* Set RX status = PRBS monitor on all lanes. */
+	addr = pmi_addr(0x7003, LANE_BCAST_VAL);
+	pmi_write(pd, addr, 0xe020);
+
+	/* Set sigdet, disable EIEOS in gen3. */
+	addr = pmi_addr(0x7007, LANE_BCAST_VAL);
+	pmi_write(pd, addr, 0xf010);
+
+	/* workaround for PHY3 and PHY7 PRBS in x8 RC */
+	if (workaround_needed_for_phy(pd, phy_num)) {
+		addr = pmi_addr(0xd073, LANE_BCAST_VAL);
+		pmi_write(pd, addr, 0x7110);
+	}
+
+	return 0;
+}
+
+static void connect_pcie_core_to_phy(struct pcie_prbs_dev *pd, int phy_num)
+{
+	struct device *dev = pd->dev;
+	void __iomem *pcie_ss_base = pd->pcie_ss_base;
+	/* First tie the serdes under test to the given core */
+	dev_info(dev, "pcie core=%d and phy=%d\n",
+				pd->slot_num, phy_num);
+	switch (pd->slot_num) {
+	case 0:
+		dev_info(dev, "phy %d wired to core0", phy_num);
+		writel(phy_num, pcie_ss_base + PCIE_CORE0_PMI_SEL_CFG);
+		break;
+	case 1:
+		writel(phy_num, pcie_ss_base + PCIE_CORE1_PMI_SEL_CFG);
+		dev_info(dev, "phy %d wired to core1", phy_num);
+		break;
+	case 2:
+		writel(phy_num, pcie_ss_base + PCIE_CORE2_PMI_SEL_CFG);
+		dev_info(dev, "phy %d wired to core2", phy_num);
+		break;
+	case 3:
+		writel(phy_num, pcie_ss_base + PCIE_CORE3_PMI_SEL_CFG);
+		dev_info(dev, "phy %d wired to core3", phy_num);
+		break;
+	case 4:
+		writel(phy_num, pcie_ss_base + PCIE_CORE4_PMI_SEL_CFG);
+		dev_info(dev, "phy %d wired to core4", phy_num);
+		break;
+	case 5:
+		writel(phy_num, pcie_ss_base + PCIE_CORE5_PMI_SEL_CFG);
+		dev_info(dev, "phy %d wired to core5", phy_num);
+		break;
+	case 6:
+		writel(phy_num, pcie_ss_base + PCIE_CORE6_PMI_SEL_CFG);
+		dev_info(dev, "phy %d wired to core6", phy_num);
+		break;
+	case 7:
+		writel(phy_num, pcie_ss_base + PCIE_CORE7_PMI_SEL_CFG);
+		dev_info(dev, "phy %d wired to core7", phy_num);
+		break;
+	};
+}
+
+static int pcie_phy_lane_prbs_flush(struct pcie_prbs_dev *pd, int lane)
+{
+	uint32_t addr;
+	u16 data;
+
+	addr = pmi_addr(0x7000, lane);
+	pmi_read(pd, addr, &data);
+
+	return 0;
+}
+
+static int pcie_phy_lane_prbs_status(struct pcie_prbs_dev *pd, int lane)
+{
+	struct device *dev = pd->dev;
+	uint32_t addr;
+	u16 data;
+	int lane_retries = 0;
+
+	addr = pmi_addr(0x7000, lane);
+	do {
+		pmi_read(pd, addr, &data);
+		dev_info(dev, "Status on Lane %d:[0x%x]\n", lane, data);
+		lane_retries++;
+	} while ((data != PMI_PASS_STATUS) &&
+				(lane_retries < MAX_LANE_RETRIES));
+
+	if (lane_retries == MAX_LANE_RETRIES)
+		return -EIO;
+
+	return 0;
+}
+
+static int pcie_phy_prbs_status(struct pcie_prbs_dev *pd, int phy_num)
+{
+	int ret = 0, lane_idx;
+	struct device *dev = pd->dev;
+
+	dev_info(dev, "Checking PRBS status for PHY 0x%x\n", phy_num);
+	/* Flush PRBS monitor status */
+	for (lane_idx = 0; lane_idx < NR_LANES_PER_PHY; lane_idx++)
+		pcie_phy_lane_prbs_flush(pd, lane_idx);
+
+	/* Checking PRBS status */
+	for (lane_idx = 0; lane_idx < NR_LANES_PER_PHY; lane_idx++) {
+		ret = pcie_phy_lane_prbs_status(pd, lane_idx);
+		if (ret) {
+			dev_err(dev, "PHY 0x%x: Lane %d PRBS failed\n",
+				phy_num, lane_idx);
+			return ret;
+		}
+
+		dev_info(dev, "PHY 0x%x: Lane %d PRBS Passed\n",
+			 phy_num, lane_idx);
+	}
+
+	return ret;
+}
+
+static void iproc_pcie_assert_reset(void __iomem *paxb_base)
+{
+	uint32_t val;
+       /*
+	* Select perst_b signal as reset source and put the device into reset
+	*/
+	val = readl(paxb_base);
+	val &= ~RC_PCIE_RST_OUTPUT;
+	writel(val, paxb_base);
+	udelay(250);
+}
+
+static void iproc_pcie_release_reset(void __iomem *paxb_base)
+{
+	uint32_t val;
+	/* Bring the device out of reset */
+	val = readl(paxb_base);
+	val |= RC_PCIE_RST_OUTPUT;
+	writel(val, paxb_base);
+	msleep(100);
+}
+
+static int do_prbs_test(struct pcie_prbs_dev *pd, unsigned int pipemux_mode)
+{
+	struct device *dev = pd->dev;
+	int phy_num, ret, i;
+
+	if (phy_mask[pipemux_mode][pd->slot_num] == 0x00) {
+		dev_info(dev, "pcie_mode(%d) and slot_num(%d)\n",
+			pipemux_mode, pd->slot_num);
+		dev_err(dev, "no such combination exists in PCIe RC modes!\n");
+		/* Set err_count in event of non-existent combination */
+		pd->err_count = 1;
+		return -EINVAL;
+	}
+
+	for (i = 0; i <= pd->test_retries; i++) {
+		pd->err_count = 0;
+		/*
+		 * setup BERT on pcie phys that need to be tested
+		 * according to self loopback cable position
+		 */
+		iproc_pcie_assert_reset(pd->paxb_base[pd->slot_num]);
+		for (phy_num = 0; phy_num < pd->phy_count; phy_num++) {
+			if (!((phy_mask[pipemux_mode][pd->slot_num]) &
+			     (1 << phy_num)))
+				continue;
+			connect_pcie_core_to_phy(pd, phy_num);
+			ret = pcie_phy_bert_setup(pd, phy_num);
+			if (ret) {
+				dev_err(pd->dev, "PHY 0x%x: BERT setup FAILED",
+					phy_num);
+				return -EIO;
+			}
+			dev_info(pd->dev, "PHY 0x%x: BERT setup done", phy_num);
+		}
+		iproc_pcie_release_reset(pd->paxb_base[pd->slot_num]);
+
+		/* Now check PRBS status for each PHY */
+		for (phy_num = 0; phy_num < pd->phy_count; phy_num++) {
+			if (!((phy_mask[pipemux_mode][pd->slot_num]) &
+			     (1 << phy_num)))
+				continue;
+			connect_pcie_core_to_phy(pd, phy_num);
+			ret = pcie_phy_prbs_status(pd, phy_num);
+			if (!ret)
+				dev_info(dev, "PHY 0x%x: PRBS test passed\n\n",
+						phy_num);
+			else {
+				dev_err(dev, "PHY 0x%x: PRBS test failed\n\n",
+						phy_num);
+				pd->err_count++;
+			}
+		}
+
+		if (pd->err_count == 0) {
+			dev_info(dev, "Try %d: PCIe %s PRBS test PASSED\n\n",
+					i, pd->test_gen);
+			return 0;
+		}
+		dev_err(dev, "Try %d: PCIe %s PRBS test FAILED (error %d)\n",
+				i, pd->test_gen, pd->err_count);
+	}
+	return 1;
+}
+
+/* sysfs callbacks */
+static ssize_t pcie_prbs_retries_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	ret = sprintf(buf, "%u\n", test->test_retries);
+	mutex_unlock(&test->test_lock);
+	return ret;
+}
+
+static ssize_t pcie_prbs_retries_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	int state;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *test = platform_get_drvdata(pdev);
+
+	if (kstrtoint(buf, 0, &state) != 0)
+		return -EINVAL;
+	if (state < 0)
+		return -EINVAL;
+	mutex_lock(&test->test_lock);
+	test->test_retries = state;
+	mutex_unlock(&test->test_lock);
+	return strnlen(buf, count);
+}
+
+static ssize_t pcie_prbs_pcie_mode_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	ret = sprintf(buf, "%d\n", test->pcie_mode);
+	mutex_unlock(&test->test_lock);
+	return ret;
+}
+
+static ssize_t pcie_prbs_pcie_mode_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	int state;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *test = platform_get_drvdata(pdev);
+
+	if (kstrtoint(buf, 0, &state) != 0)
+		return -EINVAL;
+	if (state < PCIE_MODE_DEFAULT || state > PCIE_MODE13)
+		return -EINVAL;
+	mutex_lock(&test->test_lock);
+	test->pcie_mode = state;
+	mutex_unlock(&test->test_lock);
+	return strnlen(buf, count);
+}
+
+static ssize_t pcie_prbs_slot_num_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	ret = sprintf(buf, "%u\n", test->slot_num);
+	mutex_unlock(&test->test_lock);
+	return ret;
+}
+
+static ssize_t pcie_prbs_slot_num_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	int state;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *test = platform_get_drvdata(pdev);
+
+	if (kstrtoint(buf, 0, &state) != 0)
+		return -EINVAL;
+	if (state < 0 || state > 7)
+		return -EINVAL;
+	mutex_lock(&test->test_lock);
+	test->slot_num = state;
+	mutex_unlock(&test->test_lock);
+	return strnlen(buf, count);
+}
+
+static ssize_t pcie_prbs_test_gen_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	ret = sprintf(buf, "%s", test->test_gen);
+	mutex_unlock(&test->test_lock);
+	return ret;
+}
+
+static ssize_t pcie_prbs_test_gen_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	sprintf(test->test_gen, "%s", buf);
+	mutex_unlock(&test->test_lock);
+	return strnlen(buf, count);
+}
+
+static ssize_t pcie_prbs_start_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	ret = sprintf(buf, "%u\n", test->test_start);
+	mutex_unlock(&test->test_lock);
+	return ret;
+}
+
+static ssize_t pcie_prbs_start_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int state;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *test = platform_get_drvdata(pdev);
+	void __iomem *pcie_ss_base = test->pcie_ss_base;
+	unsigned int pipemux_mode;
+
+	if (kstrtoint(buf, 0, &state) != 0)
+		return -EINVAL;
+	if (state < 1)
+		return -EINVAL;
+	mutex_lock(&test->test_lock);
+	test->test_start = state;
+	if (test->test_start) {
+		if (test->pcie_mode == PCIE_MODE_DEFAULT) {
+			/* read pipemux strap register */
+			dev_info(dev, "reading pipemux strap register\n");
+			pipemux_mode = pcie_pipemux_strap_read(test);
+		} else {
+			pipemux_mode =
+				readl(pcie_ss_base + PCIE_PIPEMUX_CFG_OFFSET);
+			if (pipemux_mode != test->pcie_mode) {
+				/*
+				 * If value read from PCIE_PIPEMUX_CFG Register
+				 * is not same as pcie_mode specified by user,
+				 * then configure the PIPE-MUX for pcie_mode
+				 */
+				pipemux_mode = test->pcie_mode;
+				dev_info(dev, "Configuring PIPE-MUX to mode %x\n",
+						pipemux_mode);
+				writel(pipemux_mode,
+					pcie_ss_base + PCIE_PIPEMUX_CFG_OFFSET);
+			}
+		}
+		dev_info(dev, "pcie mode = %d\n", pipemux_mode);
+		do_prbs_test(test, pipemux_mode);
+	}
+	mutex_unlock(&test->test_lock);
+	return strnlen(buf, count);
+}
+
+static ssize_t pcie_phy_err_count_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	ret = sprintf(buf, "%u\n", test->err_count);
+	mutex_unlock(&test->test_lock);
+	return ret;
+}
+
+static ssize_t lane_store(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *pd = platform_get_drvdata(pdev);
+	unsigned int lane;
+	int ret;
+
+	ret = kstrtouint(buf, 0, &lane);
+	if (ret)
+		return ret;
+
+	if (lane >= NR_LANES_PER_PHY)
+		return -EINVAL;
+
+	mutex_lock(&pd->test_lock);
+	pd->lane = lane;
+	mutex_unlock(&pd->test_lock);
+
+	return count;
+}
+
+static ssize_t lane_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *pd = platform_get_drvdata(pdev);
+
+	mutex_lock(&pd->test_lock);
+	ret = sprintf(buf, "%u\n", pd->lane);
+	mutex_unlock(&pd->test_lock);
+
+	return ret;
+}
+
+static ssize_t ber_sampling_time_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *pd = platform_get_drvdata(pdev);
+
+	mutex_lock(&pd->test_lock);
+	ret = sprintf(buf, "%u\n", pd->ber_sampling_time);
+	mutex_unlock(&pd->test_lock);
+
+	return ret;
+}
+
+static ssize_t ber_sampling_time_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	ssize_t ret;
+	unsigned int ber_sampling_time;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *pd = platform_get_drvdata(pdev);
+
+	ret = kstrtoint(buf, 0, &ber_sampling_time);
+	if (ret)
+		return ret;
+
+	if (ber_sampling_time > MAX_BER_SAMPLING_TIME)
+		return -EINVAL;
+
+	mutex_lock(&pd->test_lock);
+	pd->ber_sampling_time = ber_sampling_time;
+	mutex_unlock(&pd->test_lock);
+
+	return strnlen(buf, count);
+}
+
+static ssize_t pmi_read_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *pd = platform_get_drvdata(pdev);
+	int ret;
+	u32 addr, lane;
+	u16 data;
+
+	ret = sscanf(buf, "%x %x", &addr, &lane);
+	if ((ret != 1) && (ret != 2))
+		return -EINVAL;
+	if (ret == 1)
+		lane = 0;
+
+	mutex_lock(&pd->test_lock);
+	addr = pmi_addr(addr, lane);
+	pmi_read(pd, addr, &data);
+	dev_info(dev, "lane: %u pmi_addr: 0x%08x val: 0x%04x\n",
+		 lane, addr, data);
+	mutex_unlock(&pd->test_lock);
+
+	return count;
+}
+
+static ssize_t pmi_write_store(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *pd = platform_get_drvdata(pdev);
+	int ret;
+	u32 addr, lane, val;
+
+	ret = sscanf(buf, "%x %x %x", &addr, &val, &lane);
+	if ((ret != 2) && (ret != 3))
+		return -EINVAL;
+	if (ret == 2)
+		lane = 0;
+
+	mutex_lock(&pd->test_lock);
+	addr = pmi_addr(addr, lane);
+	pmi_write(pd, addr, val & 0xffff);
+	mutex_unlock(&pd->test_lock);
+
+	return count;
+}
+
+static ssize_t uc_ram_store(struct device *dev,
+			    struct device_attribute *attr, const char *buf,
+			    size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *pd = platform_get_drvdata(pdev);
+	int ret;
+	u32 i, addr, len, lane;
+	u32 *data;
+
+	ret = sscanf(buf, "%x %x %x", &addr, &len, &lane);
+	if (ret != 2 && ret != 3)
+		return -EINVAL;
+	if (len < SZ_4)
+		return -EINVAL;
+	if (ret == 2)
+		lane = 0;
+
+	addr = ALIGN_DOWN(addr, SZ_4);
+	len = ALIGN_DOWN(len, SZ_4);
+	pd->lane = lane;
+
+	data = kzalloc(len, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	mutex_lock(&pd->test_lock);
+	ret = uc_ram_read(pd, data, addr, len);
+	if (ret) {
+		mutex_unlock(&pd->test_lock);
+		kfree(data);
+		return ret;
+	}
+
+	pr_info("Dump of ucode RAM starting from Lane[%u]...\n\n", lane);
+	for (i = 0; i < len; i += SZ_4) {
+		pr_info("[0x%08x] 0x%08x\n", addr + i, *data);
+		data++;
+	}
+	pr_info("\nDump of ucode RAM finished\n");
+
+	mutex_unlock(&pd->test_lock);
+	kfree(data);
+	return count;
+}
+
+static ssize_t reset_store(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *pd = platform_get_drvdata(pdev);
+	unsigned int reset;
+
+	if (kstrtouint(buf, 0, &reset) != 0)
+		return -EINVAL;
+
+	mutex_lock(&pd->test_lock);
+	if (reset)
+		iproc_pcie_assert_reset(pd->paxb_base[pd->slot_num]);
+	else
+		iproc_pcie_release_reset(pd->paxb_base[pd->slot_num]);
+	mutex_unlock(&pd->test_lock);
+
+	return count;
+}
+
+static ssize_t eye_store(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *pd = platform_get_drvdata(pdev);
+	unsigned int phy, lane;
+	int ret = 0, i;
+	s8 y;
+	u32 pipemux;
+	enum uc_cmd_ctrl ctrl;
+
+	ret = sscanf(buf, "%u %u", &phy, &lane);
+	if (ret != 2)
+		return -EINVAL;
+
+	if (lane >= NR_LANES_PER_PHY)
+		return -EINVAL;
+
+	/* display reference frame and return immediately */
+	if (phy == EYE_REF_MODE) {
+		uc_eye_display_ref();
+		return count;
+	}
+
+	pipemux = pcie_pipemux_strap_read(pd);
+	if (pd->pcie_mode == PCIE_MODE_DEFAULT) {
+		pipemux = pcie_pipemux_strap_read(pd);
+		dev_info(dev, "PIPEMUX from strap 0x%x\n", pipemux);
+	} else if (pipemux != pd->pcie_mode) {
+		dev_info(dev, "Override PIPEMUX from 0x%x to 0x%x\n",
+			 pipemux, pd->pcie_mode);
+		pipemux = pd->pcie_mode;
+		writel(pipemux, pd->pcie_ss_base + PCIE_PIPEMUX_CFG_OFFSET);
+	}
+
+	if (!((phy_mask[pipemux][pd->slot_num]) & BIT(phy)))
+		return -EINVAL;
+
+	mutex_lock(&pd->test_lock);
+	pd->lane = lane;
+
+	connect_pcie_core_to_phy(pd, phy);
+	iproc_pcie_assert_reset(pd->paxb_base[pd->slot_num]);
+	iproc_pcie_release_reset(pd->paxb_base[pd->slot_num]);
+
+	/* populate uc information */
+	ret = uc_get_info(pd);
+	if (ret) {
+		dev_err(dev, "unable to get uc info\n");
+		goto err;
+	}
+
+	/* check if RX is locked */
+	if (uc_rx_lock(pd))
+		ctrl = UC_CMD_CTRL_STOP_GRACEFULLY;
+	else
+		ctrl = UC_CMD_CTRL_STOP_IMMEDIATE;
+
+	/* stop uc before diag test */
+	ret = uc_cmd_run(pd, UC_CMD_UC_CTRL, ctrl);
+	if (ret) {
+		dev_err(dev, "unable to stop uc\n");
+		goto err;
+	}
+
+	uc_eye_display_header();
+
+	ret = uc_eye_scan_start(pd, false);
+	if (ret) {
+		dev_err(dev, "unable to start eye scan\n");
+		goto err_resume_uc;
+	}
+
+	for (i = 0, y = Y_START; i < MAX_EYE_Y; i++, y--) {
+		memset(&stripe[i][0], 0, MAX_EYE_X);
+		ret = uc_eye_scan_stripe(pd, &stripe[i][0]);
+		if (ret) {
+			dev_err(dev, "eye scan failed\n");
+			goto err_stop_eye_scan;
+		}
+		uc_eye_display_stripe(pd, &stripe[i][0], y);
+	}
+
+	uc_eye_display_footer();
+
+err_stop_eye_scan:
+	uc_eye_scan_done(pd);
+err_resume_uc:
+	uc_cmd_run(pd, UC_CMD_UC_CTRL, UC_CMD_CTRL_RESUME);
+err:
+	mutex_unlock(&pd->test_lock);
+	return ret < 0 ? ret : count;
+}
+
+static ssize_t ber_store(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *pd = platform_get_drvdata(pdev);
+	unsigned int i, phy, lane;
+	int ret = 0;
+	u32 pipemux;
+	enum uc_cmd_ctrl ctrl;
+
+	ret = sscanf(buf, "%u %u", &phy, &lane);
+	if (ret != 2)
+		return -EINVAL;
+
+	if (lane >= NR_LANES_PER_PHY)
+		return -EINVAL;
+
+	pipemux = pcie_pipemux_strap_read(pd);
+	if (pd->pcie_mode == PCIE_MODE_DEFAULT) {
+		pipemux = pcie_pipemux_strap_read(pd);
+		dev_info(dev, "PIPEMUX from strap 0x%x\n", pipemux);
+	} else if (pipemux != pd->pcie_mode) {
+		dev_info(dev, "Override PIPEMUX from 0x%x to 0x%x\n",
+			 pipemux, pd->pcie_mode);
+		pipemux = pd->pcie_mode;
+		writel(pipemux, pd->pcie_ss_base + PCIE_PIPEMUX_CFG_OFFSET);
+	}
+
+	if (!((phy_mask[pipemux][pd->slot_num]) & BIT(phy)))
+		return -EINVAL;
+
+	mutex_lock(&pd->test_lock);
+	pd->lane = lane;
+
+	connect_pcie_core_to_phy(pd, phy);
+	iproc_pcie_assert_reset(pd->paxb_base[pd->slot_num]);
+	iproc_pcie_release_reset(pd->paxb_base[pd->slot_num]);
+
+	/* populate uc information */
+	ret = uc_get_info(pd);
+	if (ret) {
+		dev_err(dev, "unable to get uc info\n");
+		goto err;
+	}
+
+	/* check if RX is locked */
+	if (uc_rx_lock(pd))
+		ctrl = UC_CMD_CTRL_STOP_GRACEFULLY;
+	else
+		ctrl = UC_CMD_CTRL_STOP_IMMEDIATE;
+
+	/* stop uc before diag test */
+	ret = uc_cmd_run(pd, UC_CMD_UC_CTRL, ctrl);
+	if (ret) {
+		dev_err(dev, "unable to stop uc\n");
+		goto err;
+	}
+
+	pr_info("\nTrying to extrapolate for BER at 1e-12\n");
+	pr_info("This may take several minutes...\n");
+
+	for (i = 0; i < BER_NR_MODES; i++) {
+		pr_info("BER mode 0x%x\n", ber_mode[i]);
+
+		/* configure BER time and error parameters */
+		uc_diag_max_time_ctrl(pd,
+				      BER_TIME_SCALING(pd->ber_sampling_time));
+		uc_diag_max_err_ctrl(pd,
+				     BER_ERR_SCALING(BER_MAX_ERR_CTRL));
+
+		/* start BER test */
+		ret = uc_cmd_run(pd, UC_CMD_CAPTURE_BER_START, ber_mode[i]);
+		if (ret) {
+			dev_err(dev, "unable to start BER\n");
+			goto err_resume_uc;
+		}
+
+		/*
+		 * Wait up to 8 times of BER sampling time for BER
+		 * extrapolation
+		 */
+		ret = uc_diag_poll_diag_done(pd,
+					     8 * MSEC_PER_SEC *
+					     pd->ber_sampling_time);
+		if (ret) {
+			dev_err(dev, "diag poll failed\n");
+			goto err_resume_uc;
+		}
+
+		/* read BER results */
+		ret = uc_ber_read_scan_data(pd, i);
+		if (ret) {
+			dev_err(dev, "unable to read BER data\n");
+			goto err_resume_uc;
+		}
+
+		/* stop BER test */
+		ret = uc_cmd_run(pd, UC_CMD_CAPTURE_BER_END, 0x0);
+		if (ret) {
+			dev_err(dev, "unable to start BER\n");
+			goto err_resume_uc;
+		}
+	}
+
+	pr_info("BER extrapolation done\n");
+
+err_resume_uc:
+	uc_cmd_run(pd, UC_CMD_UC_CTRL, UC_CMD_CTRL_RESUME);
+err:
+	mutex_unlock(&pd->test_lock);
+	return ret < 0 ? ret : count;
+}
+
+static ssize_t ber_show(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pcie_prbs_dev *pd = platform_get_drvdata(pdev);
+	ssize_t count = 0;
+	unsigned int i, j;
+
+	mutex_lock(&pd->test_lock);
+	for (i = 0; i < BER_NR_MODES; i++) {
+		count += sprintf(&buf[count], "%u ", BER_SIGNATURE);
+		count += sprintf(&buf[count], "%u ", ber_mode[i]);
+		for (j = 0; j < BER_MAX_SAMPLES; j++)
+			count += sprintf(&buf[count], "%u ", ber_time[i][j]);
+		for (j = 0; j < BER_MAX_SAMPLES; j++)
+			count += sprintf(&buf[count], "%u ", ber_err[i][j]);
+	}
+	mutex_unlock(&pd->test_lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(test_retries, 0644,		/* S_IRUGO | S_IWUSR */
+		   pcie_prbs_retries_show, pcie_prbs_retries_store);
+
+static DEVICE_ATTR(pcie_mode, 0644,		/* S_IRUGO | S_IWUSR */
+		   pcie_prbs_pcie_mode_show, pcie_prbs_pcie_mode_store);
+
+static DEVICE_ATTR(slot_num, 0644,		/* S_IRUGO | S_IWUSR */
+		   pcie_prbs_slot_num_show, pcie_prbs_slot_num_store);
+
+static DEVICE_ATTR(test_gen, 0644,		/* S_IRUGO | S_IWUSR */
+		   pcie_prbs_test_gen_show, pcie_prbs_test_gen_store);
+
+static DEVICE_ATTR(test_start, 0644,		/* S_IRUGO | S_IWUSR */
+		   pcie_prbs_start_show, pcie_prbs_start_store);
+
+static DEVICE_ATTR(err_count, 0444,		/* S_IRUGO */
+		   pcie_phy_err_count_show, NULL);
+
+static DEVICE_ATTR_RW(lane);
+static DEVICE_ATTR_RW(ber_sampling_time);
+static DEVICE_ATTR_WO(pmi_read);
+static DEVICE_ATTR_WO(pmi_write);
+static DEVICE_ATTR_WO(uc_ram);
+static DEVICE_ATTR_WO(reset);
+static DEVICE_ATTR_WO(eye);
+static DEVICE_ATTR_RW(ber);
+
+static int stingray_pcie_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *dn = dev->of_node, *child;
+	struct pcie_prbs_dev *pd;
+	struct resource reg;
+	uint32_t child_cnt = 0;
+	int ret = 0;
+
+	child_cnt = of_get_child_count(dn);
+	if (child_cnt < MAX_PHY_COUNT) {
+		dev_err(dev, "All the PCIe PHY nodes not present\n");
+		return -EINVAL;
+	}
+
+	pd = devm_kzalloc(dev, sizeof(*pd), GFP_KERNEL);
+	if (!pd)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, pd);
+	pd->dev = dev;
+
+	/* Allocate PCIE_SS resources */
+	ret = of_address_to_resource(dn, 0, &reg);
+	if (ret < 0) {
+		dev_err(dev, "unable to obtain PCIE_SS resources\n");
+		return ret;
+	}
+
+	pd->pcie_ss_base = devm_ioremap(dev, reg.start, resource_size(&reg));
+	if (IS_ERR(pd->pcie_ss_base)) {
+		dev_err(dev, "unable to map controller registers\n");
+		return PTR_ERR(pd->pcie_ss_base);
+	}
+
+	pd->pipemux_strap_map = syscon_regmap_lookup_by_phandle(dn,
+					"brcm,pcie-pipemux-strap-syscon");
+	if (IS_ERR(pd->pipemux_strap_map)) {
+		dev_err(dev, "unable to find CDRU device\n");
+		return PTR_ERR(pd->pipemux_strap_map);
+	}
+
+	pd->phy_count = 0;
+	for_each_available_child_of_node(dn, child) {
+		/* Allocate resources for each PCIe PHY */
+		ret = of_address_to_resource(child, 0, &reg);
+		if (ret < 0) {
+			dev_err(dev, "unable to obtain PCIe core %d resources\n",
+					pd->phy_count);
+			of_node_put(child);
+			return -ENOMEM;
+		}
+
+		pd->paxb_base[pd->phy_count] =
+			devm_ioremap(dev, reg.start, resource_size(&reg));
+		if (IS_ERR(pd->paxb_base[pd->phy_count])) {
+			dev_err(dev, "unable to map PCIe core %d registers\n",
+					pd->phy_count);
+			of_node_put(child);
+			return PTR_ERR(pd->paxb_base[pd->phy_count]);
+		}
+
+		pd->phy_count++;
+	}
+
+
+	/* creating sysfs entries */
+	ret = device_create_file(dev, &dev_attr_test_retries);
+	if (ret < 0)
+		return ret;
+	ret = device_create_file(dev, &dev_attr_pcie_mode);
+	if (ret < 0)
+		goto destroy_test_retries;
+	ret = device_create_file(dev, &dev_attr_slot_num);
+	if (ret < 0)
+		goto destroy_pcie_mode;
+	ret = device_create_file(dev, &dev_attr_test_gen);
+	if (ret < 0)
+		goto destroy_slot_num;
+	ret = device_create_file(dev, &dev_attr_err_count);
+	if (ret < 0)
+		goto destroy_test_gen;
+	ret = device_create_file(dev, &dev_attr_test_start);
+	if (ret < 0)
+		goto destroy_err_count;
+	ret = device_create_file(dev, &dev_attr_lane);
+	if (ret < 0)
+		goto destroy_test_start;
+	ret = device_create_file(dev, &dev_attr_ber_sampling_time);
+	if (ret < 0)
+		goto destroy_lane;
+	ret = device_create_file(dev, &dev_attr_pmi_read);
+	if (ret < 0)
+		goto destroy_ber_sampling_time;
+	ret = device_create_file(dev, &dev_attr_pmi_write);
+	if (ret < 0)
+		goto destroy_pmi_read;
+	ret = device_create_file(dev, &dev_attr_uc_ram);
+	if (ret < 0)
+		goto destroy_pmi_write;
+	ret = device_create_file(dev, &dev_attr_reset);
+	if (ret < 0)
+		goto destroy_uc_ram;
+	ret = device_create_file(dev, &dev_attr_eye);
+	if (ret < 0)
+		goto destroy_reset;
+	ret = device_create_file(dev, &dev_attr_ber);
+	if (ret < 0)
+		goto destroy_eye;
+
+	mutex_init(&pd->test_lock);
+	pd->test_retries = 0;
+	pd->test_start = 0;
+	pd->pcie_mode = PCIE_MODE_DEFAULT;
+	pd->slot_num = 0;
+	pd->ber_sampling_time = BER_DFT_SAMPLING_TIME;
+	strncpy(pd->test_gen, "gen2", GEN_STR_LEN);
+	dev_info(dev, "%d PCIe PHYs registered\n", pd->phy_count);
+	return 0;
+
+destroy_eye:
+	device_remove_file(dev, &dev_attr_eye);
+destroy_reset:
+	device_remove_file(dev, &dev_attr_reset);
+destroy_uc_ram:
+	device_remove_file(dev, &dev_attr_uc_ram);
+destroy_pmi_write:
+	device_remove_file(dev, &dev_attr_pmi_write);
+destroy_pmi_read:
+	device_remove_file(dev, &dev_attr_pmi_read);
+destroy_ber_sampling_time:
+	device_remove_file(dev, &dev_attr_ber_sampling_time);
+destroy_lane:
+	device_remove_file(dev, &dev_attr_lane);
+destroy_test_start:
+	device_remove_file(dev, &dev_attr_test_start);
+destroy_err_count:
+	device_remove_file(dev, &dev_attr_err_count);
+destroy_test_gen:
+	device_remove_file(dev, &dev_attr_test_gen);
+destroy_slot_num:
+	device_remove_file(dev, &dev_attr_slot_num);
+destroy_pcie_mode:
+	device_remove_file(dev, &dev_attr_pcie_mode);
+destroy_test_retries:
+	device_remove_file(dev, &dev_attr_test_retries);
+	return ret;
+}
+
+static const struct of_device_id stingray_pcie_phy_of_match[] = {
+	{ .compatible = "brcm,stingray-pcie-phy-prbs" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, stingray_pcie_phy_of_match);
+
+static struct platform_driver stingray_pcie_prbs_driver = {
+	.driver = {
+		.name = "stingray-pcie-prbs",
+		.of_match_table = stingray_pcie_phy_of_match,
+	},
+	.probe = stingray_pcie_phy_probe,
+};
+module_platform_driver(stingray_pcie_prbs_driver);
+
+MODULE_DESCRIPTION("Broadcom Stingray PCIe PHY PRBS test driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Broadcom");
--- /dev/null
+++ b/drivers/phy/broadcom/phy-bcm-sr-pcie.c
@@ -0,0 +1,305 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2016-2018 Broadcom
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+/* we have up to 8 PAXB based RC. The 9th one is always PAXC */
+#define SR_NR_PCIE_PHYS               9
+#define SR_PAXC_PHY_IDX               (SR_NR_PCIE_PHYS - 1)
+
+#define PCIE_PIPEMUX_CFG_OFFSET       0x10c
+#define PCIE_PIPEMUX_SELECT_STRAP     0xf
+
+#define CDRU_STRAP_DATA_LSW_OFFSET    0x5c
+#define PCIE_PIPEMUX_SHIFT            19
+#define PCIE_PIPEMUX_MASK             0xf
+
+#define MHB_MEM_PW_PAXC_OFFSET        0x1c0
+#define MHB_PWR_ARR_POWERON           0x8
+#define MHB_PWR_ARR_POWEROK           0x4
+#define MHB_PWR_POWERON               0x2
+#define MHB_PWR_POWEROK               0x1
+#define MHB_PWR_STATUS_MASK           (MHB_PWR_ARR_POWERON | \
+				       MHB_PWR_ARR_POWEROK | \
+				       MHB_PWR_POWERON | \
+				       MHB_PWR_POWEROK)
+
+struct sr_pcie_phy_core;
+
+/**
+ * struct sr_pcie_phy - Stingray PCIe PHY
+ *
+ * @core: pointer to the Stingray PCIe PHY core control
+ * @index: PHY index
+ * @phy: pointer to the kernel PHY device
+ */
+struct sr_pcie_phy {
+	struct sr_pcie_phy_core *core;
+	unsigned int index;
+	struct phy *phy;
+};
+
+/**
+ * struct sr_pcie_phy_core - Stingray PCIe PHY core control
+ *
+ * @dev: pointer to device
+ * @base: base register of PCIe SS
+ * @cdru: regmap to the CDRU device
+ * @mhb: regmap to the MHB device
+ * @pipemux: pipemuex strap
+ * @phys: array of PCIe PHYs
+ */
+struct sr_pcie_phy_core {
+	struct device *dev;
+	void __iomem *base;
+	struct regmap *cdru;
+	struct regmap *mhb;
+	u32 pipemux;
+	struct sr_pcie_phy phys[SR_NR_PCIE_PHYS];
+};
+
+/*
+ * PCIe PIPEMUX lookup table
+ *
+ * Each array index represents a PIPEMUX strap setting
+ * The array element represents a bitmap where a set bit means the PCIe
+ * core and associated serdes has been enabled as RC and is available for use
+ */
+static const u8 pipemux_table[] = {
+	/* PIPEMUX = 0, EP 1x16 */
+	0x00,
+	/* PIPEMUX = 1, EP 1x8 + RC 1x8, core 7 */
+	0x80,
+	/* PIPEMUX = 2, EP 4x4 */
+	0x00,
+	/* PIPEMUX = 3, RC 2x8, cores 0, 7 */
+	0x81,
+	/* PIPEMUX = 4, RC 4x4, cores 0, 1, 6, 7 */
+	0xc3,
+	/* PIPEMUX = 5, RC 8x2, all 8 cores */
+	0xff,
+	/* PIPEMUX = 6, RC 3x4 + 2x2, cores 0, 2, 3, 6, 7 */
+	0xcd,
+	/* PIPEMUX = 7, RC 1x4 + 6x2, cores 0, 2, 3, 4, 5, 6, 7 */
+	0xfd,
+	/* PIPEMUX = 8, EP 1x8 + RC 4x2, cores 4, 5, 6, 7 */
+	0xf0,
+	/* PIPEMUX = 9, EP 1x8 + RC 2x4, cores 6, 7 */
+	0xc0,
+	/* PIPEMUX = 10, EP 2x4 + RC 2x4, cores 1, 6 */
+	0x42,
+	/* PIPEMUX = 11, EP 2x4 + RC 4x2, cores 2, 3, 4, 5 */
+	0x3c,
+	/* PIPEMUX = 12, EP 1x4 + RC 6x2, cores 2, 3, 4, 5, 6, 7 */
+	0xfc,
+	/* PIPEMUX = 13, RC 2x4 + RC 1x4 + 2x2, cores 2, 3, 6 */
+	0x4c,
+};
+
+/*
+ * Return true if the strap setting is valid
+ */
+static bool pipemux_strap_is_valid(u32 pipemux)
+{
+	return !!(pipemux < ARRAY_SIZE(pipemux_table));
+}
+
+/*
+ * Read the PCIe PIPEMUX from strap
+ */
+static u32 pipemux_strap_read(struct sr_pcie_phy_core *core)
+{
+	u32 pipemux;
+
+	/*
+	 * Read PIPEMUX configuration register to determine the pipemux setting
+	 *
+	 * In the case when the value indicates using HW strap, fall back to
+	 * use HW strap
+	 */
+	pipemux = readl(core->base + PCIE_PIPEMUX_CFG_OFFSET);
+	pipemux &= PCIE_PIPEMUX_MASK;
+	if (pipemux == PCIE_PIPEMUX_SELECT_STRAP) {
+		regmap_read(core->cdru, CDRU_STRAP_DATA_LSW_OFFSET, &pipemux);
+		pipemux >>= PCIE_PIPEMUX_SHIFT;
+		pipemux &= PCIE_PIPEMUX_MASK;
+	}
+
+	return pipemux;
+}
+
+/*
+ * Given a PIPEMUX strap and PCIe core index, this function returns true if the
+ * PCIe core needs to be enabled
+ */
+static bool pcie_core_is_for_rc(struct sr_pcie_phy *phy)
+{
+	struct sr_pcie_phy_core *core = phy->core;
+	unsigned int core_idx = phy->index;
+
+	return !!((pipemux_table[core->pipemux] >> core_idx) & 0x1);
+}
+
+static int sr_pcie_phy_init(struct phy *p)
+{
+	struct sr_pcie_phy *phy = phy_get_drvdata(p);
+
+	/*
+	 * Check whether this PHY is for root complex or not. If yes, return
+	 * zero so the host driver can proceed to enumeration. If not, return
+	 * an error and that will force the host driver to bail out
+	 */
+	if (pcie_core_is_for_rc(phy))
+		return 0;
+
+	return -ENODEV;
+}
+
+static int sr_paxc_phy_init(struct phy *p)
+{
+	struct sr_pcie_phy *phy = phy_get_drvdata(p);
+	struct sr_pcie_phy_core *core = phy->core;
+	unsigned int core_idx = phy->index;
+	u32 val;
+
+	if (core_idx != SR_PAXC_PHY_IDX)
+		return -EINVAL;
+
+	regmap_read(core->mhb, MHB_MEM_PW_PAXC_OFFSET, &val);
+	if ((val & MHB_PWR_STATUS_MASK) != MHB_PWR_STATUS_MASK) {
+		dev_err(core->dev, "PAXC is not powered up\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static const struct phy_ops sr_pcie_phy_ops = {
+	.init = sr_pcie_phy_init,
+	.owner = THIS_MODULE,
+};
+
+static const struct phy_ops sr_paxc_phy_ops = {
+	.init = sr_paxc_phy_init,
+	.owner = THIS_MODULE,
+};
+
+static struct phy *sr_pcie_phy_xlate(struct device *dev,
+				     struct of_phandle_args *args)
+{
+	struct sr_pcie_phy_core *core;
+	int phy_idx;
+
+	core = dev_get_drvdata(dev);
+	if (!core)
+		return ERR_PTR(-EINVAL);
+
+	phy_idx = args->args[0];
+
+	if (WARN_ON(phy_idx >= SR_NR_PCIE_PHYS))
+		return ERR_PTR(-ENODEV);
+
+	return core->phys[phy_idx].phy;
+}
+
+static int sr_pcie_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct sr_pcie_phy_core *core;
+	struct resource *res;
+	struct phy_provider *provider;
+	unsigned int phy_idx = 0;
+
+	core = devm_kzalloc(dev, sizeof(*core), GFP_KERNEL);
+	if (!core)
+		return -ENOMEM;
+
+	core->dev = dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	core->base = devm_ioremap_resource(core->dev, res);
+	if (IS_ERR(core->base))
+		return PTR_ERR(core->base);
+
+	core->cdru = syscon_regmap_lookup_by_phandle(node, "brcm,sr-cdru");
+	if (IS_ERR(core->cdru)) {
+		dev_err(core->dev, "unable to find CDRU device\n");
+		return PTR_ERR(core->cdru);
+	}
+
+	core->mhb = syscon_regmap_lookup_by_phandle(node, "brcm,sr-mhb");
+	if (IS_ERR(core->mhb)) {
+		dev_err(core->dev, "unable to find MHB device\n");
+		return PTR_ERR(core->mhb);
+	}
+
+	/* read the PCIe PIPEMUX strap setting */
+	core->pipemux = pipemux_strap_read(core);
+	if (!pipemux_strap_is_valid(core->pipemux)) {
+		dev_err(core->dev, "invalid PCIe PIPEMUX strap %u\n",
+			core->pipemux);
+		return -EIO;
+	}
+
+	for (phy_idx = 0; phy_idx < SR_NR_PCIE_PHYS; phy_idx++) {
+		struct sr_pcie_phy *p = &core->phys[phy_idx];
+		const struct phy_ops *ops;
+
+		if (phy_idx == SR_PAXC_PHY_IDX)
+			ops = &sr_paxc_phy_ops;
+		else
+			ops = &sr_pcie_phy_ops;
+
+		p->phy = devm_phy_create(dev, NULL, ops);
+		if (IS_ERR(p->phy)) {
+			dev_err(dev, "failed to create PCIe PHY\n");
+			return PTR_ERR(p->phy);
+		}
+
+		p->core = core;
+		p->index = phy_idx;
+		phy_set_drvdata(p->phy, p);
+	}
+
+	dev_set_drvdata(dev, core);
+
+	provider = devm_of_phy_provider_register(dev, sr_pcie_phy_xlate);
+	if (IS_ERR(provider)) {
+		dev_err(dev, "failed to register PHY provider\n");
+		return PTR_ERR(provider);
+	}
+
+	dev_info(dev, "Stingray PCIe PHY driver initialized\n");
+
+	return 0;
+}
+
+static const struct of_device_id sr_pcie_phy_match_table[] = {
+	{ .compatible = "brcm,sr-pcie-phy" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sr_pcie_phy_match_table);
+
+static struct platform_driver sr_pcie_phy_driver = {
+	.driver = {
+		.name		= "sr-pcie-phy",
+		.of_match_table	= sr_pcie_phy_match_table,
+	},
+	.probe	= sr_pcie_phy_probe,
+};
+module_platform_driver(sr_pcie_phy_driver);
+
+MODULE_AUTHOR("Ray Jui <ray.jui@broadcom.com>");
+MODULE_DESCRIPTION("Broadcom Stingray PCIe PHY driver");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/phy/broadcom/phy-bcm-stingray-sata-prbs.c
@@ -0,0 +1,583 @@
+/*
+ * Copyright 2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation (the "GPL").
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License version 2 (GPLv2) for more details.
+ */
+
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+
+#define SATA_PCB_BANK_OFFSET		0x23c
+#define SATA_PCB_REG_OFFSET(ofs)	((ofs) * 4)
+#define RX_DFE_PASS_VAL 0x8000
+
+enum sata_phy_regs {
+	BLOCK0_REG_BANK			= 0x0000,
+	BLOCK0_XGXSCONTROL		= 0x80,
+	BLOCK0_XGXSSTATUS		= 0x81,
+	BLOCK0_XGXSSTATUS_PLL_LOCK	= BIT(12),
+	BLOCK0_SPARE			= 0x8d,
+	BLOCK0_SPEEDCTRL		= 0x8e,
+	/*
+	 * For Gen 1 - 0x400
+	 * For Gen 2 - 0x1400
+	 * For Gen 3 - 0x2400
+	 */
+	SAPIS_DATA_RATE_OVERRIDE_VAL	= 0x400,
+	SAPIS_DATA_RATE_GEN2_MASK	= BIT(12),
+	SAPIS_DATA_RATE_GEN3_MASK	= BIT(13),
+
+	/*
+	* 0x600 - 2   x REFCLK = 200 MHz
+	* 0x601 - 1/2 x REFCLK = 50  MHz
+	* 0x602 - 1   x REFCLK = 100 MHz
+	* 0x603 - 1   x REFCLK = 100 MHz
+	*/
+	OOB_REF_CLK_SEL			= 0x600,
+
+	BLOCK1_REG_BANK			= 0x0010,
+	BLOCK1_TX_TEST			= 0x83,
+	BLOCK1_PRBSCONTROL		= 0x88,
+
+	/*
+	 * For Gen 1 - 0x10
+	 * For Gen 2 - 0x11
+	 * For Gen 3 - 0x12
+	 */
+	TX0_DATA_RATE_VAL		= 0x0010,
+	TX0_DATA_RATE_GEN2_MASK		= BIT(0),
+	TX0_DATA_RATE_GEN3_MASK		= BIT(1),
+
+	PRBS7_EN_VAL			= 0x88,
+	PRBS15_EN_VAL			= 0x89,
+	PRBS23_EN_VAL			= 0x8a,
+	PRBS31_EN_VAL			= 0x8b,
+
+	PLL0_REG_BANK			= 0x0050,
+	PLL0_ACTRL6			= 0x86,
+
+	PLL1_REG_BANK			= 0x0060,
+	PLL1_ACTRL2			= 0x82,
+	PLL1_ACTRL3			= 0x83,
+	PLL1_ACTRL4			= 0x84,
+
+	TX_REG_BANK			= 0x0070,
+	TX_GEN_CTRL1			= 0x80,
+
+	RX_REG_BANK			= 0x00b0,
+	RX_STATUS			= 0x80,
+	RX_GEN_CTRL1			= 0x81,
+	RX_GEN_CTRL2			= 0x89,
+
+	BLOCK1D0_REG_BANK		= 0x1D0,
+	TXRX_ACTRL_11			= 0x81,
+	TXRX_ACTRL_12			= 0x82,
+	TXRX_ACTRL_15			= 0x85,
+	TXRX_ACTRL_18			= 0x88,
+	TXRX_ACTRL_1B			= 0x8B,
+};
+
+enum sata_phy_regs sapis_data_rate;
+enum sata_phy_regs tx0_data_rate;
+
+/* SR PHY PLL1 registers values for shortening PLL Lock period */
+#define SR_PLL1_ACTRL2_MAGIC		0x32
+#define SR_PLL1_ACTRL3_MAGIC		0x2
+#define SR_PLL1_ACTRL4_MAGIC		0x3e8
+#define SR_PLL0_ACTRL6_MAGIC		0xa
+
+
+struct sata_prbs_test {
+	struct device *dev;
+	void __iomem *pcb_base;
+	struct mutex test_lock;
+	unsigned int test_start;
+	unsigned int test_retries;
+	unsigned int err_status;
+	unsigned int prbs_order;
+	char sata_test_gen[4];
+};
+
+static void sata_phy_write(void __iomem *pcb_base, u32 bank,
+			      u32 ofs, u32 msk, u32 value)
+{
+	u32 tmp;
+
+	writel(bank, pcb_base + SATA_PCB_BANK_OFFSET);
+	tmp = readl(pcb_base + SATA_PCB_REG_OFFSET(ofs));
+	tmp = (tmp & msk) | value;
+	writel(tmp, pcb_base + SATA_PCB_REG_OFFSET(ofs));
+}
+
+static u32 sata_phy_read(void __iomem *pcb_base, u32 bank, u32 ofs)
+{
+	writel(bank, pcb_base + SATA_PCB_BANK_OFFSET);
+	return readl(pcb_base + SATA_PCB_REG_OFFSET(ofs));
+}
+
+static int sata_phy_bert_setup(struct sata_prbs_test *test)
+{
+	uint16_t data_rd;
+	void __iomem *base = test->pcb_base;
+	int try;
+	unsigned int val;
+
+	/* Shorten PLL Lock time - writes to speed up tuning */
+	val = SR_PLL1_ACTRL2_MAGIC;
+	sata_phy_write(base, PLL1_REG_BANK, PLL1_ACTRL2, 0x0, val);
+	val = SR_PLL1_ACTRL3_MAGIC;
+	sata_phy_write(base, PLL1_REG_BANK, PLL1_ACTRL3, 0x0, val);
+	val = SR_PLL1_ACTRL4_MAGIC;
+	sata_phy_write(base, PLL1_REG_BANK, PLL1_ACTRL4, 0x0, val);
+	val = SR_PLL0_ACTRL6_MAGIC;
+	sata_phy_write(base, PLL0_REG_BANK, PLL0_ACTRL6, 0x0, val);
+	dev_info(test->dev, "Finished writes to speed up tuning\n");
+
+	/* Clear status register */
+	sata_phy_read(base, BLOCK0_REG_BANK, BLOCK0_XGXSSTATUS);
+
+	/* Wait for PHY PLL Lock by polling pll_lock bit */
+	try = 50;
+	while (try) {
+		val = sata_phy_read(base, BLOCK0_REG_BANK, BLOCK0_XGXSSTATUS);
+		if (val & BLOCK0_XGXSSTATUS_PLL_LOCK)
+			break;
+		msleep(20);
+		try--;
+	}
+	if (!try) {
+		/* PLL did not lock; give up */
+		dev_err(test->dev, "PLL did not lock\n");
+		return -ETIMEDOUT;
+	}
+
+	/* PRBS GEN3: TXRX_ACTRL Boost AFE parameter for swing boost */
+	sata_phy_write(base, BLOCK1D0_REG_BANK, TXRX_ACTRL_11, 0x0, 0x80B9);
+	sata_phy_write(base, BLOCK1D0_REG_BANK, TXRX_ACTRL_12, 0x0, 0x88A0);
+	sata_phy_write(base, BLOCK1D0_REG_BANK, TXRX_ACTRL_15, 0x0, 0x7C12);
+	/*
+	 * 1.5 dB pre-emphasis:	0x1d17
+	 * 3 dB pre-emphasis:	0x1d27
+	 * 6 dB pre-emphasis:	0x1d37
+	 */
+	sata_phy_write(base, BLOCK1D0_REG_BANK, TXRX_ACTRL_18, 0x0, 0x1D37);
+	sata_phy_write(base, BLOCK1D0_REG_BANK, TXRX_ACTRL_1B, 0x0, 0x25c);
+
+	/* override SAPIS_DATA_RATE input */
+	sata_phy_write(base, BLOCK0_REG_BANK, BLOCK0_SPEEDCTRL, 0x0,
+			sapis_data_rate);
+	/* Software override SAPIS enable and enable tx0 driver */
+	sata_phy_write(base, BLOCK0_REG_BANK, BLOCK0_SPARE, 0x0,
+			OOB_REF_CLK_SEL);
+	/* Set tx0_data_rate_val for tx0 driver */
+	sata_phy_write(base, BLOCK1_REG_BANK, BLOCK1_TX_TEST, 0x0,
+		       tx0_data_rate);
+
+	/* Verifying that data has been written */
+	data_rd = sata_phy_read(base, BLOCK0_REG_BANK, BLOCK0_SPEEDCTRL);
+
+	if (data_rd == sapis_data_rate) {
+		dev_info(test->dev, "Data read from 0x%x is correct- 0x%x\n",
+			 BLOCK0_SPEEDCTRL, data_rd);
+		dev_info(test->dev, "overridden SAPIS_DATA_RATE input");
+	}
+	else {
+		dev_err(test->dev, "Data read from address 0x%x is incorrect\n",
+			BLOCK0_SPEEDCTRL);
+		dev_info(test->dev, "Expected is 0x%x, Received is 0x%x\n",
+			 sapis_data_rate, data_rd);
+		return -EIO;
+	}
+
+	data_rd = sata_phy_read(base, BLOCK0_REG_BANK, BLOCK0_SPARE);
+	if (data_rd == OOB_REF_CLK_SEL) {
+		dev_info(test->dev, "Data read from 0x%x is correct- 0x%x\n",
+			 BLOCK0_SPARE, data_rd);
+		dev_info(test->dev, "Software override SAPIS enable and enabled tx0 driver");
+	}
+	else {
+		dev_err(test->dev, "Data read from address 0x%x is incorrect\n",
+			BLOCK0_SPARE);
+		dev_info(test->dev, "Expected is 0x%x, Received is 0x%x\n",
+			 OOB_REF_CLK_SEL, data_rd);
+		return -EIO;
+	}
+
+	data_rd = sata_phy_read(base, BLOCK1_REG_BANK, BLOCK1_TX_TEST);
+	if (data_rd == tx0_data_rate) {
+		dev_info(test->dev, "Data read from 0x%x is correct- 0x%x\n",
+			 BLOCK1_TX_TEST, data_rd);
+		dev_info(test->dev, "Set tx0_data_rate_val for tx0 driver");
+	}
+	else {
+		dev_err(test->dev, "Data read from address 0x%x is incorrect\n",
+			BLOCK1_TX_TEST);
+		dev_info(test->dev, "Expected is 0x%x, Received is 0x%x\n",
+			 tx0_data_rate, data_rd);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int sata_phy_begin_test(struct sata_prbs_test *test)
+{
+	uint16_t data_rd;
+	void __iomem *base = test->pcb_base;
+
+	/* Select prbs data as TX test data source */
+	data_rd = sata_phy_read(base, TX_REG_BANK, TX_GEN_CTRL1);
+	dev_info(test->dev, "Data read from 0x%x is- 0x%x\n",
+			TX_GEN_CTRL1, data_rd);
+
+	sata_phy_write(base, TX_REG_BANK, TX_GEN_CTRL1, 0x0, 0x42);
+
+	/* Enable PRBS monitor */
+	if (test->prbs_order == 7)
+		sata_phy_write(base, BLOCK1_REG_BANK,
+				BLOCK1_PRBSCONTROL, 0x0, PRBS7_EN_VAL);
+	else if (test->prbs_order == 15)
+		sata_phy_write(base, BLOCK1_REG_BANK,
+				BLOCK1_PRBSCONTROL, 0x0, PRBS15_EN_VAL);
+	else if (test->prbs_order == 23)
+		sata_phy_write(base, BLOCK1_REG_BANK,
+				BLOCK1_PRBSCONTROL, 0x0, PRBS23_EN_VAL);
+	else if (test->prbs_order == 31)
+		sata_phy_write(base, BLOCK1_REG_BANK,
+				BLOCK1_PRBSCONTROL, 0x0, PRBS31_EN_VAL);
+	else {
+		dev_warn(test->dev, "Incorrect PRBS order specified\n");
+		dev_warn(test->dev, "Defaulting to PRBS7\n");
+		test->prbs_order = 7;
+		sata_phy_write(base, BLOCK1_REG_BANK,
+				BLOCK1_PRBSCONTROL, 0x0, PRBS7_EN_VAL);
+	}
+	udelay(50);
+	dev_info(test->dev, "Enabled PRBS%d monitor\n", test->prbs_order);
+
+	sata_phy_write(base, RX_REG_BANK, RX_GEN_CTRL2, 0x0, 0x0800);
+	/* Select PRBS status register as RX_STATUS register input */
+	sata_phy_write(base, RX_REG_BANK, RX_GEN_CTRL1, 0x0, 0x5CD7);
+
+	/* Read status register */
+	data_rd = sata_phy_read(base, RX_REG_BANK, RX_STATUS);
+	if (data_rd == RX_DFE_PASS_VAL)
+		dev_info(test->dev, "Data read from DFE is correct - 0x%x",
+			 data_rd);
+	else {
+		dev_err(test->dev, "Data read from DFE is incorrect");
+		dev_info(test->dev, "Expected is 0x%x, Received is 0x%x\n",
+				RX_DFE_PASS_VAL, data_rd);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int do_prbs_test(struct sata_prbs_test *test)
+{
+	int ret = 0;
+	dev_info(test->dev, "SATA Test gen: %s", test->sata_test_gen);
+	if (!strncasecmp(test->sata_test_gen, "gen1",
+		sizeof(test->sata_test_gen))) {
+		sapis_data_rate = SAPIS_DATA_RATE_OVERRIDE_VAL;
+		tx0_data_rate = TX0_DATA_RATE_VAL;
+	} else if (!strncasecmp(test->sata_test_gen, "gen2",
+		sizeof(test->sata_test_gen))) {
+		sapis_data_rate = SAPIS_DATA_RATE_OVERRIDE_VAL |
+					SAPIS_DATA_RATE_GEN2_MASK;
+		tx0_data_rate = TX0_DATA_RATE_VAL | TX0_DATA_RATE_GEN2_MASK;
+	} else if (!strncasecmp(test->sata_test_gen, "gen3",
+		sizeof(test->sata_test_gen))) {
+		sapis_data_rate = SAPIS_DATA_RATE_OVERRIDE_VAL |
+					SAPIS_DATA_RATE_GEN3_MASK;
+		tx0_data_rate = TX0_DATA_RATE_VAL | TX0_DATA_RATE_GEN3_MASK;
+	} else {
+		dev_err(test->dev, "SATA GEN: Invalid option\n");
+		return -EINVAL;
+	}
+
+	ret = sata_phy_bert_setup(test);
+	if (ret) {
+		dev_err(test->dev, "SATA PHY BERT setup FAILED\n");
+		return -EIO;
+	} else
+		dev_info(test->dev, "BERT setup done");
+
+	ret = sata_phy_begin_test(test);
+	if (ret)
+		dev_err(test->dev, "SATA PHY PRBS test FAILED\n");
+	else
+		dev_info(test->dev, "SATA PHY PRBS test PASSED\n");
+
+	return ret;
+}
+
+/* sysfs callbacks */
+static ssize_t sata_prbs_order_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sata_prbs_test *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	ret = sprintf(buf, "%u", test->prbs_order);
+	mutex_unlock(&test->test_lock);
+
+	return ret;
+}
+
+static ssize_t sata_prbs_order_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	int state;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sata_prbs_test *test = platform_get_drvdata(pdev);
+
+	if (kstrtoint(buf, 0, &state) != 0)
+		return -EINVAL;
+	if (state < 1)
+		return -EINVAL;
+	mutex_lock(&test->test_lock);
+	test->prbs_order = state;
+	mutex_unlock(&test->test_lock);
+
+	return strnlen(buf, count);
+}
+
+static ssize_t sata_prbs_gen_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sata_prbs_test *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	ret = sprintf(buf, "%s", test->sata_test_gen);
+	mutex_unlock(&test->test_lock);
+
+	return ret;
+}
+
+static ssize_t sata_prbs_gen_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sata_prbs_test *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	sprintf(test->sata_test_gen, "%s", buf);
+	mutex_unlock(&test->test_lock);
+
+	return strnlen(buf, count);
+}
+
+static ssize_t sata_prbs_err_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sata_prbs_test *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	ret = sprintf(buf, "%u\n", test->err_status);
+	mutex_unlock(&test->test_lock);
+
+	return ret;
+}
+
+static ssize_t sata_prbs_retries_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sata_prbs_test *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	ret = sprintf(buf, "%u\n", test->test_retries);
+	mutex_unlock(&test->test_lock);
+
+	return ret;
+}
+
+static ssize_t sata_prbs_retries_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	int state;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sata_prbs_test *test = platform_get_drvdata(pdev);
+
+	if (kstrtoint(buf, 0, &state) != 0)
+		return -EINVAL;
+	if (state < 1)
+		return -EINVAL;
+	mutex_lock(&test->test_lock);
+	test->test_retries = state;
+	mutex_unlock(&test->test_lock);
+
+	return strnlen(buf, count);
+}
+
+static ssize_t sata_prbs_start_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	ssize_t ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sata_prbs_test *test = platform_get_drvdata(pdev);
+
+	mutex_lock(&test->test_lock);
+	ret = sprintf(buf, "%u\n", test->test_start);
+	mutex_unlock(&test->test_lock);
+
+	return ret;
+}
+
+static ssize_t sata_prbs_start_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int state, ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sata_prbs_test *test = platform_get_drvdata(pdev);
+
+	if (kstrtoint(buf, 0, &state) != 0)
+		return -EINVAL;
+	if (state < 1)
+		return -EINVAL;
+
+	mutex_lock(&test->test_lock);
+	test->test_start = state;
+	if (test->test_start) {
+		test->err_status = 0;
+		dev_info(test->dev, "SATA PHY test started\n");
+		ret = do_prbs_test(test);
+		if (ret)
+			test->err_status = 1;
+		test->test_start = 0;
+	}
+	mutex_unlock(&test->test_lock);
+
+	return strnlen(buf, count);
+}
+
+static DEVICE_ATTR(test_retries, S_IRUGO | S_IWUSR,
+		   sata_prbs_retries_show, sata_prbs_retries_store);
+
+static DEVICE_ATTR(err_status, S_IRUGO,
+		   sata_prbs_err_show, NULL);
+
+static DEVICE_ATTR(sata_test_gen, S_IRUGO | S_IWUSR,
+		   sata_prbs_gen_show, sata_prbs_gen_store);
+
+static DEVICE_ATTR(test_start, S_IRUGO | S_IWUSR,
+		   sata_prbs_start_show, sata_prbs_start_store);
+
+static DEVICE_ATTR(prbs_order, S_IRUGO | S_IWUSR,
+		   sata_prbs_order_show, sata_prbs_order_store);
+
+static int stingray_sata_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *dn = dev->of_node, *child;
+	struct sata_prbs_test *test;
+	struct resource *res;
+	void __iomem *base;
+	unsigned int count = 0;
+	int ret = 0;
+
+	for_each_available_child_of_node(dn, child)
+		count++;
+	if (count < 1)
+		return -ENODEV;
+
+	test = devm_kzalloc(dev, sizeof(*test), GFP_KERNEL);
+	if (!test)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, test);
+	test->dev = dev;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy");
+	base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+	test->pcb_base = base;
+
+	/* creating sysfs entries */
+	ret = device_create_file(dev, &dev_attr_test_retries);
+	if (ret < 0)
+		return ret;
+	ret = device_create_file(dev, &dev_attr_err_status);
+	if (ret < 0)
+		goto destroy_test_retries;
+	ret = device_create_file(dev, &dev_attr_sata_test_gen);
+	if (ret < 0)
+		goto destroy_err_status;
+	ret = device_create_file(dev, &dev_attr_prbs_order);
+	if (ret < 0)
+		goto destroy_sata_test_gen;
+	ret = device_create_file(dev, &dev_attr_test_start);
+	if (ret < 0)
+		goto destroy_prbs_order;
+
+	mutex_init(&test->test_lock);
+	test->test_retries = 0;
+	test->test_start = 0;
+	test->err_status = 0;
+	test->prbs_order = 7;
+	strcpy(test->sata_test_gen, "gen3");
+
+	dev_info(dev, "SATA PHY initialized for PRBS test\n");
+
+	return 0;
+
+destroy_prbs_order:
+	device_remove_file(dev, &dev_attr_prbs_order);
+destroy_sata_test_gen:
+	device_remove_file(dev, &dev_attr_sata_test_gen);
+destroy_err_status:
+	device_remove_file(dev, &dev_attr_err_status);
+destroy_test_retries:
+	device_remove_file(dev, &dev_attr_test_retries);
+	return ret;
+}
+
+static const struct of_device_id stingray_sata_phy_of_match[] = {
+	{ .compatible = "brcm,stingray-sata-phy-prbs" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, stingray_sata_phy_of_match);
+
+static struct platform_driver stingray_sata_prbs_driver = {
+	.driver = {
+		.name = "stingray-sata-prbs",
+		.of_match_table = stingray_sata_phy_of_match,
+	},
+	.probe = stingray_sata_phy_probe,
+};
+module_platform_driver(stingray_sata_prbs_driver);
+
+MODULE_DESCRIPTION("Broadcom Stingray SATA PHY PRBS test driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Broadcom");
--- /dev/null
+++ b/drivers/phy/broadcom/phy-bcm-stingray-usb.c
@@ -0,0 +1,374 @@
+/*
+ * Copyright (C) 2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+
+enum bcm_usb_phy_version {
+	BCM_USB_PHY_V1,
+	BCM_USB_PHY_V2,
+};
+
+enum bcm_usb_phy_reg {
+	PLL_NDIV_FRAC,
+	PLL_NDIV_INT,
+	PLL_CTRL,
+	PHY_CTRL,
+	PHY_PLL_CTRL,
+};
+
+/* USB PHY registers */
+
+static const u8 bcm_usb_u3phy_v1[] = {
+	[PLL_CTRL]		= 0x18,
+	[PHY_CTRL]		= 0x14,
+};
+
+static const u8 bcm_usb_u2phy_v1[] = {
+	[PLL_NDIV_FRAC]	= 0x04,
+	[PLL_NDIV_INT]	= 0x08,
+	[PLL_CTRL]	= 0x0c,
+	[PHY_CTRL]	= 0x10,
+};
+
+#define HSPLL_NDIV_INT_VAL	0x13
+#define HSPLL_NDIV_FRAC_VAL	0x1005
+
+static const u8 bcm_usb_u2phy_v2[] = {
+	[PLL_NDIV_FRAC]	= 0x0,
+	[PLL_NDIV_INT]	= 0x4,
+	[PLL_CTRL]	= 0x8,
+	[PHY_CTRL]	= 0xc,
+};
+
+enum pll_ctrl_bits {
+	PLL_RESETB,
+	SSPLL_SUSPEND_EN,
+	PLL_SEQ_START,
+	PLL_LOCK,
+	PLL_PDIV,
+};
+
+static const u8 u3pll_ctrl[] = {
+	[PLL_RESETB]		= 0,
+	[SSPLL_SUSPEND_EN]	= 1,
+	[PLL_SEQ_START]		= 2,
+	[PLL_LOCK]		= 3,
+};
+
+#define HSPLL_PDIV_MASK		0xF
+#define HSPLL_PDIV_VAL		0x1
+
+static const u8 u2pll_ctrl[] = {
+	[PLL_PDIV]	= 1,
+	[PLL_RESETB]	= 5,
+	[PLL_LOCK]	= 6,
+};
+
+enum bcm_usb_phy_ctrl_bits {
+	CORERDY,
+	AFE_LDO_PWRDWNB,
+	AFE_PLL_PWRDWNB,
+	AFE_BG_PWRDWNB,
+	PHY_ISO,
+	PHY_RESETB,
+	PHY_PCTL,
+};
+
+#define PHY_PCTL_MASK	0xffff
+/*
+ * 0x0806 of PCTL_VAL has below bits set
+ * BIT-8 : refclk divider 1
+ * BIT-3:2: device mode; mode is not effect
+ * BIT-1: soft reset active low
+ */
+#define HSPHY_PCTL_VAL	0x0806
+#define SSPHY_PCTL_VAL	0x0006
+
+static const u8 u3phy_ctrl[] = {
+	[PHY_RESETB]	= 1,
+	[PHY_PCTL]	= 2,
+};
+
+static const u8 u2phy_ctrl[] = {
+	[CORERDY]		= 0,
+	[AFE_LDO_PWRDWNB]	= 1,
+	[AFE_PLL_PWRDWNB]	= 2,
+	[AFE_BG_PWRDWNB]	= 3,
+	[PHY_ISO]		= 4,
+	[PHY_RESETB]		= 5,
+	[PHY_PCTL]		= 6,
+};
+
+struct bcm_usb_phy_cfg {
+	uint32_t type;
+	uint32_t ver;
+	void __iomem *regs;
+	struct phy *phy;
+	const u8 *offset;
+};
+
+#define PLL_LOCK_RETRY_COUNT	1000
+
+#define USB_HS_PHY	0
+#define USB_SS_PHY	1
+
+static inline void bcm_usb_reg32_clrbits(void __iomem *addr, uint32_t clear)
+{
+	writel(readl(addr) & ~clear, addr);
+}
+
+static inline void bcm_usb_reg32_setbits(void __iomem *addr, uint32_t set)
+{
+	writel(readl(addr) | set, addr);
+}
+
+static int bcm_usb_pll_lock_check(void __iomem *addr, u32 bit)
+{
+	int retry;
+	u32 rd_data;
+
+	retry = PLL_LOCK_RETRY_COUNT;
+	do {
+		rd_data = readl(addr);
+		if (rd_data & bit)
+			return 0;
+		udelay(1);
+	} while (--retry > 0);
+
+	pr_err("%s: FAIL\n", __func__);
+	return -ETIMEDOUT;
+}
+
+static int bcm_usb_ss_phy_init(struct bcm_usb_phy_cfg *phy_cfg)
+{
+	int ret = 0;
+	void __iomem *regs = phy_cfg->regs;
+	const u8 *offset;
+	u32 rd_data;
+
+	offset = phy_cfg->offset;
+
+	/* Set pctl with mode and soft reset */
+	rd_data = readl(regs + offset[PHY_CTRL]);
+	rd_data &= ~(PHY_PCTL_MASK << u3phy_ctrl[PHY_PCTL]);
+	rd_data |= (SSPHY_PCTL_VAL << u3phy_ctrl[PHY_PCTL]);
+	writel(rd_data, regs + offset[PHY_CTRL]);
+
+	bcm_usb_reg32_clrbits(regs + offset[PLL_CTRL],
+			      BIT(u3pll_ctrl[SSPLL_SUSPEND_EN]));
+	bcm_usb_reg32_setbits(regs + offset[PLL_CTRL],
+			      BIT(u3pll_ctrl[PLL_SEQ_START]));
+	bcm_usb_reg32_setbits(regs + offset[PLL_CTRL],
+			      BIT(u3pll_ctrl[PLL_RESETB]));
+
+	msleep(30);
+
+	ret = bcm_usb_pll_lock_check(regs + offset[PLL_CTRL],
+				     BIT(u3pll_ctrl[PLL_LOCK]));
+
+	return ret;
+}
+
+static int bcm_usb_hs_phy_init(struct bcm_usb_phy_cfg *phy_cfg)
+{
+	int ret = 0;
+	void __iomem *regs = phy_cfg->regs;
+	const u8 *offset;
+	u32 rd_data;
+
+	offset = phy_cfg->offset;
+
+	writel(HSPLL_NDIV_INT_VAL, regs + offset[PLL_NDIV_INT]);
+	writel(HSPLL_NDIV_FRAC_VAL, regs + offset[PLL_NDIV_FRAC]);
+
+	rd_data = readl(regs + offset[PLL_CTRL]);
+	rd_data &= ~(HSPLL_PDIV_MASK << u2pll_ctrl[PLL_PDIV]);
+	rd_data |= (HSPLL_PDIV_VAL << u2pll_ctrl[PLL_PDIV]);
+	writel(rd_data, regs + offset[PLL_CTRL]);
+
+	/* Set Core Ready high */
+	bcm_usb_reg32_setbits(regs + offset[PHY_CTRL],
+			      BIT(u2phy_ctrl[CORERDY]));
+
+	msleep(100);
+
+	bcm_usb_reg32_setbits(regs + offset[PLL_CTRL],
+			      BIT(u2pll_ctrl[PLL_RESETB]));
+	bcm_usb_reg32_setbits(regs + offset[PHY_CTRL],
+			      BIT(u2phy_ctrl[PHY_RESETB]));
+
+
+	rd_data = readl(regs + offset[PHY_CTRL]);
+	rd_data &= ~(PHY_PCTL_MASK << u2phy_ctrl[PHY_PCTL]);
+	rd_data |= (HSPHY_PCTL_VAL << u2phy_ctrl[PHY_PCTL]);
+	writel(rd_data, regs + offset[PHY_CTRL]);
+
+	ret = bcm_usb_pll_lock_check(regs + offset[PLL_CTRL],
+				     BIT(u2pll_ctrl[PLL_LOCK]));
+
+	return ret;
+}
+
+static int bcm_usb_phy_reset(struct phy *phy)
+{
+	struct bcm_usb_phy_cfg *phy_cfg = phy_get_drvdata(phy);
+	void __iomem *regs = phy_cfg->regs;
+	const u8 *offset;
+
+	offset = phy_cfg->offset;
+
+	if (phy_cfg->type == USB_HS_PHY) {
+		bcm_usb_reg32_clrbits(regs + offset[PHY_CTRL],
+				      BIT(u2phy_ctrl[CORERDY]));
+		bcm_usb_reg32_setbits(regs + offset[PHY_CTRL],
+				      BIT(u2phy_ctrl[CORERDY]));
+	}
+
+	return 0;
+}
+
+static int bcm_usb_phy_init(struct phy *phy)
+{
+	struct bcm_usb_phy_cfg *phy_cfg = phy_get_drvdata(phy);
+	int ret = -EINVAL;
+
+	if (phy_cfg->type == USB_SS_PHY)
+		ret = bcm_usb_ss_phy_init(phy_cfg);
+	else if (phy_cfg->type == USB_HS_PHY)
+		ret = bcm_usb_hs_phy_init(phy_cfg);
+
+	return ret;
+}
+
+static struct phy_ops sr_phy_ops = {
+	.init		= bcm_usb_phy_init,
+	.reset		= bcm_usb_phy_reset,
+	.owner		= THIS_MODULE,
+};
+
+static int bcm_usb_phy_create(struct device *dev, struct device_node *node,
+			     void __iomem *regs, uint32_t version)
+{
+	struct bcm_usb_phy_cfg *phy_cfg;
+	struct phy_provider *phy_provider;
+
+	phy_cfg = devm_kzalloc(dev, sizeof(struct bcm_usb_phy_cfg), GFP_KERNEL);
+	if (!phy_cfg)
+		return -ENOMEM;
+
+	phy_cfg->regs = regs;
+	phy_cfg->ver = version;
+
+	if (phy_cfg->ver == BCM_USB_PHY_V1) {
+		unsigned int id;
+
+		if (of_property_read_u32(node, "reg", &id)) {
+			dev_err(dev, "missing reg property in node %s\n",
+				node->name);
+			return -EINVAL;
+		}
+
+		if (id == 0) {
+			phy_cfg->offset = bcm_usb_u2phy_v1;
+			phy_cfg->type = USB_HS_PHY;
+		} else if (id == 1) {
+			phy_cfg->offset = bcm_usb_u3phy_v1;
+			phy_cfg->type = USB_SS_PHY;
+		} else {
+			return -ENODEV;
+		}
+	} else if (phy_cfg->ver == BCM_USB_PHY_V2) {
+		phy_cfg->offset = bcm_usb_u2phy_v2;
+		phy_cfg->type = USB_HS_PHY;
+	}
+
+	phy_cfg->phy = devm_phy_create(dev, node, &sr_phy_ops);
+	if (IS_ERR(phy_cfg->phy))
+		return PTR_ERR(phy_cfg->phy);
+
+	phy_set_drvdata(phy_cfg->phy, phy_cfg);
+	phy_provider = devm_of_phy_provider_register(&phy_cfg->phy->dev,
+						     of_phy_simple_xlate);
+	if (IS_ERR(phy_provider)) {
+		dev_err(dev, "Failed to register phy provider\n");
+		return PTR_ERR(phy_provider);
+	}
+
+	return 0;
+}
+
+static const struct of_device_id bcm_usb_phy_of_match[] = {
+	{
+		.compatible = "brcm,sr-usb-phy",
+		.data = (void *)BCM_USB_PHY_V1,
+	},
+	{
+		.compatible = "brcm,sr-usb-phy-v2",
+		.data = (void *)BCM_USB_PHY_V2,
+	},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, bcm_usb_phy_of_match);
+
+static int bcm_usb_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *dn = dev->of_node, *child;
+	const struct of_device_id *of_id;
+	struct resource *res;
+	void __iomem *regs;
+	int ret;
+	uint32_t version;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	of_id = of_match_node(bcm_usb_phy_of_match, dn);
+	if (of_id)
+		version = (enum bcm_usb_phy_version)of_id->data;
+	else
+		return -ENODEV;
+
+	if (of_get_child_count(dn) == 0)
+		return bcm_usb_phy_create(dev, dn, regs, version);
+
+	for_each_available_child_of_node(dn, child) {
+		ret = bcm_usb_phy_create(dev, child, regs, version);
+		if (ret) {
+			of_node_put(child);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static struct platform_driver bcm_usb_phy_driver = {
+	.driver = {
+		.name = "phy-bcm-sr-usb",
+		.of_match_table = bcm_usb_phy_of_match,
+	},
+	.probe = bcm_usb_phy_probe,
+};
+module_platform_driver(bcm_usb_phy_driver);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("Broadcom stingray USB Phy driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/phy/broadcom/phy-brcm-sata.c
+++ b/drivers/phy/broadcom/phy-brcm-sata.c
@@ -49,11 +49,29 @@ enum brcm_sata_phy_version {
 	BRCM_SATA_PHY_IPROC_SR,
 };
 
+enum brcm_sata_phy_rxaeq_mode {
+	RXAEQ_MODE_OFF = 0,
+	RXAEQ_MODE_AUTO,
+	RXAEQ_MODE_MANUAL,
+};
+
+static enum brcm_sata_phy_rxaeq_mode rxaeq_to_val(const char *m)
+{
+	if (!strcmp(m, "auto"))
+		return RXAEQ_MODE_AUTO;
+	else if (!strcmp(m, "manual"))
+		return RXAEQ_MODE_MANUAL;
+	else
+		return RXAEQ_MODE_OFF;
+}
+
 struct brcm_sata_port {
 	int portnum;
 	struct phy *phy;
 	struct brcm_sata_phy *phy_priv;
 	bool ssc_en;
+	enum brcm_sata_phy_rxaeq_mode rxaeq_mode;
+	u32 rxaeq_val;
 };
 
 struct brcm_sata_phy {
@@ -89,9 +107,14 @@ enum sata_phy_regs {
 	PLL1_ACTRL3				= 0x83,
 	PLL1_ACTRL4				= 0x84,
 
-	TX_REG_BANK				= 0x070,
-	TX_ACTRL0				= 0x80,
-	TX_ACTRL0_TXPOL_FLIP			= BIT(6),
+	AEQRX_REG_BANK_0			= 0xd0,
+	AEQ_CONTROL1				= 0x81,
+	AEQ_CONTROL1_ENABLE			= BIT(2),
+	AEQ_CONTROL1_FREEZE			= BIT(3),
+	AEQ_FRC_EQ				= 0x83,
+	AEQ_FRC_EQ_FORCE			= BIT(0),
+	AEQ_FRC_EQ_FORCE_VAL			= BIT(1),
+	AEQRX_REG_BANK_1			= 0xe0,
 
 	OOB_REG_BANK				= 0x150,
 	OOB1_REG_BANK				= 0x160,
@@ -190,7 +213,7 @@ static u32 brcm_sata_phy_rd(void __iomem *pcb_base, u32 bank, u32 ofs)
 #define STB_FMAX_VAL_DEFAULT	0x3df
 #define STB_FMAX_VAL_SSC	0x83
 
-static int brcm_stb_sata_init(struct brcm_sata_port *port)
+static void brcm_stb_sata_ssc_init(struct brcm_sata_port *port)
 {
 	void __iomem *base = brcm_sata_pcb_base(port);
 	struct brcm_sata_phy *priv = port->phy_priv;
@@ -215,10 +238,47 @@ static int brcm_stb_sata_init(struct brcm_sata_port *port)
 
 	brcm_sata_phy_wr(base, TXPMD_REG_BANK, TXPMD_TX_FREQ_CTRL_CONTROL3,
 			  ~TXPMD_TX_FREQ_CTRL_CONTROL3_FMAX_MASK, tmp);
+}
+
+#define AEQ_FRC_EQ_VAL_SHIFT	2
+#define AEQ_FRC_EQ_VAL_MASK	0x3f
+
+static int brcm_stb_sata_rxaeq_init(struct brcm_sata_port *port)
+{
+	void __iomem *base = brcm_sata_pcb_base(port);
+	u32 tmp = 0, reg = 0;
+
+	switch (port->rxaeq_mode) {
+	case RXAEQ_MODE_OFF:
+		return 0;
+
+	case RXAEQ_MODE_AUTO:
+		reg = AEQ_CONTROL1;
+		tmp = AEQ_CONTROL1_ENABLE | AEQ_CONTROL1_FREEZE;
+		break;
+
+	case RXAEQ_MODE_MANUAL:
+		reg = AEQ_FRC_EQ;
+		tmp = AEQ_FRC_EQ_FORCE | AEQ_FRC_EQ_FORCE_VAL;
+		if (port->rxaeq_val > AEQ_FRC_EQ_VAL_MASK)
+			return -EINVAL;
+		tmp |= port->rxaeq_val << AEQ_FRC_EQ_VAL_SHIFT;
+		break;
+	}
+
+	brcm_sata_phy_wr(base, AEQRX_REG_BANK_0, reg, ~tmp, tmp);
+	brcm_sata_phy_wr(base, AEQRX_REG_BANK_1, reg, ~tmp, tmp);
 
 	return 0;
 }
 
+static int brcm_stb_sata_init(struct brcm_sata_port *port)
+{
+	brcm_stb_sata_ssc_init(port);
+
+	return brcm_stb_sata_rxaeq_init(port);
+}
+
 /* NS2 SATA PLL1 defaults were characterized by H/W group */
 #define NS2_PLL1_ACTRL2_MAGIC	0x1df8
 #define NS2_PLL1_ACTRL3_MAGIC	0x2b00
@@ -397,10 +457,6 @@ static int brcm_sr_sata_init(struct brcm_sata_port *port)
 		return -ETIMEDOUT;
 	}
 
-	/* Invert Tx polarity */
-	brcm_sata_phy_wr(base, TX_REG_BANK, TX_ACTRL0,
-			 ~TX_ACTRL0_TXPOL_FLIP, TX_ACTRL0_TXPOL_FLIP);
-
 	/* Configure OOB control to handle 100MHz reference clock */
 	val = ((0xc << OOB_CTRL1_BURST_MAX_SHIFT) |
 		(0x4 << OOB_CTRL1_BURST_MIN_SHIFT) |
@@ -463,6 +519,7 @@ static int brcm_sata_phy_init(struct phy *phy)
 
 static int brcm_sata_phy_probe(struct platform_device *pdev)
 {
+	const char *rxaeq_mode;
 	struct device *dev = &pdev->dev;
 	struct device_node *dn = dev->of_node, *child;
 	const struct of_device_id *of_id;
@@ -525,6 +582,13 @@ static int brcm_sata_phy_probe(struct platform_device *pdev)
 		port->portnum = id;
 		port->phy_priv = priv;
 		port->phy = devm_phy_create(dev, child, &phy_ops);
+		port->rxaeq_mode = RXAEQ_MODE_OFF;
+		if (!of_property_read_string(child, "brcm,rxaeq-mode",
+					     &rxaeq_mode))
+			port->rxaeq_mode = rxaeq_to_val(rxaeq_mode);
+		if (port->rxaeq_mode == RXAEQ_MODE_MANUAL)
+			of_property_read_u32(child, "brcm,rxaeq-value",
+					     &port->rxaeq_val);
 		port->ssc_en = of_property_read_bool(child, "brcm,enable-ssc");
 		if (IS_ERR(port->phy)) {
 			dev_err(dev, "failed to create PHY\n");
--- a/drivers/pinctrl/bcm/pinctrl-iproc-gpio.c
+++ b/drivers/pinctrl/bcm/pinctrl-iproc-gpio.c
@@ -36,6 +36,11 @@
 #include <linux/pinctrl/pinconf.h>
 #include <linux/pinctrl/pinconf-generic.h>
 
+#if defined(CONFIG_MAILBOX)
+#include <linux/mailbox_client.h>
+#include <linux/bcm_iproc_mailbox.h>
+#endif
+
 #include "../pinctrl-utils.h"
 
 #define IPROC_GPIO_DATA_IN_OFFSET   0x00
@@ -76,6 +81,10 @@ enum iproc_pinconf_param {
 	IPROC_PINCON_MAX,
 };
 
+/* Commands sent to M0 via mailbox driver. */
+#define M0_IPC_M0_CMD_AON_GPIO_WAKEUP_GPIO_ENABLE_CFG   0x15
+#define M0_IPC_M0_CMD_AON_GPIO_WAKEUP_GPIO_DISABLE_CFG  0x16
+
 /*
  * Iproc GPIO core
  *
@@ -103,6 +112,7 @@ struct iproc_gpio {
 
 	raw_spinlock_t lock;
 
+	struct irq_chip irqchip;
 	struct gpio_chip gc;
 	unsigned num_banks;
 
@@ -113,6 +123,11 @@ struct iproc_gpio {
 
 	struct pinctrl_dev *pctl;
 	struct pinctrl_desc pctldesc;
+
+#if defined(CONFIG_MAILBOX)
+	struct mbox_client  client;
+	struct mbox_chan    *mbox_chan;
+#endif
 };
 
 /*
@@ -291,13 +306,56 @@ static int iproc_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 	return 0;
 }
 
-static struct irq_chip iproc_gpio_irq_chip = {
-	.name = "bcm-iproc-gpio",
-	.irq_ack = iproc_gpio_irq_ack,
-	.irq_mask = iproc_gpio_irq_mask,
-	.irq_unmask = iproc_gpio_irq_unmask,
-	.irq_set_type = iproc_gpio_irq_set_type,
-};
+#if defined(CONFIG_MAILBOX)
+static int iproc_gpio_mailbox_send_cmd(struct iproc_gpio *chip,
+	u32 cmd, u32 param)
+{
+	int ret = 0;
+	struct iproc_mbox_msg msg;
+
+	msg.cmd = cmd;
+	msg.param = param;
+	msg.wait_ack = true;
+	ret = mbox_send_message(chip->mbox_chan, &msg);
+	mbox_client_txdone(chip->mbox_chan, 0);
+
+	return ret < 0 ? ret : msg.reply_code;
+}
+#endif
+
+static int iproc_gpio_irq_set_wake(struct irq_data *d, unsigned int on)
+{
+	int ret = -ENOTSUPP;
+#if defined(CONFIG_MAILBOX)
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct iproc_gpio *chip = gpiochip_get_data(gc);
+
+	unsigned long gpio = d->hwirq;
+	u32 cmd;
+
+	/*
+	 * gpio irq can not be used as a wake source if no mailbox
+	 * channel to PM co-processor is provided.
+	 */
+	if (IS_ERR(chip->mbox_chan))
+		return -ENODEV;
+
+	if (on)
+		cmd = M0_IPC_M0_CMD_AON_GPIO_WAKEUP_GPIO_ENABLE_CFG;
+	else
+		cmd = M0_IPC_M0_CMD_AON_GPIO_WAKEUP_GPIO_DISABLE_CFG;
+
+	ret = iproc_gpio_mailbox_send_cmd(chip, cmd, gpio);
+	if (ret) {
+		dev_err(chip->dev,
+			"M0 mailbox command to set gpio %lu wake enable failed with error %d\n",
+			gpio, ret);
+		ret = ret < 0 ? ret : -EINVAL;
+	}
+#endif
+
+	return ret;
+}
 
 /*
  * Request the Iproc IOMUX pinmux controller to mux individual pins to GPIO
@@ -814,22 +872,49 @@ static int iproc_gpio_probe(struct platform_device *pdev)
 		}
 	}
 
+#if defined(CONFIG_MAILBOX)
+	/* Request mailbox channel. This is optional.*/
+	chip->client.dev          = &pdev->dev;
+	chip->client.tx_block     = false;
+	chip->client.tx_tout      = 1;
+	chip->client.knows_txdone = true;
+	chip->mbox_chan = mbox_request_channel(&chip->client, 0);
+	if (IS_ERR(chip->mbox_chan) && PTR_ERR(chip->mbox_chan) != -ENODEV) {
+		dev_err(dev, "unable to request PM mailbox channel\n");
+		ret = PTR_ERR(chip->mbox_chan);
+		goto err_rm_gpiochip;
+	}
+#endif
+
 	/* optional GPIO interrupt support */
 	irq = platform_get_irq(pdev, 0);
 	if (irq) {
-		ret = gpiochip_irqchip_add(gc, &iproc_gpio_irq_chip, 0,
+		chip->irqchip.name = "bcm-iproc-gpio";
+		chip->irqchip.irq_ack = iproc_gpio_irq_ack;
+		chip->irqchip.irq_mask = iproc_gpio_irq_mask;
+		chip->irqchip.irq_unmask = iproc_gpio_irq_unmask;
+		chip->irqchip.irq_set_type = iproc_gpio_irq_set_type;
+		chip->irqchip.irq_enable = iproc_gpio_irq_unmask;
+		chip->irqchip.irq_disable = iproc_gpio_irq_mask;
+		chip->irqchip.irq_set_wake = iproc_gpio_irq_set_wake;
+
+		ret = gpiochip_irqchip_add(gc, &chip->irqchip, 0,
 					   handle_simple_irq, IRQ_TYPE_NONE);
 		if (ret) {
 			dev_err(dev, "no GPIO irqchip\n");
-			goto err_rm_gpiochip;
+			goto err_mbox;
 		}
 
-		gpiochip_set_chained_irqchip(gc, &iproc_gpio_irq_chip, irq,
+		gpiochip_set_chained_irqchip(gc, &chip->irqchip, irq,
 					     iproc_gpio_irq_handler);
 	}
 
 	return 0;
 
+err_mbox:
+#if defined(CONFIG_MAILBOX)
+	mbox_free_channel(chip->mbox_chan);
+#endif
 err_rm_gpiochip:
 	gpiochip_remove(gc);
 
--- a/drivers/power/reset/Kconfig
+++ b/drivers/power/reset/Kconfig
@@ -107,6 +107,17 @@ config POWER_RESET_IMX
 	  say N here or disable in dts to make sure pm_power_off never be
 	  overwrote wrongly by this driver.
 
+config POWER_RESET_IPROC
+	bool "Broadcom iproc reset and power-off driver"
+	depends on BCM_IPROC_MBOX && POWER_RESET && (ARCH_BCM_IPROC || COMPILE_TEST)
+	default ARCH_BCM_IPROC
+	help
+	  Power off and reset support for the iproc architected SoC's. This
+	  driver requires the iproc mailbox driver in order to
+	  communicate with the M0 processor.
+
+	  Say Y here to enable board reset and power off
+
 config POWER_RESET_MSM
 	bool "Qualcomm MSM power-off driver"
 	depends on ARCH_QCOM
--- a/drivers/power/reset/Makefile
+++ b/drivers/power/reset/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_POWER_RESET_GPIO) += gpio-poweroff.o
 obj-$(CONFIG_POWER_RESET_GPIO_RESTART) += gpio-restart.o
 obj-$(CONFIG_POWER_RESET_HISI) += hisi-reboot.o
 obj-$(CONFIG_POWER_RESET_IMX) += imx-snvs-poweroff.o
+obj-$(CONFIG_POWER_RESET_IPROC) += bcm-iproc-poweroff.o
 obj-$(CONFIG_POWER_RESET_MSM) += msm-poweroff.o
 obj-$(CONFIG_POWER_RESET_PIIX4_POWEROFF) += piix4-poweroff.o
 obj-$(CONFIG_POWER_RESET_LTC2952) += ltc2952-poweroff.o
--- /dev/null
+++ b/drivers/power/reset/bcm-iproc-poweroff.c
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2016 Broadcom.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/of.h>
+#include <linux/reboot.h>
+#include <linux/mailbox_client.h>
+#include <linux/bcm_iproc_mailbox.h>
+#include <asm/system_misc.h>
+
+struct iproc_reset {
+	struct device       *dev;
+	struct mbox_client  client;
+	struct mbox_chan    *mbox_chan;
+};
+
+enum iproc_reset_m0_cmd_param {
+	/*
+	 * Reset request
+	 * Param - must be 0xffffffff
+	 * Response - return code
+	 */
+	M0_IPC_M0_CMD_IPROC_RESET = 0,
+	M0_IPC_M0_CMD_IPROC_RESET_PARAM = 0xffffffff,
+
+	/*
+	 * Issue chip Warm reset
+	 * Param - none
+	 * Response - none (A9 will reset as a result of this command)
+	 */
+	M0_IPC_M0_CMD_WARM_RESET = 0xd,
+
+	/*
+	 * Enter OFF state
+	 * Param - physical address to resume execution from upon power saving
+	 *   mode exit.
+	 * Response - none (M0 will power the system off as a result of this
+	 *   command)
+	 */
+	M0_IPC_M0_CMD_ENTER_OFF = 0xa,
+};
+
+static struct iproc_reset *iproc_reset;
+
+static inline void iproc_reset_print_mbox_err(int mbox_err, int reply_code)
+{
+	if (mbox_err < 0)
+		dev_err(iproc_reset->dev,
+			"mbox_send_message failed: %d\n", mbox_err);
+	else if (reply_code)
+		dev_err(iproc_reset->dev,
+			"M0 command failed: 0x%x\n", reply_code);
+}
+
+static inline void iproc_mbox_send_msg(struct iproc_mbox_msg *msg)
+{
+	int err;
+
+	err = mbox_send_message(iproc_reset->mbox_chan, msg);
+	iproc_reset_print_mbox_err(err, msg->reply_code);
+	mbox_client_txdone(iproc_reset->mbox_chan, 0);
+}
+/*
+ * Perform cold (L0) reset.
+ */
+static inline void iproc_cold_reset(void)
+{
+	struct iproc_mbox_msg msg;
+
+	msg.cmd = M0_IPC_M0_CMD_IPROC_RESET;
+	msg.param = M0_IPC_M0_CMD_IPROC_RESET_PARAM;
+	msg.wait_ack = true;
+	iproc_mbox_send_msg(&msg);
+}
+
+/*
+ * Perform warm reset (keep ethernet switch active through the reset)
+ */
+static inline void iproc_warm_reset(void)
+{
+	struct iproc_mbox_msg msg;
+
+	msg.cmd = M0_IPC_M0_CMD_WARM_RESET;
+	msg.param = 0;
+	msg.wait_ack = false;
+	iproc_mbox_send_msg(&msg);
+}
+
+/*
+ * Notifies M0 to power off.
+ */
+static inline void iproc_power_off(void)
+{
+	struct iproc_mbox_msg msg;
+
+	msg.cmd = M0_IPC_M0_CMD_ENTER_OFF;
+	msg.param = 0;
+	msg.wait_ack = false;
+	iproc_mbox_send_msg(&msg);
+}
+
+/*
+ * Handles rebooting CPU.
+ */
+static void iproc_reboot(enum reboot_mode mode, const char *cmd)
+{
+	if (mode == REBOOT_COLD)
+		iproc_cold_reset();
+	else if (mode == REBOOT_WARM)
+		iproc_warm_reset();
+}
+
+static int iproc_reset_probe(struct platform_device *pdev)
+{
+
+	iproc_reset = devm_kzalloc(&pdev->dev,
+		sizeof(struct iproc_reset), GFP_KERNEL);
+	if (!iproc_reset)
+		return -ENOMEM;
+
+	iproc_reset->dev = &pdev->dev;
+
+	/* Request mailbox channel. */
+	iproc_reset->client.dev          = &pdev->dev;
+	iproc_reset->client.tx_block     = false;
+	iproc_reset->client.tx_tout      = 1;
+	iproc_reset->client.knows_txdone = true;
+	iproc_reset->mbox_chan = mbox_request_channel(&iproc_reset->client, 0);
+	if (IS_ERR(iproc_reset->mbox_chan)) {
+		dev_err(&pdev->dev, "unable to get mbox channel\n");
+		return PTR_ERR(iproc_reset->mbox_chan);
+	}
+
+	/* Set the machine restart handler. */
+	arm_pm_restart = iproc_reboot;
+
+	/* Set the power off handler. */
+	pm_power_off = iproc_power_off;
+
+	return 0;
+}
+
+static const struct of_device_id iproc_reset_of_match[] = {
+	{ .compatible = "brcm,iproc-reset", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, iproc_reset_of_match);
+
+struct platform_driver iproc_reset_driver = {
+	.driver = {
+		.name = "brcm,iproc-reset",
+		.of_match_table = iproc_reset_of_match,
+	},
+	.probe = iproc_reset_probe,
+};
+module_platform_driver(iproc_reset_driver);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("Broadcom iproc Reset Driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1243,6 +1243,19 @@ config RTC_DRV_ASM9260
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-asm9260.
 
+config RTC_DRV_BCM_IPROC
+	tristate "iProc RTC support"
+	depends on (ARCH_BCM_IPROC && ARM64) || COMPILE_TEST
+	default ARCH_BCM_IPROC
+	help
+	  If you say yes here you get support for the RTC on the
+	  iProc Based Broadcom SoCs with secure OS.
+	  This driver works as proxy and forward all calls
+	  to secure OS to perform the requested function.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-bcm-iproc.
+
 config RTC_DRV_DAVINCI
 	tristate "TI DaVinci RTC"
 	depends on ARCH_DAVINCI_DM365 || COMPILE_TEST
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -38,6 +38,7 @@ obj-$(CONFIG_RTC_DRV_AT91RM9200)+= rtc-at91rm9200.o
 obj-$(CONFIG_RTC_DRV_AT91SAM9)	+= rtc-at91sam9.o
 obj-$(CONFIG_RTC_DRV_AU1XXX)	+= rtc-au1xxx.o
 obj-$(CONFIG_RTC_DRV_BFIN)	+= rtc-bfin.o
+obj-$(CONFIG_RTC_DRV_BCM_IPROC) += rtc-bcm-iproc.o
 obj-$(CONFIG_RTC_DRV_BRCMSTB)	+= rtc-brcmstb-waketimer.o
 obj-$(CONFIG_RTC_DRV_BQ32K)	+= rtc-bq32k.o
 obj-$(CONFIG_RTC_DRV_BQ4802)	+= rtc-bq4802.o
--- /dev/null
+++ b/drivers/rtc/rtc-bcm-iproc.c
@@ -0,0 +1,226 @@
+/*
+ * Copyright 2017 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation (the "GPL").
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License version 2 (GPLv2) for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 (GPLv2) along with this source code.
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/rtc.h>
+#include <linux/of_irq.h>
+#include <linux/of_device.h>
+#include <linux/arm-smccc.h>
+
+#define ARM_SMCCC_OWNER_TRUSTED_OS_SECIPS (ARM_SMCCC_OWNER_TRUSTED_OS + 5)
+
+#define FN_ID(fun_num)	ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL,\
+					   ARM_SMCCC_SMC_32,\
+					   ARM_SMCCC_OWNER_TRUSTED_OS_SECIPS, \
+					   fun_num)
+
+#define SMCID_BBL_POWER_GOOD	FN_ID(0x4)
+#define SMCID_RTC_GET_TIME	FN_ID(0x5)
+#define SMCID_RTC_SET_TIME	FN_ID(0x6)
+#define SMCID_RTC_ALARM_ENA	FN_ID(0x7)
+#define SMCID_RTC_GET_ALARM	FN_ID(0x8)
+#define SMCID_RTC_SET_ALARM	FN_ID(0x9)
+
+struct bcm_iproc_rtc {
+	struct device *dev;
+	struct rtc_device  *rtc;
+	int periodic_irq;
+	int alarm_irq;
+};
+
+static irqreturn_t rtc_sec_smc_irq(int irq, void *pdev_data)
+{
+	struct bcm_iproc_rtc *rtc = pdev_data;
+	unsigned long events = RTC_IRQF;
+
+	if (irq == rtc->periodic_irq)
+		events |= RTC_PF;
+	else
+		events |= RTC_AF;
+	rtc_update_irq(rtc->rtc, 1, events);
+
+	return IRQ_HANDLED;
+}
+
+static int rtc_read_time_smc(struct device *dev, struct rtc_time *tm)
+{
+	u32 seconds = 0;
+	int ret;
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(SMCID_RTC_GET_TIME, 0, 0, 0, 0, 0, 0, 0, &res);
+	if (res.a0) {
+		dev_err(dev, "rtc get time err :%lx\n", res.a0);
+		return res.a0;
+	}
+
+	seconds = res.a1;
+	rtc_time_to_tm(seconds, tm);
+	ret = rtc_valid_tm(tm);
+
+	return ret;
+}
+
+static int rtc_set_time_smc(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long t;
+	struct arm_smccc_res res;
+
+	rtc_tm_to_time(tm, &t);
+	arm_smccc_smc(SMCID_RTC_SET_TIME, t, 0, 0, 0, 0, 0, 0, &res);
+	if (res.a0)
+		dev_err(dev, "%s failed(%lu) for t:%lx\n", __func__, res.a0, t);
+
+	return res.a0;
+}
+
+static int rtc_alarm_irq_enable_smc(struct device *dev, u32 enabled)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(SMCID_RTC_ALARM_ENA, enabled, 0, 0, 0, 0, 0, 0, &res);
+	if (res.a0)
+		dev_err(dev, "%s failed ret:%lx", __func__, res.a0);
+
+	return res.a0;
+}
+
+static int rtc_read_alarm_smc(struct device *dev, struct rtc_wkalrm *alm)
+{
+	u32 seconds = 0;
+	struct arm_smccc_res res;
+	struct bcm_iproc_rtc *rtc = dev_get_drvdata(dev);
+
+	arm_smccc_smc(SMCID_RTC_GET_ALARM, 0, 0, 0, 0, 0, 0, 0, &res);
+	if (res.a0) {
+		dev_err(rtc->dev, "%s failed(%lx)", __func__, res.a0);
+		goto err;
+	}
+
+	seconds = res.a1;
+	alm->pending = res.a2;
+	rtc_time_to_tm(seconds, &alm->time);
+	alm->enabled = alm->pending && device_may_wakeup(dev);
+err:
+	return res.a0;
+}
+
+static int rtc_set_alarm_smc(struct device *dev,
+						struct rtc_wkalrm *alm)
+{
+	unsigned long seconds;
+	struct arm_smccc_res res;
+	struct bcm_iproc_rtc *rtc = dev_get_drvdata(dev);
+	/*
+	 * Setting RTC match to the time
+	 * for alarm interrupt
+	 */
+	rtc_tm_to_time(&alm->time, &seconds);
+	arm_smccc_smc(SMCID_RTC_SET_ALARM, seconds, 0, 0, 0, 0, 0, 0, &res);
+	if (res.a0)
+		dev_err(rtc->dev, "%s failed(%lx)", __func__, res.a0);
+
+	return res.a0;
+}
+
+static struct rtc_class_ops rtc_ops = {
+	.read_time		= rtc_read_time_smc,
+	.set_time		= rtc_set_time_smc,
+	.alarm_irq_enable	= rtc_alarm_irq_enable_smc,
+	.read_alarm		= rtc_read_alarm_smc,
+	.set_alarm		= rtc_set_alarm_smc,
+};
+
+static int rtc_check_power(void)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(SMCID_BBL_POWER_GOOD, 0, 0, 0, 0, 0, 0, 0, &res);
+	if (res.a0)
+		return res.a0;
+
+	return res.a1;
+}
+
+static int rtc_probe(struct platform_device *pdev)
+{
+	struct bcm_iproc_rtc *rtc;
+	int ret;
+
+	ret = rtc_check_power();
+	if (ret) {
+		dev_err(&pdev->dev, "bbl is not powered up:%d", ret);
+		return -ENODEV;
+	}
+
+	rtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);
+	if (!rtc)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, rtc);
+	rtc->dev = &pdev->dev;
+
+	rtc->periodic_irq = platform_get_irq(pdev, 0);
+	if (rtc->periodic_irq < 0) {
+		dev_err(rtc->dev, "RTC periodic interrupt not defined\n");
+		return rtc->periodic_irq;
+	}
+
+	ret = devm_request_irq(rtc->dev, rtc->periodic_irq, rtc_sec_smc_irq, 0,
+			       "iproc_periodic_rtc", rtc);
+	if (ret)
+		return ret;
+
+	rtc->alarm_irq = platform_get_irq(pdev, 1);
+	if (rtc->alarm_irq > 0) {
+		ret = devm_request_irq(rtc->dev, rtc->alarm_irq,
+				       rtc_sec_smc_irq, 0,
+				       "iproc_alarm_rtc", rtc);
+		if (ret)
+			return ret;
+	}
+	ret = device_init_wakeup(rtc->dev, true);
+	if (ret)
+		return ret;
+
+	rtc->rtc = devm_rtc_device_register(rtc->dev, pdev->name,
+					    &rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc->rtc))
+		return PTR_ERR(rtc->rtc);
+
+	dev_info(rtc->dev, "iproc-rtc registered\n");
+	return 0;
+}
+
+static const struct of_device_id rtc_of_match[] = {
+	{.compatible = "brcm,iproc-rtc",},
+	{ }
+};
+
+static struct platform_driver rtc_driver = {
+	.probe		= rtc_probe,
+	.driver		= {
+		.name = "iproc-rtc",
+		.of_match_table = rtc_of_match
+	},
+};
+
+module_platform_driver(rtc_driver);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("Broadcom iProc RTC Driver");
+MODULE_LICENSE("GPL v2");
+
--- a/drivers/spi/spi-bcm-qspi.c
+++ b/drivers/spi/spi-bcm-qspi.c
@@ -910,6 +910,7 @@ static int bcm_qspi_transfer_one(struct spi_master *master,
 
 		read_from_hw(qspi, slots);
 	}
+	bcm_qspi_enable_bspi(qspi);
 
 	return 0;
 }
--- a/drivers/spi/spi-iproc-qspi.c
+++ b/drivers/spi/spi-iproc-qspi.c
@@ -143,6 +143,7 @@ static int bcm_iproc_remove(struct platform_device *pdev)
 static const struct of_device_id bcm_iproc_of_match[] = {
 	{ .compatible = "brcm,spi-nsp-qspi" },
 	{ .compatible = "brcm,spi-ns2-qspi" },
+	{ .compatible = "brcm,spi-iproc-qspi-v1" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, bcm_iproc_of_match);
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -724,11 +724,10 @@ static int spidev_probe(struct spi_device *spi)
 	 * compatible string, it is a Linux implementation thing
 	 * rather than a description of the hardware.
 	 */
-	if (spi->dev.of_node && !of_match_device(spidev_dt_ids, &spi->dev)) {
-		dev_err(&spi->dev, "buggy DT: spidev listed directly in DT\n");
-		WARN_ON(spi->dev.of_node &&
-			!of_match_device(spidev_dt_ids, &spi->dev));
-	}
+	WARN(spi->dev.of_node &&
+	     of_device_is_compatible(spi->dev.of_node, "spidev"),
+	     "%pOF: buggy DT: spidev listed directly in DT\n",
+	     spi->dev.of_node);
 
 	spidev_probe_acpi(spi);
 
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -408,7 +408,8 @@ config MTK_THERMAL
 	  controller present in Mediatek SoCs
 
 menu "Broadcom thermal drivers"
-depends on ARCH_BCM || ARCH_BCM2835 || COMPILE_TEST
+depends on ARCH_BCM || ARCH_BRCMSTB || ARCH_BCM2835 || ARCH_BCM_IPROC || \
+		COMPILE_TEST
 source "drivers/thermal/broadcom/Kconfig"
 endmenu
 
--- a/drivers/thermal/broadcom/Kconfig
+++ b/drivers/thermal/broadcom/Kconfig
@@ -15,3 +15,12 @@ config BCM_NS_THERMAL
 	  BCM4708, BCM4709, BCM5301x, BCM95852X, etc). It contains DMU (Device
 	  Management Unit) block with a thermal sensor that allows checking CPU
 	  temperature.
+
+config BCM_SR_THERMAL
+	tristate "Stingray thermal driver"
+	depends on ARCH_BCM_IPROC || COMPILE_TEST
+	default ARCH_BCM_IPROC
+	help
+	  Support for the Stingray family of SoCs. Its different blocks like
+	  iHost, CRMU and NITRO has thermal sensor that allows checking its
+	  temperature.
--- a/drivers/thermal/broadcom/Makefile
+++ b/drivers/thermal/broadcom/Makefile
@@ -1,2 +1,3 @@
 obj-$(CONFIG_BCM2835_THERMAL)		+= bcm2835_thermal.o
 obj-$(CONFIG_BCM_NS_THERMAL)		+= ns-thermal.o
+obj-$(CONFIG_BCM_SR_THERMAL)		+= sr-thermal.o
--- /dev/null
+++ b/drivers/thermal/broadcom/sr-thermal.c
@@ -0,0 +1,121 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 Broadcom
+ */
+
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/thermal.h>
+
+/*
+ * In stingray thermal IO memory,
+ * Total Number of available TMONs MASK is at offset 0
+ * temperature registers BASE is at 4 byte offset.
+ * Each TMON temperature register size is 4.
+ */
+#define SR_TMON_TEMP_BASE(id)   ((id) * 0x4)
+
+#define SR_TMON_MAX_LIST        6
+
+struct sr_tmon {
+	struct thermal_zone_device *tz;
+	unsigned int crit_temp;
+	unsigned int tmon_id;
+	struct sr_thermal *priv;
+};
+
+struct sr_thermal {
+	void __iomem *regs;
+	unsigned int max_crit_temp;
+	struct sr_tmon tmon[SR_TMON_MAX_LIST];
+};
+
+static int sr_get_temp(void *data, int *temp)
+{
+	struct sr_tmon *tmon = data;
+	struct sr_thermal *sr_thermal = tmon->priv;
+
+	*temp = readl(sr_thermal->regs + SR_TMON_TEMP_BASE(tmon->tmon_id));
+
+	return 0;
+}
+
+static const struct thermal_zone_of_device_ops sr_tz_ops = {
+	.get_temp = sr_get_temp,
+};
+
+static int sr_thermal_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sr_thermal *sr_thermal;
+	struct sr_tmon *tmon;
+	struct resource *res;
+	u32 sr_tmon_list = 0;
+	unsigned int i;
+	int ret;
+
+	sr_thermal = devm_kzalloc(dev, sizeof(*sr_thermal), GFP_KERNEL);
+	if (!sr_thermal)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	sr_thermal->regs = (void __iomem *)devm_memremap(&pdev->dev, res->start,
+							 resource_size(res),
+							 MEMREMAP_WB);
+	if (IS_ERR(sr_thermal->regs)) {
+		dev_err(dev, "failed to get io address\n");
+		return PTR_ERR(sr_thermal->regs);
+	}
+
+	ret = device_property_read_u32(dev, "brcm,tmon-mask", &sr_tmon_list);
+	if (ret)
+		return ret;
+
+	tmon = sr_thermal->tmon;
+	for (i = 0; i < SR_TMON_MAX_LIST; i++, tmon++) {
+		if (!(sr_tmon_list & BIT(i)))
+			continue;
+
+		/* Flush temperature registers */
+		writel(0, sr_thermal->regs + SR_TMON_TEMP_BASE(i));
+		tmon->tmon_id = i;
+		tmon->priv = sr_thermal;
+		tmon->tz = devm_thermal_zone_of_sensor_register(dev, i, tmon,
+								&sr_tz_ops);
+		if (IS_ERR(tmon->tz))
+			return PTR_ERR(tmon->tz);
+
+		dev_dbg(dev, "thermal sensor %d registered\n", i);
+	}
+	platform_set_drvdata(pdev, sr_thermal);
+
+	return 0;
+}
+
+static const struct of_device_id sr_thermal_of_match[] = {
+	{ .compatible = "brcm,sr-thermal", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sr_thermal_of_match);
+
+static const struct acpi_device_id sr_thermal_acpi_ids[] = {
+	{ .id = "BRCM0500" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(acpi, sr_thermal_acpi_ids);
+
+static struct platform_driver sr_thermal_driver = {
+	.probe		= sr_thermal_probe,
+	.driver = {
+		.name = "sr-thermal",
+		.of_match_table = sr_thermal_of_match,
+		.acpi_match_table = ACPI_PTR(sr_thermal_acpi_ids),
+	},
+};
+module_platform_driver(sr_thermal_driver);
+
+MODULE_AUTHOR("Pramod Kumar <pramod.kumar@broadcom.com>");
+MODULE_DESCRIPTION("Stingray thermal driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/thermal/thermal_helpers.c
+++ b/drivers/thermal/thermal_helpers.c
@@ -224,3 +224,29 @@ int thermal_zone_get_offset(struct thermal_zone_device *tz)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(thermal_zone_get_offset);
+
+/**
+ * thermal_zone_get_crit_temp() - returns the critical temperature limit of a
+ * thermal zone
+ * @tz: a valid pointer to a struct thermal_zone_device
+ * @temp: a valid pointer to where to store the critical temperature limit.
+ *
+ * When a valid thermal zone reference is passed, it will fetch its
+ * critical temperature limit and fill @temp.
+ *
+ * Return: On success returns 0, an error code otherwise
+ */
+int thermal_zone_get_crit_temp(struct thermal_zone_device *tz, int *temp)
+{
+	int ret = -EINVAL;
+
+	if (!tz || IS_ERR(tz) || !tz->ops->get_crit_temp)
+		goto exit;
+
+	mutex_lock(&tz->lock);
+	ret = tz->ops->get_crit_temp(tz, temp);
+	mutex_unlock(&tz->lock);
+exit:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(thermal_zone_get_crit_temp);
--- a/drivers/thermal/thermal_hwmon.c
+++ b/drivers/thermal/thermal_hwmon.c
@@ -59,14 +59,6 @@ struct thermal_hwmon_temp {
 static DEFINE_MUTEX(thermal_hwmon_list_lock);
 
 static ssize_t
-name_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct thermal_hwmon_device *hwmon = dev_get_drvdata(dev);
-	return sprintf(buf, "%s\n", hwmon->type);
-}
-static DEVICE_ATTR_RO(name);
-
-static ssize_t
 temp_input_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	int temperature;
@@ -165,15 +157,12 @@ int thermal_add_hwmon_sysfs(struct thermal_zone_device *tz)
 
 	INIT_LIST_HEAD(&hwmon->tz_list);
 	strlcpy(hwmon->type, tz->type, THERMAL_NAME_LENGTH);
-	hwmon->device = hwmon_device_register(NULL);
+	hwmon->device = hwmon_device_register_with_info(NULL, hwmon->type,
+							hwmon, NULL, NULL);
 	if (IS_ERR(hwmon->device)) {
 		result = PTR_ERR(hwmon->device);
 		goto free_mem;
 	}
-	dev_set_drvdata(hwmon->device, hwmon);
-	result = device_create_file(hwmon->device, &dev_attr_name);
-	if (result)
-		goto free_mem;
 
  register_sys_interface:
 	temp = kzalloc(sizeof(*temp), GFP_KERNEL);
@@ -222,10 +211,8 @@ int thermal_add_hwmon_sysfs(struct thermal_zone_device *tz)
  free_temp_mem:
 	kfree(temp);
  unregister_name:
-	if (new_hwmon_device) {
-		device_remove_file(hwmon->device, &dev_attr_name);
+	if (new_hwmon_device)
 		hwmon_device_unregister(hwmon->device);
-	}
  free_mem:
 	if (new_hwmon_device)
 		kfree(hwmon);
@@ -267,7 +254,6 @@ void thermal_remove_hwmon_sysfs(struct thermal_zone_device *tz)
 	list_del(&hwmon->node);
 	mutex_unlock(&thermal_hwmon_list_lock);
 
-	device_remove_file(hwmon->device, &dev_attr_name);
 	hwmon_device_unregister(hwmon->device);
 	kfree(hwmon);
 }
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -674,6 +674,7 @@ static int dw8250_runtime_resume(struct device *dev)
 	{ "AMDI0020", 0 },
 	{ "BRCM2032", 0 },
 	{ "HISI0031", 0 },
+	{ "BRCM2032", 0 },
 	{ },
 };
 MODULE_DEVICE_TABLE(acpi, dw8250_acpi_match);
--- a/drivers/tty/serial/8250/8250_early.c
+++ b/drivers/tty/serial/8250/8250_early.c
@@ -198,3 +198,153 @@ static int __init early_au_setup(struct earlycon_device *dev, const char *opt)
 OF_EARLYCON_DECLARE(palmchip, "ralink,rt2880-uart", early_au_setup);
 
 #endif
+
+#ifdef CONFIG_SERIAL_8250_EARLYLOG
+
+#include <linux/io.h>
+
+/* logging signature */
+#define LOG_SIG_OFFSET       0x0000
+#define LOG_SIG_VAL          0x75767971
+
+/* current logging offset that points to where new logs should be added */
+#define LOG_OFF_OFFSET       0x0004
+
+/* current logging length (excluding header) */
+#define LOG_LEN_OFFSET       0x0008
+
+#define LOG_HEADER_LEN       12
+
+/*
+ * @base: CPU virtual address of the memory where log is saved
+ * @is_initialized: flag that indicates logging has been initialized
+ * @addr: physical address of the memory where log is saved
+ * @max_size: maximum log buffer size
+ */
+struct uart8250_early_log {
+	void *base;
+	bool is_initialized;
+	phys_addr_t addr;
+	u32 max_size;
+};
+
+static struct uart8250_early_log early_log;
+
+static int __init param_setup_earlylog(char *buf)
+{
+	struct uart8250_early_log *log = &early_log;
+	phys_addr_t addr;
+	u32 size;
+	char *end;
+	int ret = -EINVAL;
+
+	if (!buf || !buf[0])
+		return ret;
+
+	addr = memparse(buf, &end);
+	if (*end == ',') {
+		size = memparse(end + 1, NULL);
+
+		if (addr && size) {
+			log->addr = addr;
+			log->max_size = size;
+			return 0;
+		}
+	}
+
+	return ret;
+}
+early_param("earlylog", param_setup_earlylog);
+
+static void uart8250_early_log_putc(struct uart_port *port, int c)
+{
+	struct uart8250_early_log *log = &early_log;
+	u32 offset, len;
+
+	/* always dump to serial port */
+	serial_putc(port, c);
+
+	/* do not save any log if it's not yet initialized */
+	if (!log->is_initialized)
+		return;
+
+	offset = readl(log->base + LOG_OFF_OFFSET);
+	len = readl(log->base + LOG_LEN_OFFSET);
+	writeb(c, log->base + offset);
+	offset++;
+
+	/* log buffer is now full and need to wrap around */
+	if (offset >= log->max_size)
+		offset = LOG_HEADER_LEN;
+
+	/* only increment length when log buffer is not full */
+	if (len < log->max_size - LOG_HEADER_LEN)
+		len++;
+
+	writel(offset, log->base + LOG_OFF_OFFSET);
+	writel(len, log->base + LOG_LEN_OFFSET);
+}
+
+static void uart8250_early_log_write(struct console *console, const char *s,
+				     unsigned int count)
+{
+	struct earlycon_device *dev = console->data;
+	struct uart_port *port = &dev->port;
+	unsigned int i;
+
+	for (i = 0; i < count; i++, s++) {
+		if (*s == '\n')
+			uart8250_early_log_putc(port, '\r');
+		uart8250_early_log_putc(port, *s);
+	}
+}
+
+static int __init uart8250_early_log_setup(struct earlycon_device *dev,
+					   const char *opt)
+{
+	if (!(dev->port.membase || dev->port.iobase))
+		return -ENODEV;
+
+	if (!dev->baud) {
+		struct uart_port *port = &dev->port;
+		unsigned int ier;
+
+		/* assume the device was initialized, only mask interrupts */
+		ier = serial8250_early_in(port, UART_IER);
+		serial8250_early_out(port, UART_IER, ier & UART_IER_UUE);
+	} else
+		init_port(dev);
+
+	dev->con->write = uart8250_early_log_write;
+
+	return 0;
+}
+EARLYCON_DECLARE(uart8250_log, uart8250_early_log_setup);
+
+static int uart8250_early_log_init(void)
+{
+	struct uart8250_early_log *log = &early_log;
+	u32 val;
+
+	/* silently bail out if invaliad parameters are seen */
+	if (log->is_initialized || !log->addr || !log->max_size)
+		return 0;
+
+	log->base = memremap(log->addr, log->max_size, MEMREMAP_WB);
+	if (!log->base)
+		return -ENOMEM;
+
+	/* Silently bail out if no header signature can be found */
+	val = readl(log->base + LOG_SIG_OFFSET);
+	if (val != LOG_SIG_VAL) {
+		memunmap(log->base);
+		return 0;
+	}
+
+	log->is_initialized = true;
+
+	return 0;
+}
+arch_initcall(uart8250_early_log_init);
+
+#endif /* CONFIG_SERIAL_8250_EARLYLOG */
--- a/drivers/tty/serial/8250/Kconfig
+++ b/drivers/tty/serial/8250/Kconfig
@@ -487,3 +487,14 @@ config SERIAL_OF_PLATFORM
 	  are probed through devicetree, including Open Firmware based
 	  PowerPC systems and embedded systems on architectures using the
 	  flattened device tree format.
+
+config SERIAL_8250_EARLYLOG
+	bool "Early logging of 8250/16550 earlycon"
+	depends on SERIAL_8250
+	help
+	  Say Y to enable logging support of the 8250 earlycon console output
+
+	  You can set this using a kernel command line option such as:
+	  "earlycon=uart8250_log,mmio32,0x68A10000"
+
+	  If unsure, say N.
--- a/drivers/usb/gadget/udc/Kconfig
+++ b/drivers/usb/gadget/udc/Kconfig
@@ -285,6 +285,19 @@ config USB_SNP_UDC_PLAT
 	  and Cygnus SoCs.
 
 	  If unsure, say N.
+
+config USB_SNP_UDC
+	tristate "Synopsys USB 2.0 Device controller"
+	select USB_GADGET_DUALSPEED
+	depends on COMPILE_TEST || USB_GADGET
+	default ARCH_BCM_IPROC
+	help
+	  This adds Device support for Synopsys Designware core
+	  AHB subsystem USB2.0 Device Controller(UDC) .
+
+	  This driver works with Synopsys UDC20 products.
+	  If unsure, say N.
+
 #
 # Controllers available in both integrated and discrete versions
 #
--- a/drivers/usb/gadget/udc/Makefile
+++ b/drivers/usb/gadget/udc/Makefile
@@ -38,5 +38,6 @@ obj-$(CONFIG_USB_FOTG210_UDC)	+= fotg210-udc.o
 obj-$(CONFIG_USB_MV_U3D)	+= mv_u3d_core.o
 obj-$(CONFIG_USB_GR_UDC)	+= gr_udc.o
 obj-$(CONFIG_USB_GADGET_XILINX)	+= udc-xilinx.o
-obj-$(CONFIG_USB_SNP_UDC_PLAT) += snps_udc_plat.o
+obj-$(CONFIG_USB_SNP_UDC_PLAT)	+= snps_udc_plat.o
+obj-$(CONFIG_USB_SNP_UDC)	+= snps_udc.o
 obj-$(CONFIG_USB_BDC_UDC)	+= bdc/
--- a/drivers/usb/gadget/udc/bdc/bdc_core.c
+++ b/drivers/usb/gadget/udc/bdc/bdc_core.c
@@ -640,6 +640,7 @@ static SIMPLE_DEV_PM_OPS(bdc_pm_ops, bdc_suspend,
 
 static const struct of_device_id bdc_of_match[] = {
 	{ .compatible = "brcm,bdc-v0.16" },
+	{ .compatible = "brcm,bdc-usb3" },
 	{ .compatible = "brcm,bdc" },
 	{ /* sentinel */ }
 };
--- /dev/null
+++ b/drivers/usb/gadget/udc/snps_udc.c
@@ -0,0 +1,1759 @@
+/*
+ * snps_udc.c - Synopsys USB 2.0 Device Controller driver
+ *
+ * Copyright (C) 2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/errno.h>
+#include <linux/extcon.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/phy/phy.h>
+#include <linux/proc_fs.h>
+#include <linux/types.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/version.h>
+#include "snps_udc.h"
+
+#define DRIVER_DESC "Driver for Synopsys Designware core UDC"
+
+static void ep0_setup_init(struct snps_udc_ep *ep, int status)
+{
+	struct snps_udc *udc = ep->udc;
+
+	ep->dma.virt->setup.status = DMA_STS_BUF_HOST_READY;
+	ep->dirn = USB_DIR_OUT;
+	ep->stopped = 0;
+
+	if (!status) {
+		clear_ep_nak(udc->regs, ep->num, USB_DIR_OUT);
+		clear_ep_nak(udc->regs, ep->num, USB_DIR_IN);
+	} else {
+		enable_ep_stall(udc->regs, ep->num, USB_DIR_IN);
+		enable_ep_stall(udc->regs, ep->num, USB_DIR_OUT);
+	}
+
+	enable_udc_ep_irq(udc->regs, ep->num, USB_DIR_OUT);
+	enable_ep_dma(udc->regs, ep->num, USB_DIR_OUT);
+
+	dev_dbg(udc->dev, "%s setup buffer initialized\n", ep->name);
+}
+
+static void ep_dma_init(struct snps_udc_ep *ep)
+{
+	struct snps_udc *udc = ep->udc;
+	u32 desc_cnt = (DESC_CNT - 1);
+	u32 i;
+
+	ep->dma.virt = &ep->udc->dma.virt->ep[ep->num];
+	ep->dma.phys = &ep->udc->dma.phys->ep[ep->num];
+
+	ep->dma.virt->setup.status = DMA_STS_BUF_HOST_BUSY;
+	set_setup_buf_ptr(udc->regs, ep->num, USB_DIR_OUT,
+			  &ep->dma.phys->setup);
+
+	for (i = 0; i < DESC_CNT; i++) {
+		ep->dma.virt->desc[i].status = DMA_STS_BUF_HOST_BUSY;
+		ep->dma.virt->desc[i].next_desc_addr =
+				(dma_addr_t)&ep->dma.phys->desc[i + 1];
+	}
+	ep->dma.virt->desc[desc_cnt].next_desc_addr =
+				(dma_addr_t)&ep->dma.phys->desc[0];
+
+	set_data_desc_ptr(udc->regs, ep->num, USB_DIR_OUT,
+			  &ep->dma.phys->desc[0]);
+	set_data_desc_ptr(udc->regs, ep->num, USB_DIR_IN,
+			  &ep->dma.phys->desc[0]);
+
+	dev_dbg(udc->dev, " %s dma initialized\n", ep->name);
+}
+
+static void ep_data_dma_init(struct snps_udc_ep *ep)
+{
+	struct ep_xfer_req *ep_req;
+
+	dev_dbg(ep->udc->dev, "enter: %s\n", __func__);
+
+	ep_req = list_first_entry(&ep->queue, struct ep_xfer_req, queue);
+
+	if (ep_req->dma_aligned) {
+		ep_req->dma_addr_orig = ep_req->usb_req.dma;
+		ep_req->usb_req.dma = ep->dma.aligned_addr;
+		if (ep->dirn == USB_DIR_IN)
+			memcpy(ep->dma.aligned_buf, ep_req->usb_req.buf,
+			       ep_req->usb_req.length);
+	}
+
+	ep->dma.done = 0;
+	ep->dma.len_done = 0;
+	ep->dma.len_rem = ep->dma.usb_req->length;
+	ep->dma.buf_addr = ep->dma.usb_req->dma;
+	ep->dma.status = DMA_STS_RX_SUCCESS;
+
+	if ((ep->dirn == USB_DIR_IN) &&
+	    (ep->type != USB_ENDPOINT_XFER_ISOC)) {
+		if (in_bf_mode)
+			ep->dma.len_max = ep->dma.usb_req->length;
+		else
+			ep->dma.len_max = ep->usb_ep.maxpacket;
+	} else {
+		if (out_bf_mode)
+			ep->dma.len_max = ep->dma.usb_req->length;
+		else
+			ep->dma.len_max = ep->usb_ep.maxpacket;
+	}
+
+	dma_desc_chain_reset(ep);
+}
+
+static void ep_data_dma_finish(struct snps_udc_ep *ep)
+{
+	struct snps_udc *udc = ep->udc;
+	struct ep_xfer_req *ep_req;
+
+	disable_udc_ep_irq(udc->regs, ep->num, ep->dirn);
+	disable_ep_dma(udc->regs, ep->num, ep->dirn);
+
+	ep_req = list_first_entry(&ep->queue, struct ep_xfer_req, queue);
+
+	if (ep_req->dma_aligned) {
+		if (ep->dirn == USB_DIR_OUT)
+			memcpy(ep_req->usb_req.buf,
+			       ep->dma.aligned_buf, ep_req->usb_req.length);
+		ep_req->usb_req.dma = ep_req->dma_addr_orig;
+	}
+	dev_dbg(udc->dev, "%s dma finished\n", ep->name);
+}
+
+static void ep_data_dma_add(struct snps_udc_ep *ep)
+{
+	struct data_desc *desc = NULL;
+	u32 status;
+	u32 len;
+
+	if (!ep->dma.len_rem)
+		ep->dma.usb_req->zero = 1;
+
+	ep->dma.last = ep->dma.usb_req->zero;
+
+	while (!dma_desc_chain_is_full(ep) &&
+	       (ep->dma.len_rem || ep->dma.usb_req->zero)) {
+		desc = dma_desc_chain_alloc(ep);
+		len = (ep->dma.len_rem < ep->dma.len_max) ?
+			ep->dma.len_rem : ep->dma.len_max;
+		ep->dma.len_rem -= len;
+		status = 0;
+
+		if (len <= ep->dma.len_max ||
+		    (out_bf_mode && (len <= ep->dma.len_max))) {
+			if (in_bf_mode ||
+			    !((ep->dirn == USB_DIR_IN) &&
+			      (ep->type == USB_ENDPOINT_XFER_BULK) &&
+			      (len != 0) &&
+			      (len % ep->usb_ep.maxpacket == 0)))
+				ep->dma.usb_req->zero = 0;
+		}
+
+		if ((ep->dirn == USB_DIR_IN) &&
+		    (ep->type == USB_ENDPOINT_XFER_ISOC)) {
+			ep->dma.frame_num += ep->dma.frame_incr;
+			dev_dbg(ep->udc->dev, "%s: DMA started: frame_num=%d.%d\n",
+				ep->name, (ep->dma.frame_num >> 3),
+				(ep->dma.frame_num & 0x7));
+			status |= ((ep->dma.frame_num <<
+				  DMA_STS_FRAME_NUM_SHIFT)
+				  & DMA_STS_FRAME_NUM_MASK);
+		}
+
+		desc->buf_addr = ep->dma.buf_addr;
+		status |= (len << DMA_STS_BYTE_CNT_SHIFT);
+		desc->status = status | DMA_STS_BUF_HOST_READY;
+		/* Ensure all writes are done before going for next descriptor*/
+		wmb();
+		ep->dma.buf_addr += len;
+
+		if ((ep->dirn == USB_DIR_IN) &&
+		    (ep->type == USB_ENDPOINT_XFER_ISOC))
+			break;
+	}
+
+	if (desc)
+		desc->status |= DMA_STS_LAST_DESC;
+
+	dev_dbg(ep->udc->dev, "%s dma data added\n", ep->name);
+}
+
+static void ep_data_dma_remove(struct snps_udc_ep *ep)
+{
+	struct data_desc *desc;
+	u32 status;
+	u32 len = 0;
+
+	while (!dma_desc_chain_is_empty(ep)) {
+		desc = dma_desc_chain_head(ep);
+		status = desc->status;
+		desc->status = DMA_STS_BUF_HOST_BUSY;
+		/* Ensure all writes are done before going for next descriptor*/
+		wmb();
+		len = (status & DMA_STS_NISO_BYTE_CNT_MASK) >>
+			DMA_STS_NISO_BYTE_CNT_SHIFT;
+
+		if ((ep->dirn == USB_DIR_IN) || (status &
+					DMA_STS_LAST_DESC)) {
+			ep->dma.len_done += len;
+			ep->dma.usb_req->actual += len;
+		}
+
+		if ((status & DMA_STS_RX_MASK) != DMA_STS_RX_SUCCESS) {
+			ep->dma.status = status & DMA_STS_RX_MASK;
+			ep->dma.usb_req->status = -EIO;
+			dev_warn(ep->udc->dev, "%s: DMA error\n", ep->name);
+		}
+
+		if ((ep->dirn == USB_DIR_IN) &&
+		    (ep->type == USB_ENDPOINT_XFER_ISOC)) {
+			if (ep->dma.usb_req->actual ==
+					ep->dma.usb_req->length)
+				ep->dma.usb_req->status = 0;
+			dma_desc_chain_reset(ep);
+		} else {
+			dma_desc_chain_free(ep);
+		}
+	}
+
+	if ((!ep->dma.len_rem || (len < ep->usb_ep.maxpacket)) &&
+	    (ep->dma.usb_req->status == -EINPROGRESS))
+		ep->dma.usb_req->status = 0;
+
+	dev_dbg(ep->udc->dev, "%s dma data removed\n", ep->name);
+}
+
+static int fifo_ram_alloc(struct snps_udc_ep *ep, u32 max_pkt_size)
+{
+	u32 rx_cnt;
+	u32 tx_cnt;
+
+	switch (EP_DIRN_TYPE(ep->dirn, ep->type)) {
+	case EP_DIRN_TYPE(USB_DIR_OUT, USB_ENDPOINT_XFER_BULK):
+	case EP_DIRN_TYPE(USB_DIR_OUT, USB_ENDPOINT_XFER_INT):
+	case EP_DIRN_TYPE(USB_DIR_OUT, USB_ENDPOINT_XFER_ISOC):
+		rx_cnt = FIFO_SZ_U8(max_pkt_size);
+		tx_cnt = 0;
+		break;
+
+	case EP_DIRN_TYPE(USB_DIR_IN, USB_ENDPOINT_XFER_BULK):
+	case EP_DIRN_TYPE(USB_DIR_IN, USB_ENDPOINT_XFER_INT):
+		rx_cnt = 0;
+		tx_cnt = FIFO_SZ_U8(max_pkt_size);
+		break;
+
+	case EP_DIRN_TYPE(USB_DIR_IN, USB_ENDPOINT_XFER_ISOC):
+		rx_cnt = 0;
+		tx_cnt = 2 * FIFO_SZ_U8(max_pkt_size);
+		break;
+
+	case EP_DIRN_TYPE(USB_DIR_IN,  USB_ENDPOINT_XFER_CONTROL):
+	case EP_DIRN_TYPE(USB_DIR_OUT, USB_ENDPOINT_XFER_CONTROL):
+		rx_cnt = FIFO_SZ_U8(max_pkt_size);
+		tx_cnt = rx_cnt;
+		break;
+
+	default:
+		dev_err(ep->udc->dev, "%s: invalid EP attributes\n", ep->name);
+		return -ENODEV;
+	}
+
+	dev_dbg(ep->udc->dev, "rx req=%u free=%u: tx req=%u free=%u\n",
+		rx_cnt, ep->udc->rx_fifo_space, tx_cnt, ep->udc->tx_fifo_space);
+
+	if ((ep->udc->rx_fifo_space < rx_cnt) ||
+	    (ep->udc->tx_fifo_space < tx_cnt)) {
+		dev_err(ep->udc->dev, "%s: fifo alloc failed\n", ep->name);
+		return -ENOSPC;
+	}
+
+	ep->rx_fifo_size = rx_cnt;
+	ep->tx_fifo_size = tx_cnt;
+
+	if (mrx_fifo)
+		ep->udc->rx_fifo_space -= rx_cnt;
+
+	ep->udc->tx_fifo_space -= tx_cnt;
+
+	return 0;
+}
+
+static void fifo_ram_free(struct snps_udc_ep *ep)
+{
+	if (mrx_fifo)
+		ep->udc->rx_fifo_space += ep->rx_fifo_size;
+
+	ep->udc->tx_fifo_space += ep->tx_fifo_size;
+
+	ep->rx_fifo_size = 0;
+	ep->tx_fifo_size = 0;
+}
+
+static int ep_cfg(struct snps_udc_ep *ep, u32 type,
+		  u32 max_pkt_size)
+{
+	struct snps_udc *udc = ep->udc;
+
+	ep->type = type;
+	if (fifo_ram_alloc(ep, max_pkt_size) != 0)
+		return -ENOSPC;
+
+	ep->type = type;
+	ep->usb_ep.maxpacket = max_pkt_size;
+
+	if (ep->udc->conn_type)
+		init_ep_reg(udc->regs, ep->num, ep->type, ep->dirn,
+			    max_pkt_size);
+	dev_dbg(udc->dev, "ep_cfg: %s: type=%u dirn=0x%x pkt=%u\n",
+		ep->usb_ep.name, type, ep->dirn, max_pkt_size);
+
+	return 0;
+}
+
+static void epreq_xfer_done(struct snps_udc_ep *ep,
+			    struct ep_xfer_req *ep_req, int status)
+{
+	struct snps_udc *udc = ep->udc;
+	u32 stopped;
+
+	list_del_init(&ep_req->queue);
+
+	if (ep_req->usb_req.status == -EINPROGRESS)
+		ep_req->usb_req.status = status;
+
+	if (ep_req->dma_aligned) {
+		ep_req->dma_aligned = 0;
+	} else if (ep_req->dma_mapped) {
+		dma_unmap_single(ep->udc->gadget.dev.parent,
+				 ep_req->usb_req.dma,
+				 (ep_req->usb_req.length ?
+				 ep_req->usb_req.length : 1),
+				 (ep->dirn == USB_DIR_IN ? DMA_TO_DEVICE :
+				 DMA_FROM_DEVICE));
+		ep_req->dma_mapped = 0;
+		ep_req->usb_req.dma = DMA_ADDR_INVALID;
+	}
+
+	dev_dbg(udc->dev, "%s xfer done req=0x%p buf=0x%p len=%d actual=%d\n",
+		ep->name, &ep_req->usb_req, ep_req->usb_req.buf,
+		ep_req->usb_req.length, ep_req->usb_req.actual);
+
+	stopped = ep->stopped;
+	ep->stopped = 1;
+	spin_unlock(&ep->udc->lock);
+	ep_req->usb_req.complete(&ep->usb_ep, &ep_req->usb_req);
+	spin_lock(&ep->udc->lock);
+	ep->stopped = stopped;
+}
+
+static void epreq_xfer_process(struct snps_udc_ep *ep)
+{
+	struct snps_udc *udc = ep->udc;
+	struct ep_xfer_req *ep_req;
+
+	dev_dbg(udc->dev, "%s: xfer request\n", ep->name);
+
+	if (!ep->dma.usb_req) {
+		dev_dbg(udc->dev, "%s: No dma usb request\n", ep->name);
+		return;
+	}
+
+	disable_ep_dma(udc->regs, ep->num, ep->dirn);
+	ep_data_dma_remove(ep);
+
+	if (ep->dma.usb_req->status != -EINPROGRESS) {
+		ep_data_dma_finish(ep);
+
+		if ((ep->type == USB_ENDPOINT_XFER_CONTROL) &&
+		    (ep->dirn == USB_DIR_IN) &&
+		    (ep->dma.usb_req->status == 0)) {
+			ep->dirn = USB_DIR_OUT;
+			ep->b_ep_addr = ep->num | ep->dirn;
+			ep->dma.usb_req->status = -EINPROGRESS;
+			ep->dma.usb_req->actual = 0;
+			ep->dma.usb_req->length = 0;
+			ep_data_dma_init(ep);
+		} else {
+			if (in_bf_mode && is_ep_in() && is_ep_bulk() &&
+			    (ep->dma.usb_req->length != 0) &&
+			    (ep->dma.usb_req->length %
+			    ep->usb_ep.maxpacket == 0) &&
+			    (ep->dma.last)) {
+				ep->dma.usb_req->status = -EINPROGRESS;
+				ep->dma.usb_req->actual = 0;
+				ep->dma.usb_req->length = 0;
+			} else if (!list_empty(&ep->queue))
+				epreq_xfer_done(ep,
+						list_first_entry(&ep->queue,
+								 struct
+								 ep_xfer_req,
+								 queue), 0);
+
+			if (ep->type == USB_ENDPOINT_XFER_CONTROL)
+				ep0_setup_init(ep, 0);
+
+			if (is_ep_in() && is_ep_bulk() &&
+			    !list_empty(&ep->queue)) {
+				ep->in_xfer_done = true;
+				clear_ep_nak(udc->regs, ep->num, ep->dirn);
+				enable_udc_ep_irq(udc->regs, ep->num, ep->dirn);
+				return;
+			}
+
+			if (list_empty(&ep->queue)) {
+				ep->dma.usb_req = NULL;
+			} else {
+				ep_req = list_first_entry(&ep->queue,
+							  struct ep_xfer_req,
+							  queue);
+				ep->dma.usb_req = &ep_req->usb_req;
+				ep_data_dma_init(ep);
+			}
+		}
+	}
+
+	if (ep->dma.usb_req) {
+		ep_data_dma_add(ep);
+		enable_udc_ep_irq(udc->regs, ep->num, ep->dirn);
+		clear_ep_nak(udc->regs, ep->num, ep->dirn);
+		enable_ep_dma(udc->regs, ep->num, ep->dirn);
+	}
+}
+
+static void epreq_xfer_error(struct snps_udc_ep *ep, int status)
+{
+	if (!ep->dma.usb_req) {
+		dev_err(ep->udc->dev, "%s: No DMA usb request\n", ep->name);
+		return;
+	}
+
+	ep->dma.usb_req->status = status;
+	epreq_xfer_process(ep);
+}
+
+static void epreq_xfer_add(struct snps_udc_ep *ep,
+			   struct ep_xfer_req *ep_req)
+{
+	struct snps_udc *udc = ep->udc;
+
+	list_add_tail(&ep_req->queue, &ep->queue);
+	if (ep->stopped)
+		return;
+
+	if ((ep->dirn == USB_DIR_IN) &&
+	    (ep->type == USB_ENDPOINT_XFER_ISOC) &&
+	    (ep->dma.usb_req) &&
+	    (ep->dma.frame_num == FRAME_NUM_INVALID)) {
+		ep_data_dma_finish(ep);
+		ep->dma.usb_req = NULL;
+		epreq_xfer_done(ep,
+				list_first_entry(&ep->queue,
+						 struct ep_xfer_req,
+						 queue),
+				-EREMOTEIO);
+	}
+
+	if (ep->dma.usb_req) {
+		dev_dbg(udc->dev, "%s: busy\n", ep->name);
+	} else if (!in_isoc_delay_disabled && (ep->dirn == USB_DIR_IN) &&
+		   (ep->type == USB_ENDPOINT_XFER_ISOC) &&
+		   (ep->dma.frame_num == FRAME_NUM_INVALID)) {
+		dev_dbg(udc->dev, "%s: ISOC delay xfer start\n", ep->name);
+		ep->dma.usb_req = &(list_first_entry(&ep->queue,
+				struct ep_xfer_req, queue))->usb_req;
+		ep_data_dma_init(ep);
+		clear_ep_nak(udc->regs, ep->num, ep->dirn);
+		enable_udc_ep_irq(udc->regs, ep->num, ep->dirn);
+
+	} else {
+		if (in_isoc_delay_disabled && (ep->dirn == USB_DIR_IN) &&
+		    (ep->type == USB_ENDPOINT_XFER_ISOC) &&
+		    (ep->dma.frame_num == FRAME_NUM_INVALID)) {
+			ep->dma.frame_num = get_last_rx_frnum(udc->regs);
+		}
+
+		if (is_ep_in() && is_ep_bulk() && !ep->dma.usb_req) {
+			ep->in_xfer_done = true;
+			clear_ep_nak(udc->regs, ep->num, ep->dirn);
+			enable_udc_ep_irq(udc->regs, ep->num, ep->dirn);
+			return;
+		}
+
+		ep_req = list_first_entry(&ep->queue,
+					  struct ep_xfer_req, queue);
+		ep->dma.usb_req = &ep_req->usb_req;
+		ep_data_dma_init(ep);
+		ep_data_dma_add(ep);
+		enable_udc_ep_irq(udc->regs, ep->num, ep->dirn);
+		clear_ep_nak(udc->regs, ep->num, ep->dirn);
+		enable_ep_dma(udc->regs, ep->num, ep->dirn);
+	}
+
+	dev_dbg(udc->dev, "%s: xfer add ep request\n", ep->name);
+}
+
+static void epreq_queue_flush(struct snps_udc_ep *ep, int status)
+{
+	struct snps_udc *udc = ep->udc;
+	struct ep_xfer_req *ep_req;
+
+	ep->stopped = 1;
+
+	while (!list_empty(&ep->queue)) {
+		ep_req = list_first_entry(&ep->queue,
+					  struct ep_xfer_req, queue);
+		epreq_xfer_done(ep, ep_req, status);
+	}
+
+	ep->dma.usb_req = NULL;
+	if ((is_ep_in() && is_ep_bulk()) || !ep->num) {
+		set_ep_fifo_flush(udc->regs, ep->num, ep->dirn);
+		clear_ep_fifo_flush(udc->regs, ep->num, ep->dirn);
+	}
+
+	dev_dbg(udc->dev, "%s: EP queue flushed\n", ep->usb_ep.name);
+}
+
+static void ep0_setup_rx(struct snps_udc_ep *ep,
+			 struct usb_ctrlrequest *setup)
+{
+	struct snps_udc *udc = ep->udc;
+	int status;
+	u32 val;
+	u32 idx;
+	u32 len;
+
+	val = le16_to_cpu(setup->wValue);
+	idx = le16_to_cpu(setup->wIndex);
+	len = le16_to_cpu(setup->wLength);
+
+	ep->dirn = setup->bRequestType & USB_ENDPOINT_DIR_MASK;
+
+	dev_dbg(udc->dev, "%s: SETUP %02x.%02x v%04x i%04x l %04x\n",
+		ep->name, setup->bRequestType, setup->bRequest,
+		val, idx, len);
+
+	if (ep->num != 0) {
+		status = -EOPNOTSUPP;
+	} else {
+		spin_unlock(&udc->lock);
+		status = udc->gadget_driver->setup(&udc->gadget, setup);
+		spin_lock(&udc->lock);
+	}
+
+	if (status < 0)
+		ep0_setup_init(ep, status);
+	else if (len == 0)
+		ep0_setup_init(ep, 0);
+}
+
+static void irq_ep_out_setup(struct snps_udc_ep *ep)
+{
+	struct setup_desc *desc = &ep->dma.virt->setup;
+	u32 status = desc->status;
+
+	dev_dbg(ep->udc->dev, "irq set up %s desc status: 0x%x\n",
+		ep->name, status);
+
+	if ((status & DMA_STS_BUF_MASK) != DMA_STS_BUF_DMA_DONE) {
+		ep0_setup_init(ep, 0);
+	} else if ((status & DMA_STS_RX_MASK) != DMA_STS_RX_SUCCESS) {
+		ep0_setup_init(ep, 0);
+	} else {
+		desc->status = (status & ~DMA_STS_BUF_MASK)
+					| DMA_STS_BUF_HOST_BUSY;
+		ep0_setup_rx(ep, (struct usb_ctrlrequest *)&desc->data1);
+	}
+}
+
+static void irq_process_epout(struct snps_udc_ep *ep)
+{
+	struct snps_udc *udc = ep->udc;
+	u32 status;
+
+	status = get_ep_status(udc->regs, ep->num, USB_DIR_OUT);
+	clear_ep_status(udc->regs, ep->num, USB_DIR_OUT, status);
+
+	status &= EP_STS_ALL;
+
+	if (!status)
+		return;
+
+	if ((ep->dirn != USB_DIR_OUT) &&
+	    (ep->type != USB_ENDPOINT_XFER_CONTROL)) {
+		dev_err(udc->dev, "%s: unexpected interrupt\n", ep->name);
+		return;
+	}
+
+	if (status & OUT_DMA_DATA_DONE) {
+		status &= ~OUT_DMA_DATA_DONE;
+		epreq_xfer_process(ep);
+	}
+
+	if (status & OUT_DMA_SETUP_DONE) {
+		status &= ~OUT_DMA_SETUP_DONE;
+		irq_ep_out_setup(ep);
+	}
+
+	if (status & DMA_BUF_NOT_AVAIL) {
+		status &= ~DMA_BUF_NOT_AVAIL;
+		dev_dbg(udc->dev, "%s: DMA BUF NOT AVAIL\n", ep->name);
+		epreq_xfer_process(ep);
+	}
+
+	if (status & DMA_ERROR) {
+		status &= ~DMA_ERROR;
+		dev_err(udc->dev, "%s: DMA ERROR\n", ep->usb_ep.name);
+		epreq_xfer_error(ep, -EIO);
+	}
+
+	if (status)
+		dev_err(udc->dev, "%s: unknown status=0x%x\n",
+			ep->name, status);
+}
+
+static void irq_process_epin(struct snps_udc_ep *ep)
+{
+	struct snps_udc *udc = ep->udc;
+	struct ep_xfer_req *ep_req;
+	u32 status;
+
+	status = get_ep_status(udc->regs, ep->num, USB_DIR_IN);
+	clear_ep_status(udc->regs, ep->num, USB_DIR_IN, status);
+
+	if (!status)
+		return;
+
+	if (ep->dirn != USB_DIR_IN) {
+		dev_err(udc->dev, "%s: unexpected OUT endpoint\n", ep->name);
+		return;
+	}
+
+	if ((ep->type == USB_ENDPOINT_XFER_ISOC) &&
+	    (status & (IN_XFER_DONE | DMA_BUF_NOT_AVAIL))) {
+		dev_warn(ep->udc->dev, "%s: ISOC IN unexpected status=0x%x\n",
+			 ep->name, status);
+	}
+
+	if (status & IN_TOKEN_RX) {
+		status &= ~IN_TOKEN_RX;
+		if (!ep->dma.usb_req && list_empty(&ep->queue))
+			enable_ep_nak(udc->regs, ep->num, USB_DIR_IN);
+
+		if (ep->type == USB_ENDPOINT_XFER_ISOC) {
+			ep->dma.frame_num = get_frnum_last_rx(udc->regs);
+			dev_dbg(udc->dev, "%s: ISOC IN\n", ep->name);
+			if (ep->dma.usb_req) {
+				ep->dma.usb_req->status = -EREMOTEIO;
+				epreq_xfer_process(ep);
+			}
+		}
+	}
+
+	if (is_ep_bulk() && !list_empty(&ep->queue) &&
+	    ep->in_xfer_done) {
+		ep->in_xfer_done = false;
+		ep_req = list_first_entry(&ep->queue,
+					  struct ep_xfer_req, queue);
+		ep->dma.usb_req = &ep_req->usb_req;
+
+		ep_data_dma_init(ep);
+		ep_data_dma_add(ep);
+		clear_ep_nak(udc->regs, ep->num, ep->dirn);
+		enable_udc_ep_irq(udc->regs, ep->num, ep->dirn);
+		enable_ep_dma(udc->regs, ep->num, ep->dirn);
+	}
+
+	if (status & IN_DMA_DONE) {
+		status &= ~IN_DMA_DONE;
+		clear_ep_nak(udc->regs, ep->num, USB_DIR_IN);
+
+		if (ep->type == USB_ENDPOINT_XFER_ISOC) {
+			dev_dbg(udc->dev, "%s: ISOC IN\n", ep->usb_ep.name);
+			epreq_xfer_process(ep);
+		} else if (ep->dma.done & IN_XFER_DONE) {
+			dev_dbg(udc->dev, "%s: late IN DMA done rec'd\n",
+				ep->name);
+			epreq_xfer_process(ep);
+		} else {
+			ep->dma.done = IN_DMA_DONE;
+		}
+	}
+
+	if (status & IN_XFER_DONE) {
+		status &= ~(IN_XFER_DONE);
+		status &= ~(IN_FIFO_EMPTY);
+
+		if (ep->dma.done & IN_DMA_DONE)
+			epreq_xfer_process(ep);
+		else
+			ep->dma.done = IN_XFER_DONE;
+	}
+
+	status &= ~(IN_FIFO_EMPTY);
+
+	if (status & DMA_BUF_NOT_AVAIL) {
+		dev_err(udc->dev, "%s: DMA BUF NOT AVAIL\n", ep->name);
+		status &= ~(DMA_BUF_NOT_AVAIL);
+		epreq_xfer_process(ep);
+	}
+
+	if (status & DMA_ERROR) {
+		status &= ~DMA_ERROR;
+		dev_err(udc->dev, "%s: DMA ERROR\n", ep->name);
+		epreq_xfer_error(ep, -EIO);
+	}
+
+	if (status)
+		dev_err(udc->dev, "%s: unknown status=0x%x\n",
+			ep->name, status);
+}
+
+static void ep_irq_process(struct snps_udc *udc, u32 irq_in, u32 irq_out)
+{
+	u32 mask = 1;
+	u32 num;
+
+	for (num = 0; num < UDC_MAX_EP; num++) {
+		if (irq_in & mask)
+			irq_process_epin(&udc->ep[num]);
+
+		if (irq_out & mask)
+			irq_process_epout(&udc->ep[num]);
+
+		mask <<= 1;
+	}
+}
+
+static void irq_process_set_intf(struct snps_udc *udc)
+{
+	struct usb_ctrlrequest setup;
+	u32 ep_num;
+	u16 intf;
+	u16 alt;
+
+	intf = (uint16_t)get_intf_num(udc->regs);
+	alt =  (uint16_t)get_alt_num(udc->regs);
+
+	setup.bRequestType = USB_DIR_OUT | USB_TYPE_STANDARD
+					 | USB_RECIP_INTERFACE;
+	setup.bRequest = USB_REQ_SET_INTERFACE;
+	setup.wValue = cpu_to_le16(alt);
+	setup.wIndex = cpu_to_le16(intf);
+	setup.wLength = 0;
+
+	for (ep_num = 0; ep_num < UDC_MAX_EP; ep_num++) {
+		set_ep_alt_num(udc->regs, ep_num, alt);
+		set_ep_intf_num(udc->regs, ep_num, intf);
+	}
+	dev_info(udc->dev, "SET INTF=%d ALT=%d\n", intf, alt);
+
+	ep0_setup_rx(&udc->ep[0], &setup);
+	set_setup_done(udc->regs);
+}
+
+static void irq_process_set_cfg(struct snps_udc *udc)
+{
+	struct usb_ctrlrequest setup;
+	u32 ep_num;
+	u16 cfg;
+
+	cfg = (u16)get_cfg_num(udc->regs);
+
+	setup.bRequestType = USB_DIR_OUT | USB_TYPE_STANDARD
+					 | USB_RECIP_DEVICE;
+	setup.bRequest = USB_REQ_SET_CONFIGURATION;
+	setup.wValue = cpu_to_le16(cfg);
+	setup.wIndex = 0;
+	setup.wLength = 0;
+
+	for (ep_num = 0; ep_num < UDC_MAX_EP; ep_num++)
+		set_epcfg_reg(udc->regs, ep_num, cfg);
+
+	dev_info(udc->dev, "SET CFG=%d\n", cfg);
+
+	ep0_setup_rx(&udc->ep[0], &setup);
+	set_setup_done(udc->regs);
+}
+
+static void irq_process_speed_enum(struct snps_udc *udc)
+{
+	u32 speed = udc->gadget.speed;
+
+	switch (get_enum_speed(udc->regs)) {
+	case SPEED_HIGH:
+		dev_info(udc->dev, "HIGH SPEED\n");
+		udc->gadget.speed = USB_SPEED_HIGH;
+		break;
+	case SPEED_FULL:
+		dev_info(udc->dev, "FULL SPEED\n");
+		udc->gadget.speed = USB_SPEED_FULL;
+		break;
+	case SPEED_LOW:
+		dev_warn(udc->dev, "LOW SPEED not supported\n");
+		udc->gadget.speed = USB_SPEED_LOW;
+		break;
+	default:
+		dev_err(udc->dev, "Unknown SPEED = 0x%x\n",
+			get_enum_speed(udc->regs));
+		break;
+	}
+
+	if ((speed == USB_SPEED_UNKNOWN) &&
+	    (udc->gadget.speed != USB_SPEED_UNKNOWN)) {
+		ep0_setup_init(&udc->ep[0], 0);
+		clear_devnak(udc->regs);
+	}
+}
+
+static void irq_process_bus_idle(struct snps_udc *udc)
+{
+	int num;
+
+	for (num = 0; num < UDC_MAX_EP; num++) {
+		set_ep_fifo_flush(udc->regs, num, EP_DIRN_IN);
+		clear_ep_fifo_flush(udc->regs, num, EP_DIRN_IN);
+	}
+}
+
+static void dev_irq_process(struct snps_udc *udc, u32 irq)
+{
+	if (irq & IRQ_BUS_RESET)
+		dev_info(udc->dev, "BUS RESET\n");
+
+	if (irq & IRQ_BUS_SUSPEND)
+		dev_dbg(udc->dev, "BUS SUSPEND\n");
+
+	if (irq & IRQ_BUS_IDLE) {
+		dev_dbg(udc->dev, "BUS IDLE\n");
+		irq_process_bus_idle(udc);
+	}
+
+	if (irq & IRQ_SPEED_ENUM_DONE) {
+		dev_dbg(udc->dev, "BUS speed enum done\n");
+		irq_process_speed_enum(udc);
+	}
+
+	if (irq & IRQ_SET_CFG) {
+		dev_dbg(udc->dev, "SET CFG\n");
+		irq_process_set_cfg(udc);
+	}
+
+	if (irq & IRQ_SET_INTF) {
+		dev_dbg(udc->dev, "SET INTF\n");
+		irq_process_set_intf(udc);
+	}
+}
+
+static irqreturn_t snps_udc_irq(int irq, void *dev)
+{
+	struct snps_udc *udc = (struct snps_udc *)dev;
+	u32 devintr, epin_intr, epout_intr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	devintr = get_irq_active(udc->regs);
+	epin_intr = get_ep_irq_active(udc->regs, USB_DIR_IN);
+	epout_intr = get_ep_irq_active(udc->regs, USB_DIR_OUT);
+
+	clear_udc_dev_irq(udc->regs, devintr);
+	clear_udc_ep_irq_list(udc->regs, USB_DIR_IN, epin_intr);
+	clear_udc_ep_irq_list(udc->regs, USB_DIR_OUT, epout_intr);
+
+	if (!udc || !udc->gadget_driver) {
+		spin_unlock_irqrestore(&udc->lock, flags);
+		return IRQ_NONE;
+	}
+
+	/* SET_CFG and SET_INTF interrupts are handled last */
+	dev_irq_process(udc, devintr & ~(IRQ_SET_CFG | IRQ_SET_INTF));
+	ep_irq_process(udc, epin_intr, epout_intr);
+	dev_irq_process(udc, devintr & (IRQ_SET_CFG | IRQ_SET_INTF));
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	dev_dbg(udc->dev, "UDC interrupts: Dev=0x%x EpIn=0x%x EpOut=0x%x\n",
+		devintr, epin_intr, epout_intr);
+
+	return IRQ_HANDLED;
+}
+
+static int snps_ep_enable(struct usb_ep *usb_ep,
+			  const struct usb_endpoint_descriptor *desc)
+{
+	struct snps_udc_ep *ep;
+	struct snps_udc *udc;
+	unsigned long flags;
+	u32 max_pkt_size;
+	u32 xfertype;
+
+	ep = container_of(usb_ep, struct snps_udc_ep, usb_ep);
+	udc = ep->udc;
+
+	if (!usb_ep || (ep->b_ep_addr != desc->bEndpointAddress)) {
+		dev_err(udc->dev, "invalid endpoint (%p)\n", usb_ep);
+		return -EINVAL;
+	}
+
+	if (!desc || (desc->bDescriptorType != USB_DT_ENDPOINT)) {
+		dev_err(udc->dev, "ep%d: invalid descriptor=%p\n",
+			ep->num, desc);
+		return -EINVAL;
+	}
+
+	if (desc == ep->desc) {
+		dev_err(udc->dev, "ep%d: already enabled\n", ep->num);
+		return -EEXIST;
+	}
+
+	if (ep->desc) {
+		dev_err(udc->dev, "ep%d:already enabled wth other descr\n",
+			ep->num);
+		return -EBUSY;
+	}
+
+	if (!udc->gadget_driver) {
+		dev_warn(udc->dev, "%s: invalid device state\n", ep->name);
+		return -ESHUTDOWN;
+	}
+
+	xfertype = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+	max_pkt_size = le16_to_cpu(desc->wMaxPacketSize) & 0x7FF;
+
+	if (!max_pkt_size || (max_pkt_size > ep->max_pkt_size)) {
+		dev_err(udc->dev, "%s: invalid max pkt size\n", ep->name);
+		return -ERANGE;
+	}
+
+	if ((ep->dirn == USB_DIR_IN) &&
+	    (xfertype == USB_ENDPOINT_XFER_ISOC)) {
+		if ((desc->bInterval < 1) || (desc->bInterval > 16)) {
+			dev_err(udc->dev, "%s: invalid binterval\n", ep->name);
+			return -ERANGE;
+		}
+		ep->dma.frame_num = FRAME_NUM_INVALID;
+		ep->dma.frame_incr = 1 << (desc->bInterval - 1);
+	}
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	if (ep_cfg(ep, xfertype, max_pkt_size) != 0) {
+		spin_unlock_irqrestore(&udc->lock, flags);
+		dev_err(udc->dev, "%s: not enough FIFO space\n", ep->name);
+		return -ENOSPC;
+	}
+
+	set_epcfg_reg(udc->regs, ep->num, get_cfg_num(udc->regs));
+
+	ep->desc = desc;
+	ep->stopped = 0;
+	ep->usb_ep.maxpacket = max_pkt_size;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	dev_dbg(udc->dev, "%s: enabled: type: 0x%x, max_pkt_size: %d\n",
+		ep->name, xfertype, max_pkt_size);
+
+	return 0;
+}
+
+static int snps_ep_disable(struct usb_ep *usb_ep)
+{
+	struct snps_udc_ep *ep;
+	struct snps_udc *udc;
+	unsigned long flags;
+
+	ep = container_of(usb_ep, struct snps_udc_ep, usb_ep);
+	udc = ep->udc;
+
+	if (!usb_ep || !ep->desc) {
+		dev_err(udc->dev, "%s: invalid endpoint\n", ep->usb_ep.name);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	epreq_queue_flush(ep, -ESHUTDOWN);
+	ep->desc = NULL;
+	ep->usb_ep.maxpacket = ep->max_pkt_size;
+	fifo_ram_free(ep);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static struct usb_request *
+snps_ep_alloc_request(struct usb_ep *usb_ep, gfp_t gfp_flags)
+{
+	struct ep_xfer_req *ep_req;
+
+	if (!usb_ep)
+		return NULL;
+
+	ep_req = kzalloc(sizeof(*ep_req), gfp_flags);
+	if (ep_req) {
+		INIT_LIST_HEAD(&ep_req->queue);
+		ep_req->usb_req.dma = DMA_ADDR_INVALID;
+		pr_debug("%s: ep alloc req\n", usb_ep->name);
+		return &ep_req->usb_req;
+	}
+
+	return NULL;
+}
+
+static void snps_ep_free_request(struct usb_ep *usb_ep,
+				 struct usb_request *usb_req)
+{
+	struct ep_xfer_req *ep_req;
+
+	ep_req = container_of(usb_req, struct ep_xfer_req, usb_req);
+
+	if (usb_req) {
+		pr_debug("%s: freed\n", usb_ep->name);
+		kfree(ep_req);
+	}
+}
+
+static int snps_ep_queue(struct usb_ep *usb_ep,
+			 struct usb_request *usb_req, gfp_t gfp_flags)
+{
+	struct ep_xfer_req *ep_req;
+	struct snps_udc_ep *ep;
+	struct snps_udc *udc;
+	unsigned long flags;
+
+	ep = container_of(usb_ep, struct snps_udc_ep, usb_ep);
+	ep_req = container_of(usb_req, struct ep_xfer_req, usb_req);
+
+	dev_dbg(ep->udc->dev, "%s: %s\n", __func__, ep->usb_ep.name);
+	if (!usb_ep || !usb_req || !ep_req->usb_req.complete ||
+	    !ep_req->usb_req.buf || !list_empty(&ep_req->queue)) {
+		dev_dbg(ep->udc->dev, "%s:invalid queue request\n", ep->name);
+		return -EINVAL;
+	}
+
+	if (!ep->desc && (ep->num != 0)) {
+		dev_err(ep->udc->dev, "%s: invalid EP state\n", ep->name);
+		return -EFAULT;
+	}
+
+	if ((ep->type == USB_ENDPOINT_XFER_CONTROL) &&
+	    !list_empty(&ep->queue)) {
+		dev_err(ep->udc->dev, "%s: EP queue not empty\n", ep->name);
+		return -EPERM;
+	}
+
+	if (usb_req->length > 0xffff) {
+		dev_err(ep->udc->dev, "%s: request too big\n", ep->name);
+		return -E2BIG;
+	}
+
+	if ((ep->type == USB_ENDPOINT_XFER_ISOC) &&
+	    (ep->dirn == USB_DIR_IN) &&
+	    (usb_req->length > ep->usb_ep.maxpacket)) {
+		dev_err(ep->udc->dev, "%s: request > scheduled bandwidth, length=%u\n",
+			ep->name, usb_req->length);
+		return -EFBIG;
+	}
+
+	udc = ep->udc;
+	if (!udc->gadget_driver) {
+		dev_err(udc->dev, "%s: invalid device state\n", ep->name);
+		return -ESHUTDOWN;
+	}
+
+	if (((unsigned long)ep_req->usb_req.buf) & 0x3UL) {
+		dev_dbg(udc->dev, "%s: invalid buffer alignment: addr=0x%p\n",
+			ep->usb_ep.name, ep_req->usb_req.buf);
+
+		if ((ep->dma.aligned_buf) &&
+		    (ep->dma.aligned_len < ep_req->usb_req.length)) {
+			dma_free_coherent(NULL, ep->dma.aligned_len,
+					  ep->dma.aligned_buf,
+					  ep->dma.aligned_addr);
+			ep->dma.aligned_buf = NULL;
+		}
+
+		if (!ep->dma.aligned_buf) {
+			ep->dma.aligned_len = ep_req->usb_req.length;
+			ep->dma.aligned_buf = dma_alloc_coherent(NULL,
+				ep->dma.aligned_len, &ep->dma.aligned_addr,
+				GFP_ATOMIC);
+		}
+
+		if (!ep->dma.aligned_buf) {
+			dev_err(udc->dev, "%s: ep dma alloc failed\n",
+				ep->name);
+			return -ENOMEM;
+		}
+
+		ep_req->dma_aligned = 1;
+	} else if ((ep_req->usb_req.dma == DMA_ADDR_INVALID) ||
+		   (ep_req->usb_req.dma == 0)) {
+		ep_req->dma_mapped = 1;
+		ep_req->usb_req.dma = dma_map_single(
+					ep->udc->gadget.dev.parent,
+					ep_req->usb_req.buf,
+					(ep_req->usb_req.length ?
+					ep_req->usb_req.length : 1),
+		(ep->dirn == USB_DIR_IN ? DMA_TO_DEVICE : DMA_FROM_DEVICE));
+		if (dma_mapping_error(ep->udc->gadget.dev.parent,
+				      ep_req->usb_req.dma)) {
+			dev_err(ep->udc->gadget.dev.parent,
+				"failed to map buffer\n");
+			return -EFAULT;
+		}
+	}
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	ep_req->usb_req.status = -EINPROGRESS;
+	ep_req->usb_req.actual = 0;
+
+	if ((ep->type == USB_ENDPOINT_XFER_CONTROL) &&
+	    (ep->dirn == USB_DIR_OUT) &&
+	    (ep_req->usb_req.length == 0)) {
+		epreq_xfer_done(ep, ep_req, 0);
+	} else {
+		if (ep_req->usb_req.length == 0)
+			ep_req->usb_req.zero = 1;
+
+		epreq_xfer_add(ep, ep_req);
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static int snps_ep_dequeue(struct usb_ep *usb_ep,
+			   struct usb_request *usb_req)
+{
+	struct ep_xfer_req *ep_req;
+	struct snps_udc_ep *ep;
+	unsigned long flags;
+
+	ep = container_of(usb_ep, struct snps_udc_ep, usb_ep);
+	ep_req = container_of(usb_req, struct ep_xfer_req, usb_req);
+
+	if (!usb_ep || !usb_req) {
+		dev_err(ep->udc->dev, "%s: invalid dequeue request\n",
+			ep->name);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&ep->udc->lock, flags);
+
+	list_for_each_entry(ep_req, &ep->queue, queue) {
+		if (&ep_req->usb_req == usb_req)
+			break;
+	}
+
+	if (&ep_req->usb_req != usb_req) {
+		spin_unlock_irqrestore(&ep->udc->lock, flags);
+		dev_err(ep->udc->dev, "%s: request not queued\n", ep->name);
+		return -ENOLINK;
+	}
+
+	epreq_xfer_done(ep, ep_req, -ECONNRESET);
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+
+	dev_dbg(ep->udc->dev, "%s: req=0x%p\n", ep->name, usb_req);
+	return 0;
+}
+
+static int snps_ep_set_halt(struct usb_ep *usb_ep, int halt)
+{
+	struct snps_udc_ep *ep;
+	unsigned long flags;
+	struct snps_udc *udc;
+
+	ep = container_of(usb_ep, struct snps_udc_ep, usb_ep);
+	udc = ep->udc;
+	if (!usb_ep) {
+		dev_err(udc->dev, "%s: invalid halt request\n", ep->name);
+		return -EINVAL;
+	}
+
+	if (ep->type == USB_ENDPOINT_XFER_ISOC) {
+		dev_err(udc->dev, "%s: unsupported halt req\n", ep->name);
+		return -EOPNOTSUPP;
+	}
+
+	if (halt && (ep->dirn == USB_DIR_IN) &&
+	    !list_empty(&ep->queue)) {
+		dev_err(udc->dev, "%s: EP IN queue not empty\n", ep->name);
+		return -EAGAIN;
+	}
+
+	if (!halt && (ep->type == USB_ENDPOINT_XFER_CONTROL)) {
+		dev_err(udc->dev, "%s: CTRL HALT clear\n", ep->name);
+		return -EPROTO;
+	}
+
+	spin_lock_irqsave(&ep->udc->lock, flags);
+
+	if (!halt) {
+		disable_ep_stall(udc->regs, ep->num, ep->dirn);
+	} else if (ep->type != USB_ENDPOINT_XFER_CONTROL) {
+		enable_ep_stall(udc->regs, ep->num, ep->dirn);
+	} else {
+		enable_ep_stall(udc->regs, ep->num, USB_DIR_IN);
+		enable_ep_stall(udc->regs, ep->num, USB_DIR_OUT);
+	}
+
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+
+	dev_dbg(udc->dev, "%s: HALT %s done\n", ep->name,
+		halt ? "SET" : "CLR");
+
+	return 0;
+}
+
+static struct usb_ep_ops snps_ep_ops = {
+	.enable		= snps_ep_enable,
+	.disable	= snps_ep_disable,
+
+	.alloc_request	= snps_ep_alloc_request,
+	.free_request	= snps_ep_free_request,
+
+	.queue		= snps_ep_queue,
+	.dequeue	= snps_ep_dequeue,
+
+	.set_halt	= snps_ep_set_halt,
+};
+
+static int eps_init(struct snps_udc *udc)
+{
+	struct snps_udc_ep *ep;
+	int i, ret;
+
+	/* Initialize Endpoint 0 */
+	ep = &udc->ep[0];
+	ep->udc = udc;
+	ep->num = 0;
+	ep->in_xfer_done = true;
+	ep->dirn = USB_DIR_OUT;
+	ep->b_ep_addr = ep->num | ep->dirn;
+	strncpy(ep->name, "ep0", sizeof(ep->name));
+	ep->usb_ep.name = ep->name;
+	ep->max_pkt_size = EP_CTRL_MAX_PKT_SIZE;
+	usb_ep_set_maxpacket_limit(&ep->usb_ep, EP_CTRL_MAX_PKT_SIZE);
+	ep->usb_ep.ops = &snps_ep_ops;
+	ep->stopped = 0;
+	ep->usb_ep.caps.type_control = true;
+	ep->usb_ep.caps.dir_in = true;
+	ep->usb_ep.caps.dir_out = true;
+	INIT_LIST_HEAD(&ep->queue);
+	ep->type = USB_ENDPOINT_XFER_CONTROL;
+	ep->usb_ep.maxpacket = EP_CTRL_MAX_PKT_SIZE;
+
+	if (udc->conn_type)
+		ep_dma_init(ep);
+
+	dev_dbg(udc->dev, "%s: type: 0x%x, Dir:0x%x, Max Size: %d\n",
+		ep->name, ep->type, ep->dirn, ep->max_pkt_size);
+
+	/* Initialize remaining endpoints */
+	for (i = 1; i < UDC_MAX_EP; i++) {
+		ep = &udc->ep[i];
+		ep->udc = udc;
+		ep->max_pkt_size = EP_MAX_PKT_SIZE;
+		usb_ep_set_maxpacket_limit(&ep->usb_ep, EP_MAX_PKT_SIZE);
+		ep->usb_ep.ops = &snps_ep_ops;
+		ep->in_xfer_done = true;
+		ep->num = i;
+		if (i % 2) {
+			snprintf(ep->name, sizeof(ep->name), "ep%din", i);
+			ep->dirn = EP_DIRN_IN;
+			ep->usb_ep.caps.dir_in = true;
+		} else {
+			snprintf(ep->name, sizeof(ep->name), "ep%dout", i);
+			ep->dirn = EP_DIRN_OUT;
+			ep->usb_ep.caps.dir_out = true;
+		}
+		ep->usb_ep.name = ep->name;
+		ep->b_ep_addr = ep->num | ep->dirn;
+
+		ep->usb_ep.caps.type_iso = true;
+		ep->usb_ep.caps.type_bulk = true;
+		ep->usb_ep.caps.type_int = true;
+		ep->stopped = 0;
+		ep->usb_ep.maxpacket = EP_MAX_PKT_SIZE;
+
+		INIT_LIST_HEAD(&ep->queue);
+		if (udc->conn_type)
+			ep_dma_init(ep);
+
+		dev_dbg(udc->dev, "%s: type: 0x%x, Dir: 0x%x, Max Size: %d\n",
+			ep->name, ep->type, ep->dirn, ep->max_pkt_size);
+	}
+
+	udc->rx_fifo_space = OUT_RX_FIFO_MEM_SIZE;
+	udc->tx_fifo_space = IN_TX_FIFO_MEM_SIZE;
+	ret = ep_cfg(&udc->ep[0], USB_ENDPOINT_XFER_CONTROL,
+		     EP_CTRL_MAX_PKT_SIZE);
+	if (ret) {
+		dev_err(udc->dev, "Synopsys-UDC: error configuring endpoints\n");
+		return ret;
+	}
+
+	dev_dbg(udc->dev, "Synopsys UDC Endpoints initialized\n");
+	return 0;
+}
+
+static void start_udc(struct snps_udc *udc)
+{
+	int i;
+
+	init_udc_reg(udc->regs);
+
+	udc->rx_fifo_space = OUT_RX_FIFO_MEM_SIZE;
+	udc->tx_fifo_space = IN_TX_FIFO_MEM_SIZE;
+
+	eps_init(udc);
+	enable_self_pwr(udc->regs);
+
+	enable_udc_dev_irq(udc->regs, IRQ_SPEED_ENUM_DONE | IRQ_BUS_SUSPEND |
+			   IRQ_BUS_IDLE | IRQ_BUS_RESET | IRQ_SET_INTF |
+			   IRQ_SET_CFG);
+
+	for (i = 0; i < UDC_MAX_EP; ++i) {
+		if (udc->ep[i].usb_ep.name) {
+			enable_udc_ep_irq(udc->regs,
+					  udc->ep[i].num, USB_DIR_OUT);
+			enable_udc_ep_irq(udc->regs,
+					  udc->ep[i].num, USB_DIR_IN);
+		}
+	}
+
+	clear_devnak(udc->regs);
+	enable_ctrl_dma(udc->regs);
+	bus_connect(udc->regs);
+
+	dev_dbg(udc->dev, "Synopsys UDC started\n");
+}
+
+static void stop_udc(struct snps_udc *udc)
+{
+	struct snps_udc_ep *ep;
+	finish_udc(udc->regs);
+
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
+	epreq_queue_flush(&udc->ep[0], -ESHUTDOWN);
+	udc->ep[0].desc = NULL;
+
+	list_for_each_entry(ep, &udc->gadget.ep_list, usb_ep.ep_list) {
+		epreq_queue_flush(ep, -ESHUTDOWN);
+	}
+
+	bus_disconnect(udc->regs);
+
+	if (udc->gadget_driver && udc->gadget_driver->disconnect) {
+		spin_unlock(&udc->lock);
+		udc->gadget_driver->disconnect(&udc->gadget);
+		spin_lock(&udc->lock);
+	}
+
+	dev_dbg(udc->dev, "Synopsys UDC stopped\n");
+}
+
+static int snps_gadget_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct snps_udc *udc;
+	unsigned long flags;
+
+	udc = container_of(gadget, struct snps_udc, gadget);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	if (!udc->gadget_driver) {
+		bus_disconnect(udc->regs);
+		spin_unlock_irqrestore(&udc->lock, flags);
+		return 0;
+	}
+
+	if (is_on && udc->pullup_on) {
+		start_udc(udc);
+		udc->ep[0].stopped = 0;
+		dev_info(udc->dev, "Synopsys UDC device connected\n");
+	} else if (!is_on && !udc->pullup_on) {
+		stop_udc(udc);
+		udc->ep[0].stopped = 1;
+		dev_info(udc->dev, "Synopsys UDC device Disconnected\n");
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static int snps_gadget_start(struct usb_gadget *gadget,
+			     struct usb_gadget_driver *driver)
+{
+	struct snps_udc *udc;
+	unsigned long flags;
+
+	udc = container_of(gadget, struct snps_udc, gadget);
+
+	if (udc->gadget_driver)
+		return -EBUSY;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	driver->driver.bus = NULL;
+	udc->gadget_driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+	udc->ep[0].stopped = 0;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	/* when cable is connected at boot time */
+	if (udc->conn_type)
+		schedule_delayed_work(&udc->drd_work, USBD_WQ_DELAY_MS);
+	dev_dbg(udc->dev, "%s: Done\n", __func__);
+
+	return 0;
+}
+
+static int snps_gadget_stop(struct usb_gadget *gadget)
+{
+	struct snps_udc_ep *ep;
+	struct snps_udc *udc;
+	unsigned long flags;
+
+	udc = container_of(gadget, struct snps_udc, gadget);
+
+	spin_lock_irqsave(&udc->lock, flags);
+	stop_udc(udc);
+	udc->gadget.dev.driver = NULL;
+	udc->gadget_driver = NULL;
+
+	list_for_each_entry(ep, &udc->gadget.ep_list, usb_ep.ep_list) {
+		epreq_queue_flush(ep, -ESHUTDOWN);
+		if (ep->desc)
+			ep->desc = NULL;
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	dev_dbg(udc->dev, "%s: Done\n", __func__);
+
+	return 0;
+}
+
+static struct usb_gadget_ops snps_gadget_ops = {
+	.pullup		= snps_gadget_pullup,
+	.udc_start	= snps_gadget_start,
+	.udc_stop	= snps_gadget_stop,
+};
+
+void snps_udc_drd_work(struct work_struct *work)
+{
+	struct snps_udc *udc;
+
+	udc = container_of(to_delayed_work(work),
+			   struct snps_udc, drd_work);
+
+	if (udc->conn_type) {
+		dev_dbg(udc->dev, "idle -> device\n");
+		if (udc->gadget_driver) {
+			udc->pullup_on = 1;
+			snps_gadget_pullup(&udc->gadget, 1);
+		}
+	} else {
+		dev_dbg(udc->dev, "device -> idle\n");
+		udc->pullup_on = 0;
+		snps_gadget_pullup(&udc->gadget, 0);
+	}
+}
+
+static int usbd_connect_notify(struct notifier_block *self,
+			       unsigned long event, void *ptr)
+{
+	struct snps_udc *udc = container_of(self, struct snps_udc, nb);
+
+	dev_dbg(udc->dev, "%s: event: %lu\n", __func__, event);
+
+	udc->conn_type = event;
+
+	schedule_delayed_work(&udc->drd_work, USBD_WQ_DELAY_MS);
+
+	return NOTIFY_OK;
+}
+
+static void free_udc_dma(struct platform_device *pdev, struct snps_udc *udc)
+{
+	u32 num;
+
+	dma_free_coherent(&pdev->dev, sizeof(struct ep_desc_array),
+			  udc->dma.virt, (dma_addr_t)udc->dma.phys);
+
+	for (num = 0; num < UDC_MAX_EP; num++) {
+		if (udc->ep[num].dma.aligned_buf) {
+			dma_free_coherent(NULL, udc->ep[num].dma.aligned_len,
+					  udc->ep[num].dma.aligned_buf,
+					  udc->ep[num].dma.aligned_addr);
+			udc->ep[num].dma.aligned_buf = NULL;
+		}
+	}
+}
+
+static int snps_udc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct snps_udc *udc;
+	int i, ret;
+
+	udc = devm_kzalloc(dev, sizeof(*udc), GFP_KERNEL);
+	if (!udc)
+		return -ENOMEM;
+
+	spin_lock_init(&udc->lock);
+	udc->dev = dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	udc->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(udc->regs))
+		return PTR_ERR(udc->regs);
+
+	udc->irq = irq_of_parse_and_map(dev->of_node, 0);
+	if (udc->irq <= 0) {
+		dev_err(dev, "Can't parse and map interrupt\n");
+		return -EINVAL;
+	}
+
+	udc->udc_phy = devm_phy_get(dev, "usb2drd");
+	if (IS_ERR(udc->udc_phy)) {
+		dev_err(dev, "Failed to obtain phy from device tree\n");
+		return PTR_ERR(udc->udc_phy);
+	}
+
+	ret = phy_init(udc->udc_phy);
+	if (ret) {
+		dev_err(dev, "UDC phy init failed");
+		return ret;
+	}
+
+	ret = phy_power_on(udc->udc_phy);
+	if (ret) {
+		dev_err(dev, "UDC phy power on failed");
+		phy_exit(udc->udc_phy);
+		return ret;
+	}
+
+	udc->edev = extcon_get_edev_by_phandle(dev, 0);
+	if (IS_ERR(udc->edev)) {
+		if (PTR_ERR(udc->edev) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		dev_err(dev, "Invalid or missing extcon\n");
+		ret = PTR_ERR(udc->edev);
+		goto exit_phy;
+	}
+
+	udc->nb.notifier_call = usbd_connect_notify;
+	ret = extcon_register_notifier(udc->edev, EXTCON_USB, &udc->nb);
+	if (ret < 0) {
+		dev_err(dev, "Can't register extcon device\n");
+		goto exit_phy;
+	}
+
+	ret = extcon_get_state(udc->edev, EXTCON_USB);
+	if (ret < 0) {
+		dev_err(dev, "Can't get cable state\n");
+		goto exit_extcon;
+	} else if (ret) {
+		bus_disconnect(udc->regs);
+		udc->conn_type = ret;
+	}
+
+	udc->dma.virt = dma_alloc_coherent(&pdev->dev,
+				sizeof(struct ep_desc_array),
+				(dma_addr_t *)&udc->dma.phys,
+				 GFP_KERNEL);
+	if (!udc->dma.virt) {
+		dev_err(dev, "Failed to allocate memory for ep\n");
+		ret = -ENOMEM;
+		goto exit_extcon;
+	}
+
+	INIT_DELAYED_WORK(&udc->drd_work, snps_udc_drd_work);
+
+	ret = devm_request_irq(dev, udc->irq, snps_udc_irq, IRQF_SHARED,
+			       "snps-udc", udc);
+	if (ret < 0) {
+		dev_err(dev, "Request irq %d failed for UDC\n", udc->irq);
+		goto exit_dma;
+	}
+
+	/* Gagdet structure init */
+	udc->gadget.name	= "snps-udc";
+	udc->gadget.speed	= USB_SPEED_UNKNOWN;
+	udc->gadget.max_speed	= USB_SPEED_HIGH;
+	udc->gadget.ops		= &snps_gadget_ops;
+	udc->gadget.ep0		= &udc->ep[0].usb_ep;
+	INIT_LIST_HEAD(&udc->gadget.ep_list);
+
+	eps_init(udc);
+	for (i = 1; i < UDC_MAX_EP; i++) {
+		list_add_tail(&udc->ep[i].usb_ep.ep_list,
+			      &udc->gadget.ep_list);
+	}
+
+	ret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);
+	if (ret) {
+		dev_err(dev, "Error adding gadget udc: %d\n", ret);
+		goto exit_dma;
+	}
+
+	platform_set_drvdata(pdev, udc);
+	dev_info(dev, "Synopsys UDC driver probe successful\n");
+
+	return 0;
+exit_dma:
+	free_udc_dma(pdev, udc);
+exit_extcon:
+	extcon_unregister_notifier(udc->edev, EXTCON_USB, &udc->nb);
+exit_phy:
+	phy_power_off(udc->udc_phy);
+	phy_exit(udc->udc_phy);
+
+	return ret;
+}
+
+static int snps_udc_remove(struct platform_device *pdev)
+{
+	struct snps_udc *udc;
+
+	udc = platform_get_drvdata(pdev);
+
+	usb_del_gadget_udc(&udc->gadget);
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (udc->drd_wq) {
+		flush_workqueue(udc->drd_wq);
+		destroy_workqueue(udc->drd_wq);
+	}
+
+	free_udc_dma(pdev, udc);
+	phy_power_off(udc->udc_phy);
+	phy_exit(udc->udc_phy);
+	extcon_unregister_notifier(udc->edev, EXTCON_USB, &udc->nb);
+	dev_info(&pdev->dev, "Synopsys UDC driver removed\n");
+
+	return 0;
+}
+
+static void snps_udc_shutdown(struct platform_device *pdev)
+{
+	struct snps_udc *udc = platform_get_drvdata(pdev);
+
+	snps_gadget_stop(&udc->gadget);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int snps_udc_suspend(struct device *dev)
+{
+	struct snps_udc *udc;
+
+	udc = dev_get_drvdata(dev);
+
+	if (extcon_get_state(udc->edev, EXTCON_USB) > 0) {
+		dev_dbg(udc->dev, "device -> idle\n");
+		udc->pullup_on = 0;
+		snps_gadget_pullup(&udc->gadget, 0);
+	}
+	phy_power_off(udc->udc_phy);
+	phy_exit(udc->udc_phy);
+
+	return 0;
+}
+
+static int snps_udc_resume(struct device *dev)
+{
+	struct snps_udc *udc;
+	int ret;
+
+	udc = dev_get_drvdata(dev);
+
+	ret = phy_init(udc->udc_phy);
+	if (ret) {
+		dev_err(udc->dev, "UDC phy init failure");
+		return ret;
+	}
+
+	ret = phy_power_on(udc->udc_phy);
+	if (ret) {
+		dev_err(udc->dev, "UDC phy power on failure");
+		phy_exit(udc->udc_phy);
+		return ret;
+	}
+
+	if (extcon_get_state(udc->edev, EXTCON_USB) > 0) {
+		dev_dbg(udc->dev, "idle -> device\n");
+		udc->pullup_on = 1;
+		snps_gadget_pullup(&udc->gadget, 1);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops snps_udc_pm_ops = {
+	.suspend	= snps_udc_suspend,
+	.resume		= snps_udc_resume,
+};
+#endif
+
+static const struct of_device_id of_udc_match[] = {
+	{ .compatible = "snps,dw-ahb-udc", },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, of_udc_match);
+
+static struct platform_driver snps_udc_driver = {
+	.probe		= snps_udc_probe,
+	.remove		= snps_udc_remove,
+	.shutdown	= snps_udc_shutdown,
+	.driver		= {
+		.name	= "snps-udc",
+		.of_match_table = of_match_ptr(of_udc_match),
+#ifdef CONFIG_PM_SLEEP
+		.pm	= &snps_udc_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(snps_udc_driver);
+
+MODULE_ALIAS("platform:snps-udc");
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/usb/gadget/udc/snps_udc.h
@@ -0,0 +1,1071 @@
+/*
+ * Copyright (C) 2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SNPS_UDC_H
+#define __SNPS_UDC_H
+
+/* UDC speeds */
+#define SPEED_UNKNOWN			(0)
+#define SPEED_LOW			(1)
+#define SPEED_FULL			(2)
+#define SPEED_HIGH			(3)
+
+/* Endpoint directions */
+#define EP_DIRN_IN			(0x80)
+#define EP_DIRN_OUT			(0x00)
+#define EP_DIRN_MASK			(0x80)
+
+/* Endpoint types */
+#define EP_TYPE_CTRL			(0)
+#define EP_TYPE_ISOC			(1)
+#define EP_TYPE_BULK			(2)
+#define EP_TYPE_INTR			(3)
+#define EP_TYPE_MASK			(0x03)
+
+/* Max supported endpoints */
+#define UDC_MAX_EP			(10)
+
+#define EP_MAX_PKT_SIZE			512
+#define EP_CTRL_MAX_PKT_SIZE		64
+#define OUT_RX_FIFO_MEM_SIZE		4096
+#define IN_TX_FIFO_MEM_SIZE		4096
+
+#define is_ep_in()			((ep->dirn) == USB_DIR_IN)
+#define is_ep_out()			((ep->dirn) == USB_DIR_OUT)
+#define is_ep_bulk()			((ep->type) == USB_ENDPOINT_XFER_BULK)
+
+#define DESC_CNT (1)
+
+#define EP_DMA_DESC_IDX_MASK		(DESC_CNT - 1)
+#define EP_DMA_DESC_IDX(num)		((num) & EP_DMA_DESC_IDX_MASK)
+
+#define USB_MODE_IDLE			(1)
+#define USB_MODE_DEVICE			(2)
+
+#define FIFO_SZ_U32(pkt_sz)		(((pkt_sz) + 3) / sizeof(u32))
+#define FIFO_SZ_U8(sz)			(FIFO_SZ_U32(sz) * sizeof(u32))
+#define USBD_WQ_DELAY_MS		msecs_to_jiffies(100)
+/* Register Masks and definitions */
+
+/* Endpoint Control Registers*/
+#define EP_CTRL_OUT_FLUSH_ENABLE	BIT(12)
+#define EP_CTRL_OUT_CLOSE_DESC		BIT(11)
+#define EP_CTRL_IN_SEND_NULL		BIT(10)
+#define EP_CTRL_OUT_DMA_ENABLE		BIT(9)
+#define EP_CTRL_NAK_CLEAR		BIT(8)
+#define EP_CTRL_NAK_SET			BIT(7)
+#define EP_CTRL_NAK_IN_PROGRESS		BIT(6)
+#define EP_CTRL_TYPE_SHIFT		(4)
+#define EP_CTRL_TYPE_MASK		(3 << EP_CTRL_TYPE_SHIFT)
+#define EP_CTRL_IN_DMA_ENABLE		BIT(3)
+#define EP_CTRL_SNOOP_ENABLE		BIT(2)
+#define EP_CTRL_IN_FLUSH_ENABLE		BIT(1)
+#define EP_CTRL_STALL_ENABLE		BIT(0)
+
+/* Endpoint Status Registers */
+#define EP_STS_CLOSE_DESC_CLEAR		BIT(28)
+#define EP_STS_IN_XFER_DONE		BIT(27)
+#define EP_STS_STALL_SET_RX		BIT(26)
+#define EP_STS_STALL_CLEAR_RX		BIT(25)
+#define EP_STS_IN_FIFO_EMPTY		BIT(24)
+#define EP_STS_IN_DMA_DONE		BIT(10)
+#define EP_STS_AHB_BUS_ERROR		BIT(9)
+#define EP_STS_OUT_FIFO_EMPTY		BIT(8)
+#define EP_STS_DMA_BUF_NOT_AVAIL	BIT(7)
+#define EP_STS_IN_TOKEN_RX		BIT(6)
+#define EP_STS_OUT_DMA_SETUP_DONE	BIT(5)
+#define EP_STS_OUT_DMA_DATA_DONE	BIT(4)
+
+/* Buffer Regs for EP In, Receive Packet Frame Num Regs for EP Out */
+#define EP_REG2_OUT_ISOC_PID_SHIFT	(16)
+#define EP_REG2_OUT_ISOC_PID_MASK	(3 << EP_REG2_OUT_ISOC_PID_SHIFT)
+#define EP_REG2_IN_DEPTH_SHIFT		(0)
+#define EP_REG2_IN_DEPTH_MASK		(0xffff << EP_REG2_IN_DEPTH_SHIFT)
+#define EP_REG2_OUT_FRAME_NUM_SHIFT	EP_REG2_IN_DEPTH_SHIFT
+#define EP_REG2_OUT_FRAME_NUM_MASK	EP_REG2_IN_DEPTH_MASK
+
+/* Max Packet Size Regs for EP In, Buffer Size Regs for EP Out */
+#define EP_REG3_OUT_DEPTH_SHIFT		(16)
+#define EP_REG3_OUT_DEPTH_MASK		(0xffff << EP_REG3_OUT_DEPTH_SHIFT)
+#define EP_REG3_PKT_MAX_SHIFT		(0)
+#define EP_REG3_PKT_MAX_MASK		(0xffff << EP_REG3_PKT_MAX_SHIFT)
+
+/* Endpoint Config Registers */
+#define EP_CFG_DIRN_IN			BIT(4)
+#define EP_CFG_DIRN_OUT			(0)
+#define EP_CFG_PKT_MAX_SHIFT		(19)
+#define EP_CFG_PKT_MAX_MASK		(0x7ff << EP_CFG_PKT_MAX_SHIFT)
+#define EP_CFG_ALT_NUM_SHIFT		(15)
+#define EP_CFG_ALT_NUM_MASK		(0xf << EP_CFG_ALT_NUM_SHIFT)
+#define EP_CFG_INTF_NUM_SHIFT		(11)
+#define EP_CFG_INTF_NUM_MASK		(0xf << EP_CFG_INTF_NUM_SHIFT)
+#define EP_CFG_CFG_NUM_SHIFT		(7)
+#define EP_CFG_CFG_NUM_MASK		(0xf << EP_CFG_CFG_NUM_SHIFT)
+#define EP_CFG_TYPE_SHIFT		(5)
+#define EP_CFG_TYPE_MASK		(0x3 << EP_CFG_TYPE_SHIFT)
+#define EP_CFG_FIFO_NUM_SHIFT		(0)
+#define EP_CFG_FIFO_NUM_MASK		(0xf << EP_CFG_FIFO_NUM_SHIFT)
+
+/* Endpoint Interrupt Registers */
+#define EP_INTR_OUT_SHIFT		(16)
+#define EP_INTR_OUT_MASK		(0xffff << EP_INTR_OUT_SHIFT)
+#define EP_INTR_IN_SHIFT		(0)
+#define EP_INTR_IN_MASK			(0xffff << EP_INTR_IN_SHIFT)
+
+/* Device Config Register */
+#define CFG_ULPI_DDR_ENABLE		BIT(19)
+#define CFG_SET_DESCRIPTOR_ENABLE	BIT(18)
+#define CFG_CSR_PROGRAM_ENABLE		BIT(17)
+#define CFG_HALT_STALL_ENABLE		BIT(16)
+#define CFG_HS_TIMEOUT_CALIB_SHIFT	(13)
+#define CFG_HS_TIMEOUT_CALIB_MASK	(7 << CFG_HS_TIMEOUT_CALIB_SHIFT)
+#define CFG_FS_TIMEOUT_CALIB_SHIFT	(10)
+#define CFG_FS_TIMEOUT_CALIB_MASK	(7 << CFG_FS_TIMEOUT_CALIB_SHIFT)
+#define CFG_STS_1_ENABLE		BIT(8)
+#define CFG_STS_ENABLE			BIT(7)
+#define CFG_UTMI_BI_DIRN_ENABLE		BIT(6)
+#define CFG_UTMI_8BIT_ENABLE		BIT(5)
+#define CFG_SYNC_FRAME_ENABLE		BIT(4)
+#define CFG_SELF_PWR_ENABLE		BIT(3)
+#define CFG_REMOTE_WAKEUP_ENABLE	BIT(2)
+#define CFG_SPD_SHIFT			(0)
+#define CFG_SPD_MASK			(3 << CFG_SPD_SHIFT)
+#define CFG_SPD_HS			(0 << CFG_SPD_SHIFT)
+#define CFG_SPD_FS			BIT(0)
+#define CFG_SPD_LS			(2 << CFG_SPD_SHIFT)
+#define CFG_SPD_FS_48MHZ		(3 << CFG_SPD_SHIFT)
+
+/* Device Control Register*/
+#define CTRL_DMA_OUT_THRESH_LEN_SHIFT	(24)
+#define CTRL_DMA_OUT_THRESH_LEN_MASK	(0xff << CTRL_DMA_OUT_THRESH_LEN_SHIFT)
+#define CTRL_DMA_BURST_LEN_SHIFT	(16)
+#define CTRL_DMA_BURST_LEN_MASK		(0xff << CTRL_DMA_BURST_LEN_SHIFT)
+#define CTRL_OUT_FIFO_FLUSH_ENABLE	BIT(14)
+#define CTRL_CSR_DONE			BIT(13)
+#define CTRL_OUT_ALL_NAK		BIT(12)
+#define CTRL_DISCONNECT_ENABLE		BIT(10)
+#define CTRL_DMA_MODE_ENABLE		BIT(9)
+#define CTRL_DMA_BURST_ENABLE		BIT(8)
+#define CTRL_DMA_OUT_THRESH_ENABLE	BIT(7)
+#define CTRL_DMA_BUFF_FILL_MODE_ENABLE	BIT(6)
+#define CTRL_ENDIAN_BIG_ENABLE		BIT(5)
+#define CTRL_DMA_DESC_UPDATE_ENABLE	BIT(4)
+#define CTRL_DMA_IN_ENABLE		BIT(3)
+#define CTRL_DMA_OUT_ENABLE		BIT(2)
+#define CTRL_RESUME_SIGNAL_ENABLE	BIT(0)
+#define CTRL_LE_ENABLE			(0)
+
+/* Device Status Register */
+#define STS_SOF_FRAME_NUM_SHIFT		(18)
+#define STS_SOF_FRAME_NUM_MASK		(0x3ffff << STS_SOF_FRAME_NUM_SHIFT)
+#define STS_REMOTE_WAKEUP_ALLOWED	BIT(17)
+#define STS_PHY_ERROR			BIT(16)
+#define STS_OUT_FIFO_EMPTY		BIT(15)
+#define STS_SPD_SHIFT			(13)
+#define STS_SPD_MASK			(3 << STS_SPD_SHIFT)
+#define STS_SPD_HS			(0 << STS_SPD_SHIFT)
+#define STS_SPD_FS			BIT(13)
+#define STS_SPD_LS			(2 << STS_SPD_SHIFT)
+#define STS_SPD_FS_48MHZ		(3 << STS_SPD_SHIFT)
+#define STS_BUS_SUSPENDED		BIT(12)
+#define STS_ALT_NUM_SHIFT		(8)
+#define STS_ALT_NUM_MASK		(0xf << STS_SPD_SHIFT)
+#define STS_INTF_NUM_SHIFT		(4)
+#define STS_INTF_NUM_MASK		(0xf << STS_INTF_NUM_SHIFT)
+#define STS_CFG_NUM_SHIFT		(0)
+#define STS_CFG_NUM_MASK		(0xf << STS_CFG_NUM_SHIFT)
+
+/* Device Interrupt Register */
+#define INTR_REMOTE_WAKEUP_DELTA	BIT(7)
+#define INTR_SPD_ENUM_DONE		BIT(6)
+#define INTR_SOF_RX			BIT(5)
+#define INTR_BUS_SUSPEND		BIT(4)
+#define INTR_BUS_RESET			BIT(3)
+#define INTR_BUS_IDLE			BIT(2)
+#define INTR_SET_INTF_RX		BIT(1)
+#define INTR_SET_CFG_RX			BIT(0)
+
+#define DMA_STS_BUF_SHIFT		(30)
+#define DMA_STS_BUF_HOST_READY		(0 << DMA_STS_BUF_SHIFT)
+#define DMA_STS_BUF_DMA_BUSY		BIT(30)
+#define DMA_STS_BUF_DMA_DONE		(2 << DMA_STS_BUF_SHIFT)
+#define DMA_STS_BUF_HOST_BUSY		(3 << DMA_STS_BUF_SHIFT)
+#define DMA_STS_BUF_MASK		(3 << DMA_STS_BUF_SHIFT)
+#define DMA_STS_RX_SHIFT		(28)
+#define DMA_STS_RX_SUCCESS		(0 << DMA_STS_RX_SHIFT)
+#define DMA_STS_RX_ERR_DESC		BIT(28)
+#define DMA_STS_RX_ERR_BUF		(3 << DMA_STS_RX_SHIFT)
+#define DMA_STS_RX_MASK			(3 << DMA_STS_RX_SHIFT)
+#define DMA_STS_CFG_NUM_SHIFT		(24)
+#define DMA_STS_CFG_NUM_MASK		(0xf << DMA_STS_CFG_NUM_SHIFT)
+#define DMA_STS_INTF_NUM_SHIFT		(20)
+#define DMA_STS_INTF_NUM_MASK		(0xf << DMA_STS_INTF_NUM_SHIFT)
+#define DMA_STS_LAST_DESC		BIT(27)
+#define DMA_STS_FRAME_NUM_SHIFT		(16)
+#define DMA_STS_FRAME_NUM_MASK		(0x7ff << DMA_STS_FRAME_NUM_SHIFT)
+#define DMA_STS_BYTE_CNT_SHIFT		(0)
+#define DMA_STS_ISO_PID_SHIFT		(14)
+#define DMA_STS_ISO_PID_MASK		(0x3 << DMA_STS_ISO_PID_SHIFT)
+#define DMA_STS_ISO_BYTE_CNT_SHIFT	(DMA_STS_BYTE_CNT_SHIFT)
+#define DMA_STS_ISO_BYTE_CNT_MASK	(0x3fff << DMA_STS_ISO_BYTE_CNT_SHIFT)
+#define DMA_STS_NISO_BYTE_CNT_SHIFT	(DMA_STS_BYTE_CNT_SHIFT)
+#define DMA_STS_NISO_BYTE_CNT_MASK	(0xffff << DMA_STS_NISO_BYTE_CNT_SHIFT)
+
+/* UDC Interrupts */
+#define UDC_IRQ_ALL			(IRQ_REMOTEWAKEUP_DELTA | \
+					IRQ_SPEED_ENUM_DONE | \
+					IRQ_BUS_SUSPEND | \
+					IRQ_BUS_RESET | \
+					IRQ_BUS_IDLE | \
+					IRQ_SET_INTF | \
+					IRQ_SET_CFG)
+#define IRQ_REMOTEWAKEUP_DELTA		INTR_REMOTE_WAKEUP_DELTA
+#define IRQ_SPEED_ENUM_DONE		INTR_SPD_ENUM_DONE
+#define IRQ_SOF_DETECTED		INTR_SOF_RX
+#define IRQ_BUS_SUSPEND			INTR_BUS_SUSPEND
+#define IRQ_BUS_RESET			INTR_BUS_RESET
+#define IRQ_BUS_IDLE			INTR_BUS_IDLE
+#define IRQ_SET_INTF			INTR_SET_INTF_RX
+#define IRQ_SET_CFG			INTR_SET_CFG_RX
+
+/* Endpoint status */
+#define EP_STS_ALL			(DMA_ERROR | \
+					DMA_BUF_NOT_AVAIL | \
+					IN_TOKEN_RX | \
+					IN_DMA_DONE | \
+					IN_XFER_DONE | \
+					OUT_DMA_DATA_DONE | \
+					OUT_DMA_SETUP_DONE)
+
+#define DMA_ERROR			EP_STS_AHB_BUS_ERROR
+#define DMA_BUF_NOT_AVAIL		EP_STS_DMA_BUF_NOT_AVAIL
+#define IN_TOKEN_RX			EP_STS_IN_TOKEN_RX
+#define IN_DMA_DONE			EP_STS_IN_DMA_DONE
+#define IN_FIFO_EMPTY			EP_STS_IN_FIFO_EMPTY
+#define IN_XFER_DONE			EP_STS_IN_XFER_DONE
+#define OUT_DMA_DATA_DONE		EP_STS_OUT_DMA_DATA_DONE
+#define OUT_DMA_SETUP_DONE		EP_STS_OUT_DMA_SETUP_DONE
+
+#define DMA_ADDR_INVALID	(~(dma_addr_t)0)
+#define DIRN_STR(dirn)		((dirn) == USB_DIR_IN ? "IN" : "OUT")
+#define EP_DIRN_TYPE(d, t)	(((d) << 8) | (t))
+
+/* Used for ISOC IN transfers for frame alignment. */
+#define FRAME_NUM_INVALID	(~(u32)0)
+
+/* UDC config parameters */
+
+/* If multiple RX FIFO controllers are implemented for
+ * OUT Endpoints, MRX_FIFO is enabled.
+ * Multi RX FIFO controllers are not implemented in RTL.
+ */
+#define MRX_FIFO 0
+#if MRX_FIFO
+static bool mrx_fifo = true;
+#else
+static bool mrx_fifo;
+#endif
+
+/* Buffer Fill mode is enabled for IN transfers,
+ * disabled for OUT transfers.
+ */
+#define IN_DMA_BUF_FILL_EN 1
+#if IN_DMA_BUF_FILL_EN
+static bool in_bf_mode = true;
+#else
+static bool in_bf_mode;
+#endif
+
+#define OUT_DMA_BUF_FILL_EN 0
+#if OUT_DMA_BUF_FILL_EN
+static bool out_bf_mode = true;
+#else
+static bool out_bf_mode;
+#endif
+/*
+ * If it desired that frames start being DMA'd w/o frame
+ * alignment, define ISOC_IN_XFER_DELAY_DISABLE.
+ * If frame alignment is used, this delay is not disabled.
+ */
+#define ISOC_IN_XFER_DELAY_DISABLE 0
+#if ISOC_IN_XFER_DELAY_DISABLE
+static bool in_isoc_delay_disabled = true;
+#else
+static bool in_isoc_delay_disabled;
+#endif
+
+/* Endpoint IN/OUT registers
+ * Register space is reserved for 16 endpoints, but the controller
+ * actually supports 10 endpoints only.
+ */
+#define EP_CNT	(16)
+struct snps_ep_regs {
+	u32 ctrl;	/* EP control */
+	u32 status;	/* EP status */
+	u32 epreg2;	/* Buffer for IN, Rec Pkt Frame num for OUT */
+	u32 epreg3;	/* Max pkt size for IN, Buf size for OUT */
+	u32 setupbuf;	/* Rsvd for IN, EP setup buffer ptr for OUT */
+	u32 datadesc;	/* EP data descriptor pointer */
+	u32 rsvd[2];
+};
+
+/* UDC registers */
+struct snps_udc_regs {
+	struct snps_ep_regs ep_in[EP_CNT];
+	struct snps_ep_regs ep_out[EP_CNT];
+	u32 devcfg;
+	u32 devctrl;
+	u32 devstatus;
+	u32 devintrstat;
+	u32 devintrmask;
+	u32 epintrstat;
+	u32 epintrmask;
+	u32 testmode;
+	u32 releasenum;
+	u32 rsvd[56];
+	u32 epcfg[EP_CNT];
+	u32 rsvd1[175];
+	u32 rx_fifo[256];
+	u32 tx_fifo[256];
+	u32 strap;
+};
+
+/* Endpoint SETUP buffer */
+struct setup_desc {
+	u32 status;
+	u32 reserved;
+	u32 data1;
+	u32 data2;
+};
+
+/* Endpoint In/Out data descriptor */
+struct data_desc {
+	u32 status;
+	u32 reserved;
+	u32 buf_addr;
+	u32 next_desc_addr;
+};
+
+/* Endpoint descriptor layout. */
+struct ep_dma_desc {
+	struct setup_desc setup;
+	struct data_desc  desc[DESC_CNT];
+};
+
+/* Endpoint descriptor array for Synopsys UDC */
+struct ep_desc_array {
+	struct ep_dma_desc ep[UDC_MAX_EP];
+};
+
+struct snps_udc;
+
+/* Endpoint data structure (for each endpoint) */
+struct snps_udc_ep {
+	struct usb_ep usb_ep;
+	const struct usb_endpoint_descriptor *desc;
+	struct list_head queue;
+	struct snps_udc *udc;
+	char name[14];
+	bool in_xfer_done;
+	u32 num;
+	u32 dirn;
+	u32 type;			/* USB_ENDPOINT_XFER_xxx */
+	u32 b_ep_addr;			/* dirn | type */
+	u32 max_pkt_size;
+	u32 rx_fifo_size;		/* Rx FIFO ram allocated */
+	u32 tx_fifo_size;		/* Tx FIFO ram allocated */
+	u32 stopped:1;
+	struct {
+		struct ep_dma_desc *virt;
+		struct ep_dma_desc *phys;
+		struct usb_request *usb_req;/* Current request being DMA'd */
+		u32 len_max;		/* to use with a descriptor */
+		u32 len_done;		/* Length of request DMA'd so far */
+		u32 len_rem;		/* Length of request left to DMA */
+		u32 add_idx;		/* descriptor chain index */
+		u32 remove_idx;		/* descriptor chain index */
+		u32 buf_addr;		/* Location in request to DMA */
+		u32 frame_num;		/* Frame number for ISOC transfers */
+		u32 frame_incr;		/* Frame number increment (period) */
+		u32 status;
+		u32 done;		/* DMA/USB xfer completion indication */
+		void *aligned_buf;	/* used if usb_req buf not aligned */
+		dma_addr_t aligned_addr;/* Aligned buffer physical address */
+		u32 aligned_len;	/* Aligned buffer length */
+		u32 last;
+	} dma;
+};
+
+/* Endpoint xfer request structure */
+struct ep_xfer_req {
+	struct usb_request	usb_req;
+	struct list_head	queue;
+	dma_addr_t		dma_addr_orig;
+	u32			dma_mapped:1;
+	u32			dma_aligned:1;
+};
+
+/* Controller data structure */
+struct snps_udc {
+	struct usb_gadget		gadget;
+	struct usb_gadget_driver	*gadget_driver;
+	struct device			*dev;
+	void __iomem			*regs;
+	int				irq;
+	struct completion		*dev_release;
+	spinlock_t			lock; /* UDC spin lock variable */
+	u32				rx_fifo_space;
+	u32				tx_fifo_space;
+	struct snps_udc_ep		ep[UDC_MAX_EP];
+	struct {
+		struct ep_desc_array	*virt;
+		struct ep_desc_array	*phys;
+	} dma;
+	struct gpio_desc		*vbus_gpiod;
+	u32				vbus_active:1;
+	u32				pullup_on:1;
+	struct phy			*udc_phy;
+	u32				mode;
+	struct extcon_dev		*edev;
+	struct extcon_specific_cable_nb	extcon_nb;
+	struct notifier_block		nb;
+	struct delayed_work		drd_work;
+	struct workqueue_struct		*drd_wq;
+	u32				conn_type;
+};
+
+#define REG_WR(reg, val)		writel(val, &reg)
+#define REG_MOD_AND(reg, val)		writel(val & readl(&reg), &reg)
+#define REG_MOD_OR(reg, val)		writel(val | readl(&reg), &reg)
+#define REG_MOD_MASK(reg, mask, val)	writel(val | (mask & readl(&reg)), &reg)
+#define REG_RD(reg)			readl(&reg)
+
+static inline void dump_regs(struct snps_udc_regs *regs)
+{
+	pr_debug("DEVCFG: 0x%x\n", REG_RD(regs->devcfg));
+	pr_debug("DEVCTRL: 0x%x\n", REG_RD(regs->devctrl));
+	pr_debug("DEVSTS: 0x%x\n", REG_RD(regs->devstatus));
+	pr_debug("DEVINTRMASK: 0x%x\n", REG_RD(regs->devintrmask));
+	pr_debug("DEVINTRSTS: 0x%x\n", REG_RD(regs->devintrstat));
+	pr_debug("EPINTRMASK: 0x%x\n", REG_RD(regs->epintrmask));
+	pr_debug("EPINTRSTS: 0x%x\n", REG_RD(regs->epintrstat));
+}
+
+static inline void bus_connect(struct snps_udc_regs *regs)
+{
+	REG_MOD_AND(regs->devctrl, ~CTRL_DISCONNECT_ENABLE);
+}
+
+static inline void bus_disconnect(struct snps_udc_regs *regs)
+{
+	REG_MOD_OR(regs->devctrl, CTRL_DISCONNECT_ENABLE);
+}
+
+static inline bool is_bus_suspend(struct snps_udc_regs *regs)
+{
+	return REG_RD(regs->devstatus) &
+		STS_BUS_SUSPENDED ? true : false;
+}
+
+static inline u32 get_alt_num(struct snps_udc_regs *regs)
+{
+	return (REG_RD(regs->devstatus) & STS_ALT_NUM_MASK)
+						>> STS_ALT_NUM_SHIFT;
+}
+
+static inline u32 get_cfg_num(struct snps_udc_regs *regs)
+{
+	return (REG_RD(regs->devstatus) & STS_CFG_NUM_MASK)
+						>> STS_CFG_NUM_SHIFT;
+}
+
+static inline u32 get_intf_num(struct snps_udc_regs *regs)
+{
+	return (REG_RD(regs->devstatus) & STS_INTF_NUM_MASK)
+						>> STS_INTF_NUM_SHIFT;
+}
+
+static inline void disable_ctrl_dma(struct snps_udc_regs *regs)
+{
+	REG_MOD_AND(regs->devctrl, ~(CTRL_DMA_IN_ENABLE |
+					     CTRL_DMA_OUT_ENABLE));
+}
+
+static inline void enable_ctrl_dma(struct snps_udc_regs *regs)
+{
+		REG_MOD_OR(regs->devctrl, (CTRL_DMA_IN_ENABLE |
+					   CTRL_DMA_OUT_ENABLE));
+}
+
+static inline bool is_ctrl_dma_enable(struct snps_udc_regs *regs)
+{
+	return REG_RD(regs->devctrl) &
+				CTRL_DMA_OUT_ENABLE ? true : false;
+}
+
+static inline void disable_epin_dma(struct snps_udc_regs *regs)
+{
+	REG_MOD_AND(regs->devctrl, ~(CTRL_DMA_IN_ENABLE));
+}
+
+static inline void enable_epin_dma(struct snps_udc_regs *regs)
+{
+	REG_MOD_OR(regs->devctrl, (CTRL_DMA_IN_ENABLE));
+}
+
+static inline bool is_epin_dma_enable(struct snps_udc_regs *regs)
+{
+	return REG_RD(regs->devctrl) &
+				CTRL_DMA_IN_ENABLE ? true : false;
+}
+
+static inline void disable_epout_dma(struct snps_udc_regs *regs)
+{
+	REG_MOD_AND(regs->devctrl, ~(CTRL_DMA_OUT_ENABLE));
+}
+
+static inline void enable_epout_dma(struct snps_udc_regs *regs)
+{
+	REG_MOD_OR(regs->devctrl, (CTRL_DMA_OUT_ENABLE));
+}
+
+static inline bool is_epout_dma_enable(struct snps_udc_regs *regs)
+{
+	return REG_RD(regs->devctrl) &
+				CTRL_DMA_OUT_ENABLE ? true : false;
+}
+
+static inline u32 get_frnum_last_rx(struct snps_udc_regs *regs)
+{
+	return (REG_RD(regs->devstatus) &
+		STS_SOF_FRAME_NUM_MASK) >> STS_SOF_FRAME_NUM_SHIFT;
+}
+
+static inline u32 get_irq_active(struct snps_udc_regs *regs)
+{
+	return REG_RD(regs->devintrstat);
+}
+
+static inline void clear_udc_dev_irq(struct snps_udc_regs *regs, u32 mask)
+{
+	REG_WR(regs->devintrstat, mask);
+}
+
+static inline void disable_udc_dev_irq(struct snps_udc_regs *regs, u32 mask)
+{
+	REG_MOD_OR(regs->devintrmask, mask);
+}
+
+static inline void enable_udc_dev_irq(struct snps_udc_regs *regs, u32 mask)
+{
+	REG_MOD_AND(regs->devintrmask, ~mask);
+}
+
+static inline u32 mask_irq(struct snps_udc_regs *regs)
+{
+	return (~REG_RD(regs->devintrmask)) & UDC_IRQ_ALL;
+}
+
+static inline void clear_devnak(struct snps_udc_regs *regs)
+{
+	REG_MOD_AND(regs->devctrl, ~CTRL_OUT_ALL_NAK);
+}
+
+static inline void set_devnak(struct snps_udc_regs *regs)
+{
+	REG_MOD_OR(regs->devctrl, CTRL_OUT_ALL_NAK);
+}
+
+static inline bool is_phy_error(struct snps_udc_regs *regs)
+{
+	return REG_RD(regs->devstatus) &
+		STS_PHY_ERROR ? true : false;
+}
+
+static inline bool is_rmtwkp(struct snps_udc_regs *regs)
+{
+	return REG_RD(regs->devstatus) &
+		STS_REMOTE_WAKEUP_ALLOWED ? true : false;
+}
+
+static inline void clear_rmtwkup(struct snps_udc_regs *regs)
+{
+	REG_MOD_AND(regs->devcfg, ~CFG_REMOTE_WAKEUP_ENABLE);
+}
+
+static inline void set_rmtwkp(struct snps_udc_regs *regs)
+{
+	REG_MOD_OR(regs->devcfg, CFG_REMOTE_WAKEUP_ENABLE);
+}
+
+static inline void start_rmtwkp(struct snps_udc_regs *regs)
+{
+	REG_MOD_OR(regs->devctrl, CTRL_RESUME_SIGNAL_ENABLE);
+}
+
+static inline void stop_rmtwkp(struct snps_udc_regs *regs)
+{
+	REG_MOD_AND(regs->devctrl, ~CTRL_RESUME_SIGNAL_ENABLE);
+}
+
+static inline void disable_self_pwr(struct snps_udc_regs *regs)
+{
+	REG_MOD_AND(regs->devcfg, ~CFG_SELF_PWR_ENABLE);
+}
+
+static inline void enable_self_pwr(struct snps_udc_regs *regs)
+{
+	REG_MOD_OR(regs->devcfg, CFG_SELF_PWR_ENABLE);
+}
+
+static inline void disable_set_desc(struct snps_udc_regs *regs)
+{
+	REG_MOD_AND(regs->devcfg, ~CFG_SET_DESCRIPTOR_ENABLE);
+}
+
+static inline void enable_set_desc(struct snps_udc_regs *regs)
+{
+	REG_MOD_OR(regs->devcfg, CFG_SET_DESCRIPTOR_ENABLE);
+}
+
+static inline void set_setup_done(struct snps_udc_regs *regs)
+{
+	REG_MOD_OR(regs->devctrl, CTRL_CSR_DONE);
+}
+
+static inline u32 get_enum_speed(struct snps_udc_regs *regs)
+{
+	switch (REG_RD(regs->devstatus) & STS_SPD_MASK) {
+	case STS_SPD_LS:
+		return SPEED_LOW;
+	case STS_SPD_HS:
+		return SPEED_HIGH;
+	case STS_SPD_FS:
+	case STS_SPD_FS_48MHZ:
+		return SPEED_FULL;
+	default:
+		return 0;
+	}
+}
+
+static inline void set_speed_requested(struct snps_udc_regs *regs, u32 speed)
+{
+	REG_MOD_AND(regs->devcfg, ~CFG_SPD_MASK);
+
+	switch (speed) {
+	case SPEED_LOW:
+		REG_MOD_OR(regs->devcfg, CFG_SPD_LS);
+		break;
+
+	case SPEED_HIGH:
+		REG_MOD_OR(regs->devcfg, CFG_SPD_HS);
+		break;
+
+	case SPEED_FULL:
+	default:
+		REG_MOD_OR(regs->devcfg, CFG_SPD_FS);
+		break;
+	}
+}
+
+static inline void init_ep_reg(struct snps_udc_regs *regs, u32 num, u32 type,
+			       u32 dirn, u32 max_pkt_size)
+{
+	if ((type == EP_TYPE_CTRL) || (dirn == EP_DIRN_OUT)) {
+		REG_WR(regs->ep_out[num].ctrl,
+		       (type << EP_CTRL_TYPE_SHIFT));
+		REG_WR(regs->ep_out[num].status,
+		       regs->ep_out[num].status);
+		REG_WR(regs->ep_out[num].epreg2,  0);
+		REG_WR(regs->ep_out[num].epreg3,
+		       ((max_pkt_size >> 2) << 16) | max_pkt_size);
+
+		if (mrx_fifo)
+			REG_MOD_OR(regs->ep_out[num].epreg3,
+				   (FIFO_SZ_U32(max_pkt_size) <<
+				   EP_REG3_OUT_DEPTH_SHIFT));
+	}
+	if ((type == EP_TYPE_CTRL) || (dirn == EP_DIRN_IN)) {
+		REG_WR(regs->ep_in[num].ctrl,
+		       (type << EP_CTRL_TYPE_SHIFT));
+		REG_WR(regs->ep_in[num].epreg3,
+		       (max_pkt_size << EP_REG3_PKT_MAX_SHIFT));
+		REG_WR(regs->ep_in[num].epreg2,
+		       (max_pkt_size >> 2));
+		REG_MOD_OR(regs->ep_in[num].ctrl,
+			   EP_CTRL_IN_FLUSH_ENABLE);
+		REG_MOD_AND(regs->ep_in[num].ctrl,
+			    ~EP_CTRL_IN_FLUSH_ENABLE);
+		REG_MOD_AND(regs->ep_in[num].ctrl,
+			    EP_CTRL_NAK_SET);
+	}
+	REG_WR(regs->epcfg[num],
+	       (num << EP_CFG_FIFO_NUM_SHIFT) |
+	       (type << EP_CFG_TYPE_SHIFT) |
+	       (max_pkt_size << EP_CFG_PKT_MAX_SHIFT) |
+	       ((dirn == EP_DIRN_OUT) ? EP_CFG_DIRN_OUT : EP_CFG_DIRN_IN));
+}
+
+static inline void set_ep_alt_num(struct snps_udc_regs *regs, u32 num, u32 alt)
+{
+	REG_MOD_MASK(regs->epcfg[num], ~EP_CFG_ALT_NUM_MASK,
+		     (alt << EP_CFG_ALT_NUM_SHIFT));
+}
+
+static inline void set_epcfg_reg(struct snps_udc_regs *regs, u32 num, u32 cfg)
+{
+	REG_MOD_MASK(regs->epcfg[num], ~EP_CFG_CFG_NUM_MASK,
+		     (cfg << EP_CFG_CFG_NUM_SHIFT));
+}
+
+static inline void set_ep_intf_num(struct snps_udc_regs *regs, u32 num,
+				   u32 intf)
+{
+	REG_MOD_MASK(regs->epcfg[num], ~EP_CFG_INTF_NUM_MASK,
+		     (intf << EP_CFG_INTF_NUM_SHIFT));
+}
+
+static inline void disable_ep_dma(struct snps_udc_regs *regs, u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT) {
+		if (mrx_fifo)
+			REG_MOD_AND(regs->ep_out[num].ctrl,
+				    ~EP_CTRL_OUT_DMA_ENABLE);
+	} else {
+		REG_MOD_AND(regs->ep_in[num].ctrl,
+			    ~EP_CTRL_IN_DMA_ENABLE);
+	}
+}
+
+static inline void enable_ep_dma(struct snps_udc_regs *regs,
+				 u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT) {
+		if (mrx_fifo)
+			REG_MOD_OR(regs->ep_out[num].ctrl,
+				   EP_CTRL_OUT_DMA_ENABLE);
+		else
+			REG_MOD_OR(regs->devctrl,
+				   CTRL_DMA_OUT_ENABLE);
+	} else
+		REG_MOD_OR(regs->ep_in[num].ctrl,
+			   EP_CTRL_IN_DMA_ENABLE);
+}
+
+static inline void set_setup_buf_ptr(struct snps_udc_regs *regs,
+				     u32 num, u32 dirn, void *addr)
+{
+	if (dirn == EP_DIRN_OUT)
+		REG_WR(regs->ep_out[num].setupbuf, (dma_addr_t)addr);
+}
+
+static inline void set_data_desc_ptr(struct snps_udc_regs *regs,
+				     u32 num, u32 dirn, void *addr)
+{
+	if (dirn == EP_DIRN_OUT)
+		REG_WR(regs->ep_out[num].datadesc, (dma_addr_t)addr);
+	else
+		REG_WR(regs->ep_in[num].datadesc, (dma_addr_t)addr);
+}
+
+static inline bool is_ep_fifo_empty(struct snps_udc_regs *regs,
+				    u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT) {
+		if (mrx_fifo)
+			return REG_RD(regs->ep_out[num].status) &
+				EP_STS_OUT_FIFO_EMPTY ? true : false;
+		else
+			return REG_RD(regs->devstatus) &
+				STS_OUT_FIFO_EMPTY ? true : false;
+	}
+	return REG_RD(regs->ep_in[num].status) &
+			EP_STS_IN_FIFO_EMPTY ? true : false;
+}
+
+static inline void clear_ep_fifo_flush(struct snps_udc_regs *regs,
+				       u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT) {
+		if (mrx_fifo)
+			REG_MOD_AND(regs->ep_out[num].ctrl,
+				    ~EP_CTRL_OUT_FLUSH_ENABLE);
+		else
+			REG_MOD_AND(regs->devctrl,
+				    ~CTRL_OUT_FIFO_FLUSH_ENABLE);
+	} else {
+		REG_MOD_AND(regs->ep_in[num].ctrl,
+			    ~EP_CTRL_IN_FLUSH_ENABLE);
+	}
+}
+
+static inline void set_ep_fifo_flush(struct snps_udc_regs *regs,
+				     u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT) {
+		if (mrx_fifo)
+			REG_MOD_OR(regs->ep_out[num].ctrl,
+				   EP_CTRL_OUT_FLUSH_ENABLE);
+		else
+			REG_MOD_OR(regs->devctrl,
+				   CTRL_OUT_FIFO_FLUSH_ENABLE);
+	} else {
+		REG_MOD_OR(regs->ep_in[num].ctrl,
+			   EP_CTRL_IN_FLUSH_ENABLE);
+	}
+}
+
+static inline u32 get_ep_frnum(struct snps_udc_regs *regs,
+			       u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT)
+		return (regs->ep_out[num].epreg2 &
+				EP_REG2_OUT_FRAME_NUM_MASK) >>
+				EP_REG2_OUT_FRAME_NUM_SHIFT;
+	return 0;
+}
+
+static inline void clear_udc_ep_irq(struct snps_udc_regs *regs,
+				    u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT)
+		REG_WR(regs->epintrstat, (1 << num) <<
+		       EP_INTR_OUT_SHIFT);
+	else
+		REG_WR(regs->epintrstat, (1 << num) <<
+		       EP_INTR_IN_SHIFT);
+}
+
+static inline void disable_udc_ep_irq(struct snps_udc_regs *regs,
+				      u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT) {
+		REG_MOD_OR(regs->epintrmask, ((1 << num) <<
+			   EP_INTR_OUT_SHIFT));
+	} else {
+		REG_MOD_OR(regs->epintrmask, ((1 << num) <<
+			   EP_INTR_IN_SHIFT));
+	}
+}
+
+static inline void enable_udc_ep_irq(struct snps_udc_regs *regs,
+				     u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT) {
+		REG_MOD_AND(regs->epintrmask, ~((1 << num) <<
+			    EP_INTR_OUT_SHIFT));
+	} else {
+		REG_MOD_AND(regs->epintrmask, ~((1 << num) <<
+			    EP_INTR_IN_SHIFT));
+	}
+}
+
+static inline u32 get_ep_irq_active(struct snps_udc_regs *regs, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT)
+		return (REG_RD(regs->epintrstat) & EP_INTR_OUT_MASK)
+				 >> EP_INTR_OUT_SHIFT;
+
+	return (REG_RD(regs->epintrstat) & EP_INTR_IN_MASK)
+				 >> EP_INTR_IN_SHIFT;
+}
+
+static inline void clear_udc_ep_irq_list(struct snps_udc_regs *regs,
+					 u32 dirn, u32 mask)
+{
+	if (dirn == EP_DIRN_OUT)
+		REG_WR(regs->epintrstat, (mask << EP_INTR_OUT_SHIFT));
+	else
+		REG_WR(regs->epintrstat, (mask << EP_INTR_IN_SHIFT));
+}
+
+static inline u32 get_ep_status(struct snps_udc_regs *regs, u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT)
+		return REG_RD(regs->ep_out[num].status);
+
+	return REG_RD(regs->ep_in[num].status);
+}
+
+static inline void clear_ep_status(struct snps_udc_regs *regs,
+				   u32 num, u32 dirn, u32 mask)
+{
+	if (dirn == EP_DIRN_OUT)
+		REG_WR(regs->ep_out[num].status, mask);
+	else
+		REG_WR(regs->ep_in[num].status, mask);
+}
+
+static inline void clear_ep_nak(struct snps_udc_regs *regs,
+				u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT)
+		REG_MOD_OR(regs->ep_out[num].ctrl, EP_CTRL_NAK_CLEAR);
+	else
+		REG_MOD_OR(regs->ep_in[num].ctrl, EP_CTRL_NAK_CLEAR);
+}
+
+static inline void enable_ep_nak(struct snps_udc_regs *regs,
+				 u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT)
+		REG_MOD_OR(regs->ep_out[num].ctrl, EP_CTRL_NAK_SET);
+	else
+		REG_MOD_OR(regs->ep_in[num].ctrl, EP_CTRL_NAK_SET);
+}
+
+static inline void disable_ep_nak(struct snps_udc_regs *regs,
+				  u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT)
+		REG_MOD_AND(regs->ep_out[num].ctrl, ~EP_CTRL_NAK_SET);
+	else
+		REG_MOD_AND(regs->ep_in[num].ctrl, ~EP_CTRL_NAK_SET);
+}
+
+static inline bool is_ep_nak_inprog(struct snps_udc_regs *regs,
+				    u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT)
+		return REG_RD(regs->ep_out[num].ctrl) &
+			EP_CTRL_NAK_IN_PROGRESS ? true : false;
+
+	return REG_RD(regs->ep_in[num].ctrl) &
+			EP_CTRL_NAK_IN_PROGRESS ? true : false;
+}
+
+static inline void disable_ep_stall(struct snps_udc_regs *regs,
+				    u32 num, u32 dirn)
+{
+	if (dirn == EP_DIRN_OUT)
+		REG_MOD_AND(regs->ep_out[num].ctrl,
+			    ~EP_CTRL_STALL_ENABLE);
+	else
+		REG_MOD_AND(regs->ep_in[num].ctrl,
+			    ~EP_CTRL_STALL_ENABLE);
+}
+
+static inline void enable_ep_stall(struct snps_udc_regs *regs,
+				   u32 num, u32 dirn)
+{
+	if (mrx_fifo && !(REG_RD(regs->ep_out[num].status) &
+			EP_STS_OUT_FIFO_EMPTY))
+		return;
+	else if (!mrx_fifo && !(REG_RD(regs->devstatus) &
+			STS_OUT_FIFO_EMPTY))
+		return;
+
+	if (dirn == EP_DIRN_OUT)
+		REG_MOD_OR(regs->ep_out[num].ctrl,
+			   EP_CTRL_STALL_ENABLE);
+	else
+		REG_MOD_OR(regs->ep_in[num].ctrl,
+			   EP_CTRL_STALL_ENABLE);
+}
+
+static inline u32 get_last_rx_frnum(struct snps_udc_regs *regs)
+{
+	return (REG_RD(regs->devstatus) & STS_SOF_FRAME_NUM_MASK)
+			>> STS_SOF_FRAME_NUM_SHIFT;
+}
+
+static inline void finish_udc(struct snps_udc_regs *regs)
+{
+	u32 ep_num;
+
+	disable_ctrl_dma(regs);
+	disable_udc_dev_irq(regs, UDC_IRQ_ALL);
+	clear_udc_dev_irq(regs, UDC_IRQ_ALL);
+
+	for (ep_num = 0; ep_num < UDC_MAX_EP; ep_num++) {
+		disable_udc_ep_irq(regs, ep_num, EP_DIRN_IN);
+		clear_udc_ep_irq(regs, ep_num, EP_DIRN_IN);
+		clear_ep_status(regs, ep_num, EP_DIRN_IN,
+				get_ep_status(regs, ep_num,
+					      EP_DIRN_IN));
+
+		disable_udc_ep_irq(regs, ep_num, EP_DIRN_OUT);
+		clear_udc_ep_irq(regs, ep_num, EP_DIRN_OUT);
+		clear_ep_status(regs, ep_num, EP_DIRN_OUT,
+				get_ep_status(regs, ep_num,
+					      EP_DIRN_OUT));
+	}
+}
+
+static inline void init_udc_reg(struct snps_udc_regs *regs)
+{
+	finish_udc(regs);
+	REG_WR(regs->devcfg, CFG_SET_DESCRIPTOR_ENABLE
+					| CFG_UTMI_8BIT_ENABLE
+					| CFG_CSR_PROGRAM_ENABLE
+					| CFG_SPD_HS);
+	REG_WR(regs->devctrl, CTRL_LE_ENABLE
+					| CTRL_DISCONNECT_ENABLE
+					| CTRL_DMA_MODE_ENABLE
+					| CTRL_DMA_DESC_UPDATE_ENABLE
+					| CTRL_OUT_ALL_NAK
+					| CTRL_DMA_OUT_THRESH_LEN_MASK
+					| CTRL_DMA_BURST_LEN_MASK
+					| CTRL_DMA_BURST_ENABLE
+					| CTRL_OUT_FIFO_FLUSH_ENABLE
+			);
+
+	if (mrx_fifo)
+		REG_MOD_AND(regs->devctrl, ~CTRL_OUT_FIFO_FLUSH_ENABLE);
+
+	if (out_bf_mode)
+		REG_MOD_OR(regs->devctrl, CTRL_DMA_BUFF_FILL_MODE_ENABLE);
+
+	REG_WR(regs->devintrmask, IRQ_BUS_IDLE | IRQ_SOF_DETECTED);
+	REG_WR(regs->epintrmask, 0);
+}
+
+static inline struct data_desc *dma_desc_chain_alloc(struct snps_udc_ep *ep)
+{
+	u32 idx;
+
+	idx = ep->dma.add_idx++;
+
+	return &ep->dma.virt->desc[EP_DMA_DESC_IDX(idx)];
+}
+
+static inline int dma_desc_chain_is_empty(struct snps_udc_ep *ep)
+{
+	return ep->dma.add_idx == ep->dma.remove_idx;
+}
+
+static inline void dma_desc_chain_free(struct snps_udc_ep *ep)
+{
+	ep->dma.remove_idx++;
+}
+
+static inline int dma_desc_chain_is_full(struct snps_udc_ep *ep)
+{
+	return !dma_desc_chain_is_empty(ep) &&
+		(EP_DMA_DESC_IDX(ep->dma.add_idx) ==
+		 EP_DMA_DESC_IDX(ep->dma.remove_idx));
+}
+
+static inline struct data_desc *dma_desc_chain_head(struct snps_udc_ep *ep)
+{
+	u32 index = EP_DMA_DESC_IDX(ep->dma.remove_idx);
+
+	return &ep->dma.virt->desc[index];
+}
+
+static inline void dma_desc_chain_reset(struct snps_udc_ep *ep)
+{
+	ep->dma.add_idx = 0;
+	ep->dma.remove_idx = 0;
+}
+#endif
--- a/drivers/usb/host/xhci-hub.c
+++ b/drivers/usb/host/xhci-hub.c
@@ -1386,6 +1386,16 @@ int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		case USB_PORT_FEAT_C_PORT_CONFIG_ERROR:
 			xhci_clear_port_change_bit(xhci, wValue, wIndex,
 					port_array[wIndex], temp);
+			if ((wValue == USB_PORT_FEAT_C_CONNECTION) &&
+					!(temp & PORT_CONNECT) &&
+					(hcd->speed < HCD_USB3) &&
+					(hcd->driver->port_power)) {
+
+				hcd->driver->port_power(hcd,
+							wIndex +
+							xhci->num_usb3_ports,
+							false);
+			}
 			break;
 		case USB_PORT_FEAT_ENABLE:
 			xhci_disable_port(hcd, xhci, wIndex,
--- a/drivers/usb/host/xhci-plat.h
+++ b/drivers/usb/host/xhci-plat.h
@@ -15,6 +15,8 @@
 
 struct xhci_plat_priv {
 	const char *firmware_name;
+	struct phy **phys;
+	int num_phys;
 	void (*plat_start)(struct usb_hcd *);
 	int (*init_quirk)(struct usb_hcd *);
 	int (*resume_quirk)(struct usb_hcd *);
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -5068,6 +5068,8 @@ void xhci_init_driver(struct hc_driver *drv,
 			drv->reset = over->reset;
 		if (over->start)
 			drv->start = over->start;
+		if (over->port_power)
+			drv->port_power = over->port_power;
 	}
 }
 EXPORT_SYMBOL_GPL(xhci_init_driver);
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1880,6 +1880,7 @@ struct xhci_driver_overrides {
 	size_t extra_priv_size;
 	int (*reset)(struct usb_hcd *hcd);
 	int (*start)(struct usb_hcd *hcd);
+	int (*port_power)(struct usb_hcd *hcd, int portnum, bool enable);
 };
 
 #define	XHCI_CFC_DELAY		10
--- a/drivers/vfio/pci/vfio_pci.c
+++ b/drivers/vfio/pci/vfio_pci.c
@@ -1160,7 +1160,13 @@ static int vfio_pci_mmap(void *device_data, struct vm_area_struct *vma)
 	}
 
 	vma->vm_private_data = vdev;
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
+	if (pci_resource_flags(pdev, index) & IORESOURCE_PREFETCH)
+		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	else
+#endif
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
 	vma->vm_pgoff = (pci_resource_start(pdev, index) >> PAGE_SHIFT) + pgoff;
 
 	return remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
--- a/drivers/vfio/platform/reset/Kconfig
+++ b/drivers/vfio/platform/reset/Kconfig
@@ -13,3 +13,12 @@ config VFIO_PLATFORM_AMDXGBE_RESET
 	  Enables the VFIO platform driver to handle reset for AMD XGBE
 
 	  If you don't know what to do here, say N.
+
+config VFIO_PLATFORM_BCMFLEXRM_RESET
+	tristate "VFIO support for Broadcom FlexRM reset"
+	depends on VFIO_PLATFORM && (ARCH_BCM_IPROC || COMPILE_TEST)
+	default ARCH_BCM_IPROC
+	help
+	  Enables the VFIO platform driver to handle reset for Broadcom FlexRM
+
+	  If you don't know what to do here, say N.
--- a/drivers/vfio/platform/reset/Makefile
+++ b/drivers/vfio/platform/reset/Makefile
@@ -6,3 +6,4 @@ ccflags-y += -Idrivers/vfio/platform
 
 obj-$(CONFIG_VFIO_PLATFORM_CALXEDAXGMAC_RESET) += vfio-platform-calxedaxgmac.o
 obj-$(CONFIG_VFIO_PLATFORM_AMDXGBE_RESET) += vfio-platform-amdxgbe.o
+obj-$(CONFIG_VFIO_PLATFORM_BCMFLEXRM_RESET) += vfio_platform_bcmflexrm.o
--- /dev/null
+++ b/drivers/vfio/platform/reset/vfio_platform_bcmflexrm.c
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2017 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * This driver provides reset support for Broadcom FlexRM ring manager
+ * to VFIO platform.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "vfio_platform_private.h"
+
+/* FlexRM configuration */
+#define RING_REGS_SIZE					0x10000
+#define RING_VER_MAGIC					0x76303031
+
+/* Per-Ring register offsets */
+#define RING_VER					0x000
+#define RING_CONTROL					0x034
+#define RING_FLUSH_DONE					0x038
+
+/* Register RING_CONTROL fields */
+#define CONTROL_FLUSH_SHIFT				5
+
+/* Register RING_FLUSH_DONE fields */
+#define FLUSH_DONE_MASK					0x1
+
+static int vfio_platform_bcmflexrm_shutdown(void __iomem *ring)
+{
+	unsigned int timeout;
+
+	/* Disable/inactivate ring */
+	writel_relaxed(0x0, ring + RING_CONTROL);
+
+	/* Set ring flush state */
+	timeout = 1000; /* timeout of 1s */
+	writel_relaxed(BIT(CONTROL_FLUSH_SHIFT), ring + RING_CONTROL);
+	do {
+		if (readl_relaxed(ring + RING_FLUSH_DONE) &
+		    FLUSH_DONE_MASK)
+			break;
+		mdelay(1);
+	} while (--timeout);
+	if (!timeout)
+		return -ETIMEDOUT;
+
+	/* Clear ring flush state */
+	timeout = 1000; /* timeout of 1s */
+	writel_relaxed(0x0, ring + RING_CONTROL);
+	do {
+		if (!(readl_relaxed(ring + RING_FLUSH_DONE) &
+		      FLUSH_DONE_MASK))
+			break;
+		mdelay(1);
+	} while (--timeout);
+	if (!timeout)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int vfio_platform_bcmflexrm_reset(struct vfio_platform_device *vdev)
+{
+	void __iomem *ring;
+	int rc = 0, ret = 0, ring_num = 0;
+	struct vfio_platform_region *reg = &vdev->regions[0];
+
+	/* Map FlexRM ring registers if not mapped */
+	if (!reg->ioaddr) {
+		reg->ioaddr = ioremap_nocache(reg->addr, reg->size);
+		if (!reg->ioaddr)
+			return -ENOMEM;
+	}
+
+	/* Discover and shutdown each FlexRM ring */
+	for (ring = reg->ioaddr;
+	     ring < (reg->ioaddr + reg->size); ring += RING_REGS_SIZE) {
+		if (readl_relaxed(ring + RING_VER) == RING_VER_MAGIC) {
+			rc = vfio_platform_bcmflexrm_shutdown(ring);
+			if (rc) {
+				dev_warn(vdev->device,
+					 "FlexRM ring%d shutdown error %d\n",
+					 ring_num, rc);
+				ret |= rc;
+			}
+			ring_num++;
+		}
+	}
+
+	return ret;
+}
+
+module_vfio_reset_handler("brcm,iproc-flexrm-mbox",
+			  vfio_platform_bcmflexrm_reset);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Anup Patel <anup.patel@broadcom.com>");
+MODULE_DESCRIPTION("Reset support for Broadcom FlexRM VFIO platform device");
--- a/drivers/watchdog/sp805_wdt.c
+++ b/drivers/watchdog/sp805_wdt.c
@@ -11,6 +11,7 @@
  * warranty of any kind, whether express or implied.
  */
 
+#include <linux/acpi.h>
 #include <linux/device.h>
 #include <linux/resource.h>
 #include <linux/amba/bus.h>
@@ -22,6 +23,7 @@
 #include <linux/math64.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
+#include <linux/of.h>
 #include <linux/pm.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
@@ -42,6 +44,7 @@
 	/* control register masks */
 	#define	INT_ENABLE	(1 << 0)
 	#define	RESET_ENABLE	(1 << 1)
+	#define	ENABLE_MASK	(INT_ENABLE | RESET_ENABLE)
 #define WDTINTCLR		0x00C
 #define WDTRIS			0x010
 #define WDTMIS			0x014
@@ -65,6 +68,7 @@ struct sp805_wdt {
 	spinlock_t			lock;
 	void __iomem			*base;
 	struct clk			*clk;
+	u64				rate;
 	struct amba_device		*adev;
 	unsigned int			load_val;
 };
@@ -74,13 +78,25 @@ struct sp805_wdt {
 MODULE_PARM_DESC(nowayout,
 		"Set to 1 to keep watchdog running after device release");
 
+/* returns true if wdt is running; otherwise returns false */
+static bool wdt_is_running(struct watchdog_device *wdd)
+{
+	struct sp805_wdt *wdt = watchdog_get_drvdata(wdd);
+
+	if ((readl_relaxed(wdt->base + WDTCONTROL) & ENABLE_MASK) ==
+	    ENABLE_MASK)
+		return true;
+	else
+		return false;
+}
+
 /* This routine finds load value that will reset system in required timout */
 static int wdt_setload(struct watchdog_device *wdd, unsigned int timeout)
 {
 	struct sp805_wdt *wdt = watchdog_get_drvdata(wdd);
 	u64 load, rate;
 
-	rate = clk_get_rate(wdt->clk);
+	rate = wdt->rate;
 
 	/*
 	 * sp805 runs counter with given value twice, after the end of first
@@ -106,9 +122,7 @@ static int wdt_setload(struct watchdog_device *wdd, unsigned int timeout)
 static unsigned int wdt_timeleft(struct watchdog_device *wdd)
 {
 	struct sp805_wdt *wdt = watchdog_get_drvdata(wdd);
-	u64 load, rate;
-
-	rate = clk_get_rate(wdt->clk);
+	u64 load;
 
 	spin_lock(&wdt->lock);
 	load = readl_relaxed(wdt->base + WDTVALUE);
@@ -118,7 +132,7 @@ static unsigned int wdt_timeleft(struct watchdog_device *wdd)
 		load += wdt->load_val + 1;
 	spin_unlock(&wdt->lock);
 
-	return div_u64(load, rate);
+	return div_u64(load, wdt->rate);
 }
 
 static int wdt_config(struct watchdog_device *wdd, bool ping)
@@ -215,11 +229,25 @@ static int wdt_disable(struct watchdog_device *wdd)
 	if (IS_ERR(wdt->base))
 		return PTR_ERR(wdt->base);
 
-	wdt->clk = devm_clk_get(&adev->dev, NULL);
-	if (IS_ERR(wdt->clk)) {
-		dev_warn(&adev->dev, "Clock not found\n");
-		ret = PTR_ERR(wdt->clk);
-		goto err;
+	if (adev->dev.of_node) {
+		wdt->clk = devm_clk_get(&adev->dev, NULL);
+		if (IS_ERR(wdt->clk)) {
+			dev_err(&adev->dev, "Clock not found\n");
+			return PTR_ERR(wdt->clk);
+		}
+		wdt->rate = clk_get_rate(wdt->clk);
+	} else if (has_acpi_companion(&adev->dev)) {
+		/*
+		 * When Driver probe with ACPI device, clock devices
+		 * are not available, so watchdog rate get from
+		 * clock-frequency property given in _DSD object.
+		 */
+		device_property_read_u64(&adev->dev, "clock-frequency",
+					 &wdt->rate);
+		if (!wdt->rate) {
+			dev_err(&adev->dev, "no clock-frequency property\n");
+			return -ENODEV;
+		}
 	}
 
 	wdt->adev = adev;
@@ -230,7 +258,23 @@ static int wdt_disable(struct watchdog_device *wdd)
 	spin_lock_init(&wdt->lock);
 	watchdog_set_nowayout(&wdt->wdd, nowayout);
 	watchdog_set_drvdata(&wdt->wdd, wdt);
-	wdt_setload(&wdt->wdd, DEFAULT_TIMEOUT);
+
+	/*
+	 * If 'timeout-sec' devicetree property is specified, use that.
+	 * Otherwise, use DEFAULT_TIMEOUT
+	 */
+	wdt->wdd.timeout = DEFAULT_TIMEOUT;
+	watchdog_init_timeout(&wdt->wdd, 0, &adev->dev);
+	wdt_setload(&wdt->wdd, wdt->wdd.timeout);
+
+	/*
+	 * If HW is already running, enable/reset the wdt and set the running
+	 * bit to tell the wdt subsystem
+	 */
+	if (wdt_is_running(&wdt->wdd)) {
+		wdt_enable(&wdt->wdd);
+		set_bit(WDOG_HW_RUNNING, &wdt->wdd.status);
+	}
 
 	ret = watchdog_register_device(&wdt->wdd);
 	if (ret) {
old mode 100644
new mode 100755
--- a/include/dt-bindings/clock/bcm-sr.h
+++ b/include/dt-bindings/clock/bcm-sr.h
@@ -35,7 +35,7 @@
 
 /* GENPLL 0 clock channel ID SCR HSLS FS PCIE */
 #define BCM_SR_GENPLL0			0
-#define BCM_SR_GENPLL0_SATA_CLK		1
+#define BCM_SR_GENPLL0_125M_CLK		1
 #define BCM_SR_GENPLL0_SCR_CLK		2
 #define BCM_SR_GENPLL0_250M_CLK		3
 #define BCM_SR_GENPLL0_PCIE_AXI_CLK	4
@@ -50,9 +50,11 @@
 /* GENPLL 2 clock channel ID NITRO MHB*/
 #define BCM_SR_GENPLL2			0
 #define BCM_SR_GENPLL2_NIC_CLK		1
-#define BCM_SR_GENPLL2_250_NITRO_CLK	2
+#define BCM_SR_GENPLL2_TS_500_CLK	2
 #define BCM_SR_GENPLL2_125_NITRO_CLK	3
 #define BCM_SR_GENPLL2_CHIMP_CLK	4
+#define BCM_SR_GENPLL2_NIC_FLASH_CLK	5
+#define BCM_SR_GENPLL2_FS4_CLK		6
 
 /* GENPLL 3 HSLS clock channel ID */
 #define BCM_SR_GENPLL3			0
@@ -62,11 +64,16 @@
 /* GENPLL 4 SCR clock channel ID */
 #define BCM_SR_GENPLL4			0
 #define BCM_SR_GENPLL4_CCN_CLK		1
+#define BCM_SR_GENPLL4_TPIU_PLL_CLK	2
+#define BCM_SR_GENPLL4_NOC_CLK		3
+#define BCM_SR_GENPLL4_CHCLK_FS4_CLK	4
+#define BCM_SR_GENPLL4_BRIDGE_FSCPU_CLK	5
 
 /* GENPLL 5 FS4 clock channel ID */
 #define BCM_SR_GENPLL5			0
-#define BCM_SR_GENPLL5_FS_CLK		1
-#define BCM_SR_GENPLL5_SPU_CLK		2
+#define BCM_SR_GENPLL5_FS4_HF_CLK	1
+#define BCM_SR_GENPLL5_CRYPTO_AE_CLK	2
+#define BCM_SR_GENPLL5_RAID_AE_CLK	3
 
 /* GENPLL 6 NITRO clock channel ID */
 #define BCM_SR_GENPLL6			0
@@ -74,13 +81,16 @@
 
 /* LCPLL0  clock channel ID */
 #define BCM_SR_LCPLL0			0
-#define BCM_SR_LCPLL0_SATA_REF_CLK	1
-#define BCM_SR_LCPLL0_USB_REF_CLK	2
-#define BCM_SR_LCPLL0_SATA_REFPN_CLK	3
+#define BCM_SR_LCPLL0_SATA_REFP_CLK	1
+#define BCM_SR_LCPLL0_SATA_REFN_CLK	2
+#define BCM_SR_LCPLL0_SATA_350_CLK	3
+#define BCM_SR_LCPLL0_SATA_500_CLK	4
 
 /* LCPLL1  clock channel ID */
 #define BCM_SR_LCPLL1			0
 #define BCM_SR_LCPLL1_WAN_CLK		1
+#define BCM_SR_LCPLL1_USB_REF_CLK	2
+#define BCM_SR_LCPLL1_CRMU_TS_CLK	3
 
 /* LCPLL PCIE  clock channel ID */
 #define BCM_SR_LCPLL_PCIE		0
--- /dev/null
+++ b/include/linux/bcm_iproc_dte.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation (the "GPL").
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License version 2 (GPLv2) for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 (GPLv2) along with this source code.
+ */
+
+#ifndef _BCM_IPROC_DTE_H_
+#define _BCM_IPROC_DTE_H_
+
+#include <linux/cdev.h>
+#include <linux/kfifo.h>
+#include <linux/timer.h>
+#include <linux/wait.h>
+
+struct dte_user_info {
+	struct file *fp; /* File opened by user */
+	bool internal_user;
+	wait_queue_head_t ts_wait_queue;
+};
+
+struct dte_client_mapping {
+	u32 client_index;
+	u32 lts_index;
+	u32 reg_offset;
+	u32 shift;
+	char *name;
+	u32 div_status;
+};
+
+struct bcm_dte {
+	struct platform_device *pdev;
+	struct cdev dte_cdev;
+	struct class *dte_class;
+	struct kfifo *recv_fifo;
+	int irq;
+	dev_t devt;
+	uint32_t fifoof;
+	uint32_t fifouf;
+	uint32_t *kfifoof;
+	uint32_t src_ena;
+	spinlock_t lock;
+	struct mutex en_ts_lock;
+	struct mutex mutex;
+	struct timespec ts_ref;
+	uint32_t timestamp_overflow_last;
+	void __iomem *audioeav;
+	void __iomem *trigg_reg;
+
+	uint32_t irq_interval_ns;
+	uint32_t usr_cnt; /* tracks num of users */
+	struct dte_user_info *user;
+	struct timer_list fifo_timer;
+	struct timer_list ovf_timer;
+	unsigned int num_of_clients;
+	struct dte_client_mapping *dte_cli;
+	uint32_t nco_susp_val;
+	uint32_t trigg_reg_susp_val;
+
+	int (*enable_ts)(struct bcm_dte *dte,
+		unsigned int client, bool enable,
+		uint32_t divider, bool both_edge, struct file *fp);
+	int (*get_ts)(struct bcm_dte *dte,
+		unsigned int client, struct timespec *ts);
+
+	int (*nco_set_time)(struct bcm_dte *dte, struct timespec *ts);
+	int (*nco_get_time)(struct bcm_dte *dte, struct timespec *ts);
+	int (*nco_adj_time)(struct bcm_dte *dte, int64_t delta);
+	int (*nco_adj_freq)(struct bcm_dte *dte, int32_t ppb);
+	int (*nco_get_freq_adj)(struct bcm_dte *dte, int32_t *ppb);
+};
+
+#endif
--- /dev/null
+++ b/include/linux/bcm_iproc_mailbox.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2016 Broadcom.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef _BCM_IPROC_MAILBOX_H_
+#define _BCM_IPROC_MAILBOX_H_
+
+#include <linux/types.h>
+/*
+ * A message to send to the M0 processor.
+ * @cmd Command to send.
+ * @param Parameter corresponding to command.
+ * @wait_ack true if mbox_send_message() should wait for a reply from the M0,
+ *   false if the M0 doesn't reply. This depends on the message being sent.
+ * @reply_code The response code from the M0 for the command sent (wait_ack was
+ *   set to true).
+ */
+struct iproc_mbox_msg {
+	u32       cmd;
+	u32       param;
+	bool      wait_ack;
+	u32       reply_code;
+};
+
+#endif
--- a/include/linux/brcmphy.h
+++ b/include/linux/brcmphy.h
@@ -19,6 +19,7 @@
 #define PHY_ID_BCM5411			0x00206070
 #define PHY_ID_BCM5421			0x002060e0
 #define PHY_ID_BCM54210E		0x600d84a0
+#define PHY_ID_BCM54210S		0x600d8590
 #define PHY_ID_BCM5464			0x002060b0
 #define PHY_ID_BCM5461			0x002060c0
 #define PHY_ID_BCM54612E		0x03625e60
@@ -65,6 +66,33 @@
 #define PHY_BRCM_CLEAR_RGMII_MODE	0x00004000
 #define PHY_BRCM_DIS_TXCRXC_NOENRGY	0x00008000
 
+/* Broadcom B502X0X_542XXXXCT RDB register definations */
+#define BCM_542XX_RDB_ADDR		0x1e	/* RDB indirect address reg */
+#define BCM_542XX_RDB_DATA		0x1f	/* RDB indirect data reg */
+#define BCM_542XX_RDB_ADDR_MASK		0x0fff	/* RDB indirect address mask */
+#define BCM_542XX_RDB_PHY_ECR		0x0	/* extended control reg */
+#define BCM_542XX_RDB_PHY_ISR		0x00a	/* interrupt status reg */
+#define BCM_542XX_RDB_PHY_IMR		0x00b	/* interrupt mask reg */
+#define BCM_542XX_RDB_CLK_ALIGN_CTRL	0x013
+#define BCM_542XX_RDB_MODE_CTRL		0x021
+#define BCM_542XX_RDB_COPPER_MISC_CTRL	0x02f
+#define BCM_542XX_RDB_SGMII_SLAVE	0x235
+#define BCM_542XX_RDB_AUTODET_MEDIUM	0x23e
+#define BCM_542XX_RDB_TOP_LEVEL_CONFIG	0x810
+
+#define BCM_542XX_RGMII_EN		BIT(7)
+#define BCM_542XX_RXC_INT_DELAY		BIT(8)
+#define BCM_542XX_GTXCLK_INT_DELAY	BIT(9)
+#define BCM_542XX_TOP_LEVEL_CONFIG	0x00b0
+#define BCM_542XX_RGMII_3P3V		BCM_542XX_TOP_LEVEL_CONFIG
+#define BCM_542XX_MODE_SEL		0x6
+#define BCM_542XX_1000BASEX		BIT(1)
+#define BCM_542XX_REG_1000X_EN		BIT(0)
+#define BCM_542XX_RGMII_AUTO_DET_MED_EN	BIT(0)
+#define BCM_542XX_POWER_DOWN		BIT(11)
+#define BCM_542XX_FIBER_LED		BIT(6)
+#define BCM_542XX_SGMII_SLAVE_MODE_EN	BIT(1)
+
 /* Broadcom BCM7xxx specific workarounds */
 #define PHY_BRCM_7XXX_REV(x)		(((x) >> 8) & 0xff)
 #define PHY_BRCM_7XXX_PATCH(x)		((x) & 0xff)
--- /dev/null
+++ b/include/linux/nvme-lpm-ssr.h
@@ -0,0 +1,117 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright(c) 2018 Broadcom
+ */
+
+#ifndef __NVME_LPM_SSR_H__
+#define __NVME_LPM_SSR_H__
+
+#include <stddef.h>
+
+enum ssr_states {
+	SSR_STATE_INVALID,
+	SSR_STATE_INIT,
+	SSR_STATE_DISARM,
+	SSR_STATE_ARM,
+	SSR_STATE_POWERLOSS,
+	SSR_STATE_INPROGRESS,
+	SSR_STATE_COMPLETE,
+	SSR_STATE_ERROR,
+};
+
+struct armed_ssr {
+	uint32_t sequence;
+	uint64_t memory_address;
+	uint64_t disk_address;
+	uint64_t length;
+} __attribute__((packed));
+
+struct disarmed_ssr {
+	uint32_t sequence;
+} __attribute__((packed));
+
+struct state_save_checkpoint {
+	uint32_t voltage;
+	uint64_t timestamp;
+} __attribute__((packed));
+
+struct ssr {
+	uint8_t state;
+	uint32_t sequence;
+	uint64_t nvme_error_code;
+	uint64_t ddr0_ecc_code;
+	uint64_t ddr1_ecc_code;
+	struct state_save_checkpoint power_loss;
+	struct state_save_checkpoint in_progress;
+	struct state_save_checkpoint complete;
+} __attribute__((packed));
+#define SSR_SIZE sizeof(struct ssr)
+
+enum {
+	NVME_LPM_CMD_GET_SSR = 0x53535201, /* cmd format in ASCII SSR<x>*/
+	NVME_LPM_CMD_ERASE_SSR,
+	NVME_LPM_CMD_ARM_SSR,
+	NVME_LPM_CMD_DISARM_SSR,
+	NVME_LPM_CMD_TRIGGER_SSR,
+};
+
+#define NVM_SSR_OFFSET	0x0
+#define OS_CRMU_SSRCMD_MEM 0x8f100100
+
+struct ssr_wrapper {
+	/*
+	 * MAIA must populate this signature indicating validity of cmd
+	 */
+#define MAIA_CRMU_VALID_REQUEST		0xbabebabe
+	uint32_t maia_crmu_valid_request;
+	/*
+	 * CRMU must populate this signature indicating status of command.
+	 * if done succussfully populate with CRMU_MAIA_VALID_RESPONSE or
+	 * 0x0 as erroneous condition.
+	 */
+#define MAX_CRMU_RESPONSE_TIMEOUT 1000 /* 100 msec */
+#define CRMU_MAIA_VALID_RESPONSE	0xfaceface
+	uint32_t crmu_maia_valid_response;
+	/*
+	 * MAIA uses this to send the command to MCU. MCU should clear this
+	 * indicating that command has been processed.
+	 */
+	uint32_t ssr_cmd_id;
+
+	/*
+	 * SSR struture. It should be populated with relevant field in case
+	 * other side expects anything i.e  sequence number
+	 */
+	struct ssr ssr;
+} __attribute__((packed));
+
+#define NVME_LPM_IOCTL_MAGIC		'N'
+#define NVME_LPM_IOCTL_GET_SSR		_IOR(NVME_LPM_IOCTL_MAGIC, 1, \
+						struct ssr)
+#define NVME_LPM_IOCTL_ERASE_SSR	_IO(NVME_LPM_IOCTL_MAGIC, 2)
+#define NVME_LPM_IOCTL_ARM_SSR		_IOW(NVME_LPM_IOCTL_MAGIC, 3, \
+						struct armed_ssr)
+#define NVME_LPM_IOCTL_DISARM_SSR	_IOW(NVME_LPM_IOCTL_MAGIC, 4, \
+						struct disarmed_ssr)
+#define NVME_LPM_IOCTL_TRIGGER_SSR	_IO(NVME_LPM_IOCTL_MAGIC, 5)
+#define NVME_LPM_IOCTL_READ		_IOW(NVME_LPM_IOCTL_MAGIC, 6, \
+						struct armed_ssr)
+#define NVME_LPM_IOCTL_AP_POLL		_IO(NVME_LPM_IOCTL_MAGIC, 7)
+
+struct nvme_lpm_drv_ops {
+	void *ctxt;
+	int (*nvme_destroy_backup_io_queues)(void *ctxt);
+	int (*nvme_build_backup_io_queues)(void *ctxt, uint64_t memory_address,
+					   uint64_t disk_address,
+					   uint64_t length,
+					   bool write_to_nvme,
+					   void *shared_nvme_data);
+	int (*nvme_initiate_xfers)(void *ctxt);
+	int (*nvme_poll_xfers)(void *ctxt);
+	int (*nvme_send_flush_cmd)(void *ctxt);
+};
+
+int register_nvme_lpm_ops(void *nvme_drv_ops);
+void unregister_nvme_lpm_ops(void);
+
+#endif
--- a/include/linux/pci-ecam.h
+++ b/include/linux/pci-ecam.h
@@ -67,6 +67,7 @@ void __iomem *pci_ecam_map_bus(struct pci_bus *bus, unsigned int devfn,
 extern struct pci_ecam_ops pci_thunder_ecam_ops; /* Cavium ThunderX 1.x */
 extern struct pci_ecam_ops xgene_v1_pcie_ecam_ops; /* APM X-Gene PCIe v1 */
 extern struct pci_ecam_ops xgene_v2_pcie_ecam_ops; /* APM X-Gene PCIe v2.x */
+extern struct pci_ecam_ops iproc_pcie_paxcv2_ecam_ops; /* iProc PAXCv2 */
 #endif
 
 #ifdef CONFIG_PCI_HOST_COMMON
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -296,6 +296,7 @@ struct pci_dev {
 	void		*sysdata;	/* hook for sys-specific extension */
 	struct proc_dir_entry *procent;	/* device entry in /proc/bus/pci */
 	struct pci_slot	*slot;		/* Physical slot this device is in */
+	struct mutex bridge_lock;
 
 	unsigned int	devfn;		/* encoded device & function index */
 	unsigned short	vendor;
@@ -307,6 +308,7 @@ struct pci_dev {
 	u8		hdr_type;	/* PCI header type (`multi' flag masked out) */
 #ifdef CONFIG_PCIEAER
 	u16		aer_cap;	/* AER capability offset */
+	struct aer_stats *aer_stats;	/* AER stats for this device */
 #endif
 	u8		pcie_cap;	/* PCIe capability offset */
 	u8		msi_cap;	/* MSI capability offset */
@@ -373,6 +375,7 @@ struct pci_dev {
 
 	bool match_driver;		/* Skip attaching driver */
 	/* These fields are used by common fixups */
+	spinlock_t	lock;		/* Protect is_added and is_busmaster */
 	unsigned int	transparent:1;	/* Subtractive decode PCI bridge */
 	unsigned int	multifunction:1;/* Part of multi-function device */
 	/* keep track of device state */
@@ -472,6 +475,7 @@ struct pci_host_bridge {
 	void *sysdata;
 	int busnr;
 	struct list_head windows;	/* resource_entry */
+	struct list_head dma_resv;	/* reserv dma ranges */
 	u8 (*swizzle_irq)(struct pci_dev *, u8 *); /* platform IRQ swizzler */
 	int (*map_irq)(const struct pci_dev *, u8, u8);
 	void (*release_fn)(struct pci_host_bridge *);
@@ -1471,13 +1475,9 @@ static inline int pci_irqd_intx_xlate(struct irq_domain *d,
 #endif
 
 #ifdef CONFIG_PCIEAER
-void pci_no_aer(void);
 bool pci_aer_available(void);
-int pci_aer_init(struct pci_dev *dev);
 #else
-static inline void pci_no_aer(void) { }
 static inline bool pci_aer_available(void) { return false; }
-static inline int pci_aer_init(struct pci_dev *d) { return -ENODEV; }
 #endif
 
 #ifdef CONFIG_PCIE_ECRC
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -2371,6 +2371,9 @@
 #define PCI_VENDOR_ID_BELKIN		0x1799
 #define PCI_DEVICE_ID_BELKIN_F5D7010V7	0x701f
 
+#define PCI_VENDOR_ID_CADENCE		0x17cd
+#define PCI_DEVICE_ID_CADENCE_AVIP	0x0100
+
 #define PCI_VENDOR_ID_RDC		0x17f3
 #define PCI_DEVICE_ID_RDC_R6020		0x6020
 #define PCI_DEVICE_ID_RDC_R6030		0x6030
--- a/include/linux/thermal.h
+++ b/include/linux/thermal.h
@@ -466,6 +466,7 @@ struct thermal_cooling_device *
 int thermal_zone_get_temp(struct thermal_zone_device *tz, int *temp);
 int thermal_zone_get_slope(struct thermal_zone_device *tz);
 int thermal_zone_get_offset(struct thermal_zone_device *tz);
+int thermal_zone_get_crit_temp(struct thermal_zone_device *tz, int *temp);
 
 int get_tz_trend(struct thermal_zone_device *, int);
 struct thermal_instance *get_thermal_instance(struct thermal_zone_device *,
@@ -532,6 +533,9 @@ static inline int thermal_zone_get_slope(
 static inline int thermal_zone_get_offset(
 		struct thermal_zone_device *tz)
 { return -ENODEV; }
+static inline int thermal_zone_get_crit_temp(
+		struct thermal_zone_device *tz, int *temp)
+{ return -ENODEV; }
 static inline int get_tz_trend(struct thermal_zone_device *tz, int trip)
 { return -ENODEV; }
 static inline struct thermal_instance *
--- /dev/null
+++ b/include/uapi/linux/bcm_dte.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation (the "GPL").
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License version 2 (GPLv2) for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 (GPLv2) along with this source code.
+ */
+
+#ifndef _BCM_IPROC_UAPI_DTE_H_
+#define _BCM_IPROC_UAPI_DTE_H_
+
+#include <linux/ioctl.h>
+
+struct dte_client_data {
+	unsigned int client;
+	unsigned int enable;
+	unsigned int divider;
+	unsigned int both_edge;
+};
+
+struct dte_timestamp {
+	unsigned int client;
+	struct timespec ts;
+};
+
+struct dte_client_list {
+	char name[25];
+	unsigned int div_status; /* divider availability */
+};
+
+#define DTE_IOCTL_BASE          0xFC
+#define DTE_IO(nr)              _IO(DTE_IOCTL_BASE, nr)
+#define DTE_IOR(nr, type)       _IOR(DTE_IOCTL_BASE, nr, type)
+#define DTE_IOW(nr, type)       _IOW(DTE_IOCTL_BASE, nr, type)
+#define DTE_IOWR(nr, type)      _IOWR(DTE_IOCTL_BASE, nr, type)
+
+#define DTE_IOCTL_SET_TIME          DTE_IOW(0x10, struct timespec)
+#define DTE_IOCTL_GET_TIME          DTE_IOR(0x11, struct timespec)
+#define DTE_IOCTL_ADJ_TIME          DTE_IOW(0x12, int64_t)
+#define DTE_IOCTL_ADJ_FREQ          DTE_IOW(0x13, int32_t)
+#define DTE_IOCTL_GET_FREQ_ADJ      DTE_IOR(0x14, int32_t)
+
+#define DTE_IOCTL_ENABLE_CLIENT_TS  DTE_IOW(0x20, struct dte_client_data)
+#define DTE_IOCTL_GET_TIMESTAMP     DTE_IOWR(0x21, struct dte_timestamp)
+
+#define DTE_IOCTL_DISPLAY_DRV_INF   DTE_IO(0x30)
+#define DTE_IOCTL_GET_NUM_OF_CLIENT DTE_IOR(0x31, uint32_t)
+#define DTE_IOCTL_GET_CLIENT_LIST   DTE_IOR(0x32, struct dte_client_list *)
+
+#endif
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -1743,6 +1743,17 @@ config ASYNC_RAID6_TEST
 
 	  If unsure, say N.
 
+config ASYNC_TX_TEST
+	tristate "Test module for Async_Tx APIs"
+	depends on ASYNC_RAID6_RECOV
+	select ASYNC_MEMCPY
+	---help---
+	  This is a iterative stress test for various async_tx APIs. It
+	  capable of batching large number of async_tx request in each
+	  iteration.
+
+	  If unsure, say N.
+
 config TEST_HEXDUMP
 	tristate "Test functions located in the hexdump module at runtime"
 
--- a/samples/bpf/Makefile
+++ b/samples/bpf/Makefile
@@ -178,6 +178,14 @@ HOSTLOADLIBES_syscall_tp += -lelf
 LLC ?= llc
 CLANG ?= clang
 
+# Detect that we're cross compiling and use the cross compiler
+ifdef CROSS_COMPILE
+HOSTCC = $(CROSS_COMPILE)gcc
+HOSTCFLAGS += $(EXTRA_HOSTCFLAGS)
+HOSTLDFLAGS += $(EXTRA_HOSTLDFLAGS)
+CLANG_ARCH_ARGS = -target $(ARCH)
+endif
+
 # Trick to allow make to be run from this directory
 all: $(LIBBPF)
 	$(MAKE) -C ../../ $(CURDIR)/
@@ -228,9 +236,13 @@ $(obj)/tracex5_kern.o: $(obj)/syscall_nrs.h
 $(obj)/%.o: $(src)/%.c
 	$(CLANG) $(NOSTDINC_FLAGS) $(LINUXINCLUDE) $(EXTRA_CFLAGS) -I$(obj) \
 		-I$(srctree)/tools/testing/selftests/bpf/ \
-		-D__KERNEL__ -D__ASM_SYSREG_H -Wno-unused-value -Wno-pointer-sign \
-		-Wno-compare-distinct-pointer-types \
+		-D__KERNEL__ -Wno-unused-value -Wno-pointer-sign \
+		-D__TARGET_ARCH_$(ARCH) -Wno-compare-distinct-pointer-types \
 		-Wno-gnu-variable-sized-type-not-at-end \
 		-Wno-address-of-packed-member -Wno-tautological-compare \
-		-Wno-unknown-warning-option \
+		-Wno-unknown-warning-option $(CLANG_ARCH_ARGS) \
 		-O2 -emit-llvm -c $< -o -| $(LLC) -march=bpf -filetype=obj -o $@
+
+install:
+	cp -f $(hostprogs-y) $(DESTDIR)
+	cp -f *_kern.o $(DESTDIR)
--- a/samples/bpf/README.rst
+++ b/samples/bpf/README.rst
@@ -64,3 +64,13 @@ It is also possible to point make to the newly compiled 'llc' or
 'clang' command via redefining LLC or CLANG on the make command line::
 
  make samples/bpf/ LLC=~/git/llvm/build/bin/llc CLANG=~/git/llvm/build/bin/clang
+
+Cross compiling samples
+-----------------------
+In order to cross-compile, say for arm64 targets, export CROSS_COMPILE and ARCH
+environment variables before calling make. This will direct make to build
+samples for the cross target.
+
+export ARCH=arm64
+export CROSS_COMPILE="aarch64-linux-gnu-"
+make samples/bpf/ LLC=~/git/llvm/build/bin/llc CLANG=~/git/llvm/build/bin/clang
--- a/samples/bpf/map_perf_test_kern.c
+++ b/samples/bpf/map_perf_test_kern.c
@@ -266,7 +266,7 @@ int stress_hash_map_lookup(struct pt_regs *ctx)
 	return 0;
 }
 
-SEC("kprobe/sys_getpgrp")
+SEC("kprobe/sys_getppid")
 int stress_array_map_lookup(struct pt_regs *ctx)
 {
 	u32 key = 1, i;
--- a/samples/bpf/map_perf_test_user.c
+++ b/samples/bpf/map_perf_test_user.c
@@ -282,7 +282,7 @@ static void test_array_lookup(int cpu)
 
 	start_time = time_get_ns();
 	for (i = 0; i < max_cnt; i++)
-		syscall(__NR_getpgrp, 0);
+		syscall(__NR_getppid, 0);
 	printf("%d:array_lookup %lld lookups per sec\n",
 	       cpu, max_cnt * 1000000000ll * 64 / (time_get_ns() - start_time));
 }
--- a/scripts/Makefile.dtbinst
+++ b/scripts/Makefile.dtbinst
@@ -6,8 +6,6 @@
 # INSTALL_DTBS_PATH directory or the default location:
 #
 #   $INSTALL_PATH/dtbs/$KERNELRELEASE
-#
-# Traverse through subdirectories listed in $(dts-dirs).
 # ==========================================================================
 
 src := $(obj)
@@ -21,8 +19,8 @@ include include/config/auto.conf
 include scripts/Kbuild.include
 include $(src)/Makefile
 
-dtbinst-files	:= $(dtb-y)
-dtbinst-dirs	:= $(dts-dirs)
+dtbinst-files	:= $(sort $(dtb-y) $(if $(CONFIG_OF_ALL_DTBS), $(dtb-)))
+dtbinst-dirs	:= $(subdir-y) $(subdir-m)
 
 # Helper targets for Installing DTBs into the boot directory
 quiet_cmd_dtb_install =	INSTALL $<
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -70,6 +70,11 @@ obj-dirs := $(dir $(multi-objs) $(obj-y))
 real-objs-y := $(foreach m, $(filter-out $(subdir-obj-y), $(obj-y)), $(if $(strip $($(m:.o=-objs)) $($(m:.o=-y))),$($(m:.o=-objs)) $($(m:.o=-y)),$(m))) $(extra-y)
 real-objs-m := $(foreach m, $(obj-m), $(if $(strip $($(m:.o=-objs)) $($(m:.o=-y)) $($(m:.o=-m))),$($(m:.o=-objs)) $($(m:.o=-y)) $($(m:.o=-m)),$(m)))
 
+# DTB
+# If CONFIG_OF_ALL_DTBS is enabled, all DT blobs are built
+extra-y				+= $(dtb-y)
+extra-$(CONFIG_OF_ALL_DTBS)	+= $(dtb-)
+
 # Add subdir path
 
 extra-y		:= $(addprefix $(obj)/,$(extra-y))
--- a/tools/testing/selftests/bpf/bpf_helpers.h
+++ b/tools/testing/selftests/bpf/bpf_helpers.h
@@ -110,7 +110,47 @@ static int (*bpf_skb_under_cgroup)(void *ctx, void *map, int index) =
 static int (*bpf_skb_change_head)(void *, int len, int flags) =
 	(void *) BPF_FUNC_skb_change_head;
 
+/* Scan the ARCH passed in from ARCH env variable (see Makefile) */
+#if defined(__TARGET_ARCH_x86)
+	#define bpf_target_x86
+	#define bpf_target_defined
+#elif defined(__TARGET_ARCH_s930x)
+	#define bpf_target_s930x
+	#define bpf_target_defined
+#elif defined(__TARGET_ARCH_arm64)
+	#define bpf_target_arm64
+	#define bpf_target_defined
+#elif defined(__TARGET_ARCH_mips)
+	#define bpf_target_mips
+	#define bpf_target_defined
+#elif defined(__TARGET_ARCH_powerpc)
+	#define bpf_target_powerpc
+	#define bpf_target_defined
+#elif defined(__TARGET_ARCH_sparc)
+	#define bpf_target_sparc
+	#define bpf_target_defined
+#else
+	#undef bpf_target_defined
+#endif
+
+/* Fall back to what the compiler says */
+#ifndef bpf_target_defined
 #if defined(__x86_64__)
+	#define bpf_target_x86
+#elif defined(__s390x__)
+	#define bpf_target_s930x
+#elif defined(__aarch64__)
+	#define bpf_target_arm64
+#elif defined(__mips__)
+	#define bpf_target_mips
+#elif defined(__powerpc__)
+	#define bpf_target_powerpc
+#elif defined(__sparc__)
+	#define bpf_target_sparc
+#endif
+#endif
+
+#if defined(bpf_target_x86)
 
 #define PT_REGS_PARM1(x) ((x)->di)
 #define PT_REGS_PARM2(x) ((x)->si)
@@ -123,7 +163,7 @@ static int (*bpf_skb_change_head)(void *, int len, int flags) =
 #define PT_REGS_SP(x) ((x)->sp)
 #define PT_REGS_IP(x) ((x)->ip)
 
-#elif defined(__s390x__)
+#elif defined(bpf_target_s390x)
 
 #define PT_REGS_PARM1(x) ((x)->gprs[2])
 #define PT_REGS_PARM2(x) ((x)->gprs[3])
@@ -136,7 +176,7 @@ static int (*bpf_skb_change_head)(void *, int len, int flags) =
 #define PT_REGS_SP(x) ((x)->gprs[15])
 #define PT_REGS_IP(x) ((x)->psw.addr)
 
-#elif defined(__aarch64__)
+#elif defined(bpf_target_arm64)
 
 #define PT_REGS_PARM1(x) ((x)->regs[0])
 #define PT_REGS_PARM2(x) ((x)->regs[1])
@@ -149,7 +189,7 @@ static int (*bpf_skb_change_head)(void *, int len, int flags) =
 #define PT_REGS_SP(x) ((x)->sp)
 #define PT_REGS_IP(x) ((x)->pc)
 
-#elif defined(__mips__)
+#elif defined(bpf_target_mips)
 
 #define PT_REGS_PARM1(x) ((x)->regs[4])
 #define PT_REGS_PARM2(x) ((x)->regs[5])
@@ -162,7 +202,7 @@ static int (*bpf_skb_change_head)(void *, int len, int flags) =
 #define PT_REGS_SP(x) ((x)->regs[29])
 #define PT_REGS_IP(x) ((x)->cp0_epc)
 
-#elif defined(__powerpc__)
+#elif defined(bpf_target_powerpc)
 
 #define PT_REGS_PARM1(x) ((x)->gpr[3])
 #define PT_REGS_PARM2(x) ((x)->gpr[4])
@@ -173,7 +213,7 @@ static int (*bpf_skb_change_head)(void *, int len, int flags) =
 #define PT_REGS_SP(x) ((x)->sp)
 #define PT_REGS_IP(x) ((x)->nip)
 
-#elif defined(__sparc__)
+#elif defined(bpf_target_sparc)
 
 #define PT_REGS_PARM1(x) ((x)->u_regs[UREG_I0])
 #define PT_REGS_PARM2(x) ((x)->u_regs[UREG_I1])
@@ -183,6 +223,8 @@ static int (*bpf_skb_change_head)(void *, int len, int flags) =
 #define PT_REGS_RET(x) ((x)->u_regs[UREG_I7])
 #define PT_REGS_RC(x) ((x)->u_regs[UREG_I0])
 #define PT_REGS_SP(x) ((x)->u_regs[UREG_FP])
+
+/* Should this also be a bpf_target check for the sparc case? */
 #if defined(__arch64__)
 #define PT_REGS_IP(x) ((x)->tpc)
 #else
@@ -191,10 +233,10 @@ static int (*bpf_skb_change_head)(void *, int len, int flags) =
 
 #endif
 
-#ifdef __powerpc__
+#ifdef bpf_target_powerpc
 #define BPF_KPROBE_READ_RET_IP(ip, ctx)		({ (ip) = (ctx)->link; })
 #define BPF_KRETPROBE_READ_RET_IP		BPF_KPROBE_READ_RET_IP
-#elif defined(__sparc__)
+#elif bpf_target_sparc
 #define BPF_KPROBE_READ_RET_IP(ip, ctx)		({ (ip) = PT_REGS_RET(ctx); })
 #define BPF_KRETPROBE_READ_RET_IP		BPF_KPROBE_READ_RET_IP
 #else
